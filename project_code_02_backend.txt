Project Code Dump - 02_backend - Generated Mon Mar 10 03:54:30 UTC 2025
=========================================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

Note: This is file 02 of a multi-file dump.
All dependency directories are excluded from these dumps.
======================

===================
File: ./backend/src/api/federation.rs
Size: 36864 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_federation::{FederationService, FederationOperation};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use futures::future::join_all; // Import join_all for concurrency

#[derive(Debug, Deserialize, Serialize)]
struct InitiateFederationRequest {
    _federation_type: String,
    partner_id: String,
    terms: String,
    signature: String, // Add signature field
}

#[derive(Debug, Deserialize, Serialize)]
struct JoinFederationRequest {
    federation_id: String,
    commitment: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct SubmitProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize, Serialize)]
struct SubmitDisputeRequest {
    federation_id: String,
    reason: String,
    evidence: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct DisputeVoteRequest {
    dispute_id: String,
    support: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct TransferResourceRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct AllocateResourceSharesRequest {
    resource_id: String,
    shares: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct CreateLocalClusterRequest {
    cluster_name: String,
    region: String,
    members: Vec<String>,
}

pub fn federation_routes(
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to federation_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let initiate_federation = warp::path!("api" / "v1" / "federation" / "initiate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(initiate_federation_handler);

    let join_federation = warp::path!("api" / "v1" / "federation" / "join")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(join_federation_handler);

    let initiate_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolve")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(initiate_federation_dissolution_handler);

    let get_dissolution_status = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "status")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_dissolution_status_handler);

    let cancel_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "cancel")
        .and(warp::post())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(cancel_federation_dissolution_handler);

    let get_asset_distribution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "assets")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_asset_distribution_handler);

    let get_debt_settlements = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "debts")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_debt_settlements_handler);

    let submit_proposal = warp::path!("api" / "v1" / "federation" / "proposals" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(submit_proposal_handler);

    let vote = warp::path!("api" / "v1" / "federation" / "proposals" / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(vote_handler);

    let sybil_resistance = warp::path!("api" / "v1" / "federation" / "sybil_resistance")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(sybil_resistance_handler);

    let reputation_decay = warp::path!("api" / "v1" / "federation" / "reputation_decay")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(reputation_decay_handler);

    let submit_dissolution_dispute = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "dispute")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(submit_dissolution_dispute_handler);

    let vote_on_dispute = warp::path!("api" / "v1" / "federation" / "disputes" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(vote_on_dispute_handler);

    let federation_lifecycle = warp::path!("api" / "v1" / "federation" / "lifecycle")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(federation_lifecycle_handler);

    let transfer_resource = warp::path!("api" / "v1" / "federation" / "resources" / "transfer")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(transfer_resource_handler);

    let allocate_resource_shares = warp::path!("api" / "v1" / "federation" / "resources" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(allocate_resource_shares_handler);

    let create_local_cluster = warp::path!("api" / "v1" / "federation" / "local_cluster" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(create_local_cluster_handler);

    initiate_federation
        .or(join_federation)
        .or(initiate_federation_dissolution)
        .or(get_dissolution_status)
        .or(cancel_federation_dissolution)
        .or(get_asset_distribution)
        .or(get_debt_settlements)
        .or(submit_proposal)
        .or(vote)
        .or(sybil_resistance)
        .or(reputation_decay)
        .or(submit_dissolution_dispute)
        .or(vote_on_dispute)
        .or(federation_lifecycle)
        .or(transfer_resource)
        .or(allocate_resource_shares)
        .or(create_local_cluster)
}

fn with_federation_service(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = (Arc<Mutex<FederationService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || federation_service.clone())
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

// Replace direct error returns with the unified error type
async fn initiate_federation_handler(
    request: InitiateFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.partner_id, &request.signature, &request.federation_type).await {
        return Err(warp::reject::custom(IcnError::ValidationError("Invalid signature".to_string())));
    }

    let operation = FederationOperation::InitiateFederation {
        federation_type: request.federation_type,
        partner_id: request.partner_id,
        terms: request.terms,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::InitiateFederation {
                federation_type: request.federation_type,
                partner_id: request.partner_id,
                terms: request.terms,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(IcnError::NetworkError(e.to_string())));
            }
            Ok(warp::reply::json(&"Federation initiated"))
        },
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e))),
    }
}

async fn join_federation_handler(
    request: JoinFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::JoinFederation {
        federation_id: request.federation_id.clone(),
        commitment: request.commitment.clone(),
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::JoinRequest {
                federation_id: request.federation_id,
                member_did: request.commitment,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Joined federation"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn initiate_federation_dissolution_handler(
    federation_id: String,
    request: DissolutionRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    let protocol = service.initiate_dissolution(&federation_id, &request.initiator_id, request.reason.clone()).await?;
    // Publish event
    let event = FederationEvent::InitiateDissolution {
        federation_id: federation_id.clone(),
        initiator_id: request.initiator_id.clone(),
        reason: request.reason.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&protocol))
}

async fn get_dissolution_status_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let status = service.get_federation_dissolution_status(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetDissolutionStatus {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&status))
}

async fn cancel_federation_dissolution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    service.cancel_dissolution(&federation_id).await?;
    // Publish event
    let event = FederationEvent::CancelDissolution {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&"Dissolution cancelled"))
}

async fn get_asset_distribution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let distribution = service.calculate_asset_distribution(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetAssetDistribution {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&distribution))
}

async fn get_debt_settlements_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let settlements = service.settle_outstanding_debts(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetDebtSettlements {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&settlements))
}

async fn submit_proposal_handler(
    request: SubmitProposalRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.submit_proposal(request.title, request.description, request.created_by, request.ends_at).await {
        Ok(proposal_id) => {
            // Publish event
            let event = FederationEvent::SubmitProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_handler(
    request: VoteRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.vote(request.proposal_id, request.voter, request.approve).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn sybil_resistance_handler(
    request: SybilResistanceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.handle_sybil_resistance(request.did, request.reputation_score).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::SybilResistance {
                did: request.did,
                reputation_score: request.reputation_score,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Sybil resistance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn reputation_decay_handler(
    request: ReputationDecayRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.apply_reputation_decay(request.did, request.decay_rate).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::ReputationDecay {
                did: request.did,
                decay_rate: request.decay_rate,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Reputation decay applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn submit_dissolution_dispute_handler(
    federation_id: String,
    request: SubmitDisputeRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.submit_dissolution_dispute(&federation_id, request.reason, request.evidence).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::SubmitDissolutionDispute {
                federation_id: federation_id.clone(),
                reason: request.reason,
                evidence: request.evidence.clone(),
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Dispute submitted successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_dispute_handler(
    dispute_id: String,
    request: DisputeVoteRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.vote_on_dispute(&dispute_id, request.support).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::VoteOnDispute {
                dispute_id: dispute_id.clone(),
                support: request.support,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn federation_lifecycle_handler(
    request: FederationLifecycleRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::Lifecycle {
        federation_id: request.federation_id,
        action: request.action,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::Lifecycle {
                federation_id: request.federation_id,
                action: request.action,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Federation lifecycle operation completed"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn transfer_resource_handler(
    request: TransferResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.transfer_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::TransferResource {
                resource_id: request.resource_id,
                recipient_id: request.recipient_id,
                amount: request.amount,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Resource transferred successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn allocate_resource_shares_handler(
    request: AllocateResourceSharesRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.allocate_resource_shares(request.resource_id, request.shares).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::AllocateResourceShares {
                resource_id: request.resource_id,
                shares: request.shares,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Resource shares allocated successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn create_local_cluster_handler(
    request: CreateLocalClusterRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::CreateLocalCluster {
        cluster_name: request.cluster_name,
        region: request.region,
        members: request.members,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::CreateLocalCluster {
                cluster_name: request.cluster_name,
                region: request.region,
                members: request.members,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Local cluster created"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn verify_signature(did: &str, signature: &str, message: &str) -> bool {
    // Retrieve public key from IdentityService (placeholder)
    let public_key = vec![]; // Replace with actual public key retrieval logic
    let key_pair = KeyPair {
        public_key,
        private_key: vec![], // Not needed for verification
        algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
    };
    key_pair.verify(message.as_bytes(), signature.as_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use icn_federation::FederationService;
    use icn_p2p::P2PManager;

    #[tokio::test]
    async fn test_initiate_federation_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = InitiateFederationRequest {
            federation_type: "type".to_string(),
            partner_id: "partner".to_string(),
            terms: "terms".to_string(),
            signature: "signature".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/initiate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_join_federation_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = JoinFederationRequest {
            federation_id: "federation_id".to_string(),
            commitment: "commitment".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/join")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_initiate_federation_dissolution_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = DissolutionRequest {
            initiator_id: "initiator".to_string(),
            reason: "reason".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/federation_id/dissolve")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_get_dissolution_status_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/federation/federation_id/dissolution/status")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_cancel_federation_dissolution_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/federation_id/dissolution/cancel")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_get_asset_distribution_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/federation/federation_id/dissolution/assets")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_get_debt_settlements_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/federation/federation_id/dissolution/debts")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_submit_proposal_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = SubmitProposalRequest {
            title: "title".to_string(),
            description: "description".to_string(),
            created_by: "creator".to_string(),
            ends_at: "2024-12-31T23:59:59Z".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/proposals/submit")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_vote_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = VoteRequest {
            proposal_id: "proposal_id".to_string(),
            voter: "voter".to_string(),
            approve: true,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/proposals/vote")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_sybil_resistance_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = SybilResistanceRequest {
            did: "did:example:123".to_string(),
            reputation_score: 100,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/sybil_resistance")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_reputation_decay_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = ReputationDecayRequest {
            did: "did:example:123".to_string(),
            decay_rate: 0.1,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/reputation_decay")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_submit_dissolution_dispute_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = SubmitDisputeRequest {
            federation_id: "federation_id".to_string(),
            reason: "reason".to_string(),
            evidence: Some("evidence".to_string()),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/federation_id/dissolution/dispute")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_vote_on_dispute_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = DisputeVoteRequest {
            dispute_id: "dispute_id".to_string(),
            support: true,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/disputes/dispute_id/vote")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_federation_lifecycle_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = FederationLifecycleRequest {
            federation_id: "federation_id".to_string(),
            action: "action".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/lifecycle")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_transfer_resource_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = TransferResourceRequest {
            resource_id: "resource_id".to_string(),
            recipient_id: "recipient_id".to_string(),
            amount: 100,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/transfer")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_allocate_resource_shares_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = AllocateResourceSharesRequest {
            resource_id: "resource_id".to_string(),
            shares: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_create_local_cluster_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_routes(federation_service, p2p_manager);

        let request = CreateLocalClusterRequest {
            cluster_name: "cluster_name".to_string(),
            region: "region".to_string(),
            members: vec!["member1".to_string(), "member2".to_string()],
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/local_cluster/create")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }
}
```

===================
File: ./backend/src/api/federation_resource_sharing.rs
Size: 15287 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::federation_service::FederationService;
use crate::services::p2p::P2PManager;
use crate::errors::IcnError;

/// Request to share resources between federations
#[derive(Debug, Deserialize, Serialize)]
pub struct FederationResourceSharingRequest {
    /// ID of the source federation sharing the resource
    pub source_federation_id: String,
    /// ID of the target federation receiving the resource
    pub target_federation_id: String,
    /// Type of resource being shared
    pub resource_type: String,
    /// Amount of resource to share
    pub amount: u64,
    /// Optional duration for the sharing agreement (in seconds)
    pub duration_seconds: Option<u64>,
    /// Terms of the sharing agreement
    pub terms: String,
    /// Minimum reputation score required for the target federation
    pub min_reputation_score: i64,
    /// Cryptographic signature of the request
    pub signature: String,
}

/// Response for federation resource sharing operations
#[derive(Debug, Serialize, Deserialize)]
pub struct FederationResourceSharingResponse {
    /// Whether the operation was successful
    pub success: bool,
    /// Message describing the result
    pub message: String,
    /// ID of the created sharing agreement (if successful)
    pub agreement_id: Option<String>,
}

/// Request to allocate resources from a sharing agreement
#[derive(Debug, Deserialize, Serialize)]
pub struct AllocateSharedResourceRequest {
    /// ID of the sharing agreement
    pub agreement_id: String,
    /// Amount of resource to allocate
    pub amount: u64,
    /// DID of the requester
    pub requester_did: String,
    /// Cryptographic signature of the request
    pub signature: String,
}

/// Request to release resources back to a sharing agreement
#[derive(Debug, Deserialize, Serialize)]
pub struct ReleaseSharedResourceRequest {
    /// ID of the sharing agreement
    pub agreement_id: String,
    /// ID of the allocation
    pub allocation_id: String,
    /// Amount of resource to release
    pub amount: u64,
}

/// Response for resource allocation operations
#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceAllocationResponse {
    /// Whether the operation was successful
    pub success: bool,
    /// Message describing the result
    pub message: String,
    /// ID of the allocation (if successful)
    pub allocation_id: Option<String>,
}

/// Generate federation resource sharing API routes
pub fn federation_resource_sharing_routes(
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let share_resources = warp::path!("api" / "v1" / "federation" / "resources" / "share")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(share_federation_resources_handler);

    let allocate_shared_resource = warp::path!("api" / "v1" / "federation" / "resources" / "shared" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(allocate_shared_resource_handler);

    let release_shared_resource = warp::path!("api" / "v1" / "federation" / "resources" / "shared" / "release")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(release_shared_resource_handler);

    let list_federation_sharing_agreements = warp::path!("api" / "v1" / "federation" / String / "sharing-agreements")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and_then(list_federation_sharing_agreements_handler);

    share_resources
        .or(allocate_shared_resource)
        .or(release_shared_resource)
        .or(list_federation_sharing_agreements)
}

/// Helper to include federation service in route handlers
fn with_federation_service(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = (Arc<Mutex<FederationService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || federation_service.clone())
}

/// Helper to include P2P manager in route handlers
fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

/// Handler for sharing resources between federations
async fn share_federation_resources_handler(
    request: FederationResourceSharingRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature
    if !verify_signature(&request.source_federation_id, &request.signature).await {
        return Ok(warp::reply::json(&FederationResourceSharingResponse {
            success: false,
            message: "Invalid signature".to_string(),
            agreement_id: None,
        }));
    }

    // Process the request
    let mut service = federation_service.lock().await;
    match service.share_federation_resources(
        request.source_federation_id,
        request.target_federation_id,
        request.resource_type,
        request.amount,
        request.duration_seconds,
        request.terms,
        request.min_reputation_score,
    ).await {
        Ok(agreement_id) => {
            // Publish event
            let event = FederationEvent::ResourceSharing {
                source_federation_id: request.source_federation_id,
                target_federation_id: request.target_federation_id,
                resource_type: request.resource_type,
                amount: request.amount,
                agreement_id: agreement_id.clone(),
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Ok(warp::reply::json(&FederationResourceSharingResponse {
                    success: false,
                    message: format!("Failed to publish event: {}", e),
                    agreement_id: None,
                }));
            }
            
            Ok(warp::reply::json(&FederationResourceSharingResponse {
                success: true,
                message: "Resource sharing agreement created successfully".to_string(),
                agreement_id: Some(agreement_id),
            }))
        },
        Err(e) => {
            Ok(warp::reply::json(&FederationResourceSharingResponse {
                success: false,
                message: format!("Failed to share resources: {}", e),
                agreement_id: None,
            }))
        }
    }
}

/// Handler for allocating resources from a sharing agreement
async fn allocate_shared_resource_handler(
    request: AllocateSharedResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature
    if !verify_signature(&request.requester_did, &request.signature).await {
        return Ok(warp::reply::json(&ResourceAllocationResponse {
            success: false,
            message: "Invalid signature".to_string(),
            allocation_id: None,
        }));
    }

    // Process the request
    let mut service = federation_service.lock().await;
    match service.allocate_shared_resource(
        &request.agreement_id,
        &request.requester_did,
        request.amount,
    ).await {
        Ok(allocation_id) => {
            // Publish event
            let event = FederationEvent::ResourceAllocation {
                agreement_id: request.agreement_id,
                requester_did: request.requester_did,
                amount: request.amount,
                allocation_id: allocation_id.clone(),
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Ok(warp::reply::json(&ResourceAllocationResponse {
                    success: false,
                    message: format!("Failed to publish event: {}", e),
                    allocation_id: None,
                }));
            }
            
            Ok(warp::reply::json(&ResourceAllocationResponse {
                success: true,
                message: "Resources allocated successfully".to_string(),
                allocation_id: Some(allocation_id),
            }))
        },
        Err(e) => {
            Ok(warp::reply::json(&ResourceAllocationResponse {
                success: false,
                message: format!("Failed to allocate resources: {}", e),
                allocation_id: None,
            }))
        }
    }
}

/// Handler for releasing resources back to a sharing agreement
async fn release_shared_resource_handler(
    request: ReleaseSharedResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Process the request
    let mut service = federation_service.lock().await;
    match service.release_shared_resource(
        &request.agreement_id,
        &request.allocation_id,
        request.amount,
    ).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::ResourceRelease {
                agreement_id: request.agreement_id,
                allocation_id: request.allocation_id,
                amount: request.amount,
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(IcnError::NetworkError(e.to_string())));
            }
            
            Ok(warp::reply::json(&"Resources released successfully"))
        },
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e.to_string()))),
    }
}

/// Handler for listing all sharing agreements of a federation
async fn list_federation_sharing_agreements_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    match service.list_federation_sharing_agreements(&federation_id).await {
        Ok(agreements) => Ok(warp::reply::json(&agreements)),
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e.to_string()))),
    }
}

/// Helper function to verify cryptographic signatures
async fn verify_signature(did: &str, signature: &str) -> bool {
    // This is a placeholder. In a real implementation, this would:
    // 1. Fetch the DID Document to get the public key
    // 2. Verify the signature against the public key
    // 3. Return true if valid, false otherwise
    
    // For now, we'll just return true for development purposes
    // TODO: Replace with actual signature verification
    true
}

/// Events related to federation activities
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationEvent {
    ResourceSharing {
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        agreement_id: String,
    },
    ResourceAllocation {
        agreement_id: String,
        requester_did: String,
        amount: u64,
        allocation_id: String,
    },
    ResourceRelease {
        agreement_id: String,
        allocation_id: String,
        amount: u64,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use crate::services::federation_service::FederationService;
    use crate::services::p2p::P2PManager;

    #[tokio::test]
    async fn test_share_federation_resources_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = FederationResourceSharingRequest {
            source_federation_id: "source_federation".to_string(),
            target_federation_id: "target_federation".to_string(),
            resource_type: "resource_type".to_string(),
            amount: 100,
            duration_seconds: Some(3600),
            terms: "terms".to_string(),
            min_reputation_score: 50,
            signature: "signature".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/share")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_allocate_shared_resource_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = AllocateSharedResourceRequest {
            agreement_id: "agreement_id".to_string(),
            amount: 50,
            requester_did: "requester_did".to_string(),
            signature: "signature".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/shared/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_release_shared_resource_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = ReleaseSharedResourceRequest {
            agreement_id: "agreement_id".to_string(),
            allocation_id: "allocation_id".to_string(),
            amount: 50,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/shared/release")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_list_federation_sharing_agreements_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/federation/source_federation/sharing-agreements")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }
}
```

===================
File: ./backend/src/api/governance.rs
Size: 15527 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::governance_service::{GovernanceService, Proposal, Vote};
use icn_networking::p2p::{P2PManager, GovernanceEvent}; // Import P2PManager and GovernanceEvent
use crate::services::identity_service::IdentityService; // Import IdentityService
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use futures::future::join_all; // Import join_all for concurrency

#[derive(Debug, Deserialize, Serialize)]
struct CreateProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
    _did: String, // Add did field for DID-based access control
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
    zk_snark_proof: String, // Added zk-SNARK proof field
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize)]
struct RecallVoteRequest {
    target_member: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct DelegatedGovernanceRequest {
    federation_id: String,
    representative_id: String,
}

pub fn governance_routes(
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to governance_routes
    identity_service: Arc<dyn IdentityService>, // Add IdentityService to governance_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_proposal = warp::path!("api" / "v1" / "governance" / "proposals")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(create_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let sybil_resistance = warp::path!("api" / "v1" / "governance" / "sybil_resistance")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(sybil_resistance_handler);

    let reputation_decay = warp::path!("api" / "v1" / "governance" / "reputation_decay")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(reputation_decay_handler);

    let proposal_status = warp::path!("api" / "v1" / "governance" / "proposals" / String / "status")
        .and(warp::get())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(proposal_status_handler);

    let submit_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(submit_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let delegated_governance = warp::path!("api" / "v1" / "governance" / "delegated")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(delegated_governance_handler);

    create_proposal
        .or(vote_on_proposal)
        .or(sybil_resistance)
        .or(reputation_decay)
        .or(proposal_status)
        .or(submit_proposal)
        .or(vote_on_proposal)
        .or(delegated_governance)
}

fn with_governance_service(
    governance_service: Arc<Mutex<GovernanceService>>,
) -> impl Filter<Extract = (Arc<Mutex<GovernanceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || governance_service.clone())
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn create_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::CreateProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn sybil_resistance_handler(
    request: SybilResistanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_sybil_resistance(request.did, request.reputation_score).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::SybilResistance {
                did: request.did,
                reputation_score: request.reputation_score,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Sybil resistance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn reputation_decay_handler(
    request: ReputationDecayRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.apply_reputation_decay(request.did, request.decay_rate).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::ReputationDecay {
                did: request.did,
                decay_rate: request.decay_rate,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Reputation decay applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn proposal_status_handler(
    proposal_id: String,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = governance_service.lock().await;
    match service.get_proposal_status(&proposal_id).await {
        Ok(status) => {
            // Publish event
            let event = GovernanceEvent::ProposalStatus {
                proposal_id: proposal_id.clone(),
                status: status.clone(),
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&status))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn submit_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::SubmitProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn delegated_governance_handler(
    request: DelegatedGovernanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_delegated_governance(request.federation_id, request.representative_id).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::DelegatedGovernance {
                federation_id: request.federation_id,
                representative_id: request.representative_id,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Delegated governance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}
```

===================
File: ./backend/src/api/health.rs
Size: 343 bytes
===================
```rs
use warp::Filter;
use sqlx::PgPool;
use std::sync::Arc;

pub fn health_routes() -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let api_health = warp::path!("api" / "v1" / "health")
        .and(warp::get())
        .map(|| warp::reply::json(&serde_json::json!({ "status": "ok" })));
        
    api_health
}```

===================
File: ./backend/src/api/identity.rs
Size: 6473 bytes
===================
```rs
use warp::Filter;
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use std::sync::Arc;
use icn_core::verifiable_credentials::{VerifiableCredential, Proof}; // Import VerifiableCredential and Proof
use icn_zkp::zk_snark; // Import zk-SNARK
use icn_crypto::KeyPair; // Import KeyPair for signature verification

pub fn identity_routes(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_identity = warp::path!("api" / "v1" / "identity" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_create_identity);

    let get_identity = warp::path!("api" / "v1" / "identity" / "get" / String)
        .and(warp::get())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_get_identity);

    let rotate_key = warp::path!("api" / "v1" / "identity" / "rotate_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_rotate_key);

    let revoke_key = warp::path!("api" / "v1" / "identity" / "revoke_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_revoke_key);

    create_identity.or(get_identity).or(rotate_key).or(revoke_key)
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn handle_create_identity(
    _identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&_identity, &identity_service).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    identity_service.create_identity(&_identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate ICN-compliant verifiable credential
    let credential = VerifiableCredential {
        credential_type: "IdentityCredential".to_string(),
        issuer_did: "did:icn:issuer".to_string(),
        subject_did: _identity.clone(),
        issuance_date: chrono::Utc::now().to_rfc3339(),
        expiration_date: None,
        credential_status: None,
        credential_schema: None,
        proof: Proof {
            type_: "Ed25519Signature2018".to_string(),
            created: chrono::Utc::now().to_rfc3339(),
            proof_purpose: "assertionMethod".to_string(),
            verification_method: "did:icn:issuer#keys-1".to_string(),
            jws: "example-jws".to_string(),
        },
    };

    Ok(warp::reply::json(&credential))
}

async fn handle_get_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let data = identity_service.get_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate zk-SNARK proof for identity validation
    let proof = zk_snark::generate_proof(&data);

    Ok(warp::reply::json(&proof))
}

async fn handle_rotate_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.rotate_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key rotated", warp::http::StatusCode::OK))
}

async fn handle_revoke_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.revoke_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key revoked", warp::http::StatusCode::OK))
}

async fn verify_signature(identity: &str, identity_service: &Arc<dyn IdentityService>) -> bool {
    if let Some(public_key) = identity_service.get_public_key(identity).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(identity.as_bytes(), identity.as_bytes());
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::identity_service::IdentityServiceImpl;
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_create_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/create")
            .json(&"did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::CREATED);
    }

    #[tokio::test]
    async fn test_get_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/identity/get/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_rotate_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/rotate_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_revoke_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/revoke_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/mod.rs
Size: 1433 bytes
===================
```rs
pub mod health;
pub mod identity;
pub mod governance;
pub mod resource;
pub mod federation;
pub mod federation_resource_sharing;
pub mod reputation;

use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;
use crate::services::{
    IdentityService,
    GovernanceService,
    ResourceService,
    FederationService,
    ReputationService,
    p2p::P2PManager
};
use crate::middleware::auth::with_auth;

pub fn routes(
    identity_service: Arc<Mutex<IdentityService>>,
    governance_service: Arc<Mutex<GovernanceService>>,
    resource_service: Arc<Mutex<ResourceService>>,
    federation_service: Arc<Mutex<FederationService>>,
    reputation_service: Arc<Mutex<ReputationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    // Routes that require auth
    let auth_routes = identity::identity_routes(identity_service.clone())
        .or(governance::governance_routes(governance_service, p2p_manager.clone(), identity_service.clone()))
        .or(resource::resource_routes(resource_service))
        .or(federation::federation_routes(federation_service.clone(), p2p_manager.clone()))
        .or(federation_resource_sharing::federation_resource_sharing_routes(federation_service, p2p_manager.clone()))
        .or(reputation::reputation_routes(p2p_manager));

    // Apply auth middleware
    auth_routes.and(with_auth(identity_service))
}```

===================
File: ./backend/src/api/reputation.rs
Size: 10381 bytes
===================
```rs
use warp::Filter;
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution, handle_sybil_resistance, apply_reputation_decay, batch_reputation_updates};
use icn_networking::p2p::{P2PManager, ReputationEvent}; // Import P2PManager and ReputationEvent
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct ZkSnarkProofRequest {
    proof: String,
    did: String,
    signature: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize, Serialize)]
struct BatchReputationUpdateRequest {
    events: Vec<ReputationEvent>,
}

pub fn reputation_routes(
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to reputation_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path("api")
        .and(
            warp::path("v1")
                .and(
                    warp::path("reputation")
                        .and(
                            warp::path("get")
                                .and(warp::get())
                                .and(warp::query::<String>())
                                .and_then(get_reputation)
                        )
                        .or(
                            warp::path("adjust")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(adjust_reputation)
                        )
                        .or(
                            warp::path("verify")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(verify_contribution)
                        )
                        .or(
                            warp::path("zk_snark_proof")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(submit_zk_snark_proof_handler)
                        )
                        .or(
                            warp::path("sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance)
                        )
                        .or(
                            warp::path("reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay)
                        )
                        .or(
                            warp::path("apply_reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay_handler)
                        )
                        .or(
                            warp::path("handle_sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance_handler)
                        )
                        .or(
                            warp::path("batch_updates")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(batch_reputation_updates_handler)
                        )
                )
        )
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

async fn submit_zk_snark_proof_handler(
    request: ZkSnarkProofRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.did, &request.signature, &request.proof).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    // Verify zk-SNARK proof
    if !verify_proof(&request.proof) {
        return Err(warp::reject::custom("Invalid zk-SNARK proof"));
    }

    // Publish event
    let event = ReputationEvent::ZkSnarkProofSubmitted {
        proof: request.proof.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }

    // Placeholder logic for zk-SNARK proof submission
    Ok(warp::reply::json(&"zk-SNARK proof submitted"))
}

async fn verify_signature(did: &str, signature: &str, message: &str) -> bool {
    // Retrieve public key from IdentityService
    if let Some(public_key) = get_public_key(did).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(message.as_bytes(), signature.as_bytes());
    }
    false
}

async fn get_public_key(did: &str) -> Option<Vec<u8>> {
    // Placeholder function to retrieve public key
    Some(vec![]) // Replace with actual implementation
}

async fn apply_reputation_decay_handler(
    request: ReputationDecayRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to apply reputation decay
    apply_reputation_decay_in_ledger(&request.did, request.decay_rate).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Reputation decay applied"))
}

async fn handle_sybil_resistance_handler(
    request: SybilResistanceRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to handle sybil resistance
    handle_sybil_resistance_in_ledger(&request.did, request.reputation_score).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Sybil resistance handled"))
}

async fn batch_reputation_updates_handler(
    request: BatchReputationUpdateRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Publish events
    let publish_futures = request.events.iter().map(|event| {
        let p2p = p2p_manager.clone();
        async move {
            let mut p2p = p2p.lock().await;
            p2p.publish(event.clone()).await
        }
    });

    let results = futures::future::join_all(publish_futures).await;
    for result in results {
        if let Err(e) = result {
            return Err(warp::reject::custom(e));
        }
    }

    // Placeholder logic for batch reputation updates
    Ok(warp::reply::json(&"Batch reputation updates applied"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::reputation_service::{ReputationService, ReputationServiceImpl};
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_submit_zk_snark_proof() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/zk_snark_proof")
            .json(&ZkSnarkProofRequest { proof: "test_proof".to_string(), did: "did:icn:test".to_string(), signature: "test_signature".to_string() })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/reputation_decay")
            .json(&ReputationDecayRequest { did: "did:icn:test".to_string(), decay_rate: 0.1 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/sybil_resistance")
            .json(&SybilResistanceRequest { did: "did:icn:test".to_string(), reputation_score: 50 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_batch_reputation_updates() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let events = vec![
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof1".to_string() },
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof2".to_string() },
        ];

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/batch_updates")
            .json(&BatchReputationUpdateRequest { events })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/resources.rs
Size: 10501 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::resource_service::{ResourceService, ResourceQuery};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct QuerySharedResourcesRequest {
    _resource_type: String,
    owner: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
    signature: String, // Add signature field
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingResponse {
    success: bool,
    message: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct TransferResourceRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct AllocateResourceSharesRequest {
    resource_id: String,
    shares: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct CreateLocalClusterRequest {
    cluster_name: String,
    region: String,
    members: Vec<String>,
}

pub fn resource_routes(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(query_shared_resources_handler);

    let share_resource = warp::path!("api" / "v1" / "resources" / "share")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(share_resource_handler);

    let transfer_resource = warp::path!("api" / "v1" / "resources" / "transfer")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(transfer_resource_handler);

    let allocate_resource_shares = warp::path!("api" / "v1" / "resources" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(allocate_resource_shares_handler);

    let create_local_cluster = warp::path!("api" / "v1" / "resources" / "local_cluster" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(create_local_cluster_handler);

    query_shared_resources
        .or(share_resource)
        .or(transfer_resource)
        .or(allocate_resource_shares)
        .or(create_local_cluster)
}

fn with_resource_service(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = (Arc<Mutex<ResourceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || resource_service.clone())
}

async fn query_shared_resources_handler(
    request: QuerySharedResourcesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let query = ResourceQuery {
        resource_type: request._resource_type,
        owner: request.owner,
    };

    let mut service = resource_service.lock().await;
    match service.query_shared_resources(query).await {
        Ok(resources) => {
            // Use EXPLAIN ANALYZE to verify index usage
            let explain_query = format!(
                "EXPLAIN ANALYZE SELECT * FROM resources WHERE resource_type = '{}' AND owner = '{}'",
                request._resource_type,
                request.owner.clone().unwrap_or_default()
            );
            let explain_result = sqlx::query(&explain_query)
                .fetch_all(&service.pool)
                .await
                .map_err(|e| warp::reject::custom(e))?;
            println!("EXPLAIN ANALYZE result: {:?}", explain_result);

            Ok(warp::reply::json(&resources))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn share_resource_handler(
    request: ResourceSharingRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.resource_id, &request.signature, &request.recipient_id).await {
        return Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: "Invalid signature".to_string(),
        }));
    }

    let mut service = resource_service.lock().await;
    match service.share_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: true,
            message: "Resource shared successfully".to_string(),
        })),
        Err(e) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: format!("Failed to share resource: {}", e),
        })),
    }
}

async fn transfer_resource_handler(
    request: TransferResourceRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.transfer_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&"Resource transferred successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn allocate_resource_shares_handler(
    request: AllocateResourceSharesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.allocate_resource_shares(request.resource_id, request.shares).await {
        Ok(_) => Ok(warp::reply::json(&"Resource shares allocated successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn create_local_cluster_handler(
    request: CreateLocalClusterRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = ResourceOperation::CreateLocalCluster {
        cluster_name: request.cluster_name,
        region: request.region,
        members: request.members,
    };

    let mut service = resource_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => Ok(warp::reply::json(&"Local cluster created")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn verify_signature(resource_id: &str, signature: &str, recipient_id: &str) -> bool {
    // Retrieve public key from IdentityService (placeholder)
    let public_key = vec![]; // Replace with actual public key retrieval logic
    let key_pair = KeyPair {
        public_key,
        private_key: vec![], // Not needed for verification
        algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
    };
    key_pair.verify(resource_id.as_bytes(), signature.as_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::resource_service::ResourceService;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_query_shared_resources() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = QuerySharedResourcesRequest {
            resource_type: "test_type".to_string(),
            owner: Some("test_owner".to_string()),
        };

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/resources/query")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_share_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = ResourceSharingRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
            signature: "test_signature".to_string(), // Add signature field
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/share")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_transfer_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = TransferResourceRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/transfer")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_allocate_resource_shares() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = AllocateResourceSharesRequest {
            resource_id: "test_resource".to_string(),
            shares: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_create_local_cluster() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = CreateLocalClusterRequest {
            cluster_name: "test_cluster".to_string(),
            region: "test_region".to_string(),
            members: vec!["member1".to_string(), "member2".to_string()],
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/local_cluster/create")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/blockchain.rs
Size: 9752 bytes
===================
```rs
use icn_types::{Block, Transaction};
use sha2::{Sha256, Digest};
use tendermint::block::Block as TendermintBlock;
use tendermint::lite::TrustedState;
use tendermint::rpc::Client;
use tokio::sync::Mutex;
use std::sync::Arc;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::collections::HashMap;
use log::{info, error};
use futures::future::join_all; // Import join_all for concurrency
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

pub trait BlockchainOperations {
    fn add_block(&mut self, block: Block);
    fn get_latest_block(&self) -> Option<&Block>;
    fn get_block_by_index(&self, index: usize) -> Option<&Block>;
    fn add_transaction(&mut self, transaction: Transaction);
    fn process_pending_transactions(&mut self) -> Result<(), String>;
    fn validate_transaction(&self, transaction: &Transaction) -> Result<bool, String>;
    fn calculate_hash(block: &Block) -> String;
    async fn start_consensus_round(&mut self, block: &mut Block) -> Result<(), String>;
    async fn vote_on_block(&mut self, block: &mut Block, validator_did: String, vote: bool) -> Result<(), String>;
    async fn finalize_block(&mut self, block: &mut Block) -> Result<(), String>;
    fn validate_contribution(&self, contribution: &Contribution) -> Result<bool, String>;
    async fn propose_block(&self, block: TendermintBlock) -> Result<(), String>;
    async fn vote_on_tendermint_block(&self, block: TendermintBlock, vote: bool) -> Result<(), String>;
    async fn finalize_tendermint_block(&self, block: TendermintBlock) -> Result<(), String>;
}

pub struct Blockchain {
    pub blocks: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub tendermint_client: Client,
    pub trusted_state: Arc<Mutex<TrustedState>>,
    pub cache: HashMap<String, Block>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
}

impl Blockchain {
    pub fn new(tendermint_client: Client, trusted_state: TrustedState, identity_system: Arc<Mutex<IdentitySystem>>, reputation_system: Arc<Mutex<ReputationSystem>>) -> Self {
        Self {
            blocks: vec![Block::new(0, "genesis".to_string(), vec![], "genesis".to_string())],
            pending_transactions: vec![],
            tendermint_client,
            trusted_state: Arc::new(Mutex::new(trusted_state)),
            cache: HashMap::new(),
            identity_system,
            reputation_system,
        }
    }

    pub async fn add_transaction(&mut self, _transaction: Transaction) -> Result<(), String> {
        // Validate transaction
        let sender = &_transaction.sender;
        
        // Check if sender has permission
        {
            let identity_system = self.identity_system.lock().unwrap();
            match _transaction.transaction_type {
                icn_types::TransactionType::Transfer { .. } => {
                    if !identity_system.has_permission(sender, "transfer") {
                        return Err("Sender does not have transfer permission".to_string());
                    }
                },
                _ => {
                    // Other transaction types validation
                }
            }
        }
        
        // Add to pending transactions
        self.pending_transactions.push(_transaction);
        Ok(())
    }

    pub async fn add_block(&mut self, mut block: Block) -> Result<(), String> {
        // Verify block
        let last_block = self.blocks.last().ok_or("No blocks in chain")?;
        if block.previous_hash != last_block.hash {
            return Err("Invalid previous hash".to_string());
        }
        
        // Process transactions in block
        for transaction in &block.transactions {
            // Process transaction effects
            match &transaction.transaction_type {
                icn_types::TransactionType::Transfer { receiver, amount } => {
                    // In a real implementation, this would update balances
                    // For now, just adjust reputation based on transaction
                    {
                        let mut reputation = self.reputation_system.lock().unwrap();
                        reputation.increase_reputation(&transaction.sender, 1);
                    }
                },
                _ => {
                    // Process other transaction types
                }
            }
        }
        
        // Finalize and add block
        block.finalize().await?;
        self.blocks.push(block);
        
        // Clear processed transactions from pending
        self.pending_transactions.clear();
        
        Ok(())
    }

    pub async fn verify_chain(&self) -> Result<(), String> {
        if self.blocks.is_empty() {
            return Ok(());
        }
        
        // Check that each block links to previous block
        for i in 1..self.blocks.len() {
            let current_block = &self.blocks[i];
            let previous_block = &self.blocks[i-1];
            
            // Verify previous hash
            if current_block.previous_hash != previous_block.hash {
                return Err(format!("Block {} has invalid previous_hash", i));
            }
            
            // Verify block hash
            if current_block.hash != current_block.calculate_hash() {
                return Err(format!("Block {} has invalid hash", i));
            }
        }
        
        Ok(())
    }
}

impl BlockchainOperations for Blockchain {
    fn add_block(&mut self, block: Block) {
        info!("Adding block with index: {}", block.index);
        self.cache.insert(block.index.to_string(), block.clone());
        self.blocks.push(block);
    }

    fn get_latest_block(&self) -> Option<&Block> {
        self.blocks.last()
    }

    fn get_block_by_index(&self, index: usize) -> Option<&Block> {
        if let Some(block) = self.cache.get(&index.to_string()) {
            return Some(block);
        }
        self.blocks.get(index)
    }

    fn add_transaction(&mut self, transaction: Transaction) {
        info!("Adding transaction with ID: {}", transaction.id);
        self.pending_transactions.push(transaction);
    }

    fn process_pending_transactions(&mut self) -> Result<(), String> {
        info!("Processing pending transactions");
        let mut new_block = Block::new();
        for transaction in &self.pending_transactions {
            if self.validate_transaction(transaction)? {
                new_block.add_transaction(transaction.clone());
            } else {
                return Err("Invalid transaction".to_string());
            }
        }
        self.add_block(new_block);
        self.pending_transactions.clear();
        Ok(())
    }

    fn validate_transaction(&self, transaction: &Transaction) -> Result<bool, String> {
        info!("Validating transaction with ID: {}", transaction.id);
        if let Some(proof) = &transaction.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(true)
    }

    fn calculate_hash(block: &Block) -> String {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string());
        hasher.update(&block.previous_hash);
        hasher.update(block.timestamp.to_string());
        for tx in &block.transactions {
            hasher.update(serde_json::to_string(tx).unwrap());
        }
        hasher.update(&block.proposer);
        format!("{:x}", hasher.finalize())
    }

    async fn start_consensus_round(&mut self, block: &mut Block) -> Result<(), String> {
        info!("Starting consensus round for block with index: {}", block.index);
        block.start_consensus_round().await.map_err(|e| e.to_string())
    }

    async fn vote_on_block(&mut self, block: &mut Block, validator_did: String, vote: bool) -> Result<(), String> {
        info!("Voting on block with index: {} by validator: {}", block.index, validator_did);
        block.vote_on_block(validator_did, vote).await.map_err(|e| e.to_string())
    }

    async fn finalize_block(&mut self, block: &mut Block) -> Result<(), String> {
        info!("Finalizing block with index: {}", block.index);
        if block.metadata.validator_count >= 3 { // Assuming 3 is the required number of validators for consensus
            block.finalize().await.map_err(|e| e.to_string())?;
            self.add_block(block.clone());
            Ok(())
        } else {
            Err("Consensus not reached".to_string())
        }
    }

    fn validate_contribution(&self, contribution: &Contribution) -> Result<bool, String> {
        info!("Validating contribution");
        Ok(true)
    }

    async fn propose_block(&self, block: TendermintBlock) -> Result<(), String> {
        info!("Proposing block with height: {}", block.header.height);
        if let Some(proof) = &block.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(())
    }

    async fn vote_on_tendermint_block(&self, block: TendermintBlock, vote: bool) -> Result<(), String> {
        info!("Voting on Tendermint block with height: {}", block.header.height);
        if let Some(proof) = &block.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(())
    }

    async fn finalize_tendermint_block(&self, block: TendermintBlock) -> Result<(), String> {
        info!("Finalizing Tendermint block with height: {}", block.header.height);
        Ok(())
    }
}
```

===================
File: ./backend/src/core.rs
Size: 6329 bytes
===================
```rs
use std::sync::{Arc, Mutex};
use crate::blockchain::Blockchain;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::governance::ProposalHistory;
use crate::services::{BlockchainService, IdentityService, GovernanceService};
use async_trait::async_trait;
use icn_consensus::ConsensusEngine;
use tendermint::rpc::Client;
use tendermint::lite::TrustedState;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_identity::ledger::{get_identity_from_ledger}; // Import icn-identity ledger function
use std::collections::HashMap;
use log::{info, error};
use crate::networking::p2p::P2PManager;

pub trait CoreOperations {
    fn start(&self) -> Result<(), String>;
    fn stop(&self) -> Result<(), String>;
    fn secure_communication(&self, address: &str, message: &[u8]) -> Result<(), String>;
    fn handle_mutual_credit_transaction(&self, sender: &str, receiver: &str, amount: f64) -> Result<(), String>;
    fn handle_mutual_credit_transaction_with_proof(&self, sender: &str, receiver: &str, amount: f64, proof: &str) -> Result<(), String>;
    fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String>;
    fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String>;
    fn manage_federation_lifecycle(&self, federation_id: &str, action: &str) -> Result<(), String>;
    fn update_proposal_status(&self, proposal_id: i64, status: &str) -> Result<(), String>;
    fn handle_resource_sharing(&self, resource_id: &str, action: &str) -> Result<(), String>;
    fn create_local_cluster(&self, cluster_name: &str, region: &str, members: Vec<String>) -> Result<(), String>;
    fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String>;
}

pub struct Core {
    pub blockchain_service: Arc<BlockchainService>,
    pub identity_service: Arc<IdentityService>,
    pub governance_service: Arc<GovernanceService>,
    pub p2p_manager: Arc<Mutex<P2PManager>>,
}

impl Core {
    pub fn new() -> Self {
        // Create the foundational systems
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        
        // Create blockchain with references to identity and reputation
        let blockchain = Arc::new(Mutex::new(
            Blockchain::new(identity_system.clone(), reputation_system.clone())
        ));
        
        // Create proposal history
        let proposal_history = Arc::new(Mutex::new(ProposalHistory::new()));
        
        // Create services
        let blockchain_service = Arc::new(BlockchainService::new(blockchain));
        let identity_service = Arc::new(IdentityService::new(identity_system));
        let governance_service = Arc::new(GovernanceService::new(proposal_history));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        
        Self {
            blockchain_service,
            identity_service,
            governance_service,
            p2p_manager,
        }
    }
    
    pub async fn start(&self) -> Result<(), String> {
        println!("Starting ICN core services...");
        
        // Initialize any systems that need startup
        // For demonstration purposes, this doesn't do much
        
        println!("ICN core services started successfully");
        Ok(())
    }
    
    pub async fn shutdown(&self) -> Result<(), String> {
        println!("Shutting down ICN core services...");
        
        // Clean up any resources
        
        println!("ICN core services shut down successfully");
        Ok(())
    }
}

#[async_trait]
impl ConsensusEngine for Core {
    async fn start(&self) -> Result<(), String> {
        self.start().await
    }

    async fn stop(&self) -> Result<(), String> {
        self.shutdown().await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use crate::storage::StorageManager;
    use crate::networking::NetworkManager;
    use crate::identity::IdentityManager;
    use crate::reputation::ReputationManager;
    use crate::core::consensus::TendermintConsensus;
    use async_trait::async_trait;

    struct MockTelemetryManager;

    impl MockTelemetryManager {
        fn log(&self, _message: &str) {
            // Mock logging
        }
    }

    struct MockRuntimeManager;

    #[async_trait]
    impl RuntimeManager for MockRuntimeManager {
        async fn start(&self) -> Result<(), String> {
            Ok(())
        }

        async fn stop(&self) -> Result<(), String> {
            Ok(())
        }
    }

    struct MockConsensusEngine;

    #[async_trait]
    impl ConsensusEngine for MockConsensusEngine {
        async fn start(&self) -> Result<(), String> {
            Ok(())
        }

        async fn stop(&self) -> Result<(), String> {
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_handle_mutual_credit_transaction() {
        let core = Core::new();

        let result = core.handle_mutual_credit_transaction("sender", "receiver", 100.0).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_submit_proposal() {
        let core = Core::new();

        let result = core.submit_proposal("title", "description", "creator", "2025-12-31").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote() {
        let core = Core::new();

        let result = core.vote(1, "voter", true).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_manage_federation_lifecycle() {
        let core = Core::new();

        let result = core.manage_federation_lifecycle("federation_id", "action").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_create_local_cluster() {
        let core = Core::new();

        let result = core.create_local_cluster("cluster_name", "region", vec!["member1".to_string(), "member2".to_string()]).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_delegated_governance() {
        let core = Core::new();

        let result = core.handle_delegated_governance("federation_id", "representative_id").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/core/consensus.rs
Size: 13611 bytes
===================
```rs
use async_trait::async_trait;
use crate::reputation::ReputationManager;
use tendermint::lite::{self, TrustedState, ValidatorSet};
use tendermint::rpc::Client;
use tokio::sync::Mutex;
use std::sync::Arc;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self) -> Result<(), String>;
    async fn stop(&self) -> Result<(), String>;
    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String>;
    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String>;
    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String>;
    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String>;
    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String>;
    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String>;
    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String>;
    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String>;
    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String>;
    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String>;
    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String>; // Pfffb
    async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String>; // Pf5c9
}

pub struct ProofOfCooperation {
    reputation_manager: ReputationManager,
    current_round: u64,
    participants: Vec<String>,
    proposed_block: Option<tendermint::block::Block>,
    votes: Vec<bool>,
    timeout: std::time::Duration,
    round_start_time: std::time::Instant,
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: ReputationManager) -> Self {
        Self {
            reputation_manager,
            current_round: 0,
            participants: Vec::new(),
            proposed_block: None,
            votes: Vec::new(),
            timeout: std::time::Duration::from_secs(60),
            round_start_time: std::time::Instant::now(),
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: tendermint::block::Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            self.participants.push(participant);
            self.votes.push(vote);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<tendermint::block::Block>, String> {
        let (total_reputation, approval_reputation) = self.parallel_vote_counting().await?;

        // BFT requirement: Need more than 2/3 of total reputation for finalization
        let bft_threshold = (total_reputation as f64 * 2.0 / 3.0) as i64;

        if approval_reputation > bft_threshold {
            if let Some(block) = &self.proposed_block {
                // Update block metadata before finalization
                let mut final_block = block.clone();
                let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                final_block.header.time = tendermint::time::Time::from_unix_timestamp(consensus_duration as i64, 0).unwrap();

                // Clear round state
                self.start_round();

                Ok(Some(final_block))
            } else {
                Err("No proposed block".into())
            }
        } else {
            Ok(None)
        }
    }

    pub async fn handle_timeout(&self) {
        // Placeholder logic for handling timeout
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus").unwrap_or(false)
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), String> {
        let total_reputation: i64 = self.participants.iter().map(|p| self.reputation_manager.get_reputation(p, "consensus").unwrap_or(0)).sum();
        let approval_reputation: i64 = self.participants.iter().zip(&self.votes).filter(|(_, &v)| v).map(|(p, _)| self.reputation_manager.get_reputation(p, "consensus").unwrap_or(0)).sum();
        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, String> {
        let mut validators = Vec::new();
        for participant in &self.participants {
            if self.reputation_manager.is_eligible(participant, min_reputation, "consensus").unwrap_or(false) {
                validators.push(participant.clone());
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.participants.len() / 3) * 3 + 1;
        if validators.len() < min_validators {
            return Err(format!("Insufficient validators: {} (need {})", validators.len(), min_validators));
        }

        Ok(validators)
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| e.to_string())
    }

    pub async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        apply_reputation_decay_in_ledger(_did, decay_rate).await.map_err(|e| e.to_string())
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) -> Result<(), String> {
        // Placeholder logic for starting the consensus engine
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        // Placeholder logic for stopping the consensus engine
        Ok(())
    }

    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String> {
        self.reputation_manager.get_reputation(did, category).await
    }

    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String> {
        self.reputation_manager.is_eligible(did, min_reputation, category).await
    }

    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String> {
        self.reputation_manager.adjust_reputation(did, contribution, "consensus").await
    }

    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> {
        self.reputation_manager.apply_decay(_did, decay_rate).await
    }

    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String> {
        self.reputation_based_access(did, min_reputation).await
    }

    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        self.propose_block(block);
        Ok(())
    }

    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String> {
        self.vote(block.header.proposer_address.to_string(), vote);
        Ok(())
    }

    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        self.finalize_block().await.map(|_| ()).map_err(|e| e.to_string())
    }

    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Placeholder logic for submitting a proposal
        Ok(1) // Placeholder proposal ID
    }

    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        // Placeholder logic for voting on a proposal
        Ok(())
    }

    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        self.handle_sybil_resistance(did, reputation_score).await
    }

    async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        self.apply_reputation_decay(_did, decay_rate).await
    }
}

pub struct TendermintConsensus {
    client: Client,
    trusted_state: Arc<Mutex<TrustedState>>,
}

impl TendermintConsensus {
    pub fn new(client: Client, trusted_state: TrustedState) -> Self {
        Self {
            client,
            trusted_state: Arc::new(Mutex::new(trusted_state)),
        }
    }
}

#[async_trait]
impl ConsensusEngine for TendermintConsensus {
    async fn start(&self) -> Result<(), String> {
        // Placeholder logic for starting the Tendermint consensus engine
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        // Placeholder logic for stopping the Tendermint consensus engine
        Ok(())
    }

    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String> {
        // Placeholder logic for getting reputation
        Ok(0)
    }

    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String> {
        // Placeholder logic for checking eligibility
        Ok(true)
    }

    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String> {
        // Placeholder logic for dynamic adjustment
        Ok(())
    }

    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> {
        // Placeholder logic for applying decay
        Ok(())
    }

    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String> {
        // Placeholder logic for reputation-based access
        Ok(true)
    }

    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        // Placeholder logic for proposing a block
        Ok(())
    }

    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String> {
        // Placeholder logic for voting on a block
        Ok(())
    }

    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        // Placeholder logic for finalizing a block
        Ok(())
    }

    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Placeholder logic for submitting a proposal
        Ok(1) // Placeholder proposal ID
    }

    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        // Placeholder logic for voting on a proposal
        Ok(())
    }

    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }

    async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        // Placeholder logic for applying reputation decay
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::reputation::ReputationManager;
    use tokio::sync::Mutex;
    use std::sync::Arc;
    use tendermint::lite::TrustedState;
    use tendermint::rpc::Client;

    #[tokio::test]
    async fn test_propose_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.propose_block(block).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote_on_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.vote_on_block(block, true).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_finalize_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.finalize_block(block).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_submit_proposal() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let result = consensus.submit_proposal("Test Proposal", "This is a test proposal", "did:icn:test", "2024-12-31T23:59:59Z").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote_on_proposal() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let result = consensus.vote(1, "did:icn:test", true).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/core/ledger.rs
Size: 3137 bytes
===================
```rs
use crate::database::models::{Proposal, Vote};
use crate::database::queries::{create_proposal, record_vote};
use sqlx::PgPool;
use std::sync::Arc;

pub struct Ledger {
    db_pool: Arc<PgPool>,
}

impl Ledger {
    pub fn new(db_pool: Arc<PgPool>) -> Self {
        Self { db_pool }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        create_proposal(&self.db_pool, &proposal).await
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        record_vote(&self.db_pool, &vote).await
    }

    pub async fn record_federation_transaction(&self, federation_id: i64, transaction: &str) -> Result<(), sqlx::Error> {
        // Placeholder logic for recording federation transaction
        Ok(())
    }

    pub async fn record_proposal_transaction(&self, proposal_id: i64, transaction: &str) -> Result<(), sqlx::Error> {
        // Placeholder logic for recording proposal transaction
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::database::models::{Proposal, Vote};
    use sqlx::{PgPool, Executor};
    use std::sync::Arc;
    use chrono::NaiveDateTime;

    async fn setup_test_db() -> Arc<PgPool> {
        let pool = PgPool::connect("postgres://icnuser:icnpass@localhost/icndb").await.unwrap();
        pool.execute("TRUNCATE TABLE proposals, votes").await.unwrap();
        Arc::new(pool)
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let result = ledger.create_proposal(proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = ledger.record_vote(vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_federation_transaction() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let result = ledger.record_federation_transaction(1, "Test Federation Transaction").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_proposal_transaction() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let result = ledger.record_proposal_transaction(1, "Test Proposal Transaction").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/database.rs
Size: 3228 bytes
===================
```rs
use sqlx::PgPool;
use std::sync::Arc;
use std::env;
use crate::models::*;

pub struct Database {
    pub pool: Arc<PgPool>,
}

impl Database {
    pub async fn new() -> Result<Self, sqlx::Error> {
        let database_url = env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@localhost:5432/icndb".to_string());
            
        let pool = PgPool::connect(&database_url).await?;
        
        Ok(Self {
            pool: Arc::new(pool),
        })
    }
    
    pub async fn create_proposal(&self, _proposal: &Proposal) -> Result<i64, sqlx::Error> {
        // This is a mock implementation for testing
        Ok(1) // Return a dummy proposal ID
    }
    
    pub async fn get_proposal(&self, id: i64) -> Result<Proposal, sqlx::Error> {
        // This is a mock implementation for testing
        // In a real system, this would query the database
        Ok(Proposal {
            id,
            title: "Test Proposal".to_string(),
            description: "A test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp_opt(1714000000, 0).unwrap(),
            created_at: chrono::NaiveDateTime::from_timestamp_opt(1613000000, 0).unwrap(),
            verifiable_credential: None,
            did: "did:icn:test".to_string(),
        })
    }
    
    pub async fn record_vote(&self, vote: &Vote) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn get_identity(&self, did: &str) -> Result<String, sqlx::Error> {
        // This is a mock implementation for testing
        Ok(did.to_string())
    }
    
    pub async fn update_identity(&self, did: &str, data: &str) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn create_federation(&self, federation: &Federation) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn add_federation_member(&self, member: &FederationMember) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn register_resource(&self, resource: &Resource) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn update_resource_usage(&self, id: &str, usage: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
}

// For tests that don't need a real database connection
#[cfg(test)]
pub fn create_test_database() -> Database {
    use std::sync::Arc;
    use sqlx::PgPool;
    
    Database {
        pool: Arc::new(PgPool::new("postgres://icnuser:icnpass@localhost:5432/icndb_test")),
    }
}
```

===================
File: ./backend/src/database/db.rs
Size: 7343 bytes
===================
```rs
use sqlx::PgPool;
use crate::models::{Proposal, Vote};
use std::env;

pub struct Database {
    pool: PgPool,
}

impl Database {
    pub async fn new() -> Result<Self, sqlx::Error> {
        // Load from environment variable with fallback
        let database_url = env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
            
        let pool = PgPool::connect(&database_url).await?;
        
        // Run migrations
        sqlx::migrate!("./migrations")
            .run(&pool)
            .await?;
            
        Ok(Self { pool })
    }

    pub async fn create_proposal(&self, proposal: &Proposal) -> Result<i64, sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO proposals (title, description, created_by, ends_at, did)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id
            "#,
            proposal.title,
            proposal.description,
            proposal.created_by,
            proposal.ends_at,
            proposal.did
        )
        .fetch_one(&self.pool)
        .await
        .map(|row| row.id)
        .map_err(|e| {
            eprintln!("Error creating proposal: {}", e);
            e
        })
    }

    pub async fn record_vote(&self, _vote: &Vote) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO votes (proposal_id, voter, approve)
            VALUES ($1, $2, $3)
            "#,
            _vote.proposal_id,
            _vote.voter,
            _vote.approve
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error recording vote: {}", e);
            e
        })?;
        
        Ok(())
    }

    pub async fn store_identity(&self, identity: &str, data: &str) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO identities (identity, data)
            VALUES ($1, $2)
            ON CONFLICT (identity) DO UPDATE SET data = $2
            "#,
            identity,
            data
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error storing identity: {}", e);
            e
        })?;
        
        Ok(())
    }

    pub async fn retrieve_identity(&self, identity: &str) -> Result<String, sqlx::Error> {
        let result = sqlx::query!(
            r#"
            SELECT data FROM identities WHERE identity = $1
            "#,
            identity
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error retrieving identity: {}", e);
            e
        })?;
        
        Ok(result.data)
    }

    pub async fn execute_query(&self, query: &str) -> Result<sqlx::Row, sqlx::Error> {
        sqlx::query(query)
            .fetch_one(&self.pool)
            .await
    }

    pub async fn run_migration(&self, migration: &str) -> Result<(), sqlx::Error> {
        sqlx::query(migration)
            .execute(&self.pool)
            .await?;
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as f64;
        let contributions = sqlx::query_as!(
            Contribution,
            r#"
            SELECT score, timestamp FROM contributions WHERE did = $1
            "#,
            did
        )
        .fetch_all(&self.pool)
        .await?;

        for contribution in contributions {
            let age = now - contribution.timestamp;
            let decayed_score = (contribution.score as f64 * (-decay_rate * age).exp()) as i64;
            sqlx::query!(
                r#"
                UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
                "#,
                decayed_score,
                did,
                contribution.timestamp
            )
            .execute(&self.pool)
            .await?;
        }

        Ok(())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> PgPool {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        PgPool::connect(&database_url).await.unwrap()
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let proposal = Proposal {
            id: 0,
            title: "Test Proposal".to_string(),
            description: "Test Description".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            did: "did:icn:test".to_string(),
        };

        let result = db.create_proposal(&proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = db.record_vote(&vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_store_and_retrieve_identity() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let identity = "did:icn:test";
        let data = "test data";

        let store_result = db.store_identity(identity, data).await;
        assert!(store_result.is_ok());

        let retrieve_result = db.retrieve_identity(identity).await;
        assert!(retrieve_result.is_ok());
        assert_eq!(retrieve_result.unwrap(), data);
    }

    #[tokio::test]
    async fn test_execute_query() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let query = "SELECT 1";
        let result = db.execute_query(query).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_run_migration() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let migration = "CREATE TABLE test_table (id SERIAL PRIMARY KEY)";
        let result = db.run_migration(migration).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let did = "did:icn:test";
        let decay_rate = 0.05;

        let result = db.apply_reputation_decay(did, decay_rate).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let did = "did:icn:test";
        let reputation_score = 50;

        let result = db.handle_sybil_resistance(did, reputation_score).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/database/migrations.rs
Size: 301 bytes
===================
```rs
use sqlx::migrate::Migrator;
use std::path::Path;

pub async fn run_migrations() -> Result<(), sqlx::Error> {
    let migrator = Migrator::new(Path::new("./migrations")).await?;
    let pool = sqlx::PgPool::connect(&std::env::var("DATABASE_URL")?).await?;
    migrator.run(&pool).await?;
    Ok(())
}
```

===================
File: ./backend/src/database/models.rs
Size: 3954 bytes
===================
```rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Proposal {
    pub id: i64,
    pub title: String,
    pub description: String,
    pub created_by: String,
    pub ends_at: chrono::NaiveDateTime,
    pub created_at: chrono::NaiveDateTime,
    pub _did: String, // Add did field for DID-based access control
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: i64,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Contribution {
    pub id: i64,
    pub did: String,
    pub score: i64,
    pub timestamp: f64,
    pub zk_snark_proof: Option<String>, // Added zk-SNARK proof field
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Federation {
    pub id: i64,
    pub name: String,
    pub description: String,
    pub created_at: chrono::NaiveDateTime,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Resource {
    pub id: i64,
    pub name: String,
    pub resource_type: String,
    pub owner: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_proposal_serialization() {
        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            _did: "did:icn:test".to_string(), // Add did field for DID-based access control
        };

        let serialized = serde_json::to_string(&proposal).unwrap();
        let deserialized: Proposal = serde_json::from_str(&serialized).unwrap();

        assert_eq!(proposal, deserialized);
    }

    #[test]
    fn test_vote_serialization() {
        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let serialized = serde_json::to_string(&vote).unwrap();
        let deserialized: Vote = serde_json::from_str(&serialized).unwrap();

        assert_eq!(vote, deserialized);
    }

    #[test]
    fn test_contribution_serialization() {
        let contribution = Contribution {
            id: 1,
            did: "did:icn:test".to_string(),
            score: 100,
            timestamp: 1_614_000_000.0,
            zk_snark_proof: Some("proof".to_string()),
        };

        let serialized = serde_json::to_string(&contribution).unwrap();
        let deserialized: Contribution = serde_json::from_str(&serialized).unwrap();

        assert_eq!(contribution, deserialized);
    }

    #[test]
    fn test_federation_serialization() {
        let federation = Federation {
            id: 1,
            name: "Test Federation".to_string(),
            description: "This is a test federation".to_string(),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let serialized = serde_json::to_string(&federation).unwrap();
        let deserialized: Federation = serde_json::from_str(&serialized).unwrap();

        assert_eq!(federation, deserialized);
    }

    #[test]
    fn test_resource_serialization() {
        let resource = Resource {
            id: 1,
            name: "Test Resource".to_string(),
            resource_type: "cpu".to_string(),
            owner: "did:icn:test".to_string(),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            updated_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let serialized = serde_json::to_string(&resource).unwrap();
        let deserialized: Resource = serde_json::from_str(&serialized).unwrap();

        assert_eq!(resource, deserialized);
    }
}
```

===================
File: ./backend/src/database/queries.rs
Size: 6448 bytes
===================
```rs
use sqlx::PgPool;
use crate::database::models::{Proposal, Vote, Contribution, Federation, Resource};

pub async fn create_proposal(pool: &PgPool, _proposal: &Proposal) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO proposals (title, description, created_by, ends_at, created_at, did)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
        "#,
        _proposal.title,
        _proposal.description,
        _proposal.created_by,
        _proposal.ends_at,
        _proposal.created_at,
        _proposal.did
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn record_vote(pool: &PgPool, vote: &Vote) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        INSERT INTO votes (proposal_id, voter, approve)
        VALUES ($1, $2, $3)
        "#,
        vote.proposal_id,
        vote.voter,
        vote.approve
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn query_shared_resources(pool: &PgPool, resource_type: &str, owner: Option<&str>) -> Result<Vec<Resource>, sqlx::Error> {
    let query = match owner {
        Some(owner) => {
            sqlx::query_as!(
                Resource,
                r#"
                SELECT * FROM resources
                WHERE resource_type = $1 AND owner = $2
                "#,
                resource_type,
                owner
            )
        }
        None => {
            sqlx::query_as!(
                Resource,
                r#"
                SELECT * FROM resources
                WHERE resource_type = $1
                "#,
                resource_type
            )
        }
    };

    let resources = query.fetch_all(pool).await?;
    Ok(resources)
}

pub async fn store_contribution(pool: &PgPool, contribution: &Contribution) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO contributions (did, score, timestamp, zk_snark_proof)
        VALUES ($1, $2, $3, $4)
        RETURNING id
        "#,
        contribution.did,
        contribution.score,
        contribution.timestamp,
        contribution.zk_snark_proof
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn retrieve_contributions(pool: &PgPool, did: &str) -> Result<Vec<Contribution>, sqlx::Error> {
    let contributions = sqlx::query_as!(
        Contribution,
        r#"
        SELECT id, did, score, timestamp, zk_snark_proof FROM contributions
        WHERE did = $1
        "#,
        did
    )
    .fetch_all(pool)
    .await?;

    Ok(contributions)
}

pub async fn store_proposal(pool: &PgPool, proposal: &Proposal) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO proposals (title, description, created_by, ends_at, created_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
        "#,
        proposal.title,
        proposal.description,
        proposal.created_by,
        proposal.ends_at,
        proposal.created_at
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn store_vote(pool: &PgPool, vote: &Vote) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        INSERT INTO votes (proposal_id, voter, approve)
        VALUES ($1, $2, $3)
        "#,
        vote.proposal_id,
        vote.voter,
        vote.approve
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn create_federation(pool: &PgPool, federation: &Federation) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO federations (name, description, created_at)
        VALUES ($1, $2, $3)
        RETURNING id
        "#,
        federation.name,
        federation.description,
        federation.created_at
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn update_federation_status(pool: &PgPool, federation_id: i64, status: &str) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        UPDATE federations
        SET status = $1
        WHERE id = $2
        "#,
        status,
        federation_id
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn dissolve_federation(pool: &PgPool, federation_id: i64) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        DELETE FROM federations
        WHERE id = $1
        "#,
        federation_id
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn get_federation_status(pool: &PgPool, federation_id: i64) -> Result<String, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        SELECT status FROM federations
        WHERE id = $1
        "#,
        federation_id
    )
    .fetch_one(pool)
    .await?;

    Ok(row.status)
}

pub async fn get_federation_assets(pool: &PgPool, federation_id: i64) -> Result<Vec<Resource>, sqlx::Error> {
    let resources = sqlx::query_as!(
        Resource,
        r#"
        SELECT * FROM resources
        WHERE federation_id = $1
        "#,
        federation_id
    )
    .fetch_all(pool)
    .await?;

    Ok(resources)
}

pub async fn get_federation_debts(pool: &PgPool, federation_id: i64) -> Result<Vec<Resource>, sqlx::Error> {
    let resources = sqlx::query_as!(
        Resource,
        r#"
        SELECT * FROM resources
        WHERE federation_id = $1 AND type = 'debt'
        "#,
        federation_id
    )
    .fetch_all(pool)
    .await?;

    Ok(resources)
}

pub async fn apply_reputation_decay(pool: &PgPool, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
    let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as f64;
    let contributions = sqlx::query_as!(
        Contribution,
        r#"
        SELECT score, timestamp FROM contributions WHERE did = $1
        "#,
        did
    )
    .fetch_all(pool)
    .await?;

    for contribution in contributions {
        let age = now - contribution.timestamp;
        let decayed_score = (contribution.score as f64 * (-decay_rate * age).exp()) as i64;
        sqlx::query!(
            r#"
            UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
            "#,
            decayed_score,
            did,
            contribution.timestamp
        )
        .execute(pool)
        .await?;
    }

    Ok(())
}

pub async fn handle_sybil_resistance(pool: &PgPool, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
    // Placeholder logic for handling Sybil resistance
    Ok(())
}
```

===================
File: ./backend/src/db.rs
Size: 1396 bytes
===================
```rs
use sqlx::PgPool;
use std::sync::Arc;
use std::env;
use crate::models::{Proposal, Vote};

pub struct Database {
    pub db_pool: Arc<PgPool>,
}

impl Database {
    pub fn new(pool: PgPool) -> Self {
        Self {
            db_pool: Arc::new(pool),
        }
    }

    pub async fn create_proposal(&self, proposal: &Proposal) -> Result<i64, sqlx::Error> {
        // This is a mock implementation for testing
        // In a real system, this would insert into a database
        Ok(1)
    }

    pub async fn record_vote(&self, vote: &Vote) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
}

pub async fn create_pool() -> Result<PgPool, sqlx::Error> {
    let database_url = env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        
    let pool = PgPool::connect(&database_url).await?;
    
    // Run migrations
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await?;
        
    Ok(pool)
}
```

===================
File: ./backend/src/db/indexing.rs
Size: 1102 bytes
===================
```rs
use sqlx::{PgPool, Row};
use log::{info, warn};

// Index usage monitoring
pub async fn analyze_index_usage(pool: &PgPool) -> Result<(), sqlx::Error> {
    // Query to get index usage statistics
    let index_stats = sqlx::query(r#"
        SELECT
            schemaname,
            relname AS table_name,
            indexrelname AS index_name,
            idx_scan AS scan_count,
            idx_tup_read AS tuples_read,
            idx_tup_fetch AS tuples_fetched
        FROM
            pg_stat_user_indexes
        ORDER BY
            idx_scan DESC
    "#)
    .fetch_all(pool)
    .await?;
    
    info!("Index usage statistics:");
    for stat in index_stats {
        let schema: String = stat.get("schemaname");
        let table: String = stat.get("table_name");
        let index: String = stat.get("index_name");
        let scans: i64 = stat.get("scan_count");
        
        if scans == 0 {
            warn!("Unused index: {}.{}.{}", schema, table, index);
        } else {
            info!("Index {}.{}.{} used {} times", schema, table, index, scans);
        }
    }
    
    Ok```

===================
File: ./backend/src/federation.rs
Size: 3169 bytes
===================
```rs
use std::collections::HashMap;
use crate::governance::{Federation, FederationType, FederationTerms};

pub struct FederationManager {
    federations: HashMap<String, Federation>,
}

impl FederationManager {
    pub fn new() -> Self {
        Self {
            federations: HashMap::new(),
        }
    }
    
    pub fn create_federation(&mut self, id: String, _federation_type: FederationType, terms: FederationTerms, admin: String) -> Result<(), String> {
        if self.federations.contains_key(&id) {
            return Err("Federation already exists".to_string());
        }
        
        let federation = Federation::new(id.clone(), _federation_type, terms, admin);
        self.federations.insert(id, federation);
        
        Ok(())
    }
    
    pub fn get_federation(&self, id: &str) -> Option<&Federation> {
        self.federations.get(id)
    }
    
    pub fn get_federations_by_member(&self, member_did: &str) -> Vec<&Federation> {
        self.federations.values()
            .filter(|f| f.members.contains_key(member_did))
            .collect()
    }
    
    pub fn add_member_to_federation(&mut self, federation_id: &str, member_did: String, role: crate::governance::MemberRole) -> Result<(), String> {
        let federation = self.federations.get_mut(federation_id)
            .ok_or("Federation not found")?;
            
        federation.add_member(member_did, role)
    }
    
    pub async fn detect_conflicts(&self, federation_id: &str) -> Result<Vec<(String, String)>, String> {
        let federation = self.federations.get(federation_id)
            .ok_or("Federation not found")?;
            
        Ok(federation.detect_resource_conflicts().await)
    }
    
    pub async fn resolve_conflicts(&mut self, federation_id: &str, conflicts: Vec<(String, String)>) -> Result<(), String> {
        let federation = self.federations.get(federation_id)
            .ok_or("Federation not found")?;
            
        federation.resolve_conflicts(conflicts).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_create_federation() {
        let mut manager = FederationManager::new();
        
        let result = manager.create_federation(
            "fed1".to_string(),
            FederationType::Cooperative,
            FederationTerms::default(),
            "admin1".to_string()
        );
        
        assert!(result.is_ok());
        assert!(manager.get_federation("fed1").is_some());
    }
    
    #[test]
    fn test_add_member_to_federation() {
        let mut manager = FederationManager::new();
        
        manager.create_federation(
            "fed1".to_string(),
            FederationType::Cooperative,
            FederationTerms::default(),
            "admin1".to_string()
        ).unwrap();
        
        let result = manager.add_member_to_federation(
            "fed1",
            "member1".to_string(),
            crate::governance::MemberRole::Member
        );
        
        assert!(result.is_ok());
        
        let federation = manager.get_federation("fed1").unwrap();
        assert!(federation.members.contains_key("member1"));
    }
}
```

===================
File: ./backend/src/governance.rs
Size: 19808 bytes
===================
```rs
use crate::models::{Proposal, Vote};
use sqlx::PgPool;
use std::sync::Arc;
use log::{info, error};
use crate::db::Database;
use crate::identity::IdentityManager;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use futures::future::join_all; // Import join_all for concurrency
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalType {
    ResourceAllocation {
        resource: String,
        amount: u64,
    },
    ConfigUpdate {
        parameter: String,
        new_value: String,
    },
    MembershipChange {
        did: String,
        action: String,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub votes_for: u32,
    pub votes_against: u32,
    pub timestamp: u64,
    pub status: ProposalStatus,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Executed,
}

impl Proposal {
    pub fn new(proposer: String, proposal_type: ProposalType) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            proposer,
            proposal_type,
            votes_for: 0,
            votes_against: 0,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            status: ProposalStatus::Active,
        }
    }

    pub fn is_approved(&self) -> bool {
        self.status == ProposalStatus::Approved
            || (self.votes_for > self.votes_against && self.votes_for >= 3)
    }
}

pub struct ProposalHistory {
    pub proposals: HashMap<String, Proposal>,
    pub votes: HashMap<String, HashMap<String, bool>>, // proposal_id -> (voter -> vote)
    pub network_connection: Option<String>, // Simulated network connection
}

impl ProposalHistory {
    pub fn new() -> Self {
        Self {
            proposals: HashMap::new(),
            votes: HashMap::new(),
            network_connection: Some("connected".to_string()),
        }
    }

    pub fn add_proposal(&mut self, proposal: Proposal) {
        let proposal_id = proposal.id.clone();
        self.proposals.insert(proposal_id.clone(), proposal);
        self.votes.insert(proposal_id, HashMap::new());
    }

    pub fn get_proposal(&self, id: String) -> Option<Proposal> {
        self.proposals.get(&id).cloned()
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, vote: bool) -> Result<(), String> {
        // Check if network is connected
        if self.network_connection.is_none() {
            return Err("Network disconnected".to_string());
        }

        // Check if proposal exists
        let proposal = self.proposals.get_mut(&proposal_id).ok_or("Proposal not found")?;

        // Check if voter has already voted
        let votes = self.votes.get_mut(&proposal_id).ok_or("Votes not found")?;
        if votes.contains_key(&voter) {
            return Err("Already voted".to_string());
        }

        // Record vote
        votes.insert(voter, vote);

        // Update proposal vote count
        if vote {
            proposal.votes_for += 1;
        } else {
            proposal.votes_against += 1;
        }

        // Check if proposal is now approved or rejected
        if proposal.votes_for >= 3 {
            proposal.status = ProposalStatus::Approved;
        } else if proposal.votes_against >= 3 {
            proposal.status = ProposalStatus::Rejected;
        }

        Ok(())
    }

    pub fn update_proposal(&mut self, updated_proposal: Proposal) {
        if let Some(proposal) = self.proposals.get_mut(&updated_proposal.id) {
            *proposal = updated_proposal;
        }
    }

    pub async fn reconnect(&mut self) -> Result<(), String> {
        // Simulate network reconnection
        self.network_connection = Some("connected".to_string());
        Ok(())
    }

    pub fn execute_proposal(&mut self, proposal_id: &str) -> Result<(), String> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or("Proposal not found")?;
        
        if proposal.status != ProposalStatus::Approved {
            return Err("Proposal is not approved".to_string());
        }
        
        // Execute proposal actions based on type
        match &proposal.proposal_type {
            ProposalType::ResourceAllocation { resource: _, amount: _ } => {
                // In a real system, this would allocate resources
                // For testing, we just mark it as executed
            }
            ProposalType::ConfigUpdate { parameter: _, new_value: _ } => {
                // In a real system, this would update configuration
            }
            ProposalType::MembershipChange { did: _, action: _ } => {
                // In a real system, this would change membership
            }
        }
        
        proposal.status = ProposalStatus::Executed;
        
        Ok(())
    }
}

pub struct Federation {
    pub id: String,
    pub federation_type: FederationType,
    pub terms: FederationTerms,
    pub admin: String,
    pub members: HashMap<String, MemberRole>,
    pub member_status: HashMap<String, MemberStatus>,
    pub proposals: HashMap<String, Proposal>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FederationType {
    Cooperative,
    Mutual,
    Association,
    Custom(String),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FederationTerms {
    pub minimum_reputation: u64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

impl Default for FederationTerms {
    fn default() -> Self {
        Self {
            minimum_reputation: 0,
            resource_sharing_policies: "Equal".to_string(),
            governance_rules: "Majority".to_string(),
            duration: "2025-12-31T23:59:59Z".to_string(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MemberStatus {
    Active,
    Suspended,
    Inactive,
}

impl Federation {
    pub fn new(id: String, federation_type: FederationType, terms: FederationTerms, admin: String) -> Self {
        let mut members = HashMap::new();
        members.insert(admin.clone(), MemberRole::Admin);
        
        let mut member_status = HashMap::new();
        member_status.insert(admin.clone(), MemberStatus::Active);
        
        Self {
            id,
            federation_type,
            terms,
            admin,
            members,
            member_status,
            proposals: HashMap::new(),
        }
    }
    
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        
        self.members.insert(did.clone(), role);
        self.member_status.insert(did, MemberStatus::Active);
        
        Ok(())
    }
    
    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.member_status.get(did)
    }
    
    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), String> {
        if !self.members.contains_key(did) {
            return Err("Member not found".to_string());
        }
        
        self.member_status.insert(did.to_string(), status);
        
        Ok(())
    }
    
    pub fn get_active_members(&self) -> Vec<String> {
        self.member_status
            .iter()
            .filter(|(_, status)| **status == MemberStatus::Active)
            .map(|(did, _)| did.clone())
            .collect()
    }
    
    pub async fn submit_proposal(&self, proposal: Proposal) -> Result<String, String> {
        // In a real implementation, this would add the proposal to the system
        Ok(proposal.id)
    }
    
    pub async fn detect_resource_conflicts(&self) -> Vec<(String, String)> {
        // This is a simplified conflict detection for testing
        let mut conflicts = Vec::new();
        
        // Find any proposals that allocate more than 70% of the same resource
        let mut resource_allocations = HashMap::new();
        
        for (id, proposal) in &self.proposals {
            if let ProposalType::ResourceAllocation { resource, amount } = &proposal.proposal_type {
                let entry = resource_allocations.entry(resource.clone()).or_insert_with(Vec::new);
                if *amount > 70 {
                    entry.push(id.clone());
                }
            }
        }
        
        // Create conflicts for resources with multiple high-allocation proposals
        for (resource, proposals) in resource_allocations {
            if proposals.len() > 1 {
                for i in 0..proposals.len() {
                    for j in i+1..proposals.len() {
                        conflicts.push((proposals[i].clone(), proposals[j].clone()));
                    }
                }
            }
        }
        
        conflicts
    }
    
    pub async fn resolve_conflicts(&self, _conflicts: Vec<(String, String)>) -> Result<(), String> {
        // In a real implementation, this would resolve conflicts
        Ok(())
    }
}

// Function for handling federation operations used in tests
pub async fn handle_federation_operation(operation: icn_types::FederationOperation) -> Result<String, String> {
    // This is a simplified implementation for testing
    match operation {
        icn_types::FederationOperation::InitiateFederation { 
            federation_type: _, partner_id: _, terms: _ 
        } => {
            Ok("federation123".to_string())
        },
        icn_types::FederationOperation::JoinFederation {
            federation_id, commitment: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::LeaveFederation {
            federation_id, reason: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::ProposeAction {
            federation_id, action_type: _, description: _, resources: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::VoteOnProposal {
            federation_id, proposal_id: _, approve: _, notes: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::ShareResources {
            federation_id, resource_type: _, amount: _, recipient_id: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::UpdateFederationTerms {
            federation_id, new_terms: _
        } => {
            Ok(federation_id)
        },
    }
}

pub struct GovernanceEngine {
    db: Arc<Database>,
    identity_manager: Arc<IdentityManager>,
}

impl GovernanceEngine {
    pub fn new(db: Arc<Database>, identity_manager: Arc<IdentityManager>) -> Self {
        Self {
            db,
            identity_manager,
        }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        // Verify DID using IdentityManager
        if !self.identity_manager.verify_did(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Invalid DID".to_string()));
        }

        // Validate verifiable credential
        if !self.identity_manager.verify_credential(&proposal.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        self.db.create_proposal(&proposal).await.map_err(|e| {
            error!("Error creating proposal: {}", e);
            e
        })
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        // Validate verifiable credential
        if !self.identity_manager.verify_credential(&vote.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        if let Some(proof) = &vote.zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }
        self.db.record_vote(&vote).await.map_err(|e| {
            error!("Error recording vote: {}", e);
            e
        })
    }

    pub async fn list_proposals(&self) -> Result<Vec<Proposal>, sqlx::Error> {
        let proposals = sqlx::query_as!(
            Proposal,
            r#"
            SELECT id, title, description, created_by, ends_at, created_at
            FROM proposals
            "#
        )
        .fetch_all(&*self.db.db_pool)
        .await
        .map_err(|e| {
            error!("Error listing proposals: {}", e);
            e
        })?;
        Ok(proposals)
    }

    pub async fn create_identity(&self, identity: &str) -> Result<(), String> {
        self.identity_manager.create_identity(identity).await
    }

    pub async fn get_identity(&self, identity: &str) -> Result<String, String> {
        self.identity_manager.get_identity(identity).await
    }

    pub async fn update_identity(&self, identity: &str, new_data: &str) -> Result<(), String> {
        self.identity_manager.update_identity(identity, new_data).await
    }

    pub async fn delete_identity(&self, identity: &str) -> Result<(), String> {
        self.identity_manager.delete_identity(identity).await
    }

    pub async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Verify DID using IdentityManager
        if !self.identity_manager.verify_did(created_by).await {
            return Err("Invalid DID".to_string());
        }

        let proposal = Proposal {
            id: 0, // Placeholder, will be set by the database
            title: title.to_string(),
            description: description.to_string(),
            created_by: created_by.to_string(),
            ends_at: chrono::NaiveDateTime::parse_from_str(ends_at, "%Y-%m-%d %H:%M:%S").map_err(|e| e.to_string())?,
            created_at: chrono::Utc::now().naive_utc(),
            did: created_by.to_string(), // Add did field for DID-based access control
        };

        self.create_proposal(proposal).await.map_err(|e| e.to_string())
    }

    pub async fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        let vote = Vote {
            proposal_id: _proposal_id,
            voter: voter.to_string(),
            approve,
        };

        self.record_vote(vote).await.map_err(|e| e.to_string())
    }

    pub async fn get_proposal_status(&self, proposal_id: &str) -> Result<String, sqlx::Error> {
        let status = sqlx::query!(
            r#"
            SELECT status FROM proposals WHERE id = $1
            "#,
            proposal_id
        )
        .fetch_one(&*self.db.db_pool)
        .await
        .map_err(|e| {
            error!("Error getting proposal status: {}", e);
            e
        })?;
        Ok(status.status)
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        self.db.apply_reputation_decay(did, decay_rate).await.map_err(|e| {
            error!("Error applying reputation decay: {}", e);
            e
        })
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        self.db.handle_sybil_resistance(did, reputation_score).await.map_err(|e| {
            error!("Error handling sybil resistance: {}", e);
            e
        })
    }

    pub async fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String> {
        // Placeholder logic for handling delegated governance
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Proposal, Vote};
    use crate::db::Database;
    use crate::identity::IdentityManager;
    use sqlx::{PgPool, Executor};
    use std::sync::Arc;
    use chrono::NaiveDateTime;

    async fn setup_test_db() -> Arc<Database> {
        let pool = PgPool::connect("postgres://icnuser:icnpass@localhost/icndb").await.unwrap();
        pool.execute("TRUNCATE TABLE proposals, votes").await.unwrap();
        Arc::new(Database::new(pool))
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let result = governance_engine.create_proposal(proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = governance_engine.record_vote(vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_list_proposals() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let proposals = governance_engine.list_proposals().await;
        assert!(proposals.is_ok());
    }

    #[tokio::test]
    async fn test_get_proposal_status() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let status = governance_engine.get_proposal_status("1").await;
        assert!(status.is_ok());
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.apply_reputation_decay("did:icn:test", 0.1).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.handle_sybil_resistance("did:icn:test", 50).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_delegated_governance() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.handle_delegated_governance("federation_id", "representative_id").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/identity.rs
Size: 17896 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_identity::ledger::{create_identity_in_ledger, get_identity_from_ledger, rotate_key_in_ledger, revoke_key_in_ledger};
use icn_core::verifiable_credentials::{VerifiableCredential, Proof};
use futures::future::join_all; // Import join_all for concurrency
use rand::rngs::OsRng;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone)]
pub struct BlsPrivateKey {
    key_data: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct BlsPublicKey {
    key_data: Vec<u8>,
}

impl BlsPrivateKey {
    pub fn generate(rng: &mut impl rand::RngCore) -> Self {
        let mut key_data = vec![0u8; 32];
        rng.fill_bytes(&mut key_data);
        Self { key_data }
    }
}

impl From<&BlsPrivateKey> for BlsPublicKey {
    fn from(private_key: &BlsPrivateKey) -> Self {
        // In a real implementation, we'd derive the public key from the private key
        // Here we just create a simple hash-like derivative for testing
        let mut key_data = private_key.key_data.clone();
        for byte in &mut key_data {
            *byte = byte.wrapping_add(1);
        }
        Self { key_data }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Algorithm {
    Secp256k1,
    Ed25519,
    Kyber,
    Dilithium,
    Falcon,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    pub algorithm: Algorithm,
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub is_revoked: bool,
}

pub enum DIDError {
    SigningError(String),
    VerificationError(String),
    RevocationError(String),
}

impl DID {
    pub fn new(id: String, algorithm: Algorithm) -> Self {
        // In a real application, this would generate proper keypairs
        // For testing, we'll simulate key generation
        let mut rng = OsRng;
        
        // Generate random "keys" for testing
        let mut public_key = vec![0u8; 32];
        let mut private_key = vec![0u8; 32];
        rand::Rng::fill(&mut rng, &mut public_key[..]);
        rand::Rng::fill(&mut rng, &mut private_key[..]);
        
        Self {
            id,
            algorithm,
            public_key,
            private_key,
            is_revoked: false,
        }
    }
    
    pub fn sign_message(&self, _message: &[u8]) -> Result<Vec<u8>, DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Key has been revoked".to_string()));
        }
        
        // In a real implementation, this would use the actual crypto library
        // For testing, we'll just simulate a signature
        let mut signature = Vec::with_capacity(64);
        signature.extend_from_slice(&self.private_key);
        signature.extend_from_slice(_message);
        
        Ok(signature)
    }
    
    pub fn verify_signature(&self, message: &[u8], signature: &[u8]) -> Result<bool, DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Key has been revoked".to_string()));
        }
        
        // In a real implementation, this would use the actual crypto library
        // For testing, we'll just verify that the signature contains our private key
        if signature.len() < self.private_key.len() {
            return Err(DIDError::VerificationError("Signature too short".to_string()));
        }
        
        let key_part = &signature[0..self.private_key.len()];
        Ok(key_part == self.private_key.as_slice())
    }
    
    pub fn rotate_key(&mut self) -> Result<(), DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Cannot rotate revoked key".to_string()));
        }
        
        // Generate new keypair
        let mut rng = OsRng;
        rand::Rng::fill(&mut rng, &mut self.public_key[..]);
        rand::Rng::fill(&mut rng, &mut self.private_key[..]);
        
        Ok(())
    }
    
    pub fn revoke_key(&mut self) -> Result<(), DIDError> {
        self.is_revoked = true;
        Ok(())
    }
}

pub struct IdentitySystem {
    pub dids: HashMap<String, DID>,
    pub permissions: HashMap<String, Vec<String>>,
    pub public_keys: HashMap<String, (Vec<u8>, Algorithm)>,
    pub federation_roles: HashMap<String, HashMap<String, Vec<String>>>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        Self {
            dids: HashMap::new(),
            permissions: HashMap::new(),
            public_keys: HashMap::new(),
            federation_roles: HashMap::new(),
        }
    }
    
    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.dids.insert(did.id.clone(), did.clone());
        self.permissions.insert(did.id.clone(), permissions);
        self.public_keys.insert(did.id.clone(), (did.public_key.clone(), did.algorithm));
    }
    
    pub fn has_permission(&self, did_str: &str, permission: &str) -> bool {
        if let Some(perms) = self.permissions.get(did_str) {
            perms.contains(&permission.to_string())
        } else {
            false
        }
    }
    
    pub fn rotate_key(&mut self, did_str: &str) -> Result<(), DIDError> {
        if let Some(did) = self.dids.get_mut(did_str) {
            did.rotate_key()?;
            self.public_keys.insert(did_str.to_string(), (did.public_key.clone(), did.algorithm.clone()));
            Ok(())
        } else {
            Err(DIDError::SigningError("DID not found".to_string()))
        }
    }
    
    pub fn assign_federation_role(&mut self, federation_id: String, did: String, role: String) -> Result<(), String> {
        let federation_roles = self.federation_roles
            .entry(federation_id)
            .or_insert_with(HashMap::new);
            
        let roles = federation_roles
            .entry(did)
            .or_insert_with(Vec::new);
            
        if !roles.contains(&role) {
            roles.push(role);
        }
        
        Ok(())
    }
    
    pub fn revoke_federation_role(&mut self, federation_id: &str, did: &str, role: &str) -> Result<(), String> {
        if let Some(federation_roles) = self.federation_roles.get_mut(federation_id) {
            if let Some(roles) = federation_roles.get_mut(did) {
                roles.retain(|r| r != role);
                return Ok(());
            }
        }
        Err("Federation or DID not found".to_string())
    }
    
    pub fn get_federation_roles(&self, federation_id: &str, did: &str) -> Vec<String> {
        self.federation_roles
            .get(federation_id)
            .and_then(|federation_roles| federation_roles.get(did))
            .cloned()
            .unwrap_or_else(Vec::new)
    }
    
    pub fn generate_bls_threshold_signature(&self, message: &[u8], _private_keys: Vec<BlsPrivateKey>) -> Result<Vec<u8>, String> {
        // This is a simplified mock for testing
        Ok(message.to_vec())
    }
    
    pub fn verify_bls_threshold_signature(&self, message: &[u8], signature: &[u8], _public_keys: Vec<BlsPublicKey>) -> Result<bool, String> {
        // This is a simplified mock for testing
        Ok(message == signature)
    }
}

pub struct IdentityManager {
    identities: Arc<Mutex<HashMap<String, String>>>,
    local_clusters: Arc<Mutex<HashMap<String, Vec<String>>>>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: Arc::new(Mutex::new(HashMap::new())),
            local_clusters: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn create_identity(&self, identity: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if identities.contains_key(identity) {
            return Err("Identity already exists".to_string());
        }
        identities.insert(identity.to_string(), String::new());

        // Issue Verifiable Credential in ICN format
        let credential = VerifiableCredential {
            credential_type: "IdentityCredential".to_string(),
            issuer_did: "did:icn:issuer".to_string(),
            subject_did: identity.to_string(),
            issuance_date: chrono::Utc::now().to_rfc3339(),
            expiration_date: None,
            credential_status: None,
            credential_schema: None,
            proof: Proof {
                type_: "Ed25519Signature2018".to_string(),
                created: chrono::Utc::now().to_rfc3339(),
                proof_purpose: "assertionMethod".to_string(),
                verification_method: "did:icn:issuer#keys-1".to_string(),
                jws: "example-jws".to_string(),
            },
        };

        // Store identity in icn-identity ledger
        create_identity_in_ledger(identity, &credential).await.map_err(|e| e.to_string())?;

        Ok(())
    }

    pub async fn get_identity(&self, identity: &str) -> Result<String, String> {
        // Retrieve identity from icn-identity ledger
        get_identity_from_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn update_identity(&self, identity: &str, new_data: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if let Some(existing_identity) = identities.get_mut(identity) {
            *existing_identity = new_data.to_string();
            Ok(())
        } else {
            Err("Identity not found".to_string())
        }
    }

    pub async fn delete_identity(&self, identity: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if identities.remove(identity).is_some() {
            Ok(())
        } else {
            Err("Identity not found".to_string())
        }
    }

    pub async fn rotate_key(&self, identity: &str) -> Result<(), String> {
        // Rotate key in icn-identity ledger
        rotate_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn revoke_key(&self, identity: &str) -> Result<(), String> {
        // Revoke key in icn-identity ledger
        revoke_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn create_local_cluster(&self, cluster_name: &str, members: Vec<String>) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if local_clusters.contains_key(cluster_name) {
            return Err("Local cluster already exists".to_string());
        }
        local_clusters.insert(cluster_name.to_string(), members);
        Ok(())
    }

    pub async fn get_local_cluster(&self, cluster_name: &str) -> Result<Vec<String>, String> {
        let local_clusters = self.local_clusters.lock().await;
        local_clusters.get(cluster_name).cloned().ok_or_else(|| "Local cluster not found".to_string())
    }

    pub async fn add_member_to_cluster(&self, cluster_name: &str, member: String) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if let Some(cluster) = local_clusters.get_mut(cluster_name) {
            if cluster.contains(&member) {
                return Err("Member already in cluster".to_string());
            }
            cluster.push(member);
            Ok(())
        } else {
            Err("Local cluster not found".to_string())
        }
    }

    pub async fn remove_member_from_cluster(&self, cluster_name: &str, member: &str) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if let Some(cluster) = local_clusters.get_mut(cluster_name) {
            if let Some(pos) = cluster.iter().position(|x| x == member) {
                cluster.remove(pos);
                Ok(())
            } else {
                Err("Member not found in cluster".to_string())
            }
        } else {
            Err("Local cluster not found".to_string())
        }
    }

    pub async fn verify_signature_concurrently(&self, dids: Vec<&str>, signatures: Vec<&str>, messages: Vec<&str>) -> Result<Vec<bool>, String> {
        let verification_futures: Vec<_> = dids.iter().zip(signatures.iter()).zip(messages.iter())
            .map(|((&did, &signature), &message)| {
                async move {
                    // Placeholder for actual signature verification logic
                    // Replace with actual implementation
                    Ok(true)
                }
            })
            .collect();

        let results = join_all(verification_futures).await;
        results.into_iter().collect()
    }
}

// BLS key types for threshold signatures
pub struct BlsPrivateKey(Vec<u8>);
pub struct BlsPublicKey(Vec<u8>);

impl BlsPrivateKey {
    pub fn new() -> Self {
        // In a real implementation, this would generate a proper BLS key
        Self(vec![0u8; 32])
    }
    
    pub fn to_bytes(&self) -> &[u8] {
        &self.0
    }
}

impl BlsPublicKey {
    pub fn from_private(private: &BlsPrivateKey) -> Self {
        // In a real implementation, this would derive the public key from private
        // For testing, we just use a different pattern
        let mut bytes = vec![0u8; 48];
        bytes[0] = 1; // Mark as public key
        Self(bytes)
    }
    
    pub fn to_bytes(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    #[test]
    fn test_create_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let result = identity_manager.create_identity("test_identity").await;
            assert!(result.is_ok());
        });
    }

    #[test]
    fn test_get_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.get_identity("test_identity").await;
            assert_eq!(result.unwrap(), "");
        });
    }

    #[test]
    fn test_update_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.update_identity("test_identity", "new_data").await;
            assert!(result.is_ok());
            let updated_identity = identity_manager.get_identity("test_identity").await.unwrap();
            assert_eq!(updated_identity, "new_data");
        });
    }

    #[test]
    fn test_delete_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.delete_identity("test_identity").await;
            assert!(result.is_ok());
            let deleted_identity = identity_manager.get_identity("test_identity").await;
            assert!(deleted_identity.is_err());
        });
    }

    #[test]
    fn test_create_local_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let result = identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await;
            assert!(result.is_ok());
        });
    }

    #[test]
    fn test_get_local_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.get_local_cluster("test_cluster").await;
            assert_eq!(result.unwrap(), vec!["member1".to_string(), "member2".to_string()]);
        });
    }

    #[test]
    fn test_add_member_to_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.add_member_to_cluster("test_cluster", "member3".to_string()).await;
            assert!(result.is_ok());
            let cluster = identity_manager.get_local_cluster("test_cluster").await.unwrap();
            assert_eq!(cluster, vec!["member1".to_string(), "member2".to_string(), "member3".to_string()]);
        });
    }

    #[test]
    fn test_remove_member_from_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.remove_member_from_cluster("test_cluster", "member1").await;
            assert!(result.is_ok());
            let cluster = identity_manager.get_local_cluster("test_cluster").await.unwrap();
            assert_eq!(cluster, vec!["member2".to_string()]);
        });
    }

    #[test]
    fn test_verify_signature_concurrently() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let dids = vec!["did:example:123", "did:example:456"];
            let signatures = vec!["signature1", "signature2"];
            let messages = vec!["message1", "message2"];
            let result = identity_manager.verify_signature_concurrently(dids, signatures, messages).await;
            assert!(result.is_ok());
            let verification_results = result.unwrap();
            assert_eq!(verification_results, vec![true, true]);
        });
    }
}
```

===================
File: ./backend/src/lib.rs
Size: 327 bytes
===================
```rs
pub mod api;
pub mod core;
pub mod db;
pub mod middleware;

use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
}

pub type Result<T> = std::result::Result<T, AppError>;
```

===================
File: ./backend/src/main.rs
Size: 2918 bytes
===================
```rs
use std::net::SocketAddr;
use warp::{Filter, Reply};
use log::{info, error};
use warp::ws::WebSocket;
use futures::{StreamExt, SinkExt};  // Combined StreamExt and added SinkExt

#[tokio::main]
async fn main() {
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("info"));
    info!("Starting ICN backend server...");

    // WebSocket handler
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .map(|ws: warp::ws::Ws| {
            ws.on_upgrade(handle_websocket_connection)
        });

    // Health check route
    let health_route = warp::path("api")
        .and(warp::path("v1"))
        .and(warp::path("health"))
        .and(warp::get())
        .map(|| {
            info!("Health check requested");
            warp::reply::json(&serde_json::json!({
                "status": "ok",
                "version": env!("CARGO_PKG_VERSION")
            }))
        });

    // Combine routes and add CORS
    let routes = health_route
        .or(ws_route)
        .with(warp::cors()
            .allow_any_origin()
            .allow_headers(vec!["content-type"])
            .allow_methods(vec!["GET", "POST", "PUT", "DELETE"])
        )
        .with(warp::log("icn_backend"));

    // Configure server address and start
    let addr = SocketAddr::from(([0, 0, 0, 0], 8081));
    info!("Server starting on http://{}", addr);
    
    warp::serve(routes)
        .run(addr)
        .await;
}

async fn handle_websocket_connection(ws: WebSocket) {
    let (mut ws_tx, mut ws_rx) = ws.split();
    
    // Handle incoming messages
    while let Some(result) = ws_rx.next().await {
        match result {
            Ok(msg) => {
                info!("Received message: {:?}", msg);
                // Echo the message back
                if let Err(e) = ws_tx.send(msg).await {
                    error!("Error sending ws message: {}", e);
                    break;
                }
            }
            Err(e) => {
                error!("Error receiving ws message: {}", e);
                break;
            }
        }
    }
}

fn with_db(pool: sqlx::PgPool) -> impl Filter<Extract = (sqlx::PgPool,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || pool.clone())
}

async fn health_handler(pool: sqlx::PgPool) -> Result<impl Reply, warp::Rejection> {
    // Test database connectivity
    let db_healthy = sqlx::query("SELECT 1")
        .fetch_one(&pool)
        .await
        .is_ok();

    let status = if db_healthy {
        warp::http::StatusCode::OK
    } else {
        warp::http::StatusCode::SERVICE_UNAVAILABLE
    };

    Ok(warp::reply::with_status(
        warp::reply::json(&serde_json::json!({
            "status": if db_healthy { "healthy" } else { "unhealthy" },
            "version": env!("CARGO_PKG_VERSION"),
            "database": db_healthy
        })),
        status
    ))
}
```

===================
File: ./backend/src/middleware/mod.rs
Size: 260 bytes
===================
```rs
use warp::Filter;

pub fn cors() -> warp::cors::Builder {
    warp::cors()
        .allow_any_origin()
        .allow_methods(vec!["GET", "POST", "PUT", "DELETE"])
        .allow_headers(vec!["content-type"])
}

pub mod auth;
pub mod cors;

pub use cors::cors;```

===================
File: ./backend/src/middleware/rate_limit.rs
Size: 6982 bytes
===================
```rs
use crate::reputation::ReputationManager;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::Instant;
use tower::ServiceBuilder;
use tower::limit::RateLimit;
use warp::Filter;
use std::collections::HashMap;
use log::{info, error};
use tokio::sync::Mutex;
use icn_types::IcnError;

pub trait RateLimitingOperations {
    fn calculate_limit_multiplier(&self, did: &str) -> f64;
    fn get_rate_limit(&self, did: &str) -> u32;
    fn check_rate_limit(&self, did: &str) -> bool;
}

pub struct AdaptiveRateLimiter {
    reputation_manager: Arc<ReputationManager>,
    base_limit: u32,
    max_limit: u32,
    min_limit: u32,
    cache: HashMap<String, u32>,
}

impl AdaptiveRateLimiter {
    pub fn new(reputation_manager: Arc<ReputationManager>) -> Self {
        Self {
            reputation_manager,
            base_limit: 10,
            max_limit: 50,
            min_limit: 5,
            cache: HashMap::new(),
        }
    }

    async fn calculate_limit_multiplier(&self, did: &str) -> f64 {
        let reputation = self.reputation_manager.get_reputation(did, "api").await;
        let base_multiplier = (reputation as f64 / 100.0).min(1.0).max(0.1);
        
        // Additional multipliers based on federation status
        let federation_multiplier = if self.is_federation_admin(did).await {
            2.0
        } else {
            1.0
        };

        base_multiplier * federation_multiplier
    }

    async fn get_rate_limit(&self, did: &str) -> u32 {
        if let Some(&cached_limit) = self.cache.get(did) {
            return cached_limit;
        }

        let multiplier = self.calculate_limit_multiplier(did).await;
        let limit = (self.base_limit as f64 * multiplier) as u32;
        let clamped_limit = limit.clamp(self.min_limit, self.max_limit);
        self.cache.insert(did.to_string(), clamped_limit);
        clamped_limit
    }

    async fn check_rate_limit(&self, did: &str) -> bool {
        let limit = self.get_rate_limit(did).await;
        // ...existing rate check logic...
        info!("Rate limit for {}: {}", did, limit);
        true
    }
}

impl RateLimitingOperations for AdaptiveRateLimiter {
    fn calculate_limit_multiplier(&self, did: &str) -> f64 {
        // Placeholder implementation
        1.0
    }

    fn get_rate_limit(&self, did: &str) -> u32 {
        // Placeholder implementation
        10
    }

    fn check_rate_limit(&self, did: &str) -> bool {
        // Placeholder implementation
        true
    }
}

pub fn with_rate_limit<F: Filter>(
    filter: F,
    requests_per_second: u64
) -> impl Filter<Extract = F::Extract, Error = warp::Rejection> + Clone {
    let rate_limiter = ServiceBuilder::new()
        .layer(RateLimit::new(
            requests_per_second, 
            Duration::from_secs(1)
        ))
        .service(warp::service(filter));

    warp::service(rate_limiter)
}

// Rate limit settings by reputation tier
struct RateLimitTier {
    requests_per_minute: u32,
    burst_capacity: u32,
}

pub struct ReputationAwareRateLimiter {
    rate_limits: HashMap<String, RateLimitTier>, // endpoint -> limit settings
    user_limits: Arc<Mutex<HashMap<String, HashMap<String, (Instant, u32)>>>>, // user_id -> endpoint -> (last_reset, count)
    reputation_manager: Arc<ReputationManager>,
}

impl ReputationAwareRateLimiter {
    pub fn new(reputation_manager: Arc<ReputationManager>) -> Self {
        let mut rate_limits = HashMap::new();
        
        // Define default rate limits for different endpoints
        rate_limits.insert("api/v1/governance/proposals".to_string(), RateLimitTier { 
            requests_per_minute: 10, 
            burst_capacity: 15 
        });
        rate_limits.insert("api/v1/federation".to_string(), RateLimitTier { 
            requests_per_minute: 5, 
            burst_capacity: 10 
        });
        
        Self {
            rate_limits,
            user_limits: Arc::new(Mutex::new(HashMap::new())),
            reputation_manager,
        }
    }
    
    pub async fn is_rate_limited(&self, user_id: &str, endpoint: &str) -> bool {
        // Get user reputation
        let reputation = self.reputation_manager.get_reputation(user_id, "api").await;
        
        // Get base rate limits for this endpoint
        let base_tier = self.rate_limits.get(endpoint).unwrap_or(&RateLimitTier {
            requests_per_minute: 5,
            burst_capacity: 10,
        });
        
        // Calculate adjusted limits based on reputation
        // Higher reputation = higher limits, up to 5x the base limit
        let reputation_multiplier = (1.0 + (reputation as f64 / 100.0)).min(5.0);
        let adjusted_rpm = (base_tier.requests_per_minute as f64 * reputation_multiplier) as u32;
        let adjusted_burst = (base_tier.burst_capacity as f64 * reputation_multiplier) as u32;
        
        // Check current usage
        let mut user_limits = self.user_limits.lock().await;
        let endpoint_limits = user_limits
            .entry(user_id.to_string())
            .or_insert_with(HashMap::new);
            
        let now = Instant::now();
        let (last_reset, count) = endpoint_limits
            .entry(endpoint.to_string())
            .or_insert_with(|| (now, 0));
            
        // Reset counter if a minute has passed
        if now.duration_since(*last_reset) > Duration::from_secs(60) {
            *last_reset = now;
            *count = 0;
        }
        
        // Check if user has exceeded their limit
        if *count >= adjusted_burst {
            return true;
        }
        
        // Increment count
        *count += 1;
        false
    }
}

// Create a warp filter that applies reputation-aware rate limiting
pub fn with_reputation_rate_limit(
    reputation_manager: Arc<ReputationManager>,
    path: &str,
) -> impl Filter<Extract = (), Error = warp::Rejection> + Clone {
    let rate_limiter = Arc::new(ReputationAwareRateLimiter::new(reputation_manager));
    let path_str = path.to_string();
    
    warp::any()
        .and(warp::header::<String>("authorization"))
        .and_then(move |auth_header: String| {
            let user_id = extract_user_id_from_auth(&auth_header);
            let rate_limiter = rate_limiter.clone();
            let endpoint = path_str.clone();
            
            async move {
                if rate_limiter.is_rate_limited(&user_id, &endpoint).await {
                    Err(warp::reject::custom(
                        IcnError::RateLimitError(format!("Rate limit exceeded for {}", endpoint))
                    ))
                } else {
                    Ok(())
                }
            }
        })
}

fn extract_user_id_from_auth(auth_header: &str) -> String {
    // Extract user ID from JWT or other auth mechanism
    // This is a placeholder implementation
    if auth_header.starts_with("Bearer ") {
        auth_header[7..].to_string()
    } else {
        "anonymous".to_string()
    }
}
```

===================
File: ./backend/src/models.rs
Size: 1686 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use chrono::NaiveDateTime;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: i64,
    pub title: String,
    pub description: String,
    pub created_by: String,
    pub ends_at: NaiveDateTime,
    pub created_at: NaiveDateTime,
    pub verifiable_credential: Option<String>,
    pub did: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: i64,
    pub voter: String,
    pub approve: bool,
    pub verifiable_credential: Option<String>,
    pub zk_snark_proof: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contribution {
    pub id: i64,
    pub contributor: String,
    pub description: String,
    pub impact_score: i64,
    pub timestamp: NaiveDateTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub description: String,
    pub admin_did: String,
    pub created_at: NaiveDateTime,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMember {
    pub federation_id: String,
    pub member_did: String,
    pub role: String,
    pub joined_at: NaiveDateTime,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperation {
    pub id: i64,
    pub name: String,
    pub description: String,
    pub admin_did: String,
    pub created_at: NaiveDateTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub owner_did: String,
    pub resource_type: String,
    pub capacity: i64,
    pub usage: i64,
    pub status: String,
}
```

===================
File: ./backend/src/networking.rs
Size: 6871 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::time::{Duration, sleep};
use log::{info, error};

pub enum PeerStatus {
    Connected,
    Disconnected,
    Syncing,
}

pub struct Peer {
    id: String,
    address: String,
    status: PeerStatus,
    latency: u64,
}

pub enum Message {
    Block { hash: String, data: Vec<u8> },
    Transaction { hash: String, data: Vec<u8> },
    Proposal { id: String, data: Vec<u8> },
    Vote { proposal_id: String, voter: String, approve: bool },
    Identity { did: String, data: Vec<u8> },
    Reputation { did: String, score: i64 },
    Ping,
    Pong,
}

pub trait NetworkingOperations {
    fn start(&self) -> Result<(), String>;
    fn stop(&self) -> Result<(), String>;
    fn connect(&self, address: &str) -> Result<(), String>;
    fn disconnect(&self, address: &str) -> Result<(), String>;
    fn send_message(&self, address: &str, message: &[u8]) -> Result<(), String>;
    fn receive_message(&self, address: &str) -> Result<Vec<u8>, String>;
}

pub struct NetworkManager {
    peers: HashMap<String, Peer>,
    message_sender: Option<Sender<Message>>,
    max_peers: usize,
    network_key: Vec<u8>,
    cache: HashMap<String, Vec<u8>>,
}

impl NetworkManager {
    pub fn new(max_peers: usize) -> Self {
        let network_key = vec![0u8; 32]; // In a real application, this would be a proper crypto key
        
        Self {
            peers: HashMap::new(),
            message_sender: None,
            max_peers,
            network_key,
            cache: HashMap::new(),
        }
    }
    
    pub fn start(&mut self) -> Result<(), String> {
        let (sender, receiver) = mpsc::channel(100);
        self.message_sender = Some(sender);
        
        // Start background task for processing messages
        let receiver_handle = tokio::spawn(async move {
            Self::process_messages(receiver).await;
        });
        
        Ok(())
    }
    
    async fn process_messages(mut receiver: Receiver<Message>) {
        while let Some(message) = receiver.recv().await {
            // In a real implementation, this would process the message
            // For testing, we just print info about it
            match message {
                Message::Block { hash, data: _ } => {
                    println!("Received block with hash: {}", hash);
                },
                Message::Transaction { hash, data: _ } => {
                    println!("Received transaction with hash: {}", hash);
                },
                Message::Proposal { id, data: _ } => {
                    println!("Received proposal with id: {}", id);
                },
                Message::Vote { proposal_id, voter, approve } => {
                    println!("Received vote on proposal {} from {}: {}", proposal_id, voter, approve);
                },
                Message::Identity { did, data: _ } => {
                    println!("Received identity for DID: {}", did);
                },
                Message::Reputation { did, score } => {
                    println!("Received reputation update for DID: {}, new score: {}", did, score);
                },
                Message::Ping => {
                    println!("Received ping");
                },
                Message::Pong => {
                    println!("Received pong");
                },
            }
        }
    }
    
    pub fn add_peer(&mut self, id: String, address: String) -> Result<(), String> {
        if self.peers.len() >= self.max_peers {
            return Err("Maximum number of peers reached".to_string());
        }
        
        let peer = Peer {
            id: id.clone(),
            address,
            status: PeerStatus::Disconnected,
            latency: 0,
        };
        
        self.peers.insert(id, peer);
        Ok(())
    }
    
    pub fn remove_peer(&mut self, id: &str) -> Result<(), String> {
        if self.peers.remove(id).is_none() {
            return Err("Peer not found".to_string());
        }
        Ok(())
    }
    
    pub fn get_peers(&self) -> Vec<&Peer> {
        self.peers.values().collect()
    }
    
    pub fn send_message(&self, peer_id: &str, message: Message) -> Result<(), String> {
        if !self.peers.contains_key(peer_id) {
            return Err("Peer not found".to_string());
        }
        
        let sender = self.message_sender.as_ref().ok_or("Network not started")?;
        
        // In a real implementation, this would actually send to the peer
        // For testing, we just forward to our own message processor
        let sender_clone = sender.clone();
        tokio::spawn(async move {
            sender_clone.send(message).await.unwrap();
        });
        
        Ok(())
    }
    
    pub async fn broadcast_message(&self, message: Message) -> Result<(), String> {
        let sender = self.message_sender.as_ref().ok_or("Network not started")?;
        
        // In a real implementation, this would send to all peers
        // For testing, we just forward to our own message processor
        let sender_clone = sender.clone();
        tokio::spawn(async move {
            sender_clone.send(message).await.unwrap();
        });
        
        Ok(())
    }
    
    pub async fn ping_all_peers(&mut self) -> Result<(), String> {
        for peer in self.peers.values_mut() {
            // In a real implementation, this would actually ping each peer
            // For testing, we just update latency with a random value
            peer.latency = rand::random::<u64>() % 100;
            peer.status = if peer.latency < 50 { PeerStatus::Connected } else { PeerStatus::Disconnected };
        }
        
        Ok(())
    }
}

impl NetworkingOperations for NetworkManager {
    fn start(&self) -> Result<(), String> {
        info!("Starting network connections");
        Ok(())
    }

    fn stop(&self) -> Result<(), String> {
        info!("Stopping network connections");
        Ok(())
    }

    fn connect(&self, address: &str) -> Result<(), String> {
        info!("Connecting to network address: {}", address);
        Ok(())
    }

    fn disconnect(&self, address: &str) -> Result<(), String> {
        info!("Disconnecting from network address: {}", address);
        Ok(())
    }

    fn send_message(&self, address: &str, message: &[u8]) -> Result<(), String> {
        info!("Sending message to network address: {}", address);
        self.cache.insert(address.to_string(), message.to_vec());
        Ok(())
    }

    fn receive_message(&self, address: &str) -> Result<Vec<u8>, String> {
        info!("Receiving message from network address: {}", address);
        if let Some(message) = self.cache.get(address) {
            Ok(message.clone())
        } else {
            Ok(vec![])
        }
    }
}
```

===================
File: ./backend/src/networking/p2p.rs
Size: 4516 bytes
===================
```rs
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::error::Error;
use libp2p::{
    floodsub::{Floodsub, FloodsubEvent, Topic},
    mdns::{Mdns, MdnsConfig, MdnsEvent},
    swarm::{SwarmBuilder, SwarmEvent},
    PeerId, Swarm, NetworkBehaviour, identity,
};
use futures::prelude::*;
use async_trait::async_trait;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub enum Event {
    Federation(FederationEvent),
    Governance(GovernanceEvent),
    Identity(IdentityEvent),
    Reputation(ReputationEvent),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum FederationEvent {
    JoinRequest { federation_id: String, member_did: String },
    // Add other federation events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum GovernanceEvent {
    Vote { proposal_id: String, voter: String, approve: bool, zk_snark_proof: String },
    // Add other governance events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum IdentityEvent {
    CreateIdentity { identity: String },
    // Add other identity events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum ReputationEvent {
    ZkSnarkProofSubmitted { proof: String },
    // Add other reputation events here
}

pub struct P2PManager {
    peers: Vec<String>,
    swarm: Swarm<MyBehaviour>,
}

impl P2PManager {
    pub fn new() -> Self {
        let local_key = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());
        println!("Local peer id: {:?}", local_peer_id);

        let floodsub = Floodsub::new(local_peer_id.clone());
        let mdns = Mdns::new(MdnsConfig::default()).expect("Failed to create mDNS service");

        let behaviour = MyBehaviour { floodsub, mdns };

        let swarm = SwarmBuilder::new(behaviour, local_peer_id.clone())
            .executor(Box::new(|fut| {
                tokio::spawn(fut);
            }))
            .build();

        P2PManager { peers: Vec::new(), swarm }
    }

    pub async fn connect(&mut self, address: &str) -> Result<(), Box<dyn Error>> {
        let stream = TcpStream::connect(address).await?;
        self.peers.push(address.to_string());
        println!("Connected to {}", address);
        Ok(())
    }

    pub async fn send_message(&self, address: &str, message: &[u8]) -> Result<(), Box<dyn Error>> {
        if let Some(peer) = self.peers.iter().find(|&&peer| peer == address) {
            let mut stream = TcpStream::connect(peer).await?;
            stream.write_all(message).await?;
            println!("Message sent to {}", address);
            Ok(())
        } else {
            Err("Peer not connected".into())
        }
    }

    pub async fn publish(&mut self, event: Event) -> Result<(), Box<dyn Error>> {
        let topic = Topic::new("icn-events");
        let message = serde_json::to_vec(&event)?;
        self.swarm.behaviour_mut().floodsub.publish(topic, message);
        Ok(())
    }

    pub async fn subscribe(&mut self) -> Result<(), Box<dyn Error>> {
        let topic = Topic::new("icn-events");
        self.swarm.behaviour_mut().floodsub.subscribe(topic);

        loop {
            match self.swarm.next().await {
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Floodsub(FloodsubEvent::Message(message)))) => {
                    let event: Event = serde_json::from_slice(&message.data)?;
                    println!("Received event: {:?}", event);
                }
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(MdnsEvent::Discovered(peers)))) => {
                    for (peer_id, _) in peers {
                        self.swarm.behaviour_mut().floodsub.add_node_to_partial_view(peer_id);
                    }
                }
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(MdnsEvent::Expired(peers)))) => {
                    for (peer_id, _) in peers {
                        if !self.swarm.behaviour().mdns.has_node(&peer_id) {
                            self.swarm.behaviour_mut().floodsub.remove_node_from_partial_view(&peer_id);
                        }
                    }
                }
                _ => {}
            }
        }
    }
}

#[derive(NetworkBehaviour)]
struct MyBehaviour {
    floodsub: Floodsub,
    mdns: Mdns,
}

enum MyBehaviourEvent {
    Floodsub(FloodsubEvent),
    Mdns(MdnsEvent),
}
```

===================
File: ./backend/src/networking/rpc.rs
Size: 1067 bytes
===================
```rs
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::error::Error;

pub struct RpcManager;

impl RpcManager {
    pub fn new() -> Self {
        RpcManager
    }

    pub async fn handle_rpc(&self, address: &str) -> Result<(), Box<dyn Error>> {
        let listener = TcpListener::bind(address).await?;
        println!("RPC server listening on {}", address);

        loop {
            let (mut socket, _) = listener.accept().await?;
            tokio::spawn(async move {
                let mut buffer = [0; 1024];
                match socket.read(&mut buffer).await {
                    Ok(_) => {
                        let response = b"RPC response";
                        if let Err(e) = socket.write_all(response).await {
                            eprintln!("Failed to write to socket: {}", e);
                        }
                    }
                    Err(e) => {
                        eprintln!("Failed to read from socket: {}", e);
                    }
                }
            });
        }
    }
}
```

===================
File: ./backend/src/networking/websocket.rs
Size: 2162 bytes
===================
```rs
use warp::ws::{Message, WebSocket};
use futures_util::{StreamExt, SinkExt};
use std::sync::Arc;
use dashmap::DashMap;
use log::{info, error};

pub type WebSocketClients = Arc<DashMap<String, warp::ws::Sender>>;

pub trait WebSocketOperations {
    fn handle_websocket(&self, ws: WebSocket, clients: WebSocketClients);
    fn process_message(&self, msg: Message, clients: &WebSocketClients) -> Result<(), String>;
    fn broadcast_message(&self, msg: &Message, clients: &WebSocketClients);
}

pub struct WebSocketManager {
    cache: DashMap<String, String>,
}

impl WebSocketManager {
    pub fn new() -> Self {
        WebSocketManager {
            cache: DashMap::new(),
        }
    }
}

impl WebSocketOperations for WebSocketManager {
    fn handle_websocket(&self, ws: WebSocket, clients: WebSocketClients) {
        let (mut ws_tx, mut ws_rx) = ws.split();
        let client_id = uuid::Uuid::new_v4().to_string();
        clients.insert(client_id.clone(), ws_tx.clone());

        tokio::spawn(async move {
            while let Some(result) = ws_rx.next().await {
                match result {
                    Ok(msg) => {
                        if let Err(e) = self.process_message(msg, &clients).await {
                            error!("Error processing message: {}", e);
                        }
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                }
            }

            clients.remove(&client_id);
        });
    }

    fn process_message(&self, msg: Message, clients: &WebSocketClients) -> Result<(), String> {
        if let Ok(text) = msg.to_str() {
            self.cache.insert(text.to_string(), text.to_string());
            self.broadcast_message(&Message::text(text), clients);
        }
        Ok(())
    }

    fn broadcast_message(&self, msg: &Message, clients: &WebSocketClients) {
        for client in clients.iter() {
            if let Err(e) = client.value().send(msg.clone()).await {
                error!("Error sending message to client: {}", e);
            }
        }
    }
}
```

===================
File: ./backend/src/notification.rs
Size: 3465 bytes
===================
```rs
use std::sync::Arc;
use reqwest::Client;
use std::error::Error;
use std::fmt;
use tokio::sync::mpsc::{self, Sender, Receiver};

#[derive(Debug)]
pub enum NotificationError {
    SendError(String),
    NetworkError(String),
}

impl fmt::Display for NotificationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            NotificationError::SendError(msg) => write!(f, "Failed to send notification: {}", msg),
            NotificationError::NetworkError(msg) => write!(f, "Network error: {}", msg),
        }
    }
}

impl Error for NotificationError {}

pub struct NotificationManager {
    http_client: Client,
    email_endpoint: String,
    sms_endpoint: String,
    event_sender: Option<Sender<NotificationEvent>>,
}

#[derive(Debug, Clone)]
pub enum NotificationEvent {
    Email { subject: String, body: String, recipient: String },
    SMS { message: String, recipient: String },
    Push { title: String, message: String, device_id: String },
}

impl NotificationManager {
    pub fn new(email_endpoint: String, sms_endpoint: String) -> Self {
        let (sender, receiver) = mpsc::channel(100);
        
        let manager = Self {
            http_client: Client::new(),
            email_endpoint,
            sms_endpoint,
            event_sender: Some(sender),
        };
        
        // Start background listener
        manager.start_event_listener(receiver);
        
        manager
    }
    
    fn start_event_listener(&self, mut receiver: Receiver<NotificationEvent>) {
        tokio::spawn(async move {
            while let Some(event) = receiver.recv().await {
                match event {
                    NotificationEvent::Email { subject, body, recipient } => {
                        println!("Email to {}: {}", recipient, subject);
                        // In a real implementation, this would send the email
                    }
                    NotificationEvent::SMS { message, recipient } => {
                        println!("SMS to {}: {}", recipient, message);
                        // In a real implementation, this would send the SMS
                    }
                    NotificationEvent::Push { title, message, device_id } => {
                        println!("Push to {}: {}", device_id, title);
                        // In a real implementation, this would send the push notification
                    }
                }
            }
        });
    }
    
    pub async fn send_email(&self, subject: &str, body: &str) -> Result<(), NotificationError> {
        // In a real implementation, this would send a HTTP request to the email service
        // For testing, we just simulate success
        Ok(())
    }
    
    pub async fn send_sms(&self, message: &str) -> Result<(), NotificationError> {
        // In a real implementation, this would send a HTTP request to the SMS service
        // For testing, we just simulate success
        Ok(())
    }
    
    pub async fn send_notification(&self, subject: &str, body: &str) -> Result<(), NotificationError> {
        // Try to send email first
        match self.send_email(subject, body).await {
            Ok(_) => return Ok(()),
            Err(_) => {
                // If email fails, try SMS
                println!("Email failed, falling back to SMS");
                self.send_sms(&format!("{}: {}", subject, body)).await?;
            }
        }
        
        Ok(())
    }
}
```

===================
File: ./backend/src/reputation.rs
Size: 11394 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::task;
use tokio::time::{self, Duration};
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use futures::future::join_all; // Import join_all for concurrency

pub struct ReputationManager {
    reputations: Mutex<HashMap<String, i64>>,
    event_sender: Sender<ReputationEvent>,
}

impl ReputationManager {
    pub fn new() -> Self {
        let (event_sender, event_receiver) = mpsc::channel(100);
        let manager = ReputationManager {
            reputations: Mutex::new(HashMap::new()),
            event_sender,
        };
        manager.start_event_listener(event_receiver);
        manager
    }

    pub fn get_reputation(&self, did: &str) -> i64 {
        let reputations = self.reputations.lock().unwrap();
        *reputations.get(did).unwrap_or(&0)
    }

    pub fn adjust_reputation(&self, _did: &str, adjustment: i64) {
        let mut reputations = self.reputations.lock().unwrap();
        let entry = reputations.entry(_did.to_string()).or_insert(0);
        *entry += adjustment;
    }

    pub fn apply_decay(&self, decay_rate: f64) {
        let mut reputations = self.reputations.lock().unwrap();
        for value in reputations.values_mut() {
            *value = (*value as f64 * (1.0 - decay_rate)).round() as i64;
        }
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String> {
        apply_reputation_decay_in_ledger(did, decay_rate).await.map_err(|e| e.to_string())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> {
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| e.to_string())
    }

    pub fn emit_event(&self, event: ReputationEvent) {
        let sender = self.event_sender.clone();
        task::spawn(async move {
            sender.send(event).await.unwrap();
        });
    }

    fn start_event_listener(&self, mut event_receiver: Receiver<ReputationEvent>) {
        task::spawn(async move {
            while let Some(event) = event_receiver.recv().await {
                match event {
                    ReputationEvent::ReputationAdjusted { did, adjustment } => {
                        // Handle reputation adjustment event
                    }
                    ReputationEvent::ReputationDecayApplied { did, decay_rate } => {
                        // Handle reputation decay event
                    }
                }
            }
        });
    }

    pub async fn batch_reputation_updates(&self, events: Vec<ReputationEvent>) -> Result<(), String> {
        let publish_futures = events.iter().map(|event| {
            let sender = self.event_sender.clone();
            async move {
                sender.send(event.clone()).await.map_err(|e| e.to_string())
            }
        });

        let results = join_all(publish_futures).await;
        for result in results {
            if let Err(e) = result {
                return Err(e);
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_reputation() {
        let manager = ReputationManager::new();
        assert_eq!(manager.get_reputation("did:example:123"), 0);
    }

    #[test]
    fn test_adjust_reputation() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 10);
        assert_eq!(manager.get_reputation("did:example:123"), 10);
    }

    #[test]
    fn test_apply_decay() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 100);
        manager.apply_decay(0.1);
        assert_eq!(manager.get_reputation("did:example:123"), 90);
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 100);
        manager.apply_reputation_decay("did:example:123", 0.1).await.unwrap();
        assert_eq!(manager.get_reputation("did:example:123"), 90);
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let manager = ReputationManager::new();
        manager.handle_sybil_resistance("did:example:123", 50).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[test]
    fn test_emit_event() {
        let manager = ReputationManager::new();
        manager.emit_event(ReputationEvent::ReputationAdjusted {
            did: "did:example:123".to_string(),
            adjustment: 10,
        });
        // Add assertions based on the expected behavior of emit_event
    }

    #[tokio::test]
    async fn test_batch_reputation_updates() {
        let manager = ReputationManager::new();
        let events = vec![
            ReputationEvent::ReputationAdjusted {
                did: "did:example:123".to_string(),
                adjustment: 10,
            },
            ReputationEvent::ReputationDecayApplied {
                did: "did:example:123".to_string(),
                decay_rate: 0.1,
            },
        ];
        manager.batch_reputation_updates(events).await.unwrap();
        // Add assertions based on the expected behavior of batch_reputation_updates
    }
}

pub struct Contribution {
    pub score: i64,
    pub timestamp: f64,
}

impl Contribution {
    pub fn new(score: i64) -> Self {
        Self {
            score,
            timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64,
        }
    }
}

pub enum ReputationEvent {
    ReputationAdjusted { did: String, adjustment: i64 },
    ReputationDecayApplied { did: String, decay_rate: f64 },
}

#[cfg(test)]
mod integration_tests {
    use super::*;
    use std::env;
    use sqlx::PgPool;

    async fn setup_test_db() -> Arc<Database> {
        let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        let pool = PgPool::connect(&database_url).await.unwrap();
        Arc::new(Database { pool })
    }

    #[tokio::test]
    async fn test_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }
}

pub struct ReputationSystem {
    // DID -> (category -> reputation score)
    reputation_scores: HashMap<String, HashMap<String, i32>>,
}

impl ReputationSystem {
    pub fn new() -> Self {
        Self {
            reputation_scores: HashMap::new(),
        }
    }
    
    pub fn increase_reputation(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, amount, "consensus".to_string());
    }
    
    pub fn decrease_reputation(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, -amount, "consensus".to_string());
    }
    
    pub fn adjust_reputation(&mut self, did: &str, amount: i32, category: String) {
        let categories = self.reputation_scores
            .entry(did.to_string())
            .or_insert_with(HashMap::new);
            
        let score = categories.entry(category).or_insert(0);
        *score += amount;
    }
    
    pub fn get_reputation(&self, did: &str, category: String) -> i32 {
        self.reputation_scores
            .get(did)
            .and_then(|categories| categories.get(&category))
            .copied()
            .unwrap_or(0)
    }
    
    pub fn is_eligible(&self, did: &str, threshold: i32, category: String) -> bool {
        self.get_reputation(did, category) >= threshold
    }
    
    // Apply decay to a specific category
    pub fn apply_decay(&mut self, did: &str, decay_factor: f64, category: String) {
        if let Some(categories) = self.reputation_scores.get_mut(did) {
            if let Some(score) = categories.get_mut(&category) {
                *score = (*score as f64 * (1.0 - decay_factor)) as i32;
            }
        }
    }
    
    // Apply decay to all categories
    pub fn apply_decay_all(&mut self, did: &str, decay_factor: f64) {
        if let Some(categories) = self.reputation_scores.get_mut(did) {
            for score in categories.values_mut() {
                *score = (*score as f64 * (1.0 - decay_factor)) as i32;
            }
        }
    }
    
    pub fn dynamic_adjustment(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, amount, "consensus".to_string());
    }
    
    pub fn reputation_based_access(&self, did: &str, threshold: i32) -> bool {
        self.reputation_scores
            .get(did)
            .map(|categories| {
                categories.values().sum::<i32>() >= threshold
            })
            .unwrap_or(false)
    }
}
```

===================
File: ./backend/src/resources.rs
Size: 1739 bytes
===================
```rs
use std::collections::HashMap;

pub struct ResourceManager {
    resources: HashMap<String, Resource>,
}

pub struct Resource {
    pub id: String,
    pub type_: String,
    pub capacity: u64,
    pub available: u64,
    pub owner_did: String,
}

impl ResourceManager {
    pub fn new() -> Self {
        ResourceManager {
            resources: HashMap::new(),
        }
    }
    
    pub fn register_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }
    
    pub fn get_resource(&self, id: &str) -> Option<&Resource> {
        self.resources.get(id)
    }
    
    pub fn list_available_resources(&self) -> Vec<&Resource> {
        self.resources.values()
            .filter(|r| r.available > 0)
            .collect()
    }
    
    pub fn request_resource(&mut self, id: &str, amount: u64) -> Result<(), String> {
        let resource = self.resources.get_mut(id).ok_or("Resource not found")?;
        
        if resource.available < amount {
            return Err("Insufficient resources available".to_string());
        }
        
        resource.available -= amount;
        Ok(())
    }
    
    pub fn release_resource(&mut self, id: &str, amount: u64) -> Result<(), String> {
        let resource = self.resources.get_mut(id).ok_or("Resource not found")?;
        
        if resource.available + amount > resource.capacity {
            return Err("Cannot release more resources than capacity".to_string());
        }
        
        resource.available += amount;
        Ok(())
    }
}
```

===================
File: ./backend/src/routes.rs
Size: 1937 bytes
===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

use crate::api::health::health_routes;
use crate::api::identity::identity_routes;
use crate::api::governance::governance_routes;
use crate::api::resource::resource_routes;
use crate::api::federation::federation_routes;
use crate::api::federation_resource_sharing::federation_resource_sharing_routes;
use crate::api::reputation::reputation_routes;
use crate::services::identity_service::IdentityService;
use crate::services::governance_service::GovernanceService;
use crate::services::resource_service::ResourceService;
use crate::services::federation_service::FederationService;
use crate::services::reputation_service::ReputationService;
use crate::services::p2p::P2PManager;
use crate::middleware::auth::with_auth;
use crate::middleware::cors::cors;

pub fn routes(
    identity_service: Arc<Mutex<IdentityService>>,
    governance_service: Arc<Mutex<GovernanceService>>,
    resource_service: Arc<Mutex<ResourceService>>,
    federation_service: Arc<Mutex<FederationService>>,
    reputation_service: Arc<Mutex<ReputationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    // Routes that don't require auth
    let health_route = health_routes();

    // Routes that require auth
    let auth_routes = identity_routes(identity_service.clone())
        .or(governance_routes(governance_service.clone(), p2p_manager.clone()))
        .or(resource_routes(resource_service.clone()))
        .or(federation_routes(federation_service.clone(), p2p_manager.clone()))
        .or(federation_resource_sharing_routes(federation_service.clone(), p2p_manager.clone()))
        .or(reputation_routes(reputation_service.clone()));

    // Apply middleware
    let auth_routes = auth_routes.and(with_auth(identity_service.clone()));

    // Combine routes
    health_route.or(auth_routes).with(cors())
}```

===================
File: ./backend/src/services.rs
Size: 3043 bytes
===================
```rs
use std::sync::{Arc, Mutex};
use icn_types::{Block, Transaction, FederationOperation};
use crate::identity::IdentitySystem;
use crate::blockchain::Blockchain;
use crate::governance::{ProposalHistory, Proposal, ProposalType, handle_federation_operation};
use crate::reputation::ReputationSystem;

pub struct BlockchainService {
    blockchain: Arc<Mutex<Blockchain>>,
}

impl BlockchainService {
    pub fn new(blockchain: Arc<Mutex<Blockchain>>) -> Self {
        Self { blockchain }
    }
    
    pub async fn add_transaction(&self, transaction: Transaction) -> Result<(), String> {
        let mut chain = self.blockchain.lock().unwrap();
        chain.add_transaction(transaction).await
    }
    
    pub async fn add_block(&self, block: Block) -> Result<(), String> {
        let mut chain = self.blockchain.lock().unwrap();
        chain.add_block(block).await
    }
    
    pub fn get_latest_block(&self) -> Option<Block> {
        let chain = self.blockchain.lock().unwrap();
        chain.blocks.last().cloned()
    }
}

pub struct IdentityService {
    identity_system: Arc<Mutex<IdentitySystem>>,
}

impl IdentityService {
    pub fn new(identity_system: Arc<Mutex<IdentitySystem>>) -> Self {
        Self { identity_system }
    }
    
    pub fn register_identity(&self, did: crate::identity::DID, permissions: Vec<String>) -> Result<(), String> {
        let mut system = self.identity_system.lock().unwrap();
        system.register_did(did, permissions);
        Ok(())
    }
    
    pub fn has_permission(&self, did: &str, permission: &str) -> bool {
        let system = self.identity_system.lock().unwrap();
        system.has_permission(did, permission)
    }
}

pub struct GovernanceService {
    proposal_history: Arc<Mutex<ProposalHistory>>,
}

impl GovernanceService {
    pub fn new(proposal_history: Arc<Mutex<ProposalHistory>>) -> Self {
        Self { proposal_history }
    }
    
    pub fn add_proposal(&self, proposer: String, proposal_type: ProposalType) -> Result<Proposal, String> {
        let mut history = self.proposal_history.lock().unwrap();
        let proposal = Proposal::new(proposer, proposal_type);
        let proposal_clone = proposal.clone();
        history.add_proposal(proposal);
        Ok(proposal_clone)
    }
    
    pub fn vote(&self, voter: String, _proposal_id: String, approve: bool) -> Result<(), String> {
        let mut history = self.proposal_history.lock().unwrap();
        history.vote(voter, _proposal_id, approve)
    }
    
    pub fn get_proposal(&self, id: String) -> Option<Proposal> {
        let history = self.proposal_history.lock().unwrap();
        history.get_proposal(id)
    }
    
    pub fn execute_proposal(&self, proposal_id: &str) -> Result<(), String> {
        let mut history = self.proposal_history.lock().unwrap();
        history.execute_proposal(proposal_id)
    }
    
    pub async fn handle_federation_operation(&self, operation: FederationOperation) -> Result<String, String> {
        handle_federation_operation(operation).await
    }
}
```

===================
File: ./backend/src/services/federation_service.rs
Size: 10648 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use chrono::Utc;
use uuid::Uuid;
use thiserror::Error;
use log::{info, error, debug};

use icn_federation::{
    FederationManager, FederationType, FederationTerms, FederationProposal, FederationError, Vote,
    ResourceSharingAgreement, ResourceAllocation, FederationResourceManager, ResourceError,
};
use icn_reputation::ReputationManager;
use icn_resource::ResourceAllocationSystem;
use crate::errors::IcnError;

/// Federation service to manage federation operations
pub struct FederationService {
    federation_manager: Arc<Mutex<FederationManager>>,
    reputation_manager: Arc<dyn ReputationManager>,
    resource_system: Arc<ResourceAllocationSystem>,
    federation_resource_manager: Arc<FederationResourceManager>,
}

#[derive(Error, Debug)]
pub enum FederationServiceError {
    #[error("Federation error: {0}")]
    FederationError(#[from] FederationError),
    
    #[error("Resource error: {0}")]
    ResourceError(#[from] ResourceError),
    
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Resource allocation error: {0}")]
    ResourceAllocationError(String),
}

/// Integration between ResourceManager trait and the ResourceAllocationSystem
struct ResourceSystemAdapter {
    resource_system: Arc<ResourceAllocationSystem>,
    reputation_manager: Arc<dyn ReputationManager>,
}

#[async_trait::async_trait]
impl icn_federation::ResourceProvider for ResourceSystemAdapter {
    async fn has_sufficient_resources(
        &self,
        federation_id: &str,
        resource_type: &str, 
        amount: u64
    ) -> Result<bool, ResourceError> {
        self.resource_system.check_resource_availability(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
    
    async fn get_federation_reputation(
        &self,
        federation_id: &str
    ) -> Result<i64, ResourceError> {
        self.reputation_manager.get_federation_reputation(federation_id)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(format!("Failed to get reputation: {}", e)))
    }
    
    async fn reserve_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError> {
        self.resource_system.reserve_resources(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
    
    async fn release_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError> {
        self.resource_system.release_resources(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
}

impl FederationService {
    /// Create a new federation service
    pub fn new(
        federation_manager: Arc<Mutex<FederationManager>>,
        reputation_manager: Arc<dyn ReputationManager>,
        resource_system: Arc<ResourceAllocationSystem>,
    ) -> Self {
        // Create adapter for the resource system
        let resource_provider = Arc::new(ResourceSystemAdapter {
            resource_system: resource_system.clone(),
            reputation_manager: reputation_manager.clone(),
        });
        
        // Create federation resource manager
        let federation_resource_manager = Arc::new(FederationResourceManager::new(resource_provider));
        
        Self {
            federation_manager,
            reputation_manager,
            resource_system,
            federation_resource_manager,
        }
    }

    /// Create a new federation
    pub async fn create_federation(
        &mut self,
        name: String,
        federation_type: FederationType,
        terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        let federation_id = manager.create_federation(name, federation_type, terms, founding_member).await?;
        Ok(federation_id)
    }

    /// Join an existing federation
    pub async fn join_federation(
        &mut self,
        federation_id: &str,
        member_id: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.join_federation(federation_id, member_id, commitment).await?;
        Ok(())
    }

    /// Submit a proposal to a federation
    pub async fn submit_proposal(
        &mut self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.submit_proposal(federation_id, proposal).await?;
        Ok(())
    }

    /// Vote on a proposal in a federation
    pub async fn vote(
        &mut self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.vote(federation_id, vote).await?;
        Ok(())
    }

    // --- Federation Resource Sharing Methods ---

    /// Share resources between federations
    pub async fn share_federation_resources(
        &mut self,
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        duration_seconds: Option<u64>,
        terms: String,
        min_reputation_score: i64,
    ) -> Result<String, FederationServiceError> {
        info!(
            "Creating resource sharing agreement: {} -> {}, type: {}, amount: {}", 
            source_federation_id, target_federation_id, resource_type, amount
        );
        
        // Verify federations exist
        let manager = self.federation_manager.lock().await;
        
        // Create the resource sharing agreement
        let agreement_id = self.federation_resource_manager.propose_agreement(
            source_federation_id,
            target_federation_id,
            resource_type,
            amount,
            duration_seconds,
            terms,
            min_reputation_score,
        ).await?;
        
        info!("Resource sharing agreement created: {}", agreement_id);
        Ok(agreement_id)
    }
    
    /// Accept a resource sharing agreement
    pub async fn accept_sharing_agreement(
        &mut self,
        agreement_id: &str,
        target_federation_id: &str,
        signer_did: &str,
        signature: String,
    ) -> Result<(), FederationServiceError> {
        info!("Accepting resource sharing agreement: {}", agreement_id);
        
        self.federation_resource_manager.accept_agreement(
            agreement_id,
            target_federation_id,
            signer_did,
            signature,
        ).await?;
        
        info!("Resource sharing agreement accepted: {}", agreement_id);
        Ok(())
    }
    
    /// Allocate resources from a sharing agreement
    pub async fn allocate_shared_resource(
        &mut self,
        agreement_id: &str,
        requester_did: &str,
        amount: u64,
    ) -> Result<String, FederationServiceError> {
        info!(
            "Allocating resources from agreement {}: requester {}, amount {}", 
            agreement_id, requester_did, amount
        );
        
        // Get agreement to find the requester's federation
        let agreement = self.federation_resource_manager.get_agreement(agreement_id).await
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Allocate resources
        let allocation_id = self.federation_resource_manager.allocate_from_agreement(
            agreement_id,
            &agreement.target_federation_id, // Federation ID from the agreement
            requester_did,
            amount,
        ).await?;
        
        info!("Resources allocated, allocation ID: {}", allocation_id);
        Ok(allocation_id)
    }
    
    /// Release resources back to a sharing agreement
    pub async fn release_shared_resource(
        &mut self,
        agreement_id: &str,
        allocation_id: &str,
        amount: u64,
    ) -> Result<(), FederationServiceError> {
        info!(
            "Releasing resources to agreement {}: allocation {}, amount {}", 
            agreement_id, allocation_id, amount
        );
        
        self.federation_resource_manager.release_to_agreement(
            agreement_id,
            allocation_id,
            amount,
        ).await?;
        
        info!("Resources released successfully");
        Ok(())
    }
    
    /// Terminate a resource sharing agreement
    pub async fn terminate_sharing_agreement(
        &mut self,
        agreement_id: &str,
        federation_id: &str,
        reason: &str,
    ) -> Result<(), FederationServiceError> {
        info!(
            "Terminating resource sharing agreement {}: federation {}, reason: {}", 
            agreement_id, federation_id, reason
        );
        
        self.federation_resource_manager.terminate_agreement(
            agreement_id,
            federation_id,
            reason,
        ).await?;
        
        info!("Resource sharing agreement terminated");
        Ok(())
    }
    
    /// List all sharing agreements for a federation
    pub async fn list_federation_sharing_agreements(
        &self,
        federation_id: &str,
    ) -> Result<Vec<ResourceSharingAgreement>, FederationServiceError> {
        let agreements = self.federation_resource_manager.get_federation_agreements(federation_id).await;
        Ok(agreements)
    }

    /// Transfer resources between federations (direct transfer not through agreement)
    pub async fn transfer_resource(
        &mut self,
        resource_id: String,
        recipient_id: String,
        amount: u64,
    ) -> Result<(), FederationServiceError> {
        // Implement direct resource transfer
        // This is a simplified implementation and would need more logic in production
        Ok(())
    }

    /// Allocate resource shares within a federation
    pub async fn allocate_resource_shares(
        &mut self,
        resource_id: String,
        shares: HashMap<String, u64>,
    ) -> Result<(), FederationServiceError> {
        // Implement resource share allocation within a federation
        // This is a simplified implementation and would need more logic in production
        Ok(())
    }
}```

===================
File: ./backend/src/services/governance.rs
Size: 4788 bytes
===================
```rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::reputation::ReputationManager;
use tokio::sync::RwLock;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Invalid recall vote")]
    InvalidRecallVote,
    #[error("Insufficient reputation")]
    InsufficientReputation,
    #[error("Proposal expired")]
    ProposalExpired,
    #[error("Member not found")]
    MemberNotFound,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceMember {
    pub did: String,
    pub joined_at: DateTime<Utc>,
    pub missed_votes: u32,
    pub last_activity: DateTime<Utc>,
    pub reputation_score: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecallVote {
    pub target_member: String,
    pub reason: String,
    pub votes: HashMap<String, bool>,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

pub struct GovernanceService {
    members: RwLock<HashMap<String, GovernanceMember>>,
    recall_votes: RwLock<HashMap<String, RecallVote>>,
    reputation_manager: ReputationManager,
    inactivity_threshold_days: u32,
    missed_votes_threshold: u32,
}

impl GovernanceService {
    pub fn new(reputation_manager: ReputationManager) -> Self {
        Self {
            members: RwLock::new(HashMap::new()),
            recall_votes: RwLock::new(HashMap::new()),
            reputation_manager,
            inactivity_threshold_days: 30,
            missed_votes_threshold: 3,
        }
    }

    pub async fn track_vote_participation(&self, member_did: &str, voted: bool) {
        let mut members = self.members.write().await;
        if let Some(member) = members.get_mut(member_did) {
            if !voted {
                member.missed_votes += 1;
                
                // Check if recall vote should be triggered
                if member.missed_votes >= self.missed_votes_threshold {
                    self.initiate_recall_vote(member_did).await;
                }
            } else {
                member.last_activity = Utc::now();
                // Reset missed votes on participation
                member.missed_votes = 0;
            }
        }
    }

    async fn initiate_recall_vote(&self, member_did: &str) {
        let recall = RecallVote {
            target_member: member_did.to_string(),
            reason: format!("Member missed {} consecutive votes", self.missed_votes_threshold),
            votes: HashMap::new(),
            created_at: Utc::now(),
            expires_at: Utc::now() + chrono::Duration::days(7),
        };

        let mut recall_votes = self.recall_votes.write().await;
        recall_votes.insert(member_did.to_string(), recall);
    }

    pub async fn process_recall_vote(&self, voter: &str, target: &str, approve: bool) -> Result<(), GovernanceError> {
        let mut recall_votes = self.recall_votes.write().await;
        
        if let Some(recall) = recall_votes.get_mut(target) {
            recall.votes.insert(voter.to_string(), approve);
            
            // Check if recall threshold met
            let total_votes = recall.votes.len();
            let approve_votes = recall.votes.values().filter(|&&v| v).count();
            
            if total_votes >= 10 && (approve_votes * 2) > total_votes {
                self.remove_member(target).await?;
                recall_votes.remove(target);
            }
        }
        Ok(())
    }

    pub async fn check_proposal_expiration(&self, proposal_id: &str) -> Result<bool, GovernanceError> {
        // Check if proposal is nearing expiration and notify if needed
        // Return true if expiring soon
        Ok(false) // Placeholder
    }

    pub async fn decay_inactive_reputation(&self) {
        let members = self.members.read().await;
        let now = Utc::now();
        
        for member in members.values() {
            let days_inactive = (now - member.last_activity).num_days();
            if days_inactive > self.inactivity_threshold_days as i64 {
                // Apply reputation decay
                let decay_factor = -0.1 * (days_inactive as f64 / self.inactivity_threshold_days as f64);
                self.reputation_manager.dynamic_adjustment(&member.did, decay_factor as i64).await
                    .unwrap_or_else(|e| eprintln!("Failed to decay reputation: {}", e));
            }
        }
    }

    async fn remove_member(&self, member_did: &str) -> Result<(), GovernanceError> {
        let mut members = self.members.write().await;
        members.remove(member_did).ok_or(GovernanceError::MemberNotFound)?;
        Ok(())
    }
}
```

===================
File: ./backend/src/services/governance_service.rs
Size: 7590 bytes
===================
```rs
use crate::database::queries::{create_proposal_in_db, record_vote_in_db};
use crate::database::models::{Proposal, Vote};
use std::sync::Arc;
use tokio::sync::Mutex;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use crate::services::identity_service::IdentityService; // Import IdentityService
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use crate::reputation::ReputationManager; // Import ReputationManager
use futures::future::join_all; // Import join_all for concurrency

pub struct GovernanceService {
    db: Arc<Mutex<dyn Database>>,
    identity_service: Arc<dyn IdentityService>, // Add IdentityService to GovernanceService
    reputation_manager: Arc<ReputationManager>, // Add ReputationManager to GovernanceService
}

impl GovernanceService {
    pub fn new(db: Arc<Mutex<dyn Database>>, identity_service: Arc<dyn IdentityService>, reputation_manager: Arc<ReputationManager>) -> Self {
        Self { db, identity_service, reputation_manager }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        // Verify DID using IdentityService
        if !self.identity_service.verify_did(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Invalid DID".to_string()));
        }

        // Validate verifiable credential
        if !self.identity_service.verify_credential(&proposal.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        // Check reputation using ReputationManager
        if !self.verify_member_eligibility(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Insufficient reputation".to_string()));
        }

        let db = self.db.lock().await;
        create_proposal_in_db(&*db, &proposal).await
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        // Validate verifiable credential
        if !self.identity_service.verify_credential(&vote.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        // Verify signature using icn-crypto
        if !self.verify_signature(&vote.voter, &vote.signature, &vote.proposal_id).await {
            return Err(sqlx::Error::Protocol("Invalid signature".to_string()));
        }

        if let Some(proof) = &vote.zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }
        let db = self.db.lock().await;
        record_vote_in_db(&*db, &vote).await
    }

    async fn verify_signature(&self, did: &str, signature: &str, message: &str) -> bool {
        // Retrieve public key from IdentityService
        if let Some(public_key) = self.identity_service.get_public_key(did).await {
            let key_pair = KeyPair {
                public_key,
                private_key: vec![], // Not needed for verification
                algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
            };
            return key_pair.verify(message.as_bytes(), signature.as_bytes());
        }
        false
    }

    async fn verify_member_eligibility(&self, did: &str) -> bool {
        self.reputation_manager.get_reputation(did, "governance") >= 50 // Example threshold
    }

    // New handler for creating proposals
    pub async fn handle_create_proposal(
        &self,
        proposal: Proposal,
        notification_manager: crate::notification::NotificationManager,
        websocket_clients: crate::websocket::WebSocketClients,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        match self.create_proposal(proposal.clone()).await {
            Ok(id) => {
                let subject = format!("New Proposal Created: {}", proposal.title);
                let body = format!("A new proposal has been created by {}. Description: {}",
                    proposal.created_by, proposal.description);
                notification_manager.send_notification(&subject, &body).await;
                let message = warp::ws::Message::text(serde_json::to_string(&proposal).unwrap());
                crate::websocket::broadcast_message(&message, websocket_clients).await;
                Ok(warp::reply::json(&id))
            },
            Err(e) => Err(warp::reject::custom(e)),
        }
    }

    // New handler for voting on proposals
    pub async fn handle_vote_on_proposal(
        &self,
        vote: Vote,
        notification_manager: crate::notification::NotificationManager,
        websocket_clients: crate::websocket::WebSocketClients,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        match self.record_vote(vote.clone()).await {
            Ok(_) => {
                let subject = format!("New Vote on Proposal: {}", vote.proposal_id);
                let body = format!("A new vote has been cast by {}. Approve: {}", vote.voter, vote.approve);
                notification_manager.send_notification(&subject, &body).await;
                let message = warp::ws::Message::text(serde_json::to_string(&vote).unwrap());
                crate::websocket::broadcast_message(&message, websocket_clients).await;
                Ok(warp::reply::json(&"Vote recorded"))
            },
            Err(e) => Err(warp::reject::custom(e)),
        }
    }

    pub async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        let proposal = Proposal {
            id: 0, // Placeholder, will be set by the database
            title: title.to_string(),
            description: description.to_string(),
            created_by: created_by.to_string(),
            ends_at: chrono::NaiveDateTime::parse_from_str(ends_at, "%Y-%m-%d %H:%M:%S").map_err(|e| e.to_string())?,
            created_at: chrono::Utc::now().naive_utc(),
            did: created_by.to_string(), // Add did field for DID-based access control
        };

        self.create_proposal(proposal).await.map_err(|e| e.to_string())
    }

    pub async fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        let vote = Vote {
            proposal_id: _proposal_id,
            voter: voter.to_string(),
            approve,
        };

        self.record_vote(vote).await.map_err(|e| e.to_string())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> {
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String> {
        let db = self.db.lock().await;
        db.apply_reputation_decay(did, decay_rate).await.map_err(|e| e.to_string())
    }

    pub async fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String> {
        // Placeholder logic for handling delegated governance
        Ok(())
    }

    pub async fn verify_signatures_concurrently(&self, dids: Vec<&str>, signatures: Vec<&str>, messages: Vec<&str>) -> Result<Vec<bool>, String> {
        let verification_futures: Vec<_> = dids.iter().zip(signatures.iter()).zip(messages.iter())
            .map(|((&did, &signature), &message)| {
                self.verify_signature(did, signature, message)
            })
            .collect();

        let results = join_all(verification_futures).await;
        Ok(results)
    }
}
```

===================
File: ./backend/src/services/identity_service.rs
Size: 7920 bytes
===================
```rs
use async_trait::async_trait;
use std::sync::Arc;
use crate::database::db::Database;
use icn_identity::ledger::{create_identity_in_ledger, get_identity_from_ledger, rotate_key_in_ledger, revoke_key_in_ledger};
use icn_core::verifiable_credentials::{VerifiableCredential, Proof};
use futures::future::join_all; // Import join_all for concurrency

#[async_trait]
pub trait IdentityService: Send + Sync {
    async fn create_identity(&self, identity: &str) -> Result<(), String>;
    async fn get_identity(&self, identity: &str) -> Result<String, String>;
    async fn rotate_key(&self, identity: &str) -> Result<(), String>;
    async fn revoke_key(&self, identity: &str) -> Result<(), String>;
    async fn verify_did(&self, _did: &str) -> Result<bool, String>; // Add verify_did method
    async fn verify_credential(&self, credential: &str) -> Result<bool, String>; // Add verify_credential method
    async fn get_public_key(&self, did: &str) -> Result<Option<Vec<u8>>, String>; // Add get_public_key method
}

pub struct IdentityServiceImpl {
    db: Arc<Database>,
}

impl IdentityServiceImpl {
    pub fn new(db: Arc<Database>) -> Self {
        Self { db }
    }
}

#[async_trait]
impl IdentityService for IdentityServiceImpl {
    async fn create_identity(&self, identity: &str) -> Result<(), String> {
        let credential = VerifiableCredential {
            credential_type: "IdentityCredential".to_string(),
            issuer_did: "did:icn:issuer".to_string(),
            subject_did: identity.to_string(),
            issuance_date: chrono::Utc::now().to_rfc3339(),
            expiration_date: None,
            credential_status: None,
            credential_schema: None,
            proof: Proof {
                type_: "Ed25519Signature2018".to_string(),
                created: chrono::Utc::now().to_rfc3339(),
                proof_purpose: "assertionMethod".to_string(),
                verification_method: "did:icn:issuer#keys-1".to_string(),
                jws: "example-jws".to_string(),
            },
        };

        create_identity_in_ledger(identity, &credential).await.map_err(|e| e.to_string())
    }

    async fn get_identity(&self, identity: &str) -> Result<String, String> {
        get_identity_from_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn rotate_key(&self, identity: &str) -> Result<(), String> {
        rotate_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn revoke_key(&self, identity: &str) -> Result<(), String> {
        revoke_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn verify_did(&self, _did: &str) -> Result<bool, String> {
        // Placeholder logic for verifying DID
        Ok(true)
    }

    async fn verify_credential(&self, credential: &str) -> Result<bool, String> {
        // Implement actual validation logic for verifying credential
        // For example, you can use a library to parse and validate the credential
        // Here, we assume the credential is a JSON string and validate its structure

        let parsed_credential: Result<VerifiableCredential, _> = serde_json::from_str(credential);
        match parsed_credential {
            Ok(vc) => {
                // Perform additional validation checks if needed
                // For example, check the issuer, expiration date, etc.
                if vc.issuer_did == "did:icn:issuer" {
                    Ok(true)
                } else {
                    Err("Invalid issuer".to_string())
                }
            }
            Err(_) => Err("Invalid credential format".to_string()),
        }
    }

    async fn get_public_key(&self, did: &str) -> Result<Option<Vec<u8>>, String> {
        // Placeholder logic for retrieving public key
        Ok(Some(vec![]))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> PgPool {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        PgPool::connect(&database_url).await.unwrap()
    }

    #[tokio::test]
    async fn test_create_identity() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.create_identity("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_get_identity() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let _ = service.create_identity("did:icn:test").await;
        let result = service.get_identity("did:icn:test").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "");
    }

    #[tokio::test]
    async fn test_rotate_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.rotate_key("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_revoke_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.revoke_key("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_verify_did() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.verify_did("did:icn:test").await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_verify_credential() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let valid_credential = r#"
        {
            "credential_type": "IdentityCredential",
            "issuer_did": "did:icn:issuer",
            "subject_did": "did:icn:test",
            "issuance_date": "2023-01-01T00:00:00Z",
            "expiration_date": null,
            "credential_status": null,
            "credential_schema": null,
            "proof": {
                "type_": "Ed25519Signature2018",
                "created": "2023-01-01T00:00:00Z",
                "proof_purpose": "assertionMethod",
                "verification_method": "did:icn:issuer#keys-1",
                "jws": "example-jws"
            }
        }
        "#;

        let invalid_credential = r#"
        {
            "credential_type": "IdentityCredential",
            "issuer_did": "did:icn:invalid",
            "subject_did": "did:icn:test",
            "issuance_date": "2023-01-01T00:00:00Z",
            "expiration_date": null,
            "credential_status": null,
            "credential_schema": null,
            "proof": {
                "type_": "Ed25519Signature2018",
                "created": "2023-01-01T00:00:00Z",
                "proof_purpose": "assertionMethod",
                "verification_method": "did:icn:issuer#keys-1",
                "jws": "example-jws"
            }
        }
        "#;

        let result = service.verify_credential(valid_credential).await;
        assert!(result.is_ok());
        assert!(result.unwrap());

        let result = service.verify_credential(invalid_credential).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_get_public_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.get_public_key("did:icn:test").await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_some());
    }
}
```

===================
File: ./backend/src/services/reputation_service.rs
Size: 16423 bytes
===================
```rs
use crate::database::db::Database;
use crate::models::Reputation;
use std::sync::Arc;
use dashmap::DashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::time::{SystemTime, Duration, UNIX_EPOCH};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::task;
use tokio::time::{self, Duration};
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions

/// A cache for storing reputation scores.
pub struct ReputationCache {
    cache: DashMap<String, i32>,
    max_size: usize,
}

impl ReputationCache {
    /// Creates a new ReputationCache with the specified maximum size.
    fn new(max_size: usize) -> Self {
        Self {
            cache: DashMap::new(),
            max_size,
        }
    }

    /// Retrieves the reputation score for the given DID from the cache.
    fn get(&self, did: &str) -> Option<i32> {
        self.cache.get(did).map(|v| *v)
    }

    /// Sets the reputation score for the given DID in the cache.
    fn set(&self, did: &str, score: i32) {
        if self.cache.len() >= self.max_size {
            // Implement a simple eviction policy (e.g., remove a random entry)
            if let Some(key) = self.cache.iter().next().map(|entry| entry.key().clone()) {
                self.cache.remove(&key);
            }
        }
        self.cache.insert(did.to_string(), score);
    }
}

/// A service for managing reputation scores.
pub struct ReputationService {
    db: Arc<Database>,
    cache: ReputationCache,
    decay_rate: f64,
    event_sender: Sender<ReputationEvent>,
}

pub struct ReputationConfig {
    base_decay_rate: f64,
    min_decay_rate: f64,
    max_decay_rate: f64,
    grace_period_days: u64,
    reputation_half_life: f64,
}

impl Default for ReputationConfig {
    fn default() -> Self {
        Self {
            base_decay_rate: 0.1,
            min_decay_rate: 0.02, // Minimum 2% decay for long-standing members
            max_decay_rate: 0.2,  // Maximum 20% decay for new/inactive members
            grace_period_days: 30, // 30 day grace period
            reputation_half_life: 365.0, // 1 year half-life for reputation weight
        }
    }
}

impl ReputationService {
    /// Creates a new ReputationService with the specified database, cache size, and decay rate.
    pub fn new(db: Arc<Database>, max_cache_size: usize, decay_rate: f64) -> Self {
        let (event_sender, event_receiver) = mpsc::channel(100);
        let service = ReputationService {
            db,
            cache: ReputationCache::new(max_cache_size),
            decay_rate,
            event_sender,
        };
        service.start_event_listener(event_receiver);
        service
    }

    /// Retrieves the reputation score for the given DID and category.
    pub async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, sqlx::Error> {
        if let Some(score) = self.cache.get(did) {
            return Ok(score as i64);
        }

        let reputation = sqlx::query_as!(
            Reputation,
            r#"
            SELECT score FROM reputations WHERE did = $1 AND category = $2
            "#,
            did,
            category
        )
        .fetch_one(&*self.db.pool)
        .await?;

        self.cache.set(did, reputation.score as i32);
        Ok(reputation.score)
    }

    /// Adjusts the reputation score for the given DID and category by the specified adjustment value.
    pub async fn adjust_reputation(&self, did: &str, category: &str, adjustment: i64, zk_snark_proof: Option<&str>) -> Result<(), sqlx::Error> {
        if let Some(proof) = zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }

        sqlx::query!(
            r#"
            INSERT INTO reputations (did, category, score)
            VALUES ($1, $2, $3)
            ON CONFLICT (did, category) DO UPDATE SET score = reputations.score + $3
            "#,
            did,
            category,
            adjustment
        )
        .execute(&*self.db.pool)
        .await?;

        // Update the cache after adjusting the reputation
        if let Some(mut score) = self.cache.get(did) {
            score += adjustment as i32;
            self.cache.set(did, score);
        } else {
            let reputation = sqlx::query_as!(
                Reputation,
                r#"
                SELECT score FROM reputations WHERE did = $1 AND category = $2
                "#,
                did,
                category
            )
            .fetch_one(&*self.db.pool)
            .await?;
            self.cache.set(did, reputation.score as i32);
        }

        Ok(())
    }

    /// Applies decay to the reputation scores for the given DID.
    pub async fn apply_decay(&self, did: &str) -> Result<(), sqlx::Error> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64;
        let contributions = sqlx::query_as!(
            Contribution,
            r#"
            SELECT score, timestamp FROM contributions WHERE did = $1
            "#,
            did
        )
        .fetch_all(&*self.db.pool)
        .await?;

        for contribution in contributions {
            let age = now - contribution.timestamp;
            let decayed_score = (contribution.score as f64 * (-self.decay_rate * age).exp()) as i64;
            sqlx::query!(
                r#"
                UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
                "#,
                decayed_score,
                did,
                contribution.timestamp
            )
            .execute(&*self.db.pool)
            .await?;
        }

        Ok(())
    }

    /// Handles Sybil resistance mechanisms for DID reputation tracking.
    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| sqlx::Error::Protocol(e.to_string()))
    }

    /// Applies reputation decay for the given DID with a specified decay rate.
    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        apply_reputation_decay_in_ledger(did, decay_rate).await.map_err(|e| sqlx::Error::Protocol(e.to_string()))
    }

    pub async fn apply_adaptive_decay(&self, did: &str) -> Result<(), sqlx::Error> {
        let config = ReputationConfig::default();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();

        // Get member history
        let history = sqlx::query!(
            r#"
            SELECT 
                join_date,
                last_contribution,
                total_contributions,
                current_reputation
            FROM member_history 
            WHERE did = $1
            "#,
            did
        )
        .fetch_one(&*self.db.pool)
        .await?;

        // Calculate member tenure in days
        let tenure_days = (now.as_secs() - history.join_date) / 86400;
        
        // Check grace period
        let days_since_contribution = (now.as_secs() - history.last_contribution) / 86400;
        if days_since_contribution <= config.grace_period_days {
            return Ok(()); // No decay during grace period
        }

        // Calculate adaptive decay rate based on tenure and contribution history
        let tenure_factor = (-tenure_days as f64 / config.reputation_half_life).exp();
        let contribution_factor = (history.total_contributions as f64).sqrt() / 10.0;
        
        let adaptive_rate = config.base_decay_rate * 
            (1.0 - tenure_factor) * 
            (1.0 - contribution_factor)
            .clamp(config.min_decay_rate, config.max_decay_rate);

        // Apply the decay
        let new_reputation = (history.current_reputation as f64 * 
            (1.0 - adaptive_rate)).round() as i64;

        sqlx::query!(
            r#"
            UPDATE member_history 
            SET current_reputation = $1
            WHERE did = $2
            "#,
            new_reputation,
            did
        )
        .execute(&*self.db.pool)
        .await?;

        // Update cache
        self.cache.set(did, new_reputation as i32);

        Ok(())
    }

    pub async fn record_contribution(&self, did: &str) -> Result<(), sqlx::Error> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        
        sqlx::query!(
            r#"
            UPDATE member_history 
            SET 
                last_contribution = $1,
                total_contributions = total_contributions + 1
            WHERE did = $2
            "#,
            now as i64,
            did
        )
        .execute(&*self.db.pool)
        .await?;

        Ok(())
    }

    pub async fn batch_reputation_updates(&self, events: Vec<ReputationEvent>) -> Result<(), sqlx::Error> {
        for event in events {
            self.emit_event(event);
        }
        Ok(())
    }

    pub fn emit_event(&self, event: ReputationEvent) {
        let sender = self.event_sender.clone();
        task::spawn(async move {
            if let Err(e) = sender.send(event).await {
                eprintln!("Failed to send event: {}", e);
            }
        });
    }

    fn start_event_listener(&self, mut event_receiver: Receiver<ReputationEvent>) {
        task::spawn(async move {
            while let Some(event) = event_receiver.recv().await {
                match event {
                    ReputationEvent::ReputationAdjusted { did, adjustment } => {
                        // Handle reputation adjustment event
                    }
                    ReputationEvent::ReputationDecayApplied { did, decay_rate } => {
                        // Handle reputation decay event
                    }
                }
            }
        });
    }
}

/// Represents a contribution with a score and timestamp.
pub struct Contribution {
    pub score: i64,
    pub timestamp: f64,
}

impl Contribution {
    /// Creates a new Contribution with the specified score and the current timestamp.
    pub fn new(score: i64) -> Self {
        Self {
            score,
            timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64,
        }
    }
}

pub enum ReputationEvent {
    ReputationAdjusted { did: String, adjustment: i64 },
    ReputationDecayApplied { did: String, decay_rate: f64 },
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> Arc<Database> {
        let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        let pool = PgPool::connect(&database_url).await.unwrap();
        Arc::new(Database { pool })
    }

    #[tokio::test]
    async fn test_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }

    #[tokio::test]
    async fn test_integration_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_integration_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_integration_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_integration_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_integration_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_integration_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_integration_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }
}
```

===================
File: ./backend/src/services/storage_service.rs
Size: 5251 bytes
===================
```rs
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;
use crate::storage::{StorageBackend, StorageResult, StorageError};

pub struct StorageService {
    pool: Arc<PgPool>,
}

impl StorageService {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }

    pub async fn store_on_chain(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        // Implement on-chain storage logic here
        Ok(())
    }

    pub async fn retrieve_on_chain(&self, key: &str) -> StorageResult<Vec<u8>> {
        // Implement on-chain retrieval logic here
        Ok(vec![])
    }

    pub async fn delete_on_chain(&self, key: &str) -> StorageResult<()> {
        // Implement on-chain deletion logic here
        Ok(())
    }

    pub async fn store_off_chain(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        self.set(key, value).await
    }

    pub async fn retrieve_off_chain(&self, key: &str) -> StorageResult<Vec<u8>> {
        self.get(key).await
    }

    pub async fn delete_off_chain(&self, key: &str) -> StorageResult<()> {
        self.delete(key).await
    }
}

#[async_trait]
impl StorageBackend for StorageService {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.exists.unwrap_or(false))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;
    use std::sync::Arc;

    async fn setup_test_db() -> Arc<PgPool> {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        Arc::new(PgPool::connect(&database_url).await.unwrap())
    }

    #[tokio::test]
    async fn test_store_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.store_on_chain("test_key", b"test_value").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_retrieve_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.retrieve_on_chain("test_key").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"test_value");
    }

    #[tokio::test]
    async fn test_delete_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.delete_on_chain("test_key").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_store_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.store_off_chain("test_key", b"test_value").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_retrieve_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.retrieve_off_chain("test_key").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"test_value");
    }

    #[tokio::test]
    async fn test_delete_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.delete_off_chain("test_key").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_exists() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let key = "test_key";
        let value = b"test_value";

        storage_service.store_off_chain(key, value).await.unwrap();
        let exists = storage_service.exists(key).await.unwrap();
        assert!(exists);

        storage_service.delete_off_chain(key).await.unwrap();
        let exists = storage_service.exists(key).await.unwrap();
        assert!(!exists);
    }
}
```

===================
File: ./backend/src/storage.rs
Size: 5796 bytes
===================
```rs
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;

pub type StorageResult<T> = Result<T, StorageError>;

#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    #[error("Key not found: {0}")]
    KeyNotFound(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
}

#[async_trait]
pub trait StorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    async fn delete(&self, key: &str) -> StorageResult<()>;
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

pub struct StorageManager {
    backend: Box<dyn StorageBackend + Send + Sync>,
}

impl StorageManager {
    pub fn new(backend: Box<dyn StorageBackend + Send + Sync>) -> Self {
        Self { backend }
    }
}

pub struct DatabaseStorageBackend {
    pool: Arc<PgPool>,
}

impl DatabaseStorageBackend {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.exists.unwrap_or(false))
    }
}

pub struct OnChainStorage {
    // Add fields for on-chain storage management
}

impl OnChainStorage {
    pub async fn store(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        // Implement on-chain storage logic here
        Ok(())
    }

    pub async fn retrieve(&self, key: &str) -> StorageResult<Vec<u8>> {
        // Implement on-chain retrieval logic here
        Ok(vec![])
    }

    pub async fn delete(&self, key: &str) -> StorageResult<()> {
        // Implement on-chain deletion logic here
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;
    use std::sync::Arc;

    async fn setup_test_db() -> Arc<PgPool> {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        Arc::new(PgPool::connect(&database_url).await.unwrap())
    }

    #[tokio::test]
    async fn test_set_and_get() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        let retrieved_value = backend.get(key).await.unwrap();
        assert_eq!(retrieved_value, value);
    }

    #[tokio::test]
    async fn test_delete() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        backend.delete(key).await.unwrap();
        let result = backend.get(key).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_exists() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        let exists = backend.exists(key).await.unwrap();
        assert!(exists);

        backend.delete(key).await.unwrap();
        let exists = backend.exists(key).await.unwrap();
        assert!(!exists);
    }

    #[tokio::test]
    async fn test_on_chain_store() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";
        let value = b"on_chain_value";

        let result = on_chain_storage.store(key, value).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_on_chain_retrieve() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";

        let result = on_chain_storage.retrieve(key).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"on_chain_value");
    }

    #[tokio::test]
    async fn test_on_chain_delete() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";

        let result = on_chain_storage.delete(key).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/test_config.rs
Size: 1365 bytes
===================
```rs
use lazy_static::lazy_static;
use std::env;
use std::sync::Once;

static INIT: Once = Once::new();

lazy_static! {
    pub static ref TEST_CONFIG: TestConfig = TestConfig::new();
}

pub struct TestConfig {
    pub database_url: String,
    pub test_did: String,
    pub test_public_key: String,
    pub test_private_key: String,
}

impl TestConfig {
    pub fn new() -> Self {
        // Initialize test environment
        INIT.call_once(|| {
            env_logger::init();
        });

        Self {
            database_url: env::var("TEST_DATABASE_URL")
                .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string()),
            test_did: "did:icn:test".to_string(),
            test_public_key: "test_public_key".to_string(),
            test_private_key: "test_private_key".to_string(),
        }
    }
}

/// Test environment setup
pub fn setup_test_env() {
    INIT.call_once(|| {
        env_logger::init();
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_initialization() {
        let config = TestConfig::new();
        assert!(!config.database_url.is_empty());
        assert!(!config.test_did.is_empty());
    }

    #[test]
    fn test_env_setup() {
        setup_test_env();
        // Verify it can be called multiple times without issues
        setup_test_env();
    }
} ```

===================
File: ./backend/src/test_macros.rs
Size: 1413 bytes
===================
```rs
#[macro_export]
macro_rules! async_test {
    ($name:ident, $body:expr) => {
        #[tokio::test]
        async fn $name() {
            crate::test_config::setup_test_env();
            let services = crate::test_utils::TestServices::new().await;
            
            // Run the test
            let result = $body(&services).await;
            
            // Cleanup
            services.cleanup().await;
            
            // Propagate any test failures
            if let Err(e) = result {
                panic!("Test failed: {}", e);
            }
        }
    };
}

#[macro_export]
macro_rules! setup_test_db {
    () => {{
        use crate::test_utils::TestDb;
        TestDb::new().await
    }};
}

#[macro_export]
macro_rules! with_test_services {
    ($services:ident, $body:expr) => {{
        let $services = crate::test_utils::TestServices::new().await;
        let result = $body;
        $services.cleanup().await;
        result
    }};
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::TestServices;

    async_test!(test_macro_works, |_services| async {
        Ok(())
    });

    #[tokio::test]
    async fn test_with_services_macro() {
        with_test_services!(services, async {
            assert!(services.database.pool.ping().await.is_ok());
            Ok::<_, Box<dyn std::error::Error>>(())
        })
        .await
        .unwrap();
    }
} ```

===================
File: ./backend/src/test_utils.rs
Size: 7302 bytes
===================
```rs
use sqlx::PgPool;
use std::env;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::database::Database;
use crate::identity::IdentityManager;
use crate::reputation::ReputationManager;
use crate::networking::p2p::P2PManager;

/// Test database configuration
pub struct TestDb {
    pub pool: PgPool,
}

impl TestDb {
    /// Creates a new test database connection
    pub async fn new() -> Self {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        let pool = PgPool::connect(&database_url)
            .await
            .expect("Failed to connect to test database");
        Self { pool }
    }

    /// Cleans up test database tables
    pub async fn cleanup(&self) {
        // List of tables to truncate
        let tables = vec![
            "proposals",
            "votes",
            "identities",
            "reputation_scores",
            "storage",
            "federation_operations",
        ];

        for table in tables {
            let _ = sqlx::query(&format!("TRUNCATE TABLE {} CASCADE", table))
                .execute(&self.pool)
                .await;
        }
    }
}

/// Creates mock services for testing
pub struct TestServices {
    pub identity_manager: Arc<IdentityManager>,
    pub reputation_manager: Arc<ReputationManager>,
    pub p2p_manager: Arc<Mutex<P2PManager>>,
    pub database: Arc<Database>,
}

impl TestServices {
    /// Creates new test services with a shared database connection
    pub async fn new() -> Self {
        let test_db = TestDb::new().await;
        let database = Arc::new(Database { pool: test_db.pool });
        
        Self {
            identity_manager: Arc::new(IdentityManager::new(database.clone())),
            reputation_manager: Arc::new(ReputationManager::new(
                database.clone(),
                100, // max_cache_size
                0.1, // decay_rate
            )),
            p2p_manager: Arc::new(Mutex::new(P2PManager::new())),
            database,
        }
    }

    /// Cleans up all test data
    pub async fn cleanup(&self) {
        let test_db = TestDb {
            pool: self.database.pool.clone(),
        };
        test_db.cleanup().await;
    }
}

/// Test helper functions
pub mod helpers {
    use super::*;
    use crate::models::{Proposal, Vote};
    use chrono::{NaiveDateTime, Utc};

    /// Creates a test proposal
    pub fn create_test_proposal(id: i32) -> Proposal {
        Proposal {
            id,
            title: format!("Test Proposal {}", id),
            description: "Test Description".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(Utc::now().timestamp() + 3600, 0),
            created_at: NaiveDateTime::from_timestamp(Utc::now().timestamp(), 0),
        }
    }

    /// Creates a test vote
    pub fn create_test_vote(proposal_id: i32, voter: &str, approve: bool) -> Vote {
        Vote {
            proposal_id,
            voter: voter.to_string(),
            approve,
        }
    }
}

pub mod test_utils {
    use crate::identity::{IdentitySystem, DID, Algorithm};
    use crate::reputation::ReputationSystem;
    use crate::blockchain::Blockchain;
    use crate::governance::ProposalHistory;
    use crate::federation::FederationManager;
    use std::sync::{Arc, Mutex};
    use std::collections::HashMap;

    /// Set up a test environment with basic components
    pub fn setup_test_environment() -> (
        Arc<Mutex<IdentitySystem>>, 
        Arc<Mutex<ReputationSystem>>,
        Arc<Mutex<Blockchain>>,
        Arc<Mutex<ProposalHistory>>,
        Arc<Mutex<FederationManager>>
    ) {
        // Create the identity system
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        
        // Create the reputation system
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        
        // Create the blockchain
        let blockchain = Arc::new(Mutex::new(
            Blockchain::new(identity_system.clone(), reputation_system.clone())
        ));
        
        // Create proposal history
        let proposal_history = Arc::new(Mutex::new(ProposalHistory::new()));
        
        // Create federation manager
        let federation_manager = Arc::new(Mutex::new(FederationManager::new()));
        
        // Return all components
        (identity_system, reputation_system, blockchain, proposal_history, federation_manager)
    }

    /// Create DIDs for testing
    pub fn create_test_dids(count: usize) -> Vec<DID> {
        let mut dids = Vec::with_capacity(count);
        
        for i in 0..count {
            let did = DID::new(
                format!("did:icn:test{}", i),
                Algorithm::Ed25519
            );
            dids.push(did);
        }
        
        dids
    }

    /// Register DIDs with permissions
    pub fn register_dids_with_permissions(
        identity_system: &mut IdentitySystem,
        dids: Vec<DID>,
        permissions: &[&str]
    ) {
        for did in dids {
            identity_system.register_did(
                did,
                permissions.iter().map(|&p| p.to_string()).collect()
            );
        }
    }

    /// Set up reputation scores for DIDs
    pub fn setup_reputations(
        reputation_system: &mut ReputationSystem,
        dids: &[&str],
        scores: &[i32]
    ) {
        for (did, &score) in dids.iter().zip(scores.iter()) {
            reputation_system.increase_reputation(did, score);
        }
    }

    /// Create a test blockchain with genesis block
    pub fn create_test_blockchain(
        identity_system: Arc<Mutex<IdentitySystem>>,
        reputation_system: Arc<Mutex<ReputationSystem>>
    ) -> Blockchain {
        Blockchain::new(identity_system, reputation_system)
    }

    /// Sample helper to verify transaction validity
    pub fn verify_transaction_validity(
        blockchain: &Blockchain,
        sender: &str,
        transaction_type: &str
    ) -> bool {
        let identity_system = blockchain.identity_system.lock().unwrap();
        match transaction_type {
            "transfer" => identity_system.has_permission(sender, "transfer"),
            "governance" => identity_system.has_permission(sender, "governance"),
            "resource" => identity_system.has_permission(sender, "resource"),
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_database_connection() {
        let test_db = TestDb::new().await;
        assert!(sqlx::query("SELECT 1")
            .execute(&test_db.pool)
            .await
            .is_ok());
    }

    #[tokio::test]
    async fn test_services_creation() {
        let services = TestServices::new().await;
        assert!(services.database.pool.ping().await.is_ok());
    }

    #[tokio::test]
    async fn test_cleanup() {
        let services = TestServices::new().await;
        services.cleanup().await;
        // Verify tables are empty
        let count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM proposals")
            .fetch_one(&services.database.pool)
            .await
            .unwrap();
        assert_eq!(count.0, 0);
    }
}```

===================
File: ./backend/src/vm.rs
Size: 6560 bytes
===================
```rs
use std::sync::Arc;
use icn_types::RuntimeError;
use icn_core::vm::{OpCode, Contract, CooperativeMetadata, VM as CoreVM};
use std::error::Error;
use std::collections::HashMap;
use icn_core::vm::{VM, VMConfig};

pub mod opcode {
    #[derive(Debug, PartialEq, Clone)]
    pub enum OpCode {
        // Stack operations
        Push(i32),
        Pop,
        Dup,
        Swap,
        
        // Math operations
        Add,
        Sub,
        Mul,
        Div,
        
        // Memory operations
        Load(String),
        Store(String),
        
        // Control flow
        Jump(usize),
        JumpIf(usize),
        Call(String),
        Return,
        
        // Cooperative operations
        ShareResource(String),
        RequestResource(String),
        ReleaseResource(String),
        
        // Federation operations
        JoinFederation(String),
        LeaveFederation(String),
        VoteOnProposal(String),
        
        // Reputation operations
        GetReputation(String),
        IncreaseReputation(String, i32),
        DecreaseReputation(String, i32),
    }
}

pub mod cooperative_metadata {
    use std::collections::HashMap;
    use serde::{Serialize, Deserialize};

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ResourceImpact {
        pub cpu: f64,
        pub memory: f64,
        pub storage: f64,
        pub bandwidth: f64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CooperativeMetadata {
        pub name: String,
        pub version: String,
        pub author: String,
        pub description: String,
        pub resource_impact: ResourceImpact,
        pub permissions: Vec<String>,
        pub dependencies: HashMap<String, String>, // name -> version
    }
    
    impl CooperativeMetadata {
        pub fn new(
            name: String,
            version: String,
            author: String,
            description: String,
        ) -> Self {
            Self {
                name,
                version,
                author,
                description,
                resource_impact: ResourceImpact {
                    cpu: 0.0,
                    memory: 0.0,
                    storage: 0.0,
                    bandwidth: 0.0,
                },
                permissions: Vec::new(),
                dependencies: HashMap::new(),
            }
        }
        
        pub fn with_resource_impact(mut self, impact: ResourceImpact) -> Self {
            self.resource_impact = impact;
            self
        }
        
        pub fn with_permissions(mut self, permissions: Vec<String>) -> Self {
            self.permissions = permissions;
            self
        }
        
        pub fn add_dependency(mut self, name: String, version: String) -> Self {
            self.dependencies.insert(name, version);
            self
        }
    }
}

pub struct BackendVM {
    inner: VM
}

impl BackendVM {
    pub fn new(config: VMConfig) -> Self {
        Self {
            inner: VM::new(config)
        }
    }

    pub fn execute(&mut self, contract_id: &str, method: &str, args: Vec<Vec<u8>>) -> Result<Vec<u8>, String> {
        self.inner.execute(contract_id, method, args)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::opcode::OpCode;
    use super::cooperative_metadata::{CooperativeMetadata, ResourceImpact};

    #[test]
    fn test_simple_program() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "TestProgram".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "A test program".to_string(),
        );
        
        // Create a simple program that calculates (5 + 3) * 2
        let program = vec![
            OpCode::Push(5),
            OpCode::Push(3),
            OpCode::Add,     // Stack now contains [8]
            OpCode::Push(2),
            OpCode::Mul,     // Stack now contains [16]
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![16]);
    }
    
    #[test]
    fn test_memory_operations() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "MemoryTest".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "Tests memory operations".to_string(),
        );
        
        // Create a program that stores and loads values from memory
        let program = vec![
            OpCode::Push(42),
            OpCode::Store("answer".to_string()),  // Store 42 in "answer"
            OpCode::Push(10),                     // Push something else to ensure we're loading
            OpCode::Load("answer".to_string()),   // Load "answer" (42)
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![42]);
    }
    
    #[test]
    fn test_control_flow() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "ControlFlowTest".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "Tests control flow".to_string(),
        );
        
        // Create a program with conditional jumps
        let program = vec![
            OpCode::Push(1),                  // Condition true
            OpCode::JumpIf(3),                // Jump to position 3 if condition is true
            OpCode::Push(0),                  // This should be skipped
            OpCode::Push(42),                 // This is where we jump to
            OpCode::Push(0),                  // Condition false
            OpCode::JumpIf(7),                // This jump should NOT happen
            OpCode::Push(100),                // This should be executed
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![100]);
    }
}
```

===================
File: ./backend/src/websocket/mod.rs
Size: 1654 bytes
===================
```rs
use redis::{Client as RedisClient, Commands};
use tokio::sync::broadcast;

pub struct DistributedWebSocketManager {
    redis: RedisClient,
    event_tx: broadcast::Sender<WebSocketEvent>,
}

impl DistributedWebSocketManager {
    pub fn new(redis_url: &str) -> Self {
        let (tx, _) = broadcast::channel(1000);
        Self {
            redis: RedisClient::open(redis_url).unwrap(),
            event_tx: tx,
        }
    }

    pub async fn broadcast_message(&self, message: WebSocketEvent) {
        // Local broadcast
        let _ = self.event_tx.send(message.clone());
        
        // Redis pub/sub broadcast
        let _ = self.redis.publish("ws_events", serde_json::to_string(&message).unwrap());
    }
}

pub struct WebSocketEvent {
    pub event_type: String,
    pub payload: String,
}

impl WebSocketEvent {
    pub fn new(event_type: &str, payload: &str) -> Self {
        Self {
            event_type: event_type.to_string(),
            payload: payload.to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::broadcast;

    #[tokio::test]
    async fn test_broadcast_message() {
        let manager = DistributedWebSocketManager::new("redis://127.0.0.1/");
        let (tx, mut rx) = broadcast::channel(1000);

        let event = WebSocketEvent::new("test_event", "test_payload");
        manager.broadcast_message(event.clone()).await;

        let received_event = rx.recv().await.unwrap();
        assert_eq!(received_event.event_type, event.event_type);
        assert_eq!(received_event.payload, event.payload);
    }
}
```

===================
File: ./contracts/cooperative/src/lib.rs
Size: 1284 bytes
===================
```rs
mod proposals;

use proposals::{ProposalContract, Proposal};
use icn_zkp::{RollupBatch, VerificationKey};
use ethers::prelude::*;

pub struct CooperativeContract {
    proposal_contract: ProposalContract,
    contract_address: Address,
    // ...existing code...
}

impl CooperativeContract {
    pub fn new(contract_address: Address, verification_key: VerificationKey) -> Self {
        Self {
            proposal_contract: ProposalContract::new(
                3,
                verification_key,
                contract_address
            ),
            contract_address,
            // ...existing code...
        }
    }

    pub async fn submit_vote_batch(&mut self, batch: RollupBatch) -> Result<(), String> {
        self.proposal_contract.submit_vote_batch(batch).await
    }

    pub async fn execute_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        self.proposal_contract.execute_proposal(proposal_id).await
    }

    pub async fn submit_zk_snark_proof(&self, proof: Vec<u8>) -> Result<(), String> {
        // Implement zk-SNARK proof submission logic
        Ok(())
    }

    pub async fn verify_zk_snark_proof(&self, proof: Vec<u8>) -> Result<bool, String> {
        // Implement zk-SNARK proof verification logic
        Ok(true)
    }
}
```

===================
File: ./crates/icn-cli/src/main.rs
Size: 9564 bytes
===================
```rs
mod client;

use clap::{App, Arg, SubCommand};
use std::error::Error;
use client::IcnClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let app = App::new("icn-cli")
        .version("0.1.0")
        .author("ICN Team")
        .about("Command Line Interface for the Inter-Cooperative Network")
        .arg(
            Arg::with_name("api-url")
                .long("api-url")
                .help("ICN API URL")
                .default_value("http://localhost:8081")
                .takes_value(true)
        )
        .subcommand(
            SubCommand::with_name("health")
                .about("Check the health of the ICN API")
        )
        .subcommand(
            SubCommand::with_name("identity")
                .about("Identity management commands")
                .subcommand(
                    SubCommand::with_name("create")
                        .about("Create a new DID identity")
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List existing DIDs")
                )
        )
        .subcommand(
            SubCommand::with_name("cooperative")
                .about("Cooperative management commands")
                .subcommand(
                    SubCommand::with_name("join")
                        .about("Join a cooperative")
                        .arg(
                            Arg::with_name("coop-id")
                                .help("ID of the cooperative to join")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List available cooperatives")
                )
        )
        .subcommand(
            SubCommand::with_name("resource")
                .about("Resource management commands")
                .subcommand(
                    SubCommand::with_name("register")
                        .about("Register a new resource")
                        .arg(
                            Arg::with_name("type")
                                .help("Type of resource (compute/storage/network)")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("capacity")
                                .help("Resource capacity")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List available resources")
                )
        )
        .subcommand(
            SubCommand::with_name("governance")
                .about("Governance commands")
                .subcommand(
                    SubCommand::with_name("propose")
                        .about("Create a new proposal")
                        .arg(
                            Arg::with_name("title")
                                .help("Proposal title")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("description")
                                .help("Proposal description")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("vote")
                        .about("Vote on a proposal")
                        .arg(
                            Arg::with_name("proposal-id")
                                .help("ID of the proposal")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("vote")
                                .help("Vote (yes/no)")
                                .required(true)
                        )
                )
        );

    let matches = app.get_matches();
    let api_url = matches.value_of("api-url").unwrap().to_string();
    let client = IcnClient::new(api_url);

    match matches.subcommand() {
        ("health", Some(_)) => {
            match client.check_health().await {
                Ok(health) => {
                    println!("✅ ICN API is healthy");
                    println!("Status: {}", health.status);
                    println!("Version: {}", health.version);
                    println!("Uptime: {} seconds", health.uptime);
                }
                Err(e) => {
                    eprintln!("❌ ICN API health check failed: {}", e);
                    return Err(e);
                }
            }
        }
        ("identity", Some(identity_matches)) => {
            match identity_matches.subcommand() {
                ("create", Some(_)) => {
                    match client.create_identity().await {
                        Ok(identity) => println!("Created new DID: {}", identity.did),
                        Err(e) => eprintln!("Error creating identity: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_identities().await {
                        Ok(identities) => {
                            println!("Existing DIDs:");
                            for identity in identities {
                                println!("- {} (public key: {})", identity.did, identity.public_key);
                            }
                        }
                        Err(e) => eprintln!("Error listing identities: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("cooperative", Some(coop_matches)) => {
            match coop_matches.subcommand() {
                ("join", Some(join_matches)) => {
                    let coop_id = join_matches.value_of("coop-id").unwrap();
                    match client.join_cooperative(coop_id).await {
                        Ok(_) => println!("Successfully joined cooperative {}", coop_id),
                        Err(e) => eprintln!("Error joining cooperative: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_cooperatives().await {
                        Ok(cooperatives) => {
                            println!("Available cooperatives:");
                            for coop in cooperatives {
                                println!("- {} ({} members)", coop.name, coop.member_count);
                            }
                        }
                        Err(e) => eprintln!("Error listing cooperatives: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("resource", Some(resource_matches)) => {
            match resource_matches.subcommand() {
                ("register", Some(register_matches)) => {
                    let resource_type = register_matches.value_of("type").unwrap();
                    let capacity = register_matches.value_of("capacity").unwrap();
                    match client.register_resource(resource_type, capacity).await {
                        Ok(resource) => println!("Registered resource: {} (ID: {})", resource.resource_type, resource.id),
                        Err(e) => eprintln!("Error registering resource: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_resources().await {
                        Ok(resources) => {
                            println!("Available resources:");
                            for resource in resources {
                                println!("- {} ({} capacity, owned by {})", 
                                    resource.resource_type, 
                                    resource.capacity,
                                    resource.owner);
                            }
                        }
                        Err(e) => eprintln!("Error listing resources: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("governance", Some(governance_matches)) => {
            match governance_matches.subcommand() {
                ("propose", Some(propose_matches)) => {
                    let title = propose_matches.value_of("title").unwrap();
                    let description = propose_matches.value_of("description").unwrap();
                    match client.create_proposal(title, description).await {
                        Ok(proposal) => println!("Created proposal: {} (ID: {})", proposal.title, proposal.id),
                        Err(e) => eprintln!("Error creating proposal: {}", e),
                    }
                }
                ("vote", Some(vote_matches)) => {
                    let proposal_id = vote_matches.value_of("proposal-id").unwrap();
                    let vote = vote_matches.value_of("vote").unwrap().to_lowercase() == "yes";
                    match client.vote_proposal(proposal_id, vote).await {
                        Ok(_) => println!("Successfully voted on proposal {}", proposal_id),
                        Err(e) => eprintln!("Error voting on proposal: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        _ => {
            println!("No command specified. Use --help to see available commands.");
        }
    }

    Ok(())
}```

===================
File: ./crates/icn-common/src/lib.rs
Size: 1095 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use thiserror::Error;

#[async_trait]
pub trait ReputationManager: Send + Sync {
    fn get_reputation(&self, participant: &str, context: &str) -> i64;
    fn is_eligible(&self, participant: &str, threshold: i64, context: &str) -> bool;
    async fn update_reputation(&self, participant: &str, change: i64, context: &str);
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self);
    async fn stop(&self);
    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError>;
    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError>;
}
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 25246 bytes
===================
```rs
pub mod proof_of_cooperation;
pub mod validation;
pub mod round_management;
pub mod timeout_handling;
pub mod federation;
pub mod sharding; // Add sharding module
pub mod pbft; // Add PBFT module

use async_trait::async_trait;
use std::collections::{HashMap, VecDeque, HashSet}; // Added HashSet import
use std::time::Duration;
use tokio::time::sleep;
use tokio::task;
use icn_common::{ReputationManager, ConsensusEngine, Vote, VoteStatus, GovernanceError};
use icn_types::{Block, Transaction}; // Import Transaction
use std::sync::Arc;
use bit_set::BitSet;
use trie_rs::Trie;
use thiserror::Error;
use federation::{Federation, FederationError};
use serde::{Serialize, Deserialize};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use log::error;

// Interface for identity services
#[async_trait]
pub trait IdentityService: Send + Sync {
    async fn get_public_key(&self, did: &str) -> Option<Vec<u8>>;
    async fn verify_identity(&self, did: &str, proof: &str) -> bool;
}

#[derive(Error, Debug)]
pub enum ConsensusError {
    #[error("Failed to reach consensus: {0}")]
    ConsensusFailure(String),
    #[error("Block validation failed: {0}")]
    ValidationFailure(String),
    #[error("Timeout occurred: {0}")]
    TimeoutError(String),
    #[error("BFT error: {0}")]
    BftError(String),
}

pub struct ProofOfCooperation {
    current_round: u64,
    participants: VecDeque<String>,
    proposed_block: Option<Block>,
    votes: BitSet,
    vote_trie: Trie,
    timeout: Duration,
    timeout_handling: timeout_handling::TimeoutHandling,
    reputation_manager: Arc<dyn ReputationManager>,
    federation_operations: HashMap<String, FederationOperation>,
    federations: HashMap<String, Federation>,
    round_start_time: std::time::Instant,
    shard_manager: sharding::ShardManager, // Add shard manager field
    pbft_consensus: Option<pbft::PbftConsensus>, // Add PBFT consensus field
    identity_did: String, // Add the identity DID of the current node
    identity_service: Arc<dyn IdentityService>, // Add identity service
    active_proposals: HashMap<String, Proposal>, // Add active proposals
    rules: ConsensusRules,
}

// Define proposal structure
#[derive(Clone, Debug)]
pub struct Proposal {
    pub proposal_id: String,
    pub proposal_type: ProposalType,
    pub votes: HashSet<Vote>,
    pub status: ProposalStatus,
    pub created_at: std::time::SystemTime,
}

// Define proposal types
#[derive(Clone, Debug)]
pub enum ProposalType {
    AddValidator(ValidatorInfo),
    RemoveValidator(String), // DID
    UpdateRules(ConsensusRules),
}

// Define validator info
#[derive(Clone, Debug)]
pub struct ValidatorInfo {
    pub did: String,
    pub reputation: i64,
    pub voting_power: u32,
}

// Define consensus rules
#[derive(Clone, Debug)]
pub struct ConsensusRules {
    pub min_reputation: i64,
    pub quorum_percentage: u8,
    pub block_time: Duration,
}

// Define proposal status
#[derive(Clone, Debug, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
    Expired,
}

impl ProofOfCooperation {
    pub fn new(
        reputation_manager: Arc<dyn ReputationManager>,
        identity_service: Arc<dyn IdentityService>,
        identity_did: String
    ) -> Self {
        let shard_config = sharding::ShardConfig {
            shard_count: 4,  // Start with 4 shards
            shard_capacity: 1000, // Each shard can hold 1000 transactions
            rebalance_threshold: 0.3, // Rebalance when load differs by 30%
        };
        
        ProofOfCooperation {
            current_round: 0,
            participants: VecDeque::new(),
            proposed_block: None,
            votes: BitSet::new(),
            vote_trie: Trie::new(),
            timeout: Duration::from_secs(60),
            timeout_handling: timeout_handling::TimeoutHandling::new(Duration::from_secs(60)),
            reputation_manager,
            federation_operations: HashMap::new(),
            federations: HashMap::new(),
            round_start_time: std::time::Instant::now(),
            shard_manager: sharding::ShardManager::new(shard_config),
            pbft_consensus: None,
            identity_did,
            identity_service,
            active_proposals: HashMap::new(),
            rules: ConsensusRules {
                min_reputation: 50,
                quorum_percentage: 67, // 2/3 majority
                block_time: Duration::from_secs(30),
            },
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.vote_trie = Trie::new();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            let index = self.participants.iter().position(|p| p == &participant).unwrap_or_else(|| {
                self.participants.push_back(participant.clone());
                self.participants.len() - 1
            });
            if vote {
                self.votes.insert(index);
            }
            self.vote_trie.insert(&participant);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Get validator list for this round
        let validators = self.select_validators(50).await
            .map_err(|e| ConsensusError::ConsensusFailure(e.to_string()))?;
            
        // Ensure we have enough validators for BFT
        let f = validators.len() / 4; // Maximum allowed Byzantine nodes
        let min_validators = 3 * f + 1; // Minimum required for BFT
        
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }
        
        if self.pbft_consensus.is_none() {
            self.pbft_consensus = Some(pbft::PbftConsensus::new(validators.clone()));
        }
        
        let pbft = self.pbft_consensus.as_mut().unwrap();
        
        if let Some(block) = &self.proposed_block {
            // Primary validator broadcasts pre-prepare message
            if pbft.is_primary(&self.identity_did) {
                let pre_prepare = pbft::ConsensusMessage {
                    message_type: pbft::MessageType::PrePrepare,
                    view_number: pbft.view_number,
                    sequence_number: pbft.sequence_number,
                    block_hash: block.hash.clone(),
                    sender: self.identity_did.clone(),
                    signature: "signature".to_string(), // This should be a proper signature
                };
                
                // Distribute to all validators
                self.broadcast_consensus_message(pre_prepare).await?;
            }
            
            // Wait for consensus to be reached
            let timeout = Duration::from_secs(30);
            let start = std::time::Instant::now();
            
            while start.elapsed() < timeout {
                if pbft.is_committed(&block.hash) {
                    // Consensus reached, update block metadata
                    let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                    let mut final_block = block.clone();
                    final_block.metadata.consensus_duration_ms = consensus_duration;
                    
                    // Clear round state
                    self.start_round();
                    
                    return Ok(Some(final_block));
                }
                
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
            
            // Timeout occurred
            Err(ConsensusError::TimeoutError("PBFT consensus timed out".into()))
        } else {
            Err(ConsensusError::ConsensusFailure("No proposed block".into()))
        }
    }

    pub async fn handle_timeout(&self) {
        if let Err(e) = self.timeout_handling.handle_timeout().await {
            eprintln!("Error handling timeout: {}", e);
        }
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus")
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), Box<dyn std::error::Error>> {
        let chunks: Vec<_> = self.participants.chunks(self.participants.len() / 4).collect();
        let mut handles = vec![];

        for chunk in chunks {
            let chunk = chunk.to_vec();
            let reputation_manager = self.reputation_manager.clone();
            let votes = self.votes.clone();
            let handle = task::spawn(async move {
                let mut total_reputation = 0i64;
                let mut approval_reputation = 0i64;
                
                for (i, p) in chunk.iter().enumerate() {
                    let rep = reputation_manager.get_reputation(p, "consensus");
                    total_reputation += rep;
                    if votes.contains(i) {
                        approval_reputation += rep;
                    }
                }
                
                Ok((total_reputation, approval_reputation))
            });
            handles.push(handle);
        }

        let mut total_reputation = 0;
        let mut approval_reputation = 0;

        for handle in handles {
            let (chunk_total, chunk_approval) = handle.await??;
            total_reputation += chunk_total;
            approval_reputation += chunk_approval;
        }

        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, ConsensusError> {
        let mut validators = Vec::new();
        let participants: Vec<_> = self.participants.iter().cloned().collect();

        for participant in participants {
            if self.reputation_manager.is_eligible(&participant, min_reputation, "consensus") {
                validators.push(participant);
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.max_faulty_nodes() * 3) + 1;
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }

        Ok(validators)
    }

    fn max_faulty_nodes(&self) -> usize {
        self.participants.len() / 3
    }

    pub async fn handle_consensus_round(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Start timeout handler
        let timeout_handler = self.timeout_handling.start_timeout();
        
        tokio::select! {
            result = self.finalize_block() => {
                result
            }
            _ = timeout_handler => {
                self.handle_timeout().await;
                Err(ConsensusError::TimeoutError("Consensus round timed out".into()))
            }
        }
    }

    pub fn handle_federation_operation(&mut self, operation: FederationOperation) {
        match operation {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                self.create_federation(partner_id, federation_type, terms).unwrap();
            }
            FederationOperation::JoinFederation { federation_id, commitment } => {
                // Handle joining federation logic
            }
            FederationOperation::LeaveFederation { federation_id, reason } => {
                // Handle leaving federation logic
            }
            FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
                // Handle proposing action logic
            }
            FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
                // Handle voting on proposal logic
            }
            FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
                // Handle sharing resources logic
            }
            FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
                // Handle updating federation terms logic
            }
        }
    }

    pub fn create_federation(
        &mut self,
        creator_id: String,
        federation_type: FederationType,
        terms: FederationTerms,
    ) -> Result<String, ConsensusError> {
        // Verify creator's reputation
        let creator_reputation = self.reputation_manager.get_reputation(&creator_id, "consensus");
        if creator_reputation < terms.minimum_reputation {
            return Err(ConsensusError::ConsensusFailure(
                "Insufficient reputation to create federation".into(),
            ));
        }

        // Generate unique federation ID
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());

        // Create new federation
        let federation = Federation::new(
            federation_id.clone(),
            federation_type,
            terms,
            creator_id,
        );

        // Store federation
        self.federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn adjust_validator_set(&mut self) -> Result<(), ConsensusError> {
        // Get current validator counts for BFT calculation
        let current_size = self.participants.len();
        let min_validators = (current_size / 3) * 3 + 1; // 3f + 1 where f is max faulty

        // Remove validators that fell below minimum reputation
        let mut to_remove = Vec::new();
        for participant in self.participants.iter() {
            if !self.reputation_manager.is_eligible(participant, 50, "consensus") {
                to_remove.push(participant.clone());
            }
        }

        // Remove disqualified validators if we maintain BFT requirements
        if (current_size - to_remove.len()) >= min_validators {
            for participant in to_remove {
                if let Some(pos) = self.participants.iter().position(|x| x == &participant) {
                    self.participants.remove(pos);
                }
            }
        }

        // Add new validators that meet higher reputation threshold
        let new_validators = self.select_validators(80).await?;
        
        // Add new validators while maintaining max size limit
        let max_validators = 100; // Example maximum validator set size
        for validator in new_validators {
            if self.participants.len() >= max_validators {
                break;
            }
            if !self.participants.contains(&validator) {
                self.participants.push_back(validator);
            }
        }

        Ok(())
    }

    pub async fn start_validator_rotation(&mut self) {
        tokio::spawn(async move {
            let rotation_interval = Duration::from_secs(3600); // 1 hour
            loop {
                sleep(rotation_interval).await;
                if let Err(e) = self.adjust_validator_set().await {
                    error!("Failed to adjust validator set: {}", e);
                }
            }
        });
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub fn apply_anti_monopoly_reputation_decay(&self, reputation: i64, dominance: f64, total: f64, alpha: f64) -> i64 {
        (reputation as f64 * (1.0 - dominance / total).powf(alpha)) as i64
    }

    pub fn quadratic_vote_weight(&self, reputation_points: i64) -> f64 {
        (reputation_points as f64).sqrt()
    }

    pub fn randomized_delegation(&self, participants: Vec<String>, num_delegates: usize) -> Vec<String> {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        let mut delegates = participants.clone();
        delegates.shuffle(&mut rng);
        delegates.truncate(num_delegates);
        delegates
    }

    pub fn dynamic_contribution_valuation(&self, value: i64, repeated: i64, lambda: f64) -> i64 {
        (value as f64 * (-lambda * repeated as f64).exp()) as i64
    }

    pub async fn add_signature(&self, did: &str, signature: &str, message: &str) -> Result<(), ConsensusError> {
        // Retrieve public key from IdentityService
        if let Some(public_key) = self.identity_service.get_public_key(did).await {
            let key_pair = KeyPair {
                public_key,
                private_key: vec![], // Not needed for verification
                algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
            };
            if key_pair.verify(message.as_bytes(), signature.as_bytes()) {
                Ok(())
            } else {
                Err(ConsensusError::ValidationFailure("Invalid signature".to_string()))
            }
        } else {
            Err(ConsensusError::ValidationFailure("Public key not found".to_string()))
        }
    }

    // Add a method to handle transaction sharding
    pub fn add_transaction(&mut self, transaction: Transaction) -> Result<u32, ConsensusError> {
        // Assign transaction to a shard
        let shard_id = self.shard_manager.assign_transaction(transaction);
        
        // Check if shard is ready for finalization
        let shard = self.shard_manager.shards.get(&shard_id).unwrap();
        if shard.len() >= self.shard_manager.config.shard_capacity as usize {
            if let Some(block) = self.shard_manager.finalize_shard(shard_id) {
                self.propose_block(block);
            }
        }
        
        // Periodically rebalance shards
        if self.current_round % 10 == 0 {  // Every 10 rounds
            self.shard_manager.rebalance();
        }
        
        Ok(shard_id)
    }

    async fn broadcast_consensus_message(&self, message: pbft::ConsensusMessage) -> Result<(), ConsensusError> {
        // Implementation to broadcast message to all validators
        // This would use your networking layer to distribute the message
        // ...
        Ok(())
    }

    // Check if a participant is eligible to vote
    pub fn is_eligible_voter(&self, voter_did: &str) -> bool {
        // Check if they have enough reputation
        let reputation = self.reputation_manager.get_reputation(voter_did, "governance");
        if reputation < self.rules.min_reputation {
            return false;
        }
        
        // Check if they're a validator
        self.participants.iter().any(|p| p == voter_did)
    }
    
    // Add a validator to the consensus system
    pub fn add_validator(&mut self, info: ValidatorInfo) -> Result<(), GovernanceError> {
        // Verify validator meets minimum reputation requirements
        if info.reputation < self.rules.min_reputation {
            return Err(GovernanceError::NotEligibleToVote);
        }
        
        // Add to participant list if not already present
        if !self.participants.contains(&info.did) {
            self.participants.push_back(info.did);
        }
        
        Ok(())
    }
    
    // Remove a validator from the consensus system
    pub fn remove_validator(&mut self, did: &str) -> Result<(), GovernanceError> {
        // Find and remove from participant list
        if let Some(index) = self.participants.iter().position(|p| p == did) {
            self.participants.remove(index);
            Ok(())
        } else {
            Err(GovernanceError::ProposalNotFound)
        }
    }
    
    // Check proposal status and update if necessary
    pub fn check_proposal_status(&mut self, proposal_id: &str) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
            
        // Count votes
        let mut approve_votes = 0;
        let mut reject_votes = 0;
        
        for vote in &proposal.votes {
            if vote.approve {
                approve_votes += 1;
            } else {
                reject_votes += 1;
            }
        }
        
        // Check if we have enough votes for a decision
        let total_participants = self.participants.len();
        let quorum_threshold = (total_participants * self.rules.quorum_percentage as usize) / 100;
        
        if approve_votes + reject_votes < quorum_threshold {
            // Not enough votes yet
            proposal.status = ProposalStatus::Pending;
            return Ok(VoteStatus::Pending);
        }
        
        // We have enough votes to make a decision
        if approve_votes > reject_votes {
            proposal.status = ProposalStatus::Approved;
            Ok(VoteStatus::Accepted)
        } else {
            proposal.status = ProposalStatus::Rejected;
            Ok(VoteStatus::Rejected)
        }
    }
    
    // Submit a new proposal
    pub fn submit_proposal(&mut self, proposal_type: ProposalType, submitter: String) -> Result<String, GovernanceError> {
        // Check if submitter is eligible
        if !self.is_eligible_voter(&submitter) {
            return Err(GovernanceError::NotEligibleToVote);
        }
        
        // Generate proposal ID
        let proposal_id = format!("prop_{}", uuid::Uuid::new_v4());
        
        // Create new proposal
        let proposal = Proposal {
            proposal_id: proposal_id.clone(),
            proposal_type,
            votes: HashSet::new(),
            status: ProposalStatus::Pending,
            created_at: std::time::SystemTime::now(),
        };
        
        // Store proposal
        self.active_proposals.insert(proposal_id.clone(), proposal);
        
        Ok(proposal_id)
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) {
        // Start the consensus process
        // In a real implementation, this would initiate validator rounds
        // and transaction processing
        log::info!("Starting Proof of Cooperation consensus engine");
    }

    async fn stop(&self) {
        // Stop the consensus process
        log::info!("Stopping Proof of Cooperation consensus engine");
    }

    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(&vote.proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
        
        if !self.is_eligible_voter(&vote.voter) {
            return Err(GovernanceError::NotEligibleToVote);
        }

        proposal.votes.insert(vote);
        self.check_proposal_status(&proposal.proposal_id)
    }

    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError> {
        let proposal = self.active_proposals.remove(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;

        match proposal.proposal_type {
            ProposalType::AddValidator(info) => self.add_validator(info),
            ProposalType::RemoveValidator(did) => self.remove_validator(&did),
            ProposalType::UpdateRules(rules) => {
                self.rules = rules;
                Ok(())
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: std::collections::HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

#[derive(Serialize, Deserialize)]
struct FederationTerms {
    minimum_reputation: i64,
    resource_sharing_policies: String,
    governance_rules: String,
    duration: String,
}

#[derive(Serialize, Deserialize)]
enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}
```

===================
File: ./crates/icn-core/src/lib.rs
Size: 609 bytes
===================
```rs
// Module declarations
pub mod blockchain;
pub mod core;
pub mod db;
pub mod identity;
pub mod reputation;
pub mod storage;
pub mod vm;
pub mod networking;
pub mod models;
pub mod telemetry;
pub mod verifiable_credentials;
pub mod zk_snarks;

// Re-export main interfaces
pub use self::{
    storage::StorageInterface,
    networking::NetworkInterface,
    identity::IdentityInterface,
    reputation::ReputationInterface,
    telemetry::TelemetryManager,
    models::{ResourceAllocationSystem, FederationManager},
    vm::runtime::RuntimeManager,
};
pub use icn_types::RuntimeInterface;

pub mod governance;
```

===================
File: ./crates/icn-core/src/storage/mod.rs
Size: 2953 bytes
===================
```rs
use async_trait::async_trait;
use icn_types::{Block, Transaction, StorageError};
use std::collections::HashMap;
use std::sync::RwLock;

#[async_trait]
pub trait StorageInterface: Send + Sync {
    async fn store_block(&self, block: &Block) -> Result<(), StorageError>;
    async fn get_block(&self, block_id: &str) -> Result<Block, StorageError>;
    async fn store_transaction(&self, transaction: &Transaction) -> Result<(), StorageError>;
    async fn get_transaction(&self, transaction_id: &str) -> Result<Transaction, StorageError>;
}

// Helper function instead of implementing on StorageError directly
fn create_db_error(msg: impl Into<String>) -> StorageError {
    StorageError::DatabaseError(msg.into())
}

pub struct MemoryStorage {
    blocks: RwLock<HashMap<String, Block>>,
    transactions: RwLock<HashMap<String, Transaction>>,
}

impl MemoryStorage {
    pub fn new() -> Self {
        Self {
            blocks: RwLock::new(HashMap::new()),
            transactions: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl StorageInterface for MemoryStorage {
    async fn store_block(&self, block: &Block) -> Result<(), StorageError> {
        let mut blocks = self.blocks.write().map_err(|_| create_db_error("Lock error"))?;
        blocks.insert(block.hash.clone(), block.clone());
        Ok(())
    }

    async fn get_block(&self, block_id: &str) -> Result<Block, StorageError> {
        let blocks = self.blocks.read().map_err(|_| create_db_error("Lock error"))?;
        blocks.get(block_id)
            .cloned()
            .ok_or_else(|| StorageError::NotFound("Block not found".into()))
    }

    async fn store_transaction(&self, transaction: &Transaction) -> Result<(), StorageError> {
        let mut transactions = self.transactions.write().map_err(|_| create_db_error("Lock error"))?;
        transactions.insert(transaction.id.clone(), transaction.clone());
        Ok(())
    }

    async fn get_transaction(&self, transaction_id: &str) -> Result<Transaction, StorageError> {
        let transactions = self.transactions.read().map_err(|_| create_db_error("Lock error"))?;
        transactions.get(transaction_id)
            .cloned()
            .ok_or_else(|| StorageError::NotFound("Transaction not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_memory_storage() {
        let storage = MemoryStorage::new();
        
        let block = Block::default(); // Assuming Block has Default implementation
        storage.store_block(&block).await.unwrap();
        let retrieved = storage.get_block(&block.hash).await.unwrap();
        assert_eq!(block.hash, retrieved.hash);

        let tx = Transaction::default(); // Assuming Transaction has Default implementation
        storage.store_transaction(&tx).await.unwrap();
        let retrieved = storage.get_transaction(&tx.id).await.unwrap();
        assert_eq!(tx.id, retrieved.id);
    }
}
```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 5761 bytes
===================
```rs
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn_types::Algorithm;
use kyber::keypair as kyber_keypair;
use kyber::encapsulate as kyber_encapsulate;
use kyber::decapsulate as kyber_decapsulate;
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;

pub enum Algorithm {
    Secp256k1,
    RSA,
    ECDSA,
    Kyber,
    Dilithium,
    Falcon,
}

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
}

impl KeyPair {
    pub fn generate(algorithm: Algorithm) -> Self {
        match algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let (private_key, public_key) = secp.generate_keypair(&mut rand::thread_rng());
                KeyPair {
                    public_key: public_key.serialize().to_vec(),
                    private_key: private_key[..].to_vec(),
                    algorithm,
                }
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::new(&mut rand::thread_rng(), 2048).expect("failed to generate a key");
                let public_key = RSAPublicKey::from(&private_key);
                KeyPair {
                    public_key: public_key.to_pkcs1().expect("failed to encode public key"),
                    private_key: private_key.to_pkcs1().expect("failed to encode private key"),
                    algorithm,
                }
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::random(&mut rand::thread_rng());
                let verifying_key = VerifyingKey::from(&signing_key);
                KeyPair {
                    public_key: verifying_key.to_bytes().to_vec(),
                    private_key: signing_key.to_bytes().to_vec(),
                    algorithm,
                }
            },
            Algorithm::Kyber => {
                let (public_key, private_key) = kyber_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Dilithium => {
                let (public_key, private_key) = dilithium_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Falcon => {
                let (public_key, private_key) = falcon_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
        }
    }

    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let private_key = SecretKey::from_slice(&self.private_key).expect("32 bytes");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                secp.sign(&message, &private_key).serialize_compact().to_vec()
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::from_pkcs1(&self.private_key).expect("failed to decode private key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                private_key.sign(padding, &Sha256::digest(message)).expect("failed to sign message")
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::from_bytes(&self.private_key).expect("failed to decode private key");
                signing_key.sign(message).to_bytes().to_vec()
            },
            Algorithm::Dilithium => {
                dilithium_sign(&self.private_key, message)
            },
            Algorithm::Falcon => {
                falcon_sign(&self.private_key, message)
            },
            _ => vec![],
        }
    }

    pub fn verify(&self, message: &[u8], signature: &[u8]) -> bool {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let public_key = PublicKey::from_slice(&self.public_key).expect("invalid public key");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                let signature = Signature::from_compact(signature).expect("invalid signature");
                secp.verify(&message, &signature, &public_key).is_ok()
            },
            Algorithm::RSA => {
                let public_key = RSAPublicKey::from_pkcs1(&self.public_key).expect("failed to decode public key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                public_key.verify(padding, &Sha256::digest(message), signature).is_ok()
            },
            Algorithm::ECDSA => {
                let verifying_key = VerifyingKey::from_bytes(&self.public_key).expect("failed to decode public key");
                verifying_key.verify(message, signature).is_ok()
            },
            Algorithm::Dilithium => {
                dilithium_verify(&self.public_key, message, signature)
            },
            Algorithm::Falcon => {
                falcon_verify(&self.public_key, message, signature)
            },
            _ => false,
        }
    }
}

pub fn hash(data: &[u8]) -> Vec<u8> {
    Sha256::digest(data).to_vec()
}
```

===================
File: ./crates/icn-dsl/src/lib.rs
Size: 5568 bytes
===================
```rs
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, multispace0, multispace1},
    combinator::{map, opt},
    multi::{many0, many1},
    sequence::{delimited, preceded, terminated, tuple},
    IResult,
};

#[derive(Debug, Clone)]
pub struct CoopLangAST {
    pub governance: Option<GovernanceNode>,
    pub reputation: Option<ReputationNode>,
    pub marketplace: Option<MarketplaceNode>,
    pub federation: Option<FederationNode>,
    pub validation: Option<ValidationNode>,
    pub logging: Option<LoggingNode>,
}

#[derive(Debug, Clone)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
    pub resource_checks: Option<ResourceChecks>,
    pub custom_merge: Option<CustomMerge>,
}

#[derive(Debug, Clone)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

#[derive(Debug, Clone)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transition: Option<String>,
}

#[derive(Debug, Clone)]
pub struct CustomMerge {
    pub strategy: String,
    pub handlers: Vec<ConflictHandler>,
}

#[derive(Debug, Clone)]
pub struct ConflictHandler {
    pub field_path: String,
    pub resolution_type: String,
}

// Parser implementation
impl CoopLangAST {
    pub fn parse(input: &str) -> IResult<&str, Self> {
        let (input, _) = multispace0(input)?;
        let (input, governance) = opt(Self::parse_governance_section)(input)?;
        let (input, reputation) = opt(Self::parse_reputation_section)(input)?;
        let (input, marketplace) = opt(Self::parse_marketplace_section)(input)?;
        let (input, federation) = opt(Self::parse_federation_section)(input)?;
        let (input, validation) = opt(Self::parse_validation_section)(input)?;
        let (input, logging) = opt(Self::parse_logging_section)(input)?;
        
        Ok((input, CoopLangAST {
            governance,
            reputation,
            marketplace,
            federation,
            validation,
            logging,
        }))
    }

    fn parse_validation_section(input: &str) -> IResult<&str, ValidationNode> {
        let (input, _) = tag("validation:")(input)?;
        let (input, _) = multispace1(input)?;
        
        let (input, pre_checks) = Self::parse_checks("pre_checks:")(input)?;
        let (input, post_checks) = Self::parse_checks("post_checks:")(input)?;
        let (input, state_validation) = opt(Self::parse_state_validation)(input)?;
        let (input, resource_checks) = opt(Self::parse_resource_checks)(input)?;
        let (input, custom_merge) = opt(Self::parse_custom_merge)(input)?;

        Ok((input, ValidationNode {
            pre_checks,
            post_checks,
            state_validation,
            resource_checks,
            custom_merge,
        }))
    }

    fn parse_checks(label: &'static str) -> impl Fn(&str) -> IResult<&str, Vec<Check>> {
        move |input: &str| {
            let (input, _) = tag(label)(input)?;
            let (input, _) = multispace1(input)?;
            many0(Self::parse_check)(input)
        }
    }

    fn parse_check(input: &str) -> IResult<&str, Check> {
        let (input, _) = char('-')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, condition) = take_while1(|c| c != ':')(input)?;
        let (input, _) = char(':')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, action) = take_while1(|c| c != '\n')(input)?;
        let (input, _) = multispace0(input)?;

        Ok((input, Check {
            condition: condition.trim().to_string(),
            action: action.trim().to_string(),
        }))
    }

    // Add other section parsers similarly...
}

// Bytecode generation
pub fn compile_to_icvm(ast: &CoopLangAST) -> Vec<u8> {
    let mut bytecode = Vec::new();

    // Header
    bytecode.extend_from_slice(&[0x49, 0x43, 0x56, 0x4D]); // "ICVM" magic bytes
    bytecode.push(0x01); // Version

    // Compile validation rules
    if let Some(validation) = &ast.validation {
        bytecode.push(0x01); // Validation section marker
        
        // Pre-checks
        bytecode.push(validation.pre_checks.len() as u8);
        for check in &validation.pre_checks {
            compile_check(&mut bytecode, check);
        }

        // Post-checks
        bytecode.push(validation.post_checks.len() as u8);
        for check in &validation.post_checks {
            compile_check(&mut bytecode, check);
        }

        // State validation
        if let Some(state_validation) = &validation.state_validation {
            bytecode.push(0x01);
            compile_state_validation(&mut bytecode, state_validation);
        } else {
            bytecode.push(0x00);
        }
    }

    // Compile other sections similarly...

    bytecode
}

fn compile_check(bytecode: &mut Vec<u8>, check: &Check) {
    // Convert check condition to bytecode operations
    bytecode.extend_from_slice(check.condition.as_bytes());
    bytecode.push(0x00); // Null terminator
    bytecode.extend_from_slice(check.action.as_bytes());
    bytecode.push(0x00); // Null terminator
}

fn compile_state_validation(bytecode: &mut Vec<u8>, validation: &StateValidation) {
    if let Some(current) = &validation.current {
        bytecode.push(0x01);
        bytecode.extend_from_slice(current.as_bytes());
        bytecode.push(0x00);
    } else {
        bytecode.push(0x00);
    }
    // Similarly for expected and transition...
}
```

===================
File: ./crates/icn-federation/src/lib.rs
Size: 43020 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_types::{Block, Transaction};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_zkp::RollupBatch;
use thiserror::Error;
use icn_networking::p2p::{P2PManager, FederationEvent}; // Import P2PManager and FederationEvent
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::time::{SystemTime, Duration};

// Add SDP support
use icn_p2p::sdp::{SDPManager, SDPPacket, SDPHeader, PublicKey};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub federation_type: FederationType,
    pub members: HashMap<String, MemberStatus>, // DID -> status
    pub member_roles: HashMap<String, MemberRole>, // DID -> role
    pub terms: FederationTerms,
    pub resources: HashMap<String, ResourcePool>,
    pub proposals: Vec<FederationProposal>, // Add proposals field
    pub created_at: u64,
    pub status: FederationStatus,
    pub disputes: HashMap<String, FederationDispute>, // Add disputes field
    pub cross_federation_disputes: HashMap<String, Vec<FederationDispute>>,
    pub audit_log: Vec<AuditEntry>,
    pub p2p_manager: Arc<tokio::sync::Mutex<P2PManager>>, // Changed to tokio::sync::Mutex
    // Add secure communication fields
    pub sdp_peers: HashMap<String, Vec<String>>, // federation_id -> [peer_addresses]
    pub federation_public_keys: HashMap<String, String>, // federation_id -> public_key (base58 encoded)
}

// Add an SDPConfig struct to handle SDP configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SDPConfig {
    pub bind_address: String,
    pub enable_multipath: bool,
    pub enable_onion_routing: bool,
    pub message_priority: HashMap<String, u8>, // message_type -> priority
}

impl Default for SDPConfig {
    fn default() -> Self {
        let mut message_priority = HashMap::new();
        message_priority.insert("governance_vote".to_string(), 8);
        message_priority.insert("dispute_resolution".to_string(), 9);
        message_priority.insert("resource_allocation".to_string(), 6);
        message_priority.insert("member_update".to_string(), 5);
        
        Self {
            bind_address: "0.0.0.0:0".to_string(), // Random port by default
            enable_multipath: true,
            enable_onion_routing: false, // Optional advanced feature
            message_priority,
        }
    }
}

// Add a struct for federation manager with SDP support
pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
    // Add SDP manager
    sdp_manager: Option<Arc<RwLock<SDPManager>>>,
    sdp_config: SDPConfig,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
            sdp_manager: None,
            sdp_config: SDPConfig::default(),
        }
    }

    // Initialize SDP for secure federation communications
    pub async fn init_sdp(&mut self, config: SDPConfig) -> Result<(), FederationError> {
        match SDPManager::new(&config.bind_address) {
            Ok(manager) => {
                self.sdp_manager = Some(Arc::new(RwLock::new(manager)));
                self.sdp_config = config;
                
                // Start receiver for handling incoming messages
                self.start_sdp_receiver().await?;
                
                Ok(())
            },
            Err(e) => Err(FederationError::CommunicationError(format!("Failed to initialize SDP: {}", e))),
        }
    }

    // Start SDP receiver to handle incoming messages
    async fn start_sdp_receiver(&self) -> Result<(), FederationError> {
        if let Some(sdp) = &self.sdp_manager {
            let sdp_clone = sdp.clone();
            let federations_clone = self.federations.clone();
            
            let handler = move |data: Vec<u8>, src| {
                let federations = federations_clone.clone();
                
                tokio::spawn(async move {
                    // Handle incoming SDP messages
                    if let Ok(message) = serde_json::from_slice::<FederationMessage>(&data) {
                        // Process message based on type
                        match message.message_type {
                            FederationMessageType::ProposalSubmission => {
                                if let Ok(proposal) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        // Add signature verification here
                                        let _ = federation.submit_proposal(proposal);
                                    }
                                }
                            },
                            FederationMessageType::Vote => {
                                if let Ok(vote) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.vote(vote);
                                    }
                                }
                            },
                            FederationMessageType::DisputeInitiation => {
                                if let Ok(dispute) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.submit_dissolution_dispute(dispute);
                                    }
                                }
                            },
                            FederationMessageType::ResourceAllocation => {
                                // Handle resource allocation messages
                            },
                            FederationMessageType::MembershipUpdate => {
                                // Handle membership updates
                            },
                        }
                    }
                });
            };
            
            sdp_clone.lock().await.start_receiver(handler).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to start SDP receiver: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    // Send a federation message via SDP
    pub async fn send_federation_message(
        &self,
        source_federation: &str,
        target_federation: &str,
        message_type: FederationMessageType,
        payload: serde_json::Value,
        signature: &str,
    ) -> Result<(), FederationError> {
        let federations = self.federations.read().await;
        
        let source_fed = federations.get(source_federation)
            .ok_or(FederationError::FederationNotFound(source_federation.to_string()))?;
            
        let target_fed = federations.get(target_federation)
            .ok_or(FederationError::FederationNotFound(target_federation.to_string()))?;
            
        // Check if we have SDP peer info for the target
        if !source_fed.sdp_peers.contains_key(target_federation) {
            return Err(FederationError::CommunicationError(
                format!("No SDP routing information for federation {}", target_federation)
            ));
        }
        
        // Create federation message
        let message = FederationMessage {
            source_federation: source_federation.to_string(),
            target_federation: target_federation.to_string(),
            message_type,
            payload,
            timestamp: SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            signature: signature.to_string(),
        };
        
        // Serialize message
        let serialized = serde_json::to_vec(&message)
            .map_err(|e| FederationError::CommunicationError(format!("Serialization error: {}", e)))?;
            
        // Get message priority
        let priority = self.sdp_config.message_priority
            .get(message.message_type.to_string().as_str())
            .cloned()
            .unwrap_or(5); // Default priority
            
        if let Some(sdp_manager) = &self.sdp_manager {
            let manager = sdp_manager.lock().await;
            manager.send_message(target_federation, &serialized, priority).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to send SDP message: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
            // Initialize SDP communication fields
            sdp_peers: HashMap::new(),
            federation_public_keys: HashMap::new(),
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }

        // Add SDP peer information if available
        if let Some(sdp) = &self.sdp_manager {
            let manager = sdp.lock().await;
            let public_key = manager.keypair.1;
            
            // Update the federation with this node's SDP information
            let mut federations = self.federations.write().await;
            if let Some(federation) = federations.get_mut(federation_id) {
                // Add public key in base58 encoding for interoperability
                federation.federation_public_keys.insert(
                    member_did.to_string(),
                    bs58::encode(public_key.as_bytes()).into_string()
                );
            }
        }
        
        Ok(())
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

// Add FederationMessage struct for secure communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMessage {
    pub source_federation: String,
    pub target_federation: String,
    pub message_type: FederationMessageType,
    pub payload: serde_json::Value,
    pub timestamp: u64,
    pub signature: String,
}

// Define message types for federation communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationMessageType {
    ProposalSubmission,
    Vote,
    DisputeInitiation,
    ResourceAllocation,
    MembershipUpdate,
}

impl ToString for FederationMessageType {
    fn to_string(&self) -> String {
        match self {
            FederationMessageType::ProposalSubmission => "governance_proposal".to_string(),
            FederationMessageType::Vote => "governance_vote".to_string(),
            FederationMessageType::DisputeInitiation => "dispute_resolution".to_string(),
            FederationMessageType::ResourceAllocation => "resource_allocation".to_string(),
            FederationMessageType::MembershipUpdate => "member_update".to_string(),
        }
    }
}

impl Federation {
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), FederationError> {
        if self.members.contains_key(&did) {
            return Err(FederationError::AlreadyMember(did));
        }

        // Verify member meets minimum reputation requirements
        if !self.verify_member_eligibility(&did) {
            return Err(FederationError::InsufficientReputation(
                "Member does not meet minimum reputation requirements".to_string(),
            ));
        }

        self.members.insert(did, MemberStatus::Active);
        Ok(())
    }

    pub fn remove_member(&mut self, did: &str) -> Result<(), FederationError> {
        if !self.members.contains_key(did) {
            return Err(FederationError::MemberNotFound(did.to_string()));
        }

        self.members.remove(did);
        Ok(())
    }

    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.members.get(did)
    }

    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), FederationError> {
        if let Some(member_status) = self.members.get_mut(did) {
            *member_status = status;
            Ok(())
        } else {
            Err(FederationError::MemberNotFound(did.to_string()))
        }
    }

    pub fn get_active_members(&self) -> Vec<String> {
        self.members
            .iter()
            .filter(|(_, status)| matches!(status, MemberStatus::Active))
            .map(|(did, _)| did.clone())
            .collect()
    }

    pub fn verify_member_eligibility(&self, did: &str) -> bool {
        // This would integrate with the reputation system in practice
        true // Simplified for example
    }

    pub fn submit_proposal(&mut self, proposal: FederationProposal) -> Result<(), FederationError> {
        // Validate proposal
        self.validate_proposal(&proposal)?;

        // Set proposal voting period
        let mut proposal = proposal;
        proposal.voting_ends_at = chrono::Utc::now().timestamp() as u64 + 
            (self.terms.governance_rules.max_voting_period_hours * 3600);

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote(&mut self, vote: Vote) -> Result<(), FederationError> {
        // Validate vote
        self.validate_vote(&vote)?;

        // Get proposal
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Record vote
        proposal.votes.insert(vote.voter, vote.approve);

        // Check if voting period ended and finalize if needed
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            proposal.status = self.finalize_proposal(&proposal.id)?;
        }

        Ok(())
    }

    pub fn validate_proposal(&self, proposal: &FederationProposal) -> Result<(), FederationError> {
        // Check if proposal type is allowed
        if !self.terms.governance_rules.allowed_proposal_types.contains(&proposal.proposal_type.to_string()) {
            return Err(FederationError::InvalidProposalType(proposal.proposal_type.to_string()));
        }

        // Validate proposer has sufficient reputation
        if !self.verify_member_eligibility(&proposal.proposer) {
            return Err(FederationError::InsufficientReputation(
                "Proposer does not meet minimum reputation requirements".to_string()
            ));
        }

        Ok(())
    }

    pub fn validate_vote(&self, vote: &Vote) -> Result<(), FederationError> {
        // Check if voter is a member
        if !self.members.contains_key(&vote.voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote".to_string(), did: vote.voter.clone() });
        }

        // Check if proposal exists
        let proposal = self.proposals.iter()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Check if voting period is still open
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            return Err(FederationError::VotingPeriodEnded(vote.proposal_id.clone()));
        }

        // Check for veto rights
        if let Some(member_role) = self.member_roles.get(&vote.voter) {
            if let Some(veto_actions) = self.terms.governance_rules.veto_rights.get(&member_role.to_string()) {
                if veto_actions.contains(&proposal.proposal_type.to_string()) && !vote.approve {
                    // Record veto
                    return Ok(());
                }
            }
        }

        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<ProposalStatus, FederationError> {
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == proposal_id)
            .ok_or(FederationError::ProposalNotFound(proposal_id.to_string()))?;

        // Create vote batch for on-chain processing
        let batch = RollupBatch {
            proposal_id: proposal_id.to_string(),
            votes: proposal.votes.iter()
                .map(|(voter, approve)| Vote { voter: voter.clone(), approve: *approve, signature: String::new() }) // Added signature field
                .collect(),
            rollup_root: [0u8; 32], // Computed by ZK prover
            proof: Vec::new(), // Generated by ZK prover
        };

        // Submit batch to chain
        self.contract.submit_vote_batch(batch)?;

        // Execute proposal on-chain
        let approved = self.contract.execute_proposal(proposal_id)?;
        
        proposal.status = if approved {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }

    pub fn calculate_asset_distribution(&self) -> HashMap<String, AssetAllocation> {
        let mut distributions = HashMap::new();
        // Implement fair asset distribution calculation
        distributions
    }

    pub fn settle_outstanding_debts(&self) -> Vec<DebtSettlement> {
        let mut settlements = Vec::new();
        // Implement debt settlement calculation
        settlements
    }

    pub fn reassign_members(&self) -> Vec<MemberReassignment> {
        let mut reassignments = Vec::new();
        // Implement member reassignment logic
        reassignments
    }

    pub fn calculate_vote_weight(&self, cooperative_id: &str, proposal: &FederationProposal) -> f64 {
        let voting_model = match proposal.proposal_type {
            ProposalType::GovernanceChange(_) | ProposalType::PolicyUpdate(_) => 
                &self.terms.governance_rules.governance_voting_model,
            ProposalType::ResourceAllocation(_) =>
                &self.terms.governance_rules.resource_voting_model,
            _ => &self.terms.governance_rules.default_voting_model,
        };

        voting_model.calculate_voting_power(self, cooperative_id)
    }

    pub fn get_cooperative_weight(&self, cooperative_id: &str) -> f64 {
        let total_members: u32 = self.members.values().map(|m| m.member_count).sum();
        let coop_members = self.members.get(cooperative_id)
            .map(|m| m.member_count)
            .unwrap_or(0);
        
        coop_members as f64 / total_members as f64
    }

    pub fn initiate_dissolution(&mut self, initiator: String, reason: String) -> Result<DissolutionProtocol, FederationError> {
        let protocol = DissolutionProtocol {
            federation_id: self.id.clone(),
            initiated_by: initiator,
            reason: DissolutionReason::Voluntary,
            status: DissolutionStatus::Initiated,
            asset_distribution: HashMap::new(),
            debt_settlements: Vec::new(),
            member_reassignments: Vec::new(),
            dispute_period_ends: SystemTime::now() + Duration::from_secs(7 * 24 * 60 * 60), // 7 days
        };

        self.status = FederationStatus::DisputePeriod;
        Ok(protocol)
    }

    pub fn submit_dissolution_dispute(&mut self, dispute: FederationDispute) -> Result<(), FederationError> {
        if self.status != FederationStatus::DisputePeriod {
            return Err(FederationError::InvalidStatusTransition { from: "DisputePeriod".to_string(), to: self.status.to_string() });
        }

        if !self.members.contains_key(&dispute.initiator) {
            return Err(FederationError::UnauthorizedAction { action: "submit_dissolution_dispute".to_string(), did: dispute.initiator.clone() });
        }

        self.disputes.insert(dispute.id.clone(), dispute);
        self.status = FederationStatus::DisputeResolution;
        Ok(())
    }

    pub fn vote_on_dispute(&mut self, dispute_id: &str, voter: String, support: bool) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        if !self.members.contains_key(&voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote_on_dispute".to_string(), did: voter.clone() });
        }

        dispute.supporting_votes.insert(voter, support);

        // Check if we have enough votes to resolve the dispute
        let total_votes = dispute.supporting_votes.len();
        let supporting_votes = dispute.supporting_votes.values().filter(|&&v| v).count();
        let required_votes = (self.members.len() * 2) / 3; // 2/3 majority

        if total_votes >= required_votes {
            if supporting_votes > total_votes / 2 {
                dispute.status = DisputeStatus::Resolved;
                self.status = FederationStatus::Active;
            } else {
                dispute.status = DisputeStatus::Rejected;
                self.status = FederationStatus::Dissolved;
            }
        }

        Ok(())
    }

    pub fn resolve_dispute(&mut self, dispute_id: &str, resolution: DisputeResolution) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        dispute.resolution = Some(resolution);
        dispute.status = DisputeStatus::Resolved;

        // If all disputes are resolved, proceed with dissolution
        if self.disputes.values().all(|d| d.status == DisputeStatus::Resolved || d.status == DisputeStatus::Rejected) {
            let any_upheld = self.disputes.values().any(|d| d.status == DisputeStatus::Resolved);
            self.status = if any_upheld {
                FederationStatus::Active
            } else {
                FederationStatus::Dissolved;
            };
        }

        Ok(())
    }

    pub async fn initiate_cross_federation_dispute(
        &mut self,
        target_federation: &str,
        dispute: FederationDispute
    ) -> Result<(), FederationError> {
        // Verify both federations exist and have sufficient reputation
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        let disputes = self.cross_federation_disputes
            .entry(target_federation.to_string())
            .or_insert_with(Vec::new);
        
        disputes.push(dispute);
        
        // Log dispute for audit
        self.audit_log.push(AuditEntry {
            action: "cross_federation_dispute".into(),
            target_federation: Some(target_federation.to_string()),
            timestamp: chrono::Utc::now(),
        });

        Ok(())
    }

    pub async fn submit_cross_federation_proposal(
        &mut self,
        target_federation: &str,
        proposal: CrossFederationProposal
    ) -> Result<(), FederationError> {
        // Verify both federations meet minimum reputation requirements
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        // Create batch for cross-federation proposals
        let mut batch = ProposalBatch::new();
        batch.add_proposal(proposal.clone());
        
        // Submit to cross-federation coordinator
        self.coordinator.submit_batch(batch).await?;
        
        // Record proposal for local tracking
        self.cross_federation_proposals.insert(proposal.id.clone(), proposal);
        
        Ok(())
    }

    pub fn batch_process_proposals(&mut self, proposals: Vec<FederationProposal>) -> Result<(), FederationError> {
        let mut batch = ProposalBatch::new();
        
        for proposal in proposals {
            self.validate_proposal(&proposal)?;
            batch.add_proposal(proposal);
        }
        
        // Process batch through ZK rollup
        let rollup = self.create_proposal_rollup(batch);
        self.contract.submit_rollup(rollup)?;
        
        Ok(())
    }

    pub async fn publish_event(&self, event: FederationEvent) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.publish(event).await.map_err(|e| FederationError::EventPublishError(e.to_string()))
    }

    pub async fn subscribe_to_events(&self) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.subscribe().await.map_err(|e| FederationError::EventSubscribeError(e.to_string()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourcePool {
    pub resource_type: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub contributors: HashMap<String, u64>, // DID -> amount contributed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationProposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub description: String,
    pub votes: HashMap<String, bool>, // DID -> vote
    pub status: ProposalStatus,
    pub created_at: u64,
    pub voting_ends_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    AddMember(String),
    RemoveMember(String),
    UpdateTerms(FederationTerms),
    AllocateResources(ResourceAllocation),
    UpdatePolicy(String),
}

impl std::fmt::Display for ProposalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProposalType::AddMember(_) => write!(f, "AddMember"),
            ProposalType::RemoveMember(_) => write!(f, "RemoveMember"),
            ProposalType::UpdateTerms(_) => write!(f, "UpdateTerms"),
            ProposalType::AllocateResources(_) => write!(f, "AllocateResources"),
            ProposalType::UpdatePolicy(_) => write!(f, "UpdatePolicy"),
        }
    }
}

pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

#[async_trait]
pub trait ResourceManager: Send + Sync {
    async fn allocate_resources(&self, allocation: ResourceAllocation) -> Result<(), String>;
    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String>;
}

pub trait FederationDissolution {
    fn initiate_dissolution(&mut self, initiator: &str, reason: DissolutionReason) -> Result<DissolutionProtocol, Error>;
    fn process_dissolution(&mut self, protocol: &DissolutionProtocol) -> Result<DissolutionStatus, Error>;
    fn cancel_dissolution(&mut self, protocol_id: &str) -> Result<(), Error>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: GovernanceRules,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceRules {
    pub min_votes_required: u32,
    pub approval_threshold_percent: u32,
    pub min_voting_period_hours: u32,
    pub max_voting_period_hours: u32,
    pub allowed_proposal_types: Vec<String>,
    pub veto_rights: HashMap<String, Vec<String>>, // role -> action types that can be vetoed
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FederationStatus {
    Active,
    Suspended,
    Dissolved,
    DisputePeriod,
    DisputeResolution,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Expired,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

impl std::fmt::Display for MemberRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MemberRole::Admin => write!(f, "Admin"),
            MemberRole::Member => write!(f, "Member"),
            MemberRole::Observer => write!(f, "Observer"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemberStatus {
    Active,
    Inactive,
    Suspended,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String, // Added required field
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationDispute {
    pub id: String,
    pub federation_id: String,
    pub initiator: String,
    pub reason: String,
    pub evidence: Option<String>,
    pub supporting_votes: HashMap<String, bool>,
    pub created_at: u64,
    pub status: DisputeStatus,
    pub resolution: Option<DisputeResolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub decision: String,
    pub rationale: String,
    pub resolved_at: u64,
    pub resolver: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DisputeStatus {
    Pending,
    Resolved,
    Rejected,
}

impl std::fmt::Display for DisputeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisputeStatus::Pending => write!(f, "Pending"),
            DisputeStatus::Resolved => write!(f, "Resolved"),
            DisputeStatus::Rejected => write!(f, "Rejected"),
        }
    }
}

#[derive(Error, Debug)]
pub enum FederationError {
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Already a member: {0}")]
    AlreadyMember(String),
    
    #[error("Invalid commitment: {0}")]
    InvalidCommitment(String),
    
    #[error("Insufficient resources: {resource_type}")]
    InsufficientResources { resource_type: String },
    
    #[error("Unauthorized action: {action} by {did}")]
    UnauthorizedAction { action: String, did: String },
    
    #[error("Member not found: {0}")]
    MemberNotFound(String),
    
    #[error("Invalid status transition from {from} to {to}")]
    InvalidStatusTransition { from: String, to: String },
    
    #[error("Insufficient permissions: {0}")]
    InsufficientPermissions(String),
    
    #[error("Invalid proposal type: {0}")] 
    InvalidProposalType(String),
    
    #[error("Voting period ended for proposal {0}")]
    VotingPeriodEnded(String),
    
    #[error("Proposal not found: {0}")]
    ProposalNotFound(String),
    
    #[error("Insufficient reputation: {0}")]
    InsufficientReputation(String),
    
    #[error("Dispute not found: {0}")]
    DisputeNotFound(String),
    
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    
    #[error("Consensus error: {0}")]
    ConsensusError(#[from] ConsensusError),
    
    #[error("Event publish error: {0}")]
    EventPublishError(String),
    
    #[error("Event subscribe error: {0}")]
    EventSubscribeError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEntry {
    pub action: String,
    pub target_federation: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossFederationProposal {
    pub id: String,
    pub source_federation: String,
    pub target_federation: String,
    pub proposal_type: CrossFederationProposalType,
    pub terms: CrossFederationTerms,
    pub votes: HashMap<String, bool>,
    pub status: ProposalStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CrossFederationProposalType {
    Merge,
    Alliance,
    ResourceSharing,
    DisputeResolution,
}

#[derive(Debug)]
pub struct BatchProcessor {
    pub coordinator: Arc<tokio::sync::Mutex<ProposalCoordinator>>,
}

#[derive(Debug)]
pub struct ProposalCoordinator {
    // Add fields as needed
}

impl ProposalCoordinator {
    pub async fn submit_batch(&self, batch: ProposalBatch) -> Result<(), FederationError> {
        // Implementation here
        Ok(())
    }
}

#[derive(Debug)]
pub struct ProposalBatch {
    proposals: Vec<FederationProposal>,
}

impl ProposalBatch {
    pub fn new() -> Self {
        Self {
            proposals: Vec::new(),
        }
    }

    pub fn add_proposal(&mut self, proposal: FederationProposal) {
        self.proposals.push(proposal);
    }
}

// Add missing types
#[derive(Debug)]
pub struct StorageError;

#[derive(Debug)]
pub struct ConsensusError;

#[derive(Debug, Clone)]
pub struct AssetAllocation {
    pub asset_type: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct DebtSettlement {
    pub debtor: String,
    pub creditor: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct MemberReassignment {
    pub member_id: String,
    pub new_federation: String,
}

#[derive(Debug, Clone)]
pub struct CrossFederationTerms {
    pub resource_sharing_terms: String,
    pub governance_terms: String,
}

// Federation system for resource sharing and governance across cooperatives
mod federation;
mod resource_sharing;
mod resource_manager;

pub use federation::{
    Federation, 
    FederationError, 
    FederationType, 
    FederationTerms, 
    FederationManager,
    FederationProposal,
    FederationRole,
    FederationMember,
    Vote
};

pub use resource_sharing::{
    ResourceSharingAgreement,
    ResourceAllocation,
    ResourceUsageMetrics,
    SharingAgreementStatus
};

pub use resource_manager::{
    FederationResourceManager,
    ResourceProvider,
    ResourceError
};

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};

/// Federation resource pool that can be shared with other federations
#[derive(Clone, Debug)]
pub struct FederationResourcePool {
    /// ID of the federation that owns this resource pool
    pub federation_id: String,
    
    /// Available resources in this pool
    pub resources: HashMap<String, Resource>,
    
    /// Access control for this resource pool
    pub access_control: FederationAccessControl,
}

/// Access control settings for federation resource pools
#[derive(Clone, Debug)]
pub struct FederationAccessControl {
    /// List of federation IDs allowed to access this pool
    pub allowed_federations: Vec<String>,
    
    /// Minimum reputation required to access resources
    pub min_reputation: i64,
    
    /// Maximum allocation per federation
    pub max_allocation_per_federation: u64,
}

/// A generic resource that can be shared between federations
#[derive(Clone, Debug)]
pub struct Resource {
    /// Unique identifier for this resource
    pub id: String,
    
    /// Type of resource (e.g., "compute", "storage", "bandwidth")
    pub resource_type: String,
    
    /// Total amount of this resource
    pub total_amount: u64,
    
    /// Currently available (unallocated) amount
    pub available_amount: u64,
    
    /// ID of the federation that owns this resource
    pub owner_federation_id: String,
    
    /// Metadata about this resource
    pub metadata: HashMap<String, String>,
}

/// Creates a new resource sharing agreement between federations
/// 
/// # Arguments
/// * `source_federation_id` - ID of the federation providing resources
/// * `target_federation_id` - ID of the federation receiving resources
/// * `resource_type` - Type of resource being shared
/// * `amount` - Amount of resource to share
/// * `duration_seconds` - Optional duration for the agreement
/// * `terms` - Terms of the sharing agreement
/// * `min_reputation_score` - Minimum reputation score required for the target
/// 
/// # Returns
/// Agreement ID if successful, error otherwise
pub async fn create_resource_sharing_agreement(
    federation_resource_manager: &FederationResourceManager,
    source_federation_id: String,
    target_federation_id: String,
    resource_type: String,
    amount: u64,
    duration_seconds: Option<u64>,
    terms: String,
    min_reputation_score: i64,
) -> Result<String, ResourceError> {
    federation_resource_manager.propose_agreement(
        source_federation_id,
        target_federation_id,
        resource_type,
        amount,
        duration_seconds,
        terms,
        min_reputation_score,
    ).await
}
```

===================
File: ./crates/icn-governance/src/lib.rs
Size: 10971 bytes
===================
```rs
use thiserror::Error;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use icn_types::{DecisionType, Federation, ExecutionEvent, EvidenceItem};
use icn_zk::verify_proof; // Import zk-SNARK verification function

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Invalid rollback - proposal is not in pending state")]
    InvalidRollback,
    #[error("Dispute already exists")]
    DisputeExists,
    #[error("Insufficient reputation to dispute")]
    InsufficientReputation,
    #[error("Invalid dispute resolution")]
    InvalidResolution,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub status: ProposalStatus,
    pub created_at: DateTime<Utc>,
    pub votes: HashMap<String, Vote>,
    pub disputes: Vec<Dispute>,
    pub execution_history: Vec<ExecutionEvent>,
    pub phase: ProposalPhase,
    pub required_signers: Vec<String>,
    pub collected_signatures: Vec<String>,
    pub state: ProposalState,
    pub dispute_resolution: Option<DisputeResolution>,
    pub timeout_timestamp: u64,
    pub zk_snark_proof: Option<String>, // Added zk-SNARK proof field
    pub voting_model: VotingModel,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Active,
    Approved,
    Rejected,
    Disputed,
    RolledBack,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalPhase {
    Submission,
    Deliberation { ends_at: DateTime<Utc> },
    Voting { ends_at: DateTime<Utc> },
    Execution,
    Reconsideration { reason: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
    pub reputation: i64,
    pub timestamp: DateTime<Utc>,
    pub voter_id: String,
    pub proposal_id: String,
    pub decision: DecisionType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dispute {
    pub id: String,
    pub proposal_id: String,
    pub disputer: String,
    pub reason: String,
    pub evidence: String,
    pub arbitrator_did: Option<String>,
    pub resolution: Option<Resolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resolution {
    pub decision: DecisionType,
    pub rationale: String,
    pub signatures: Vec<String>, // Requires 75% of arbitrators
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DissolutionProtocol {
    pub federation_id: String,
    pub initiated_by: String,
    pub reason: DissolutionReason,
    pub status: DissolutionStatus,
    pub asset_distribution: HashMap<String, u64>,
    pub debt_settlements: Vec<String>,
    pub member_reassignments: Vec<String>,
    pub dispute_period_ends: std::time::SystemTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionReason {
    Voluntary,
    InactivityThreshold,
    GovernanceFailure,
    ResourceDepletion,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionStatus {
    Initiated,
    UnderReview,
    Approved,
    Rejected,
    Completed,
}

#[derive(Debug)]
pub struct AssetAllocation {
    asset_id: String,
    recipient_id: String,
    allocation_share: f64,
}

#[derive(Debug)]
pub struct DebtSettlement {
    creditor_id: String,
    debtor_id: String,
    amount: f64,
    due_date: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct MemberReassignment {
    member_id: String,
    new_federation_id: Option<String>,
    transition_period: chrono::Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionThresholds {
    pub resource_allocation_threshold: u64,
    pub technical_effort_threshold: u32, // in days
    pub financial_impact_threshold: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationControls {
    pub max_gap_multiplier: f64,
    pub decay_threshold_multiplier: f64,
    pub monthly_decay_rate: f64,
    pub equity_bonus_groups: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VotingModel {
    Equal,
    Proportional { cap_percentage: u8 },
    Hybrid {
        governance_model: Box<VotingModel>,
        resource_model: Box<VotingModel>,
    },
    Simple,
    Weighted { weight_factor: f64 },
    Hybrid { governance_model: f64, resource_model: f64 },
}

impl VotingModel {
    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match self {
            VotingModel::Equal => 1.0,
            VotingModel::Proportional { cap_percentage } => {
                let power = federation.get_cooperative_weight(cooperative_id);
                power.min(*cap_percentage as f64 / 100.0)
            },
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Use different models based on proposal type
                // ...existing code...
            }
            VotingModel::Simple => 1.0,
            VotingModel::Weighted { weight_factor } => {
                // Implement weighted voting calculation
                weight_factor * 1.0
            }
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Implement hybrid voting calculation
                governance_model * 0.5 + resource_model * 0.5
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationManager {
    pub controls: ReputationControls,
    reputation_scores: HashMap<String, f64>,
    last_decay_check: DateTime<Utc>,
}

impl ReputationManager {
    pub fn apply_anti_oppression_mechanisms(&mut self) {
        let avg_reputation = self.calculate_average_reputation();
        
        for score in self.reputation_scores.values_mut() {
            if *score > avg_reputation * self.controls.decay_threshold_multiplier {
                *score *= 1.0 - self.controls.monthly_decay_rate;
            }
        }
    }
    
    pub fn calculate_average_reputation(&self) -> f64 {
        // Implement actual calculation
        0.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalState {
    Draft,
    UnderReview,
    Voting,
    DisputeResolution,
    Finalized,
    TimedOut,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub initiator: String,
    pub reason: String, 
    pub mediators: Vec<String>,
    pub resolution: Option<String>,
    pub votes: HashMap<String, bool>,
    pub evidence: Vec<EvidenceItem>,
    pub id: String,
    pub proposal_id: String,
    pub timestamp: i64,
}

impl Proposal {
    pub fn transition_state(&mut self, new_state: ProposalState) -> Result<(), String> {
        let valid = match (&self.state, &new_state) {
            (ProposalState::Draft, ProposalState::UnderReview) => true,
            (ProposalState::UnderReview, ProposalState::Voting) => true,
            (ProposalState::Voting, ProposalState::DisputeResolution) => true,
            (ProposalState::DisputeResolution, ProposalState::Finalized) => true,
            _ => false,
        };

        if valid {
            self.state = new_state;
            Ok(())
        } else {
            Err("Invalid state transition".to_string())
        }
    }
    
    pub fn initiate_dispute(&mut self, initiator: String, reason: String) -> Result<(), String> {
        if self.state != ProposalState::Voting {
            return Err("Can only initiate dispute during voting phase".to_string());
        }
        
        if let Some(proof) = &self.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        
        self.dispute_resolution = Some(DisputeResolution {
            initiator,
            reason,
            mediators: vec![],
            resolution: None,
            votes: HashMap::new(),
            evidence: vec![],
            id: String::new(),
            proposal_id: String::new(),
            timestamp: 0,
        });
        
        self.transition_state(ProposalState::DisputeResolution)
    }

    pub async fn execute_proposal(&self) -> bool {
        if let Some(proof) = &self.zk_snark_proof {
            if verify_proof(proof) {
                execute_approved_action();
                return true;
            }
        }
        false
    }

    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match &self.voting_model {
            VotingModel::Simple => 1.0,
            VotingModel::Weighted { weight_factor } => {
                // Implement weighted voting calculation
                weight_factor * 1.0
            }
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Implement hybrid voting calculation
                governance_model * 0.5 + resource_model * 0.5
            }
        }
    }

    pub fn validate_vote(&self, vote: &Vote) -> bool {
        if self.state != ProposalState::Voting {
            return false;
        }
        // Add more validation logic
        true
    }
}

fn verify_proof(proof: &str) -> bool {
    // Implement zk-SNARK proof verification logic
    true
}

fn execute_approved_action() {
    // Implement the action to be executed upon proposal approval
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_reputation_decay() {
        let gov = GovernanceService::new(db_pool).await;
        
        // Test normal decay
        let result = gov.apply_decay("did:icn:test", 0.1).await;
        assert!(result.is_ok());
        
        // Test maximum decay limit
        let result = gov.apply_decay("did:icn:test", 0.9).await;
        assert!(result.is_err());
        
        // Test decay exemption
        let result = gov.apply_decay("did:icn:exempt", 0.1).await;
        assert!(result.is_ok());
        assert_eq!(gov.get_reputation("did:icn:exempt").await.unwrap(), 100);
    }

    #[tokio::test]
    async fn test_voting_edge_cases() {
        let gov = GovernanceService::new(db_pool).await;

        // Test vote after period ends
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 0).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", true).await;
        assert!(matches!(result, Err(GovernanceError::VotingPeriodEnded(_))));

        // Test double voting
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 3600).await.unwrap();
        gov.vote(&proposal.id, "did:icn:voter", true).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", false).await;
        assert!(matches!(result, Err(GovernanceError::AlreadyVoted(_))));
    }
}
```

===================
File: ./crates/icn-identity/src/lib.rs
Size: 1952 bytes
===================
```rs
pub mod ledger {
    use crate::VerifiableCredential;
    
    /// Create an identity in the ledger
    pub async fn create_identity_in_ledger(identity: &str, _credential: &VerifiableCredential) -> Result<(), String> {
        println!("Creating identity in ledger: {}", identity);
        Ok(())
    }
    
    /// Get identity from the ledger
    pub async fn get_identity_from_ledger(identity: &str) -> Result<String, String> {
        println!("Getting identity from ledger: {}", identity);
        Ok(identity.to_string())
    }
    
    /// Rotate a key in the ledger
    pub async fn rotate_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Rotating key in ledger: {}", identity);
        Ok(())
    }
    
    /// Revoke a key in the ledger
    pub async fn revoke_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Revoking key in ledger: {}", identity);
        Ok(())
    }
    
    /// Apply reputation decay in the ledger
    pub async fn apply_reputation_decay_in_ledger(did: &str, decay_rate: f64) -> Result<(), String> {
        println!("Applying reputation decay to {}: {}", did, decay_rate);
        Ok(())
    }
    
    /// Handle sybil resistance in the ledger
    pub async fn handle_sybil_resistance_in_ledger(did: &str, reputation_score: i64) -> Result<(), String> {
        println!("Handling sybil resistance for {}: {}", did, reputation_score);
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct VerifiableCredential {
    pub credential_type: String,
    pub issuer_did: String,
    pub subject_did: String,
    pub issuance_date: String,
    pub expiration_date: Option<String>,
    pub credential_status: Option<String>,
    pub credential_schema: Option<String>,
    pub proof: Proof,
}

#[derive(Debug, Clone)]
pub struct Proof {
    pub type_: String,
    pub created: String,
    pub proof_purpose: String,
    pub verification_method: String,
    pub jws: String,
}```

===================
File: ./crates/icn-mutual-credit/src/lib.rs
Size: 2294 bytes
===================
```rs
use std::collections::HashMap;
use chrono::Utc;
use serde::{Serialize, Deserialize};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64,
    pub signature: String,
    pub timestamp: i64,
}

pub struct MutualCreditLedger {
    // Maps member DID to current credit balance.
    pub balances: HashMap<String, i64>,
    // Ordered list of all mutual credit transactions.
    pub history: Vec<MutualCreditTransaction>,
}

impl MutualCreditLedger {
    pub fn new() -> Self {
        Self {
            balances: HashMap::new(),
            history: Vec::new(),
        }
    }

    // Process a new mutual credit transaction.
    pub fn process_transaction(&mut self, tx: MutualCreditTransaction) -> Result<(), String> {
        // Verify sender signature
        if !Self::verify_signature(&tx.sender_did, &tx.signature, tx.amount) {
            return Err("Invalid signature".into());
        }
        // Update sender and receiver balances
        *self.balances.entry(tx.sender_did.clone()).or_insert(0) -= tx.amount;
        *self.balances.entry(tx.receiver_did.clone()).or_insert(0) += tx.amount;
        // Append to history
        self.history.push(tx);
        Ok(())
    }

    // Verify signature using icn-crypto
    fn verify_signature(did: &str, signature: &str, amount: i64) -> bool {
        // Retrieve public key from IdentityService (placeholder)
        let public_key = vec![]; // Replace with actual public key retrieval logic
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        key_pair.verify(amount.to_string().as_bytes(), signature.as_bytes())
    }

    // Get balance summary for a member
    pub fn get_balance(&self, did: &str) -> i64 {
        *self.balances.get(did).unwrap_or(&0)
    }

    // Print simple ledger summary (for logging)
    pub fn print_summary(&self) {
        for (did, balance) in &self.balances {
            println!("Member {}: Balance {}", did, balance);
        }
    }
}
```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 168 bytes
===================
```rs
pub mod websocket;
pub mod protocol;
pub mod networking;
pub mod sdp;

// Re-export necessary types
pub use x25519_dalek::PublicKey;
pub use sdp::SDPManager;

```

===================
File: ./crates/icn-reputation/src/lib.rs
Size: 2471 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use icn_zkp::zk_snark;
use std::sync::Arc;
use async_trait::async_trait;
use icn_types::ReputationError;
use icn_storage::StorageInterface;

#[derive(Debug, Serialize, Deserialize)]
pub struct ReputationScore {
    pub score: i64,
}

impl ReputationScore {
    pub fn generate_proof(&self) -> Vec<u8> {
        // Generate zk-SNARK proof for the reputation score
        zk_snark::generate_proof(self.score)
    }

    pub fn verify_proof(proof: &[u8], expected_score: i64) -> bool {
        // Verify zk-SNARK proof for the reputation score
        zk_snark::verify_proof(proof, expected_score)
    }
}

#[async_trait::async_trait]
pub trait ReputationInterface: Send + Sync {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError>;
    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError>;
    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError>;
}

pub struct ReputationManager {
    store: Arc<dyn StorageInterface>,
}

impl ReputationManager {
    pub fn new(store: Arc<dyn StorageInterface>) -> Self {
        Self { store }
    }
}

#[async_trait::async_trait]
impl ReputationInterface for ReputationManager {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError> {
        let current = self.get_reputation(member_id).await.unwrap_or(0);
        let new_score = current + delta;
        
        self.store.store(&format!("reputation:{}", member_id), &new_score.to_le_bytes())
            .await
            .map_err(|e| ReputationError { message: e.to_string() })
    }

    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError> {
        match self.store.get(&format!("reputation:{}", member_id)).await {
            Ok(bytes) => {
                let score = i64::from_le_bytes(bytes.try_into().map_err(|_| ReputationError {
                    message: "Invalid reputation data format".to_string()
                })?);
                Ok(score)
            }
            Err(_) => Ok(0) // New members start with 0 reputation
        }
    }

    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError> {
        let current = self.get_reputation(member_id).await?;
        Ok(current >= min_required)
    }
}
```

===================
File: ./crates/icn-resource/src/lib.rs
Size: 6916 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_federation::ResourceManager;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub resource_type: String,
    pub owner: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub price_per_unit: f64,
    pub constraints: ResourceConstraints,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceConstraints {
    pub min_reputation: i64,
    pub max_allocation: u64,
    pub time_limit: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationResourcePool {
    pub federation_id: String,
    pub resources: HashMap<String, Resource>,
    pub access_control: FederationAccessControl,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationAccessControl {
    pub allowed_federations: Vec<String>,
    pub min_reputation: i64,
    pub max_allocation_per_federation: u64,
}

pub struct ResourceAllocationSystem {
    resources: Arc<RwLock<HashMap<String, Resource>>>,
    allocations: Arc<RwLock<HashMap<String, Vec<ResourceAllocation>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub allocation_id: String,
    pub resource_id: String,
    pub recipient: String,
    pub amount: u64,
    pub allocated_at: u64,
    pub expires_at: Option<u64>,
}

impl ResourceAllocationSystem {
    pub fn new() -> Self {
        Self {
            resources: Arc::new(RwLock::new(HashMap::new())),
            allocations: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn register_resource(
        &self,
        owner: String,
        resource_type: String,
        amount: u64,
        price: f64,
        constraints: ResourceConstraints,
    ) -> Result<String, ResourceError> {
        let resource_id = format!("res_{}", uuid::Uuid::new_v4());
        let resource = Resource {
            id: resource_id.clone(),
            resource_type,
            owner,
            total_amount: amount,
            available_amount: amount,
            price_per_unit: price,
            constraints,
        };

        let mut resources = self.resources.write().await;
        resources.insert(resource_id.clone(), resource);

        Ok(resource_id)
    }

    pub async fn allocate(
        &self,
        resource_id: &str,
        recipient: String,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        let resource = resources.get_mut(resource_id)
            .ok_or(ResourceError::ResourceNotFound)?;

        if resource.available_amount < amount {
            return Err(ResourceError::InsufficientResources);
        }

        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        let allocation = ResourceAllocation {
            allocation_id: allocation_id.clone(),
            resource_id: resource_id.to_string(),
            recipient,
            amount,
            allocated_at: chrono::Utc::now().timestamp() as u64,
            expires_at: None,
        };

        resource.available_amount -= amount;

        let mut allocations = self.allocations.write().await;
        allocations.entry(resource_id.to_string())
            .or_insert_with(Vec::new)
            .push(allocation);

        Ok(allocation_id)
    }

    pub async fn release(
        &self,
        allocation_id: &str,
    ) -> Result<(), ResourceError> {
        let mut allocations = self.allocations.write().await;
        for (resource_id, resource_allocations) in allocations.iter_mut() {
            if let Some(index) = resource_allocations.iter().position(|alloc| alloc.allocation_id == allocation_id) {
                let allocation = resource_allocations.remove(index);
                let mut resources = self.resources.write().await;
                if let Some(resource) = resources.get_mut(&allocation.resource_id) {
                    resource.available_amount += allocation.amount;
                }
                return Ok(());
            }
        }
        Err(ResourceError::InvalidAllocation)
    }

    pub async fn adjust_price(
        &self,
        resource_id: &str,
        new_price: f64,
    ) -> Result<(), ResourceError> {
        let mut resources = self.resources.write().await;
        if let Some(resource) = resources.get_mut(resource_id) {
            resource.price_per_unit = new_price;
            Ok(())
        } else {
            Err(ResourceError::ResourceNotFound)
        }
    }

    pub async fn create_federation_pool(
        &self,
        federation_id: String,
        access_control: FederationAccessControl,
    ) -> Result<(), ResourceError> {
        let pool = FederationResourcePool {
            federation_id: federation_id.clone(),
            resources: HashMap::new(),
            access_control,
        };
        
        let mut resources = self.resources.write().await;
        resources.insert(federation_id, pool);
        Ok(())
    }

    pub async fn share_with_federation(
        &self,
        source_federation: &str,
        target_federation: &str, 
        resource_id: &str,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        
        // Verify federation access permissions
        let source_pool = resources.get(source_federation)
            .ok_or(ResourceError::ResourceNotFound)?;
            
        if !source_pool.access_control.allowed_federations.contains(&target_federation.to_string()) {
            return Err(ResourceError::UnauthorizedAction);
        }

        // Create allocation record
        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        
        // Allocate resources to target federation
        self.allocate(resource_id, target_federation.to_string(), amount).await?;

        Ok(allocation_id)
    }
}

#[async_trait]
impl ResourceManager for ResourceAllocationSystem {
    async fn allocate_resources(&self, allocation: icn_federation::ResourceAllocation) -> Result<(), String> {
        self.allocate(&allocation.resource_type, allocation.recipient, allocation.amount)
            .await
            .map_err(|e| e.to_string())
    }

    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String> {
        // Implementation for releasing resources back to the pool
        Ok(())
    }
}

#[derive(Debug)]
pub enum ResourceError {
    ResourceNotFound,
    InsufficientResources,
    InvalidAllocation,
    UnauthorizedAction,
}
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 7207 bytes
===================
```rs
use async_trait::async_trait;
use icn_types::{
    Block, Transaction, RuntimeError, RuntimeResult, ExecutionContext,
    ValidationNode, GovernanceNode, MarketplaceNode, Check, StateValidation,
    RuntimeConfig
};
use icn_dsl::CoopLangAST;
use tracing::{info, warn, error};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::collections::HashMap;

/// Runtime interface trait for blockchain execution
#[async_trait]
pub trait VM {
    /// Executes a single transaction
    async fn execute_transaction(&self, transaction: Transaction) -> RuntimeResult<()>;
    
    /// Executes all transactions in a block
    async fn execute_block(&self, block: Block) -> RuntimeResult<()>;
}

/// Contract execution handler
pub struct ContractExecution {
    /// Map of contract addresses to their byte code
    contracts: HashMap<String, Vec<u8>>,
    /// Storage for contract state
    state: HashMap<String, Vec<u8>>,
    /// Maximum gas allowed for execution
    max_gas: u64,
}

impl ContractExecution {
    /// Create a new contract execution environment
    pub fn new(max_gas: u64) -> Self {
        Self {
            contracts: HashMap::new(),
            state: HashMap::new(),
            max_gas,
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        if self.contracts.contains_key(&address) {
            return Err("Contract already exists at this address".to_string());
        }
        self.contracts.insert(address, bytecode);
        Ok(())
    }
    
    /// Execute a contract call
    pub async fn execute_contract_call(&mut self, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        if gas > self.max_gas {
            return Err("Gas limit exceeded".to_string());
        }
        
        let contract = self.contracts.get(address).ok_or("Contract not found")?;
        
        // In a real implementation, this would actually execute the bytecode
        // For testing purposes, we just return a dummy result
        Ok(vec![1, 2, 3])
    }
}

/// Runtime manager for handling contract execution
pub struct RuntimeManager {
    /// Execution environment
    execution: ContractExecution,
    /// Map of transaction hashes to execution results
    results: HashMap<String, Vec<u8>>,
}

impl RuntimeManager {
    /// Create a new runtime manager
    pub fn new(max_gas: u64) -> Self {
        Self {
            execution: ContractExecution::new(max_gas),
            results: HashMap::new(),
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        self.execution.deploy_contract(address, bytecode)
    }
    
    /// Execute a transaction
    pub async fn execute_transaction(&mut self, tx_hash: String, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        let result = self.execution.execute_contract_call(address, input, gas).await?;
        self.results.insert(tx_hash, result.clone());
        Ok(result)
    }
    
    /// Get transaction result
    pub fn get_transaction_result(&self, tx_hash: &str) -> Option<&Vec<u8>> {
        self.results.get(tx_hash)
    }
}

#[async_trait]
pub trait ValidationExecutor {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()>;
}

#[async_trait]
impl ValidationExecutor for RuntimeManager {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()> {
        // Execute pre-checks
        for check in &validation.pre_checks {
            info!("Executing pre-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        // Validate state if specified
        if let Some(state_validation) = &validation.state_validation {
            info!("Validating state");
            self.validate_state(state_validation, context).await?;
        }

        // Execute post-checks
        for check in &validation.post_checks {
            info!("Executing post-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        Ok(())
    }

    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()> {
        let condition_result = self.evaluate_condition(&check.condition, context).await?;
        if !condition_result {
            error!("Check failed: {}", check.action);
            return Err(RuntimeError::ValidationFailed(check.action.clone()));
        }
        Ok(())
    }

    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()> {
        let current_state = self.get_current_state(context).await?;

        // Validate current state if specified
        if let Some(expected_current) = &validation.current {
            if current_state != *expected_current {
                error!("Invalid state. Expected: {}, Found: {}", expected_current, current_state);
                return Err(RuntimeError::InvalidState);
            }
        }

        // Validate expected state transitions
        if let Some(expected) = &validation.expected {
            if !validation.transitions.contains(expected) {
                error!("Invalid state transition to: {}", expected);
                return Err(RuntimeError::InvalidState);
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_types::{Block, Transaction};

    #[tokio::test]
    async fn test_runtime_initialization() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        assert!(runtime.dsl_context.is_none());
    }

    #[tokio::test]
    async fn test_validation_rules() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        
        let context = ExecutionContext {
            transaction: None,
            block: None,
            state: HashMap::new(),
            metadata: HashMap::new(),
        };

        let validation = ValidationNode {
            pre_checks: vec![
                Check {
                    condition: "true".to_string(),
                    action: "test".to_string(),
                }
            ],
            post_checks: vec![],
            state_validation: None,
        };

        runtime.execute_validation_rules(&validation, &context).await.unwrap();
    }
}
```

===================
File: ./crates/icn-storage/src/lib.rs
Size: 6298 bytes
===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use icn_types::{StorageError, StorageResult, StorageBackend, StorageConfig};
use std::time::Duration;
use ipfs_api_backend_actix::{IpfsClient, TryFromUri};
use futures::TryStreamExt;

mod cache;
use cache::StorageCache;

/// Errors that can occur in storage operations
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
}

/// Represents the result of storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Core storage interface for the system
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    
    /// Retrieve a value by key
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Manages persistent storage for the system
pub struct StorageManager {
    backend: Arc<Mutex<Box<dyn StorageBackend>>>,
    cache: Arc<StorageCache>,
    ipfs_client: IpfsClient,
}

impl StorageManager {
    /// Create a new storage manager with the given backend and configuration
    pub fn new(backend: Box<dyn StorageBackend>, config: StorageConfig) -> Self {
        Self {
            backend: Arc::new(Mutex::new(backend)),
            cache: Arc::new(StorageCache::new(
                config.cache_size,
                Duration::from_secs(config.cache_ttl_seconds)
            )),
            ipfs_client: IpfsClient::from_str(&config.ipfs_url).expect("Invalid IPFS URL"),
        }
    }
    
    /// Store a serializable value
    pub async fn store<T: Serialize>(&self, key: &str, value: &T) -> StorageResult<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| StorageError::SerializationError(e.to_string()))?;
            
        // Update backend
        let backend = self.backend.lock().await;
        backend.set(key, &serialized).await?;
        
        // Update cache
        self.cache.set(key.to_string(), serialized);
        
        Ok(())
    }
    
    /// Retrieve and deserialize a value
    pub async fn retrieve<T: for<'de> Deserialize<'de>>(&self, key: &str) -> StorageResult<T> {
        // Try cache first
        if let Some(cached_data) = self.cache.get(key) {
            return serde_json::from_slice(&cached_data)
                .map_err(|e| StorageError::SerializationError(e.to_string()));
        }

        // Fall back to backend
        let backend = self.backend.lock().await;
        let data = backend.get(key).await?;
        
        // Update cache
        self.cache.set(key.to_string(), data.clone());
        
        serde_json::from_slice(&data)
            .map_err(|e| StorageError::SerializationError(e.to_string()))
    }
    
    /// Delete a stored value
    pub async fn remove(&self, key: &str) -> StorageResult<()> {
        let backend = self.backend.lock().await;
        backend.delete(key).await
    }
    
    /// Check if a key exists in storage
    pub async fn has_key(&self, key: &str) -> StorageResult<bool> {
        let backend = self.backend.lock().await;
        backend.exists(key).await
    }

    /// Store data using IPFS
    pub async fn store_ipfs(&self, data: &[u8]) -> StorageResult<String> {
        let result = self.ipfs_client.add(data).await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(result.hash)
    }

    /// Retrieve data from IPFS
    pub async fn retrieve_ipfs(&self, hash: &str) -> StorageResult<Vec<u8>> {
        let data = self.ipfs_client.cat(hash).map_ok(|chunk| chunk.to_vec()).try_concat().await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Mock storage backend for testing
    struct MockStorage {
        data: HashMap<String, Vec<u8>>,
    }
    
    #[async_trait::async_trait]
    impl StorageBackend for MockStorage {
        async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
            self.data.insert(key.to_string(), value.to_vec());
            Ok(())
        }
        
        async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
            self.data.get(key)
                .cloned()
                .ok_or_else(|| StorageError::NotFound(key.to_string()))
        }
        
        async fn delete(&self, key: &str) -> StorageResult<()> {
            self.data.remove(key);
            Ok(())
        }
        
        async fn exists(&self, key: &str) -> StorageResult<bool> {
            Ok(self.data.contains_key(key))
        }
    }
    
    #[tokio::test]
    async fn test_basic_storage_operations() {
        let config = StorageConfig {
            backend_type: "mock".to_string(),
            cache_size: 1000,
            cache_ttl_seconds: 300,
            ipfs_url: "http://localhost:5001".to_string(),
            database_url: None,
        };
        
        let storage = StorageManager::new(
            Box::new(MockStorage { data: HashMap::new() }),
            config
        );

        // Test store and retrieve
        let key = "test_key";
        let value = "test_value";
        storage.store(key, &value).await.unwrap();
        
        let retrieved: String = storage.retrieve(key).await.unwrap();
        assert_eq!(retrieved, value);
        
        // Test exists
        assert!(storage.has_key(key).await.unwrap());
        
        // Test delete
        storage.remove(key).await.unwrap();
        assert!(!storage.has_key(key).await.unwrap());
    }
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 33812 bytes
===================
```rs
//! Core types for the ICN (Inter-Cooperative Network) system
//! 
//! This crate provides the fundamental types used across all ICN modules.
//! It serves as a central repository for shared data structures, ensuring
//! consistency across the codebase.

use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use tokio::task;
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;
use thiserror::Error;
use async_trait::async_trait;

mod errors;
pub use errors::{IcnError, IcnResult, log_error};

#[derive(Debug, Error)]
pub enum BlockError {
    #[error("Invalid block index")]
    InvalidIndex,
    #[error("Invalid previous hash")]
    InvalidPreviousHash,
    #[error("Invalid transaction")]
    InvalidTransaction,
    #[error("Invalid proposer")]
    InvalidProposer,
    #[error("Consensus error")]
    ConsensusError,
    #[error("Database error")]
    DatabaseError,
}

#[derive(Debug)]
pub struct ResourceDebt {
    pub cpu_debt: u64,
    pub memory_debt: u64,
    pub bandwidth_debt: u64,
}

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
    pub proposer: String,
    pub metadata: BlockMetadata,
    pub signatures: Vec<BlockSignature>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    pub validator_did: String,
    pub signature: String,
    pub timestamp: DateTime<Utc>,
    pub voting_power: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub height: u64,
    pub state_root: String,
    pub transaction_root: String,
    pub consensus_data: HashMap<String, String>,
    pub validator_signatures: Vec<String>,
    pub consensus_duration_ms: u64,
    pub validator_count: u32,
    pub total_voting_power: f64,
    pub size: u64,
    pub resources_used: u64,
    pub relationship_updates: Option<RelationshipMetadata>,
    pub fault_tolerance: Option<u32>,
}

impl Default for BlockMetadata {
    fn default() -> Self {
        Self {
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            size: 0,
            resources_used: 0,
            relationship_updates: None,
            fault_tolerance: None,
        }
    }
}

impl BlockMetadata {
    pub fn with_bft_info(&mut self, quorum_size: u32, fault_tolerance: u32) {
        self.validator_count = quorum_size;
        self.fault_tolerance = Some(fault_tolerance);
        self.consensus_duration_ms = 0; // Will be set during finalization
    }

    pub fn is_bft_valid(&self) -> bool {
        if let Some(fault_tolerance) = self.fault_tolerance {
            // Check if we have enough validators (3f + 1)
            self.validator_count >= (fault_tolerance * 3) + 1
        } else {
            false
        }
    }
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

lazy_static! {
    static ref TRANSACTION_CACHE: Mutex<HashMap<String, bool>> = {
        let m = HashMap::new();
        Mutex::new(m)
    };
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
            fault_tolerance: None,
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            metadata,
            signatures: Vec::new(),
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        for tx in &self.transactions {
            if let Ok(tx_json) = serde_json::to_string(tx) {
                hasher.update(tx_json);
            }
        }
        
        hasher.update(&self.proposer);
        
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub async fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        let signature_task = task::spawn(async move {
            BlockSignature {
                validator_did,
                signature,
                timestamp: Utc::now(),
                voting_power,
            }
        });

        let new_signature = signature_task.await.unwrap();
        self.signatures.push(new_signature);

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub async fn verify(&self, previous_block: Option<&Block>) -> Result<(), BlockError> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify previous block linkage
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err(BlockError::InvalidPreviousHash);
            }
            if self.index != prev.index + 1 {
                return Err(BlockError::InvalidIndex);
            }
            if self.timestamp <= prev.timestamp {
                return Err(BlockError::InvalidTransaction);
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err(BlockError::InvalidTransaction);
        }

        // Validate transactions
        self.validate_transactions().await?;

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Validates the transactions in the block
    async fn validate_transactions(&self) -> Result<(), BlockError> {
        for tx in &self.transactions {
            let mut cache = TRANSACTION_CACHE.lock().unwrap();
            
            // Check if transaction is already processed
            if cache.contains_key(&tx.hash) {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Validate the transaction
            if !tx.validate() {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Add to cache
            cache.insert(tx.hash.clone(), true);
        }
        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> Option<RelationshipMetadata> {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        Some(metadata)
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }

    /// Finalizes the block and ensures all validations pass
    pub async fn finalize(&mut self) -> Result<(), BlockError> {
        self.verify(None).await?;
        
        let resource_usage: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
            
        self.metadata.resources_used = resource_usage;
        
        self.metadata.size = bincode::serialize(&self)
            .map_err(|_| BlockError::InvalidTransaction)?
            .len() as u64;
            
        self.hash = self.calculate_hash();

        Ok(())
    }

    /// Initiates a consensus round among the validators
    pub async fn start_consensus_round(&mut self) -> Result<(), BlockError> {
        // Simulate consensus process
        let validator = "validator1";
        let signature = format!("signature_of_{}", validator);
        
        if !self.add_signature(validator.to_string(), signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Records a validator's vote on the block
    pub async fn vote_on_block(&mut self, validator_did: String, vote: bool) -> Result<(), BlockError> {
        if !vote {
            return Err(BlockError::InvalidTransaction);
        }

        let signature = "signature".to_string(); // In real implementation, this would be a proper signature
        
        if !self.add_signature(validator_did, signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    pub fn update_validator_metadata(&mut self, validator: String, reputation: i64) {
        let validator_meta = BlockSignature {
            validator_did: validator,
            signature: String::new(),
            timestamp: Utc::now(),
            voting_power: reputation as f64,
        };
        self.signatures.push(validator_meta);
        
        // Update validator count and total voting power
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: std::collections::HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

impl TransactionType {
    pub fn as_str(&self) -> &str {
        match self {
            TransactionType::Transfer { .. } => "Transfer",
            TransactionType::ContractExecution { .. } => "ContractExecution",
            TransactionType::RecordContribution { .. } => "RecordContribution",
            TransactionType::RecordMutualAid { .. } => "RecordMutualAid",
            TransactionType::UpdateRelationship { .. } => "UpdateRelationship",
            TransactionType::AddEndorsement { .. } => "AddEndorsement",
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub id: String,
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType,
    pub timestamp: i64,
    pub hash: String,
    pub signature: Option<String>,
    pub resource_cost: u64,
    pub resource_priority: u8,
    pub zk_snark_proof: Option<String>,
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos();

        let receiver = match &transaction_type {
            TransactionType::Transfer { receiver, .. } => receiver.clone(),
            TransactionType::RecordMutualAid { receiver, .. } => receiver.clone(),
            TransactionType::UpdateRelationship { member_two, .. } => member_two.clone(),
            TransactionType::AddEndorsement { to_did, .. } => to_did.clone(),
            _ => String::new(),
        };

        let amount = match &transaction_type {
            TransactionType::Transfer { amount, .. } => *amount,
            _ => 0,
        };

        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);

        Transaction {
            id: String::new(),
            sender,
            receiver,
            amount,
            transaction_type,
            timestamp: timestamp as i64,
            hash,
            signature: None,
            resource_cost,
            resource_priority: 5, // Default priority
            zk_snark_proof: None,
        }
    }

    pub fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    pub fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                   60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        if self.sender.is_empty() {
            return false;
        }
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0 && self.sender != *receiver
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && !impact_story.is_empty() && !context.is_empty() && !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && !description.is_empty() && !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && !relationship_type.is_empty() && !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && !content.is_empty() && !context.is_empty() && !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp as u128
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap_or_else(|_| Vec::new())
    }
    
    pub fn get_zk_snark_inputs(&self) -> Vec<u8> {
        // A simple implementation that concatenates transaction data
        let mut inputs = Vec::new();
        inputs.extend_from_slice(self.sender.as_bytes());
        inputs.extend_from_slice(self.receiver.as_bytes());
        inputs.extend_from_slice(&self.amount.to_le_bytes());
        inputs.extend_from_slice(self.hash.as_bytes());
        inputs
    }
}

#[derive(Debug, Clone)]
pub struct AuthError(String);

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for AuthError {}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistryTransaction {
    pub registry_data: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AttestMembershipTransaction {
    pub member_did: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64, // positive value; sender's balance decreases and receiver's increases
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceTransaction {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceTransaction {
    pub resource_id: String,
    pub operation: String,
    pub metadata: String,
    pub did_proof: DidProof,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidProof {
    pub did: String,
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ElectionTransaction {
    pub candidate_id: String,
    pub votes: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VoteProposal {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub voter_did: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistry;

impl DidRegistry {
    pub fn new() -> Self {
        DidRegistry
    }

    pub fn get_did(&self, _did: &str) -> Option<DidDocument> {
        // Placeholder implementation
        Some(DidDocument { is_verified: true })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidDocument {
    pub is_verified: bool,
}

impl Transaction {
    pub fn verify_did_signature(_did: &str, _signature: &str, _message: &str) -> Result<bool, AuthError> {
        Ok(true)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

/// Represents a unique identifier for a federation
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct FederationId(pub String);

/// Represents a unique identifier for a cooperative
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct CooperativeId(pub String);

/// Represents a member's identity within the system
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct MemberId {
    pub did: String,
    pub cooperative_id: CooperativeId,
}

/// Represents the status of a federation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationStatus {
    Active,
    Suspended,
    Inactive,
}

/// Represents a governance proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: MemberId,
    pub created_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub votes: HashMap<MemberId, VoteChoice>,
}

/// Represents the status of a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Draft,
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VoteChoice {
    Yes,
    No,
    Abstain,
}

/// Represents a member's reputation score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    pub member_id: MemberId,
    pub score: f64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

/// Represents a resource in the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub owner: CooperativeId,
    pub resource_type: String,
    pub metadata: HashMap<String, String>,
    pub availability: ResourceAvailability,
}

/// Represents the availability status of a resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResourceAvailability {
    Available,
    InUse,
    Maintenance,
    Offline,
}

/// Storage-related error types
#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
    
    #[error("Storage reference already exists")]
    ReferenceAlreadyExists,
    
    #[error("Storage reference not found")]
    ReferenceNotFound,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageReference {
    pub id: String,
    pub storage_type: StorageType,
    pub location: String,
    pub status: StorageStatus,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageType {
    Local,
    Distributed,
    Cloud,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageStatus {
    Available,
    Unavailable,
    Syncing,
}

#[async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn store(&self, data: &[u8]) -> Result<String, StorageError>;
    
    /// Retrieve a value by key
    async fn retrieve(&self, id: &str) -> Result<Vec<u8>, StorageError>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Result type for storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Storage configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub backend_type: String,
    pub cache_size: usize,
    pub cache_ttl_seconds: u64,
    pub ipfs_url: String,
    pub database_url: Option<String>,
}

/// Runtime-related error types
#[derive(Debug, thiserror::Error)]
pub enum RuntimeError {
    #[error("Validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Invalid state")]
    InvalidState,
    
    #[error("Execution error: {0}")]
    ExecutionError(String),
    
    #[error("DSL error: {0}")]
    DslError(String),
    
    #[error("Contract error: {0}")]
    ContractError(String),
}

impl From<RuntimeError> for IcnError {
    fn from(err: RuntimeError) -> Self {
        IcnError::RuntimeError(err.to_string())
    }
}

pub type RuntimeResult<T> = Result<T, RuntimeError>;

/// Represents the execution context for runtime operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub transaction: Option<Transaction>,
    pub block: Option<Block>,
    pub state: HashMap<String, Vec<u8>>,
    pub metadata: HashMap<String, String>,
}

/// Represents a validation check in the runtime
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

/// Represents state validation rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transitions: Vec<String>,
}

/// Represents a validation node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
}

/// Represents a governance node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceNode {
    pub rules: Vec<String>,
    pub voting_config: HashMap<String, String>,
    pub permissions: HashMap<String, Vec<String>>,
}

/// Represents a marketplace node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplaceNode {
    pub rules: Vec<String>,
    pub pricing_model: String,
    pub constraints: Vec<String>,
}

/// Runtime configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuntimeConfig {
    pub vm_type: String,
    pub max_execution_time: u64,
    pub max_memory: u64,
    pub enable_debugging: bool,
    pub log_level: String,
}

#[derive(Debug, Clone)]
pub struct ReputationError {
    pub message: String,
}

impl std::fmt::Display for ReputationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ReputationError {}

#[derive(Debug, Clone)]
pub struct ExecutionError {
    pub message: String,
}

impl std::fmt::Display for ExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ExecutionError {}

#[derive(Debug, Clone)]
pub struct ContractInput {
    pub contract_id: String,
    pub method: String,
    pub args: Vec<u8>,
}

#[async_trait::async_trait]
pub trait RuntimeInterface: Send + Sync {
    async fn execute_transaction(&self, transaction: &Transaction) -> Result<(), RuntimeError>;
    async fn execute_block(&self, block: &Block) -> Result<(), RuntimeError>;
    async fn execute_contract(&self, input: ContractInput) -> Result<Vec<u8>, ExecutionError>;
    async fn get_contract_state(&self, contract_id: &str) -> Result<Vec<u8>, ExecutionError>;
}
```

===================
File: ./crates/icn-zk/src/lib.rs
Size: 1853 bytes
===================
```rs
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use ff::PrimeField;
use serde::{Deserialize, Serialize};
use std::error::Error;

pub struct ProofOfCooperation<F: PrimeField> {
    pub reputation_score: Option<F>,
    pub cooperation_proof: Option<F>,
}

impl<F: PrimeField> Circuit<F> for ProofOfCooperation<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS
    ) -> Result<(), SynthesisError> {
        // Basic circuit implementation - to be expanded
        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RollupBatch {
    pub proposal_id: String,
    pub votes: Vec<Vote>,
    pub rollup_root: [u8; 32],
    pub proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
}

pub fn verify_proof(proof: &str) -> bool {
    // TODO: Implement actual zk-SNARK verification
    // For now, return true for testing
    true
}

pub fn generate_proof(_cs: &mut impl ConstraintSystem) -> Result<String, Box<dyn Error>> {
    // TODO: Implement actual proof generation
    Ok("dummy_proof".to_string())
}

#[derive(Debug)]
pub struct ProofCircuit {
    // Circuit parameters
    pub public_inputs: Vec<u64>,
    pub private_inputs: Vec<u64>,
}

pub trait ConstraintSystem {
    fn alloc(&mut self, value: Option<u64>) -> Result<Variable, Box<dyn Error>>;
    fn enforce(&mut self, lc0: LinearCombination, lc1: LinearCombination, lc2: LinearCombination);
}

#[derive(Clone, Debug)]
pub struct Variable(u32);

#[derive(Clone, Debug)]
pub struct LinearCombination {
    terms: Vec<(Variable, u64)>,
}

impl LinearCombination {
    pub fn zero() -> Self {
        LinearCombination { terms: Vec::new() }
    }

    pub fn add_assign(&mut self, var: Variable, coeff: u64) {
        self.terms.push((var, coeff));
    }
}
```

===================
File: ./crates/zk_snarks/src/lib.rs
Size: 446 bytes
===================
```rs
//! Mock implementation of ZK-SNARKs for integration testing

/// Verify a ZK-SNARK proof
/// 
/// This is a mock implementation that always returns true
pub fn verify_proof(proof: &str) -> bool {
    // In a real implementation, this would verify the proof
    println!("Verifying ZK-SNARK proof: {}", proof);
    true
}

/// Generate a dummy proof for testing
pub fn generate_test_proof() -> String {
    "dummy_proof_for_testing".to_string()
}```

===================
File: ./docker/backend/src/main.rs
Size: 45 bytes
===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./icn-consensus/src/lib.rs
Size: 1234 bytes
===================
```rs
// ...existing code...

// Define the structure for cooperative governance rules
struct GovernanceRules {
    max_validators: usize,
    min_stake: u64,
    election_period: u64,
    // ...other rules...
}

// Define the structure for a validator
struct Validator {
    id: String,
    stake: u64,
    // ...other properties...
}

// Define the structure for the genesis block
struct GenesisBlock {
    initial_validators: Vec<Validator>,
    // ...other properties...
}

// Function to enforce cooperative governance rules
fn enforce_governance_rules(validators: &mut Vec<Validator>, rules: &GovernanceRules) {
    // Implement rules to prevent centralized control
    // ...code to enforce rules...
}

// Function to finalize the genesis block format
fn finalize_genesis_block(validators: Vec<Validator>) -> GenesisBlock {
    GenesisBlock {
        initial_validators: validators,
        // ...initialize other properties...
    }
}

// Function to develop a validator election mechanism
fn elect_validators(current_validators: &Vec<Validator>, candidates: &Vec<Validator>, rules: &GovernanceRules) -> Vec<Validator> {
    // Implement democratic election mechanism
    // ...code to elect validators...
}

// ...existing code...
```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./src/api/handlers.rs
Size: 1823 bytes
===================
```rs
use crate::network::communication::NetworkLayer;
use crate::services::event_service::EventService;
use crate::services::event_service::DomainEvent;
use crate::storage::event_store::EventStore;
use crate::network::communication::NetworkEvent;
use warp::Reply;

pub async fn health_check() -> &'static str {
    "OK"
}

pub struct ApiHandlers {
    network: NetworkLayer,
    event_service: EventService,
    event_store: EventStore,
}

impl ApiHandlers {
    pub async fn new() -> Self {
        Self {
            network: NetworkLayer::new(Some("127.0.0.1:8080")).await.expect("Failed to create NetworkLayer"),
            event_service: EventService::new(),
            event_store: EventStore::new(),
        }
    }

    pub async fn handle_vote(&self, proposal_id: String, vote: bool) -> impl Reply {
        // Handle vote through all layers
        let event = DomainEvent::VoteCast {
            proposal_id: proposal_id.clone(),
            voter: "user".to_string(),
            vote,
        };

        // Publish event
        self.event_service.publish(event.clone()).await;

        // Store the event
        if let Err(e) = self.event_store.append(&proposal_id, event) {
            eprintln!("Failed to store vote event: {}", e);
            return warp::reply::json(&format!("Failed to store vote: {}", e));
        }

        // Broadcast with error handling
        if let Err(e) = self.network.broadcast_event(NetworkEvent::VoteUpdate {
            proposal_id,
            votes: 1,
        }).await {
            eprintln!("Failed to broadcast vote update: {}", e);
            return warp::reply::json(&format!("Vote recorded but broadcast failed: {}", e));
        }

        warp::reply::json(&"Vote recorded and broadcast successfully")
    }

    // Add more handlers for other API endpoints
}
```

===================
File: ./src/api/mod.rs
Size: 160 bytes
===================
```rs
// API module for the ICN system
pub mod routes;
pub mod handlers;

use crate::icn_types::IcnResult;

pub async fn initialize() -> IcnResult<()> {
    Ok(())
} ```

===================
File: ./src/api/routes.rs
Size: 213 bytes
===================
```rs
use warp::Filter;

pub fn icn_routes() -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path!("health")
        .and(warp::get())
        .map(|| warp::reply::json(&"OK"))
}
```

===================
File: ./src/attestation/mod.rs
Size: 138 bytes
===================
```rs
//! Attestation module for ICN

pub struct AttestationService;

impl AttestationService {
    pub fn new() -> Self {
        Self
    }
}
```

===================
File: ./src/consensus/mod.rs
Size: 191 bytes
===================
```rs
use chrono::{DateTime, Utc};

#[derive(Debug)]
pub enum ConsensusMessage {
    ProposalExecution {
        id: String,
        changes: Vec<String>,
        timestamp: DateTime<Utc>,
    }
}
```

===================
File: ./src/dsl/governance.rs
Size: 1878 bytes
===================
```rs
use super::vm::IcnVM;
use crate::consensus::ConsensusMessage;
use std::sync::Arc;
use tokio::sync::mpsc;

pub struct GovernanceExecutor {
    vm: Arc<IcnVM>,
    consensus_tx: mpsc::Sender<ConsensusMessage>,
}

impl GovernanceExecutor {
    pub fn new(vm: Arc<IcnVM>, consensus_tx: mpsc::Sender<ConsensusMessage>) -> Self {
        Self { vm, consensus_tx }
    }

    pub async fn execute_proposal(&self, proposal_id: &str, rules: &str) -> Result<(), Box<dyn std::error::Error>> {
        let ast = super::parser::parse(rules)?;
        
        // Execute in VM and get state changes
        let state_changes = self.vm.execute_with_state_diff(ast)?;
        
        // Prepare consensus message
        let consensus_msg = ConsensusMessage::ProposalExecution {
            id: proposal_id.to_string(),
            changes: state_changes,
            timestamp: chrono::Utc::now(),
        };

        // Submit to consensus layer
        self.consensus_tx.send(consensus_msg).await?;
        Ok(())
    }

    pub async fn validate_transaction(&self, tx: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // Execute validation rules
        let validation_result = self.vm.execute_validation(tx)?;
        Ok(validation_result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_governance_execution() {
        // Test governance rule execution
        let rules = r#"
            governance: {
                voting_method: "quadratic",
                threshold: 75,
                min_participants: 10
            }
        "#;

        let (consensus_tx, _consensus_rx) = mpsc::channel(32);
        let vm = Arc::new(IcnVM::new());
        let executor = GovernanceExecutor::new(vm, consensus_tx);

        let result = executor.execute_proposal("test-proposal", rules).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./src/dsl/mod.rs
Size: 149 bytes
===================
```rs
pub mod parser;
pub mod vm;
pub mod governance;

pub use parser::{CoopLangParser, parse};
pub use vm::IcnVM;
pub use governance::GovernanceExecutor;
```

===================
File: ./src/dsl/parser.rs
Size: 496 bytes
===================
```rs
use pest::Parser;
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "../grammar/coop_lang.pest"] // Path relative to this file
pub struct CoopLangParser;

#[derive(Debug)]
pub struct CoopLangAST {
    pub raw: String,
}

impl CoopLangAST {
    pub fn new(raw: String) -> Self {
        Self { raw }
    }
}

pub fn parse(input: &str) -> Result<CoopLangAST, Box<dyn std::error::Error>> {
    let _ = CoopLangParser::parse(Rule::program, input)?;
    Ok(CoopLangAST::new(input.to_owned()))
}
```

===================
File: ./src/dsl/vm.rs
Size: 931 bytes
===================
```rs
use std::collections::HashMap;

#[derive(Debug)]
pub enum VMValue {
    String(String),
    Number(f64),
    Boolean(bool),
    Array(Vec<VMValue>),
    Object(HashMap<String, VMValue>),
}

#[allow(dead_code)]
#[derive(Default)]
pub struct ExecutionContext {
    variables: HashMap<String, VMValue>,
    permissions: Vec<String>,
}

pub struct IcnVM;

impl IcnVM {
    pub fn new() -> Self {
        IcnVM
    }
    
    // Execute DSL code and return dummy state changes (empty vector)
    pub fn execute_with_state_diff(&self, _ast: crate::dsl::parser::CoopLangAST) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        // In a real implementation, the AST would be compiled and executed.
        Ok(vec![])
    }
    
    // Execute validation DSL for a transaction string; return a dummy true result.
    pub fn execute_validation(&self, _tx: &str) -> Result<bool, Box<dyn std::error::Error>> {
        Ok(true)
    }
}
```

===================
File: ./src/governance/mod.rs
Size: 2489 bytes
===================
```rs
mod rollback;

use rollback::{DisputeInfo, DisputeStatus, RollbackError, RollbackConfig};
use std::collections::HashMap;
use chrono::Utc;
use crate::icn_types::Proposal;

pub struct GovernanceService {
    // ...existing code...
    disputes: HashMap<String, DisputeInfo>,
    rollback_config: RollbackConfig,
    proposals: HashMap<String, Proposal>,
}

impl GovernanceService {
    pub async fn initiate_rollback(
        &mut self,
        proposal_id: &str,
        initiator: String,
        reason: String,
        evidence: Option<String>,
    ) -> Result<(), RollbackError> {
        let proposal = self.proposals
            .get(proposal_id)
            .ok_or(RollbackError::ProposalNotFound)?;

        if !self.is_within_rollback_window(&proposal) {
            return Err(RollbackError::TimeframePassed);
        }

        let dispute = DisputeInfo {
            initiator,
            reason,
            timestamp: Utc::now(),
            evidence,
            status: DisputeStatus::Pending,
            votes: HashMap::new(),
        };

        self.disputes.insert(proposal_id.to_string(), dispute);
        self.freeze_proposal(proposal_id)?;
        Ok(())
    }

    pub async fn execute_rollback(
        &mut self,
        proposal_id: &str,
    ) -> Result<(), RollbackError> {
        let dispute = self.disputes.get(proposal_id)
            .ok_or(RollbackError::InvalidRollbackState)?;

        if dispute.status != DisputeStatus::Pending {
            return Err(RollbackError::InvalidRollbackState);
        }

        if self.get_rollback_approvals(proposal_id) < self.rollback_config.required_approvals {
            return Err(RollbackError::UnauthorizedRollback);
        }

        self.proposals.remove(proposal_id)
            .ok_or(RollbackError::ProposalNotFound)?;
        self.disputes.remove(proposal_id);
        Ok(())
    }

    fn is_within_rollback_window(&self, proposal: &Proposal) -> bool {
        let now = Utc::now();
        let window = chrono::Duration::seconds(self.rollback_config.rollback_window.as_secs() as i64);
        now.signed_duration_since(proposal.created_at) <= window
    }

    fn freeze_proposal(&mut self, _proposal_id: &str) -> Result<(), RollbackError> {
        // Implementation to freeze proposal during dispute resolution
        Ok(())
    }

    fn get_rollback_approvals(&self, _proposal_id: &str) -> u32 {
        // Implementation to count governance members' approvals for rollback
        0
    }
}
```

===================
File: ./src/governance/rollback.rs
Size: 1029 bytes
===================
```rs
use std::time::Duration;
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
pub enum DisputeStatus {
    Pending,
    UnderReview,
    Resolved,
    Rejected,
}

#[derive(Debug, Clone)]
pub struct DisputeInfo {
    pub initiator: String,
    pub reason: String,
    pub timestamp: DateTime<Utc>,
    pub evidence: Option<String>,
    pub status: DisputeStatus,
    pub votes: HashMap<String, bool>,
}

#[derive(Debug)]
pub enum RollbackError {
    ProposalNotFound,
    InvalidRollbackState,
    DisputeAlreadyExists,
    UnauthorizedRollback,
    TimeframePassed,
}

pub struct RollbackConfig {
    pub rollback_window: Duration,
    pub required_approvals: u32,
    pub cooling_period: Duration,
}

impl Default for RollbackConfig {
    fn default() -> Self {
        Self {
            rollback_window: Duration::from_secs(86400), // 24 hours
            required_approvals: 3,
            cooling_period: Duration::from_secs(3600), // 1 hour
        }
    }
}
```

===================
File: ./src/lib.rs
Size: 301 bytes
===================
```rs
pub mod api;
pub mod governance;
pub mod dsl;
pub mod attestation;
pub mod consensus;
pub mod network;
pub mod services;
pub mod storage;

/// Re-export commonly used types and functions
pub use icn_types;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}```

===================
File: ./src/main.rs
Size: 4057 bytes
===================
```rs
use std::sync::Arc;
use log::{info, error};
use icn_core::{
    core::Core,
    telemetry::{TelemetryManager, PrometheusMetrics, Logger, TracingSystem},
    storage::{StorageInterface, MemoryStorage},
    networking::{NetworkInterface, NetworkManager},
    identity::{IdentityInterface, IdentityManager},
    reputation::{ReputationInterface, ReputationSystem},
    models::{ResourceAllocationSystem, FederationManager},
    RuntimeManager, RuntimeInterface
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("info"));
    info!("Starting ICN node initialization...");

    // Initialize core components
    let storage_manager = MemoryStorage::new();
    let network_manager = NetworkManager::new();
    let prometheus = PrometheusMetrics::new();
    let logger = Logger::new();
    let tracing = TracingSystem::new();
    let telemetry_manager = TelemetryManager::new(prometheus, logger, tracing);
    let identity_manager = IdentityManager::new();
    let reputation_manager = ReputationSystem::new();
    let runtime_manager = RuntimeManager::new();
    let resource_system = Arc::new(ResourceAllocationSystem::new());
    let federation_manager = Arc::new(FederationManager::new(resource_system.clone()));

    // Wrap components in Arc for shared ownership
    let storage: Arc<dyn StorageInterface> = Arc::new(storage_manager);
    let network: Arc<dyn NetworkInterface> = Arc::new(network_manager);
    let identity: Arc<dyn IdentityInterface> = Arc::new(identity_manager);
    let reputation: Arc<dyn ReputationInterface> = Arc::new(reputation_manager);
    let runtime: Arc<dyn RuntimeInterface> = Arc::new(runtime_manager);
    let _telemetry = Arc::new(telemetry_manager);

    // Create core system with the components it needs
    let core = Arc::new(Core::new(
        storage.clone(),
        network.clone(),
        identity.clone(),
        reputation.clone(),
        runtime.clone()
    ));

    // Start the core system
    info!("Starting core system components...");
    match core.start().await {
        Ok(_) => info!("Core system started successfully"),
        Err(e) => {
            error!("Failed to start core system: {}", e);
            std::process::exit(1);
        }
    }

    // Initialize P2P networking
    info!("Initializing P2P networking...");
    if let Err(e) = network.start().await {
        error!("Failed to start P2P networking: {}", e);
        std::process::exit(1);
    }

    // Start consensus engine
    info!("Starting consensus engine...");
    if let Err(e) = core.start_consensus().await {
        error!("Failed to start consensus engine: {}", e);
        std::process::exit(1);
    }

    // Start federation manager
    info!("Starting federation manager...");
    if let Err(e) = federation_manager.start().await {
        error!("Failed to start federation manager: {}", e);
        std::process::exit(1);
    }

    // Set up signal handlers for graceful shutdown
    let core_clone = core.clone();
    let network_clone = network.clone();
    let federation_clone = federation_manager.clone();
    
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.expect("Failed to listen for ctrl+c");
        info!("Received shutdown signal, initiating graceful shutdown...");
        
        // Shutdown sequence
        if let Err(e) = federation_clone.stop().await {
            error!("Error stopping federation manager: {}", e);
        }
        if let Err(e) = network_clone.stop().await {
            error!("Error stopping P2P networking: {}", e);
        }
        if let Err(e) = core_clone.stop().await {
            error!("Error stopping core system: {}", e);
        }
        
        info!("Node shutdown completed");
        std::process::exit(0);
    });

    info!("ICN node startup complete - running...");

    // Keep the main thread alive
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
}```

===================
File: ./src/network/communication.rs
Size: 5920 bytes
===================
```rs
use futures::StreamExt;
use tokio::sync::mpsc;
use tokio_tungstenite::{WebSocketStream, tungstenite::Message};
use serde::{Serialize, Deserialize};
use std::net::{SocketAddr, ToSocketAddrs};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_p2p::{SDPManager, PublicKey};  // Use re-exported PublicKey

#[derive(Debug, Serialize, Deserialize)]
pub enum NetworkEvent {
    VoteUpdate { proposal_id: String, votes: u32 },
    ReputationChange { member_id: String, score: i32 },
    MembershipUpdate { members: Vec<String> },
    StateChange { key: String, value: String },
}

#[derive(Debug, Clone)]
pub enum NetworkTransport {
    WebSocket,
    SDP,
}

#[derive(Debug, Clone)]
pub struct PeerInfo {
    pub id: String,
    pub addresses: Vec<SocketAddr>,
    pub public_key: Option<PublicKey>,
    pub transport: NetworkTransport,
}

pub struct NetworkLayer {
    gossip_peers: Vec<String>,
    event_tx: mpsc::Sender<NetworkEvent>,
    sdp_manager: Option<Arc<Mutex<SDPManager>>>,
    peers: HashMap<String, PeerInfo>,
}

impl NetworkLayer {
    pub async fn new(bind_addr: Option<&str>) -> Result<Self, String> {
        let (tx, _rx) = mpsc::channel(100);
        let mut layer = Self {
            gossip_peers: Vec::new(),
            event_tx: tx,
            sdp_manager: None,
            peers: HashMap::new(),
        };

        if let Some(addr) = bind_addr {
            layer.initialize(addr).await?;
        }

        Ok(layer)
    }

    pub async fn initialize(&mut self, bind_addr: &str) -> Result<(), String> {
        let addr = bind_addr.to_socket_addrs()
            .map_err(|e| format!("Invalid address: {}", e))?
            .next()
            .ok_or_else(|| "Failed to resolve address".to_string())?;

        match SDPManager::new(addr) {
            Ok(manager) => {
                self.sdp_manager = Some(Arc::new(Mutex::new(manager)));
                
                let manager_clone = self.sdp_manager.as_ref().unwrap().clone();
                tokio::spawn(async move {
                    let handler = |result: Result<(Vec<u8>, SocketAddr, String), String>| {
                        match result {
                            Ok((payload, _addr, sender)) => {  // Prefix unused addr with _
                                println!("Received message from {}: {:?}", sender, payload);
                            }
                            Err(e) => {
                                println!("Error handling message: {}", e);
                            }
                        }
                    };
                    
                    if let Err(e) = manager_clone.lock().await.start(handler).await {
                        eprintln!("SDP manager error: {}", e);
                    }
                });
                
                Ok(())
            }
            Err(e) => Err(format!("Failed to initialize SDP manager: {}", e))
        }
    }

    pub async fn register_peer(&mut self, peer_id: String, public_key: PublicKey, addrs: Vec<SocketAddr>) -> Result<(), String> {
        if let Some(manager) = &self.sdp_manager {
            let manager = manager.lock().await;
            for addr in addrs.clone() {
                manager.register(peer_id.clone(), addr, public_key).await;
            }
            self.peers.insert(peer_id.clone(), PeerInfo {
                id: peer_id,
                addresses: addrs,
                public_key: Some(public_key),
                transport: NetworkTransport::SDP,
            });
            Ok(())
        } else {
            Err("SDP manager not initialized".to_string())
        }
    }

    pub async fn send_message(&self, peer_id: &str, data: Vec<u8>, priority: u8) -> Result<(), String> {
        if let Some(manager) = &self.sdp_manager {
            manager.lock().await.send_message(peer_id, data, priority).await?;
        }
        Ok(())
    }

    pub fn get_public_key(&self) -> Option<PublicKey> {
        self.sdp_manager.as_ref().map(|sdp| {
            let guard = futures::executor::block_on(sdp.lock());
            guard.get_public_key()
        })
    }

    pub async fn broadcast_event(&self, event: NetworkEvent) -> Result<(), String> {
        let json = serde_json::to_string(&event)
            .map_err(|e| format!("Serialization error: {}", e))?;
        let bytes = json.as_bytes();
        
        if let Some(sdp) = &self.sdp_manager {
            let manager = sdp.lock().await;
            
            for (peer_id, peer_info) in &self.peers {
                if let NetworkTransport::SDP = peer_info.transport {
                    let priority = match &event {
                        NetworkEvent::VoteUpdate { .. } => 8,
                        NetworkEvent::StateChange { .. } => 6,
                        _ => 4,
                    };
                    
                    if let Err(e) = manager.send_message(peer_id, bytes.to_vec(), priority).await {
                        eprintln!("Failed to send SDP message to {}: {}", peer_id, e);
                    }
                }
            }
        }

        // Legacy WebSocket broadcast
        for peer in &self.gossip_peers {
            if let Some(peer_info) = self.peers.get(peer) {
                if let NetworkTransport::WebSocket = peer_info.transport {
                    // WebSocket send logic here
                }
            }
        }

        Ok(())
    }

    pub async fn handle_websocket_connection(&self, mut stream: WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>) {
        while let Some(msg) = stream.next().await {
            if let Ok(msg) = msg {
                if let Message::Text(text) = msg {
                    if let Ok(event) = serde_json::from_str(&text) {
                        let _ = self.event_tx.send(event).await;
                    }
                }
            }
        }
    }
}
```

===================
File: ./src/network/mod.rs
Size: 22 bytes
===================
```rs
pub mod communication;```

===================
File: ./src/services/event_service.rs
Size: 1060 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use tokio::sync::mpsc;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DomainEvent {
    VoteCast {
        proposal_id: String,
        voter: String,
        vote: bool,
    },
    ReputationChanged {
        member_id: String,
        delta: i32,
    },
    MembershipChanged {
        member_id: String,
        action: String,
    }
}

pub struct EventService {
    event_tx: mpsc::Sender<DomainEvent>,
}

impl EventService {
    pub fn new() -> Self {
        let (tx, mut rx) = mpsc::channel(100);
        // Spawn event processor
        tokio::spawn(async move {
            while let Some(event) = rx.recv().await {
                // Process domain events
                println!("Processing domain event: {:?}", event);
            }
        });
        
        Self {
            event_tx: tx,
        }
    }

    pub async fn publish(&self, event: DomainEvent) {
        if let Err(e) = self.event_tx.send(event).await {
            eprintln!("Failed to publish event: {}", e);
        }
    }
}
```

===================
File: ./src/services/mod.rs
Size: 22 bytes
===================
```rs
pub mod event_service;```

===================
File: ./src/storage/event_store.rs
Size: 850 bytes
===================
```rs
use std::sync::RwLock;
use std::collections::HashMap;
use crate::services::event_service::DomainEvent;

pub struct EventStore {
    events: RwLock<HashMap<String, Vec<DomainEvent>>>,
}

impl EventStore {
    pub fn new() -> Self {
        Self {
            events: RwLock::new(HashMap::new()),
        }
    }

    pub fn append(&self, stream_id: &str, event: DomainEvent) -> Result<(), String> {
        let mut events = self.events.write().map_err(|_| "Lock error")?;
        events.entry(stream_id.to_string())
            .or_insert_with(Vec::new)
            .push(event);
        Ok(())
    }

    pub fn get_stream(&self, stream_id: &str) -> Result<Vec<DomainEvent>, String> {
        let events = self.events.read().map_err(|_| "Lock error")?;
        Ok(events.get(stream_id)
            .cloned()
            .unwrap_or_default())
    }
}
```

===================
File: ./src/storage/mod.rs
Size: 20 bytes
===================
```rs
pub mod event_store;```

===================
Summary for 02_backend
===================
Total size of dump: 2392 bytes
Patterns included:
- backend/src/blockchain.rs
- backend/src/core.rs
- backend/src/database.rs
- backend/src/db.rs
- backend/src/federation.rs
- backend/src/governance.rs
- backend/src/identity.rs
- backend/src/lib.rs
- backend/src/main.rs
- backend/src/models.rs
- backend/src/networking.rs
- backend/src/notification.rs
- backend/src/reputation.rs
- backend/src/resources.rs
- backend/src/routes.rs
- backend/src/services.rs
- backend/src/storage.rs
- backend/src/test_config.rs
- backend/src/test_macros.rs
- backend/src/test_utils.rs
- backend/src/vm.rs
- backend/src/api/cooperative.rs
- backend/src/api/federation.rs
- backend/src/api/federation_resource_sharing.rs
- backend/src/api/governance.rs
- backend/src/api/handlers.rs
- backend/src/api/health.rs
- backend/src/api/identity.rs
- backend/src/api/mod.rs
- backend/src/api/reputation.rs
- backend/src/api/resources.rs
- backend/src/api/routes.rs
- backend/src/core/consensus.rs
- backend/src/core/ledger.rs
- backend/src/database/db.rs
- backend/src/database/migrations.rs
- backend/src/database/models.rs
- backend/src/database/queries.rs
- backend/src/db/indexing.rs
- backend/src/middleware/mod.rs
- backend/src/middleware/rate_limit.rs
- backend/src/networking/p2p.rs
- backend/src/networking/rpc.rs
- backend/src/networking/websocket.rs
- backend/src/services/cooperative_service.rs
- backend/src/services/federation_service.rs
- backend/src/services/governance.rs
- backend/src/services/governance_service.rs
- backend/src/services/identity_service.rs
- backend/src/services/mod.rs
- backend/src/services/reputation_service.rs
- backend/src/services/storage_service.rs
- backend/src/websocket/mod.rs
- src/block.rs
- src/lib.rs
- src/main.rs
- src/parser.rs
- src/api/handlers.rs
- src/api/mod.rs
- src/api/routes.rs
- src/attestation/mod.rs
- src/consensus/mod.rs
- src/dsl/governance.rs
- src/dsl/mod.rs
- src/dsl/parser.rs
- src/dsl/vm.rs
- src/governance/mod.rs
- src/governance/rollback.rs
- src/network/communication.rs
- src/network/mod.rs
- src/services/event_service.rs
- src/services/mod.rs
- src/storage/event_store.rs
- src/storage/mod.rs
- src/*/*/*.rs

Files processed: 103
===================
