Project Tree:
=============
.
├── Cargo.lock
├── Cargo.toml
├── generate_code_dump.sh
├── project_code_dump.txt
└── src
    ├── blockchain.rs
    ├── did.rs
    ├── governance.rs
    ├── main.rs
    ├── notifications.rs
    ├── reputation.rs
    └── transaction.rs

2 directories, 11 files



===================
File: src/notifications.rs
===================
// notifications.rs

use chrono::{Utc, DateTime};

#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}



===================
File: src/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::{Serialize, Deserialize};
use serde::ser::{Serializer, SerializeStruct};
use serde::de::{self, Deserializer, Visitor};
use std::fmt;

/// Struct representing a decentralized identifier (DID)
#[derive(Debug, Clone)]
pub struct DID {
    pub id: String,
    pub public_key: PublicKey,
}

impl DID {
    /// Creates a new DID with a specified identifier and an existing secret key.
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);

        DID { id, public_key }
    }

    /// Generates a new random DID and secret key pair.
    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let secret_key = SecretKey::from_slice(&rand::random::<[u8; 32]>()).expect("32 bytes, within curve order");
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);

        let did = DID { id, public_key };
        (did, secret_key)
    }
}

// Custom serialization for DID
impl Serialize for DID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut state = serializer.serialize_struct("DID", 2)?;
        state.serialize_field("id", &self.id)?;
        state.serialize_field("public_key", &self.public_key.to_string())?;  // Serialize public_key as a string
        state.end()
    }
}



===================
File: src/governance.rs
===================
// governance.rs

use chrono::Utc;
use std::collections::VecDeque;

#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: VecDeque<Proposal>,
    pub notifications: VecDeque<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: VecDeque::new(),
            notifications: VecDeque::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.push_back(proposal);
        self.notifications.push_back("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.iter_mut().find(|p| p.id == proposal_id) {
            proposal.close();
            self.notifications.push_back(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.iter() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push_back(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in &self.proposals {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}



===================
File: src/main.rs
===================
// main.rs

mod blockchain;
mod did;
mod transaction;
mod reputation;
mod governance;
mod notifications;

use blockchain::Blockchain;
use did::DID;
use transaction::Transaction;
use reputation::ReputationSystem;
use governance::{Proposal, ProposalType, ProposalStatus, ProposalHistory};
use std::collections::VecDeque;

fn main() {
    let mut blockchain = Blockchain::new();
    let mut reputation_system = ReputationSystem::new();
    let mut proposal_history = ProposalHistory::new();

    let (sender_did, _) = DID::generate_random(String::from("did:icn:001"));
    let (receiver_did, _) = DID::generate_random(String::from("did:icn:002"));

    // Create and add transactions
    let transaction1 = Transaction::new(sender_did.id.clone(), receiver_did.id.clone(), 100);
    blockchain.add_transaction(transaction1.clone());
    reputation_system.increase_reputation(&sender_did.id, 10);

    let transaction2 = Transaction::new(receiver_did.id.clone(), sender_did.id.clone(), 50);
    blockchain.add_transaction(transaction2.clone());
    reputation_system.decrease_reputation(&receiver_did.id, 5);

    // Finalize the block instead of mining
    blockchain.finalize_block();

    // Create proposals
    let mut funding_proposal = Proposal::new(
        1,
        ProposalType::Funding,
        String::from("Increase community funding"),
    );

    let mut policy_proposal = Proposal::new(
        2,
        ProposalType::PolicyChange,
        String::from("Amend community policy"),
    );

    let mut allocation_proposal = Proposal::new(
        3,
        ProposalType::ResourceAllocation,
        String::from("Allocate 500 units for community project"),
    );

    // Fetch reputations for DID holders
    let sender_reputation = reputation_system.get_reputation(&sender_did.id);
    let receiver_reputation = reputation_system.get_reputation(&receiver_did.id);

    // Voting on proposals
    if funding_proposal.validate(ProposalType::Funding) {
        funding_proposal.vote(&sender_did.id, sender_reputation);
        reputation_system.reward_voting(&sender_did.id, 2);
    }

    if policy_proposal.validate(ProposalType::PolicyChange) {
        policy_proposal.vote(&receiver_did.id, receiver_reputation);
        reputation_system.reward_voting(&receiver_did.id, 2);
    }

    if allocation_proposal.validate(ProposalType::ResourceAllocation) {
        allocation_proposal.vote(&sender_did.id, sender_reputation);
        allocation_proposal.vote(&receiver_did.id, receiver_reputation);
        reputation_system.reward_voting(&sender_did.id, 2);
        reputation_system.reward_voting(&receiver_did.id, 2);
    }

    // Checking proposal statuses and notifying users
    funding_proposal.check_and_notify(15);
    policy_proposal.check_and_notify(15);
    allocation_proposal.check_and_notify(15);

    funding_proposal.close();
    policy_proposal.close();
    allocation_proposal.close();

    // Adding proposals to history and sending reminders
    proposal_history.add_proposal(funding_proposal);
    proposal_history.add_proposal(policy_proposal);
    proposal_history.add_proposal(allocation_proposal);

    proposal_history.send_voting_reminder();

    // Displaying proposal history and blockchain details
    println!("\n=== Proposal History ===");
    proposal_history.display_history();

    println!("Blockchain: {:?}", blockchain.chain);
    println!(
        "Reputation Scores:\nSender: {} => {}\nReceiver: {} => {}",
        sender_did.id,
        reputation_system.get_reputation(&sender_did.id),
        receiver_did.id,
        reputation_system.get_reputation(&receiver_did.id)
    );
}



===================
File: src/transaction.rs
===================
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,       // DID of sender
    pub receiver: String,     // DID of receiver
    pub amount: u64,          // Amount/value exchanged
    pub timestamp: u128,      // Transaction timestamp
    pub hash: String,         // Hash to secure transaction
}

impl Transaction {
    /// Creates a new transaction and calculates its hash
    pub fn new(sender: String, receiver: String, amount: u64) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = calculate_transaction_hash(&sender, &receiver, amount, timestamp);

        Transaction {
            sender,
            receiver,
            amount,
            timestamp,
            hash,
        }
    }
}

/// Calculate the transaction hash based on transaction details
fn calculate_transaction_hash(sender: &str, receiver: &str, amount: u64, timestamp: u128) -> String {
    let mut hasher = Sha256::new();
    hasher.update(format!("{}{}{}{}", sender, receiver, amount, timestamp));
    let result = hasher.finalize();
    format!("{:x}", result)
}



===================
File: src/reputation.rs
===================
// reputation.rs

use std::collections::HashMap;

pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) += amount;
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) -= amount;
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        self.increase_reputation(did, reward_points);
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }
}



===================
File: src/blockchain.rs
===================
// src/blockchain.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use crate::transaction::Transaction;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u128,
    pub transactions: Vec<Transaction>, // Vector to hold transactions
    pub hash: String,
}

impl Block {
    /// Creates a new block with a list of transactions and calculates its hash.
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = calculate_hash(index, &previous_hash, timestamp, &transactions);

        Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash,
        }
    }
}

/// Calculates a hash for the block based on its contents.
fn calculate_hash(index: u64, previous_hash: &str, timestamp: u128, transactions: &Vec<Transaction>) -> String {
    let mut hasher = Sha256::new();
    let transaction_data = serde_json::to_string(transactions).expect("Failed to serialize transactions");
    hasher.update(format!("{}{}{}{}", index, previous_hash, timestamp, transaction_data));
    let result = hasher.finalize();
    format!("{:x}", result)
}

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: usize,
}

impl Blockchain {
    /// Initializes a new blockchain with a genesis block.
    pub fn new() -> Self {
        let genesis_block = Block::new(0, String::from("0"), vec![]);
        Blockchain {
            chain: vec![genesis_block],
            pending_transactions: vec![],
            difficulty: 2,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    pub fn add_transaction(&mut self, transaction: Transaction) {
        self.pending_transactions.push(transaction);
    }

    /// Finalizes a new block with pending transactions.
    pub fn finalize_block(&mut self) {
        let previous_hash = self.chain.last().unwrap().hash.clone();
        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        self.chain.push(new_block);
        self.pending_transactions.clear();
    }
}



