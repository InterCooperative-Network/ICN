Project Code Dump - Generated Sat Nov  2 02:25:38 AM UTC 2024
======================================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── lib.rs
│   ├── src
│   │   ├── api
│   │   │   ├── cooperative.rs
│   │   │   └── mod.rs
│   │   ├── blockchain
│   │   │   ├── mod.rs
│   │   │   └── transaction.rs
│   │   ├── config
│   │   ├── cooperative
│   │   │   └── mod.rs
│   │   ├── governance
│   │   │   └── mod.rs
│   │   ├── identity
│   │   │   ├── did.rs
│   │   │   └── mod.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── reputation
│   │   │   └── mod.rs
│   │   ├── utils
│   │   │   ├── mod.rs
│   │   │   └── notifications.rs
│   │   └── vm
│   │       └── mod.rs
│   ├── target
│   │   ├── CACHEDIR.TAG
│   │   ├── debug
│   │   │   ├── build
│   │   │   ├── deps
│   │   │   ├── examples
│   │   │   ├── icn-backend
│   │   │   ├── icn-backend.d
│   │   │   └── incremental
│   │   └── tmp
│   └── tests
│       └── integration_test.rs
├── contracts
│   ├── cooperative
│   │   └── src
│   │       └── lib.rs
│   └── governance
├── docker
│   ├── backend.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── docs
│   ├── INDEX.md
│   ├── README.md
│   ├── api
│   ├── architecture
│   │   ├── backend
│   │   ├── diagrams
│   │   │   ├── component
│   │   │   ├── sequence
│   │   │   └── system
│   │   ├── frontend
│   │   └── overview
│   ├── development
│   │   ├── guides
│   │   │   └── documentation-standards.md
│   │   ├── plans
│   │   └── setup
│   ├── guides
│   ├── specifications
│   │   ├── api
│   │   ├── core
│   │   │   └── 2024-11-01-reputation-system.md
│   │   └── protocols
│   ├── templates
│   │   ├── api-template.md
│   │   ├── core-component-template.md
│   │   └── protocol-template.md
│   └── user
│       ├── guides
│       └── tutorials
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   │   ├── cooperative
│   │   │   ├── governance
│   │   │   ├── identity
│   │   │   └── ui
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── project_code_dump.txt
├── setup_docs.sh
├── setup_venv.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── docmanager.cpython-312.pyc
    │   │   └── specgen.cpython-312.pyc
    │   ├── docmanager.py
    │   ├── docsctl
    │   └── specgen.py
    ├── install_docsctl.sh
    └── requirements.txt

63 directories, 49 files


===================
File: ./backend/src/identity/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::Serialize;

/// Struct representing a decentralized identifier (DID)
#[derive(Debug, Clone)]
pub struct DID {
    pub id: String,
    pub public_key: PublicKey,
}

impl DID {
    /// Creates a new DID with a specified identifier and an existing secret key.
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);

        DID { id, public_key }
    }

    /// Generates a new random DID and secret key pair.
    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let secret_key = SecretKey::from_slice(&rand::random::<[u8; 32]>()).expect("32 bytes, within curve order");
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);

        let did = DID { id, public_key };
        (did, secret_key)
    }
}

// Custom serialization for DID
impl Serialize for DID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("DID", 2)?;
        state.serialize_field("id", &self.id)?;
        state.serialize_field("public_key", &self.public_key.to_string())?;
        state.end()
    }
}

===================
File: ./backend/src/identity/mod.rs
===================
pub mod did;

pub use did::DID;

===================
File: ./backend/src/cooperative/mod.rs
===================


===================
File: ./backend/src/utils/notifications.rs
===================
use chrono::{DateTime, Utc};
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}

===================
File: ./backend/src/utils/mod.rs
===================
pub mod notifications;



===================
File: ./backend/src/vm/mod.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
#[allow(dead_code)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OpCode {
    // Stack Operations
    Push,
    Pop,
    Dup,      
    Swap,     
    
    // Arithmetic Operations
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    
    // Memory Operations
    Store,    
    Load,     
    
    // Control Flow
    Call,     
    Return,   
    Jump,     
    JumpIf,   
    
    // Cooperative Operations
    CooperativeAction,
    CreateCooperative,
    JoinCooperative,
    LeaveCooperative,
    AllocateResource,
    TransferResource,
    UpdateCooperativeMetadata,
    AddCooperativeMember,
    RemoveCooperativeMember,
    SetMemberRole,
    
    // Resource Management
    CreateResource,
    AssignResource,
    RevokeResource,
    ShareResource,
    CheckResourceAvailability,
    
    // Governance Operations
    CreateProposal,
    CastVote,
    DelegateVotes,
    ExecuteProposal,
    CalculateVotingWeight,
    CancelProposal,
    ExtendVotingPeriod,
    UpdateQuorum,
    
    // Reputation Operations
    UpdateReputation,
    GetReputation,
    TransferReputation,
    BurnReputation,
    MintReputation,
    SetReputationContext,
    MergeReputationContexts,
    
    // Identity Operations
    VerifyDID,
    UpdateDIDDocument,
    CreateCredential,
    VerifyCredential,
    RevokeCredential,
    
    // Federation Operations
    InitiateFederation,
    JoinFederation,
    LeaveFederation,
    SyncFederationState,
    ValidateFederationAction,
    
    // Transaction Operations
    CreateTransaction,
    ValidateTransaction,
    SignTransaction,
    BroadcastTransaction,
    
    // System Operations
    Log,      
    Halt,     
    EmitEvent,
    GetBlockNumber,
    GetTimestamp,
    GetCaller,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceImpact {
    pub cpu_intensity: u32,
    pub memory_usage: u32,
    pub network_usage: u32,
    pub storage_usage: u32,
    pub bandwidth_usage: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CooperativeMetadata {
    pub creator_did: String,
    pub cooperative_id: String,
    pub purpose: String,
    pub resource_impact: ResourceImpact,
    pub federation_id: Option<String>,
    pub creation_timestamp: u64,
    pub last_updated: u64,
    pub member_count: u32,
    pub resource_allocation: HashMap<String, u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contract {
    pub code: Vec<(OpCode, Option<i64>)>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}

#[derive(Debug)]
pub struct ExecutionContext {
    pub caller_did: String,
    pub cooperative_id: String,
    pub block_number: u64,
    pub timestamp: u64,
    pub federation_context: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub event_type: String,
    pub cooperative_id: String,
    pub data: HashMap<String, String>,
    pub timestamp: u64,
}

#[derive(Debug)]
pub struct VM {
    stack: Vec<i64>,
    memory: HashMap<String, i64>,
    program_counter: usize,
    contribution_credits: u64,
    reputation_context: HashMap<String, i64>,
    execution_context: Option<ExecutionContext>,
    logs: Vec<String>,
    events: Vec<Event>,
    state: HashMap<String, Vec<u8>>,
}

impl VM {
    pub fn new(contribution_limit: u64, reputation_context: HashMap<String, i64>) -> Self {
        VM {
            stack: Vec::new(),
            memory: HashMap::new(),
            program_counter: 0,
            contribution_credits: contribution_limit,
            reputation_context,
            execution_context: None,
            logs: Vec::new(),
            events: Vec::new(),
            state: HashMap::new(),
        }
    }

    pub fn set_execution_context(&mut self, context: ExecutionContext) {
        self.execution_context = Some(context);
    }

    pub fn execute_contract(&mut self, contract: &Contract) -> Result<i64, String> {
        // Verify reputation requirements
        if let Some(context) = &self.execution_context {
            let caller_reputation = self.reputation_context
                .get(&context.caller_did)
                .copied()
                .unwrap_or(0);
            
            if caller_reputation < contract.required_reputation {
                return Err("Insufficient reputation to execute contract".to_string());
            }
        }

        while self.program_counter < contract.code.len() {
            let (op, value) = &contract.code[self.program_counter];
            self.execute_instruction(op, *value, &contract.cooperative_metadata)?;
            self.program_counter += 1;

            // Check contribution credits
            if self.contribution_credits == 0 {
                return Err("Out of contribution credits".to_string());
            }
            self.contribution_credits -= 1;
        }

        Ok(self.stack.pop().unwrap_or(0))
    }

    pub fn execute_instruction(&mut self, op: &OpCode, value: Option<i64>, metadata: &CooperativeMetadata) -> Result<(), String> {
        match op {
            // Stack Operations
            OpCode::Push => {
                if let Some(v) = value {
                    self.stack.push(v);
                }
                Ok(())
            }
            OpCode::Pop => {
                self.stack.pop().ok_or("Stack underflow")?;
                Ok(())
            }
            OpCode::Dup => {
                if let Some(&v) = self.stack.last() {
                    self.stack.push(v);
                    Ok(())
                } else {
                    Err("Stack underflow".to_string())
                }
            }
            OpCode::Swap => {
                if self.stack.len() >= 2 {
                    let len = self.stack.len();
                    self.stack.swap(len - 1, len - 2);
                    Ok(())
                } else {
                    Err("Stack underflow".to_string())
                }
            }

            // Arithmetic Operations
            OpCode::Add => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a + b);
                Ok(())
            }
            OpCode::Sub => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a - b);
                Ok(())
            }
            OpCode::Mul => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a * b);
                Ok(())
            }
            OpCode::Div => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Division by zero".to_string());
                }
                self.stack.push(a / b);
                Ok(())
            }
            OpCode::Mod => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Modulo by zero".to_string());
                }
                self.stack.push(a % b);
                Ok(())
            }

            // Memory Operations
            OpCode::Store => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                let key = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(key.to_string(), value);
                Ok(())
            }
            OpCode::Load => {
                let key = self.stack.pop().ok_or("Stack underflow")?;
                let value = self.memory.get(&key.to_string()).copied().unwrap_or(0);
                self.stack.push(value);
                Ok(())
            }

            // Cooperative Operations
            OpCode::CreateCooperative => self.handle_create_cooperative(metadata),
            OpCode::JoinCooperative => self.handle_join_cooperative(metadata),
            OpCode::AllocateResource => self.handle_allocate_resource(value, metadata),
            OpCode::LeaveCooperative => self.handle_leave_cooperative(metadata),

            // Governance Operations
            OpCode::CreateProposal => self.handle_create_proposal(metadata),
            OpCode::CastVote => self.handle_cast_vote(value, metadata),
            OpCode::CalculateVotingWeight => self.handle_calculate_voting_weight(value, metadata),

            // Federation Operations
            OpCode::InitiateFederation => self.handle_federation_operation(op, metadata),
            OpCode::JoinFederation => self.handle_federation_operation(op, metadata),

            // Resource Operations
            OpCode::CreateResource => self.handle_resource_operation(op, value, metadata),
            OpCode::ShareResource => self.handle_resource_operation(op, value, metadata),

            // System Operations
            OpCode::Log => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.logs.push(format!("Log: {}", value));
                Ok(())
            }
            OpCode::Halt => Ok(()),
            OpCode::EmitEvent => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event("CustomEvent", metadata.cooperative_id.clone(), 
                    HashMap::from([("value".to_string(), value.to_string())]));
                Ok(())
            }

            _ => Err(format!("Opcode {:?} not implemented", op)),
        }
    }

    fn handle_create_cooperative(&mut self, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            self.emit_event(
                "CooperativeCreated",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("creator".to_string(), context.caller_did.clone()),
                    ("purpose".to_string(), metadata.purpose.clone()),
                ])
            );
            Ok(())
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_join_cooperative(&mut self, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            self.emit_event(
                "CooperativeJoined",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("member".to_string(), context.caller_did.clone()),
                ])
            );
            Ok(())
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_leave_cooperative(&mut self, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            self.emit_event(
                "CooperativeLeft",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("member".to_string(), context.caller_did.clone()),
                ])
            );
            Ok(())
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_allocate_resource(&mut self, resource_id: Option<i64>, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(id) = resource_id {
            // Check resource impact
            if metadata.resource_impact.cpu_intensity > 80 || 
               metadata.resource_impact.memory_usage > 80 || 
               metadata.resource_impact.network_usage > 80 {
                return Err("Resource impact too high".to_string());
            }

            self.emit_event(
                "ResourceAllocated",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("resource_id".to_string(), id.to_string()),
                ])
            );
            self.memory.insert(format!("resource_{}", id), 1);
            Ok(())
        } else {
            Err("Missing resource ID".to_string())
        }
    }

    fn handle_create_proposal(&mut self, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            let caller_reputation = self.reputation_context
                .get(&context.caller_did)
                .copied()
                .unwrap_or(0);
            
            if caller_reputation < 100 {
                return Err("Insufficient reputation to create proposal".to_string());
            }

            self.emit_event(
                "ProposalCreated",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("creator".to_string(), context.caller_did.clone()),
                ])
            );
            Ok(())
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_cast_vote(&mut self, vote_value: Option<i64>, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            if let Some(value) = vote_value {
                self.emit_event(
                    "VoteCast",
                    metadata.cooperative_id.clone(),
                    HashMap::from([
                        ("voter".to_string(), context.caller_did.clone()),
                        ("vote".to_string(), value.to_string()),
                    ])
                );
                Ok(())
            } else {
                Err("Missing vote value".to_string())
            }
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_calculate_voting_weight(&mut self, _weight_id: Option<i64>, metadata: &CooperativeMetadata) -> Result<(), String> {
        if let Some(context) = &self.execution_context {
            let reputation = self.reputation_context
                .get(&context.caller_did)
                .copied()
                .unwrap_or(0);
            
            let weight = (reputation as f64 * 0.7 + 100.0) as i64;
            
            self.stack.push(weight);
            self.emit_event(
                "VotingWeightCalculated",
                metadata.cooperative_id.clone(),
                HashMap::from([
                    ("member".to_string(), context.caller_did.clone()),
                    ("weight".to_string(), weight.to_string()),
                ])
            );
            Ok(())
        } else {
            Err("No execution context".to_string())
        }
    }

    fn handle_federation_operation(&mut self, op: &OpCode, metadata: &CooperativeMetadata) -> Result<(), String> {
        match op {
            OpCode::InitiateFederation => {
                if let Some(context) = &self.execution_context {
                    self.emit_event(
                        "FederationInitiated",
                        metadata.cooperative_id.clone(),
                        HashMap::from([
                            ("initiator".to_string(), context.caller_did.clone()),
                        ])
                    );
                    Ok(())
                } else {
                    Err("No execution context".to_string())
                }
            },
            OpCode::JoinFederation => {
                if let Some(fed_id) = &metadata.federation_id {
                    if let Some(context) = &self.execution_context {
                        self.emit_event(
                            "FederationJoined",
                            metadata.cooperative_id.clone(),
                            HashMap::from([
                                ("federation_id".to_string(), fed_id.clone()),
                                ("member".to_string(), context.caller_did.clone()),
                            ])
                        );
                        Ok(())
                    } else {
                        Err("No execution context".to_string())
                    }
                } else {
                    Err("No federation ID specified".to_string())
                }
            },
            _ => Err("Federation operation not implemented".to_string())
        }
    }

    fn handle_resource_operation(&mut self, op: &OpCode, value: Option<i64>, metadata: &CooperativeMetadata) -> Result<(), String> {
        match op {
            OpCode::CreateResource => {
                if let Some(resource_id) = value {
                    if metadata.resource_impact.cpu_intensity > 80 || 
                       metadata.resource_impact.memory_usage > 80 {
                        return Err("Resource impact too high".to_string());
                    }
                    
                    self.emit_event(
                        "ResourceCreated",
                        metadata.cooperative_id.clone(),
                        HashMap::from([
                            ("resource_id".to_string(), resource_id.to_string()),
                        ])
                    );
                    Ok(())
                } else {
                    Err("Missing resource ID".to_string())
                }
            },
            OpCode::ShareResource => {
                if let Some(resource_id) = value {
                    if let Some(context) = &self.execution_context {
                        self.emit_event(
                            "ResourceShared",
                            metadata.cooperative_id.clone(),
                            HashMap::from([
                                ("resource_id".to_string(), resource_id.to_string()),
                                ("shared_by".to_string(), context.caller_did.clone()),
                            ])
                        );
                        Ok(())
                    } else {
                        Err("No execution context".to_string())
                    }
                } else {
                    Err("Missing resource ID".to_string())
                }
            },
            _ => Err("Resource operation not implemented".to_string())
        }
    }

    fn emit_event(&mut self, event_type: &str, cooperative_id: String, data: HashMap<String, String>) {
        if let Some(context) = &self.execution_context {
            let event = Event {
                event_type: event_type.to_string(),
                cooperative_id,
                data,
                timestamp: context.timestamp,
            };
            self.events.push(event);
        }
    }

    pub fn get_logs(&self) -> &Vec<String> {
        &self.logs
    }

    pub fn get_events(&self) -> &Vec<Event> {
        &self.events
    }

    pub fn get_stack(&self) -> &Vec<i64> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_metadata() -> CooperativeMetadata {
        CooperativeMetadata {
            creator_did: "did:icn:test".to_string(),
            cooperative_id: "test-coop".to_string(),
            purpose: "Test Cooperative".to_string(),
            resource_impact: ResourceImpact {
                cpu_intensity: 10,
                memory_usage: 10,
                network_usage: 10,
                storage_usage: 10,
                bandwidth_usage: 10,
            },
            federation_id: None,
            creation_timestamp: 1635724800,
            last_updated: 1635724800,
            member_count: 1,
            resource_allocation: HashMap::new(),
        }
    }

    fn create_test_context() -> ExecutionContext {
        ExecutionContext {
            caller_did: "did:icn:test".to_string(),
            cooperative_id: "test-coop".to_string(),
            block_number: 1,
            timestamp: 1635724800,
            federation_context: None,
        }
    }

    #[test]
    fn test_stack_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let metadata = create_test_metadata();

        // Test Push and Pop
        vm.execute_instruction(&OpCode::Push, Some(42), &metadata).unwrap();
        assert_eq!(vm.get_stack().last(), Some(&42));

        // Test Dup
        vm.execute_instruction(&OpCode::Dup, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().len(), 2);
        assert_eq!(vm.get_stack().last(), Some(&42));

        // Test Swap
        vm.execute_instruction(&OpCode::Push, Some(24), &metadata).unwrap();
        vm.execute_instruction(&OpCode::Swap, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().len(), 3);
        assert_eq!(vm.get_stack()[vm.get_stack().len() - 1], 42);
        assert_eq!(vm.get_stack()[vm.get_stack().len() - 2], 24);
    }

    #[test]
    fn test_arithmetic_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let metadata = create_test_metadata();

        // Setup stack for arithmetic
        vm.execute_instruction(&OpCode::Push, Some(10), &metadata).unwrap();
        vm.execute_instruction(&OpCode::Push, Some(5), &metadata).unwrap();

        // Test Add
        vm.execute_instruction(&OpCode::Add, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().last(), Some(&15));

        // Test Sub
        vm.execute_instruction(&OpCode::Push, Some(3), &metadata).unwrap();
        vm.execute_instruction(&OpCode::Sub, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().last(), Some(&12));

        // Test Mul
        vm.execute_instruction(&OpCode::Push, Some(4), &metadata).unwrap();
        vm.execute_instruction(&OpCode::Mul, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().last(), Some(&48));

        // Test Div
        vm.execute_instruction(&OpCode::Push, Some(6), &metadata).unwrap();
        vm.execute_instruction(&OpCode::Div, None, &metadata).unwrap();
        assert_eq!(vm.get_stack().last(), Some(&8));
    }

    #[test]
    fn test_cooperative_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let metadata = create_test_metadata();
        vm.set_execution_context(create_test_context());

        // Test CreateCooperative
        vm.execute_instruction(&OpCode::CreateCooperative, None, &metadata).unwrap();
        assert!(!vm.get_events().is_empty());
        assert_eq!(vm.get_events()[0].event_type, "CooperativeCreated");

        // Test JoinCooperative
        vm.execute_instruction(&OpCode::JoinCooperative, None, &metadata).unwrap();
        assert_eq!(vm.get_events()[1].event_type, "CooperativeJoined");
    }

    #[test]
    fn test_resource_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let metadata = create_test_metadata();
        vm.set_execution_context(create_test_context());

        // Test CreateResource
        vm.execute_instruction(&OpCode::CreateResource, Some(1), &metadata).unwrap();
        assert!(!vm.get_events().is_empty());
        assert_eq!(vm.get_events()[0].event_type, "ResourceCreated");

        // Test ShareResource
        vm.execute_instruction(&OpCode::ShareResource, Some(1), &metadata).unwrap();
        assert_eq!(vm.get_events()[1].event_type, "ResourceShared");
    }

    #[test]
    fn test_federation_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let mut metadata = create_test_metadata();
        metadata.federation_id = Some("fed1".to_string());
        vm.set_execution_context(create_test_context());

        // Test InitiateFederation
        vm.execute_instruction(&OpCode::InitiateFederation, None, &metadata).unwrap();
        assert!(!vm.get_events().is_empty());
        assert_eq!(vm.get_events()[0].event_type, "FederationInitiated");

        // Test JoinFederation
        vm.execute_instruction(&OpCode::JoinFederation, None, &metadata).unwrap();
        assert_eq!(vm.get_events()[1].event_type, "FederationJoined");
    }

    #[test]
    fn test_governance_operations() {
        let mut vm = VM::new(100, HashMap::new());
        let metadata = create_test_metadata();
        let mut reputation_context = HashMap::new();
        reputation_context.insert("did:icn:test".to_string(), 150);
        vm = VM::new(100, reputation_context);
        vm.set_execution_context(create_test_context());

        // Test CreateProposal
        vm.execute_instruction(&OpCode::CreateProposal, None, &metadata).unwrap();
        assert!(!vm.get_events().is_empty());
        assert_eq!(vm.get_events()[0].event_type, "ProposalCreated");

        // Test CastVote
        vm.execute_instruction(&OpCode::CastVote, Some(1), &metadata).unwrap();
        assert_eq!(vm.get_events()[1].event_type, "VoteCast");

        // Test CalculateVotingWeight
        vm.execute_instruction(&OpCode::CalculateVotingWeight, None, &metadata).unwrap();
        assert_eq!(vm.get_events()[2].event_type, "VotingWeightCalculated");
    }
}

===================
File: ./backend/src/api/cooperative.rs
===================


===================
File: ./backend/src/api/mod.rs
===================


===================
File: ./backend/src/blockchain/mod.rs
===================
pub mod transaction;

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use self::transaction::Transaction;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u128,
    pub transactions: Vec<Transaction>, // Vector to hold transactions
    pub hash: String,
}

impl Block {
    /// Creates a new block with a list of transactions and calculates its hash.
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = calculate_hash(index, &previous_hash, timestamp, &transactions);

        Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash,
        }
    }
}

/// Calculates a hash for the block based on its contents.
fn calculate_hash(index: u64, previous_hash: &str, timestamp: u128, transactions: &Vec<Transaction>) -> String {
    let mut hasher = Sha256::new();
    let transaction_data = serde_json::to_string(transactions).expect("Failed to serialize transactions");
    hasher.update(format!("{}{}{}{}", index, previous_hash, timestamp, transaction_data));
    let result = hasher.finalize();
    format!("{:x}", result)
}

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: usize,
}

impl Blockchain {
    /// Initializes a new blockchain with a genesis block.
    pub fn new() -> Self {
        let genesis_block = Block::new(0, String::from("0"), vec![]);
        Blockchain {
            chain: vec![genesis_block],
            pending_transactions: vec![],
            difficulty: 2,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    pub fn add_transaction(&mut self, transaction: Transaction) {
        self.pending_transactions.push(transaction);
    }

    /// Finalizes a new block with pending transactions.
    pub fn finalize_block(&mut self) {
        let previous_hash = self.chain.last().unwrap().hash.clone();
        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        self.chain.push(new_block);
        self.pending_transactions.clear();
    }
}

===================
File: ./backend/src/blockchain/transaction.rs
===================
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,       // DID of sender
    pub receiver: String,     // DID of receiver
    pub amount: u64,          // Amount/value exchanged
    pub timestamp: u128,      // Transaction timestamp
    pub hash: String,         // Hash to secure transaction
}

impl Transaction {
    /// Creates a new transaction and calculates its hash
    pub fn new(sender: String, receiver: String, amount: u64) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = calculate_transaction_hash(&sender, &receiver, amount, timestamp);

        Transaction {
            sender,
            receiver,
            amount,
            timestamp,
            hash,
        }
    }
}

/// Calculate the transaction hash based on transaction details
fn calculate_transaction_hash(sender: &str, receiver: &str, amount: u64, timestamp: u128) -> String {
    let mut hasher = Sha256::new();
    hasher.update(format!("{}{}{}{}", sender, receiver, amount, timestamp));
    let result = hasher.finalize();
    format!("{:x}", result)
}

===================
File: ./backend/src/reputation/mod.rs
===================
use std::collections::HashMap;
#[allow(dead_code)]
pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) += amount;
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) -= amount;
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        self.increase_reputation(did, reward_points);
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }
}

===================
File: ./backend/src/governance/mod.rs
===================
use std::collections::VecDeque;
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: VecDeque<Proposal>,
    pub notifications: VecDeque<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: VecDeque::new(),
            notifications: VecDeque::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.push_back(proposal);
        self.notifications.push_back("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.iter_mut().find(|p| p.id == proposal_id) {
            proposal.close();
            self.notifications.push_back(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.iter() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push_back(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in &self.proposals {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}

===================
File: ./backend/src/main.rs
===================
mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;

use std::collections::HashMap;
use blockchain::{Blockchain, transaction::Transaction};
use identity::DID;
use reputation::ReputationSystem;
use governance::{Proposal, ProposalType, ProposalHistory};
use vm::{VM, Contract, CooperativeMetadata, OpCode, ResourceImpact};

fn main() {
    let mut blockchain = Blockchain::new();
    let mut reputation_system = ReputationSystem::new();
    let mut proposal_history = ProposalHistory::new();

    let (sender_did, _) = DID::generate_random(String::from("did:icn:001"));
    let (receiver_did, _) = DID::generate_random(String::from("did:icn:002"));

    // Create and add transactions
    let transaction1 = Transaction::new(sender_did.id.clone(), receiver_did.id.clone(), 100);
    blockchain.add_transaction(transaction1.clone());
    reputation_system.increase_reputation(&sender_did.id, 10);

    let transaction2 = Transaction::new(receiver_did.id.clone(), sender_did.id.clone(), 50);
    blockchain.add_transaction(transaction2.clone());
    reputation_system.decrease_reputation(&receiver_did.id, 5);

    // Finalize the block
    blockchain.finalize_block();

    // Create proposals for governance
    let proposal1 = Proposal::new(1, ProposalType::Funding, String::from("Proposal for funding development."));
    proposal_history.add_proposal(proposal1);

    let proposal2 = Proposal::new(2, ProposalType::PolicyChange, String::from("Proposal for changing cooperative policy."));
    proposal_history.add_proposal(proposal2);

    // Vote on proposals
    proposal_history.send_voting_reminder();
    proposal_history.proposals[0].vote(&sender_did.id, 10);
    proposal_history.proposals[1].vote(&receiver_did.id, 5);
    proposal_history.proposals[0].close();

    // Display proposal history
    proposal_history.display_history();

    // Create and execute a contract with the new opcode
    let metadata = CooperativeMetadata {
        creator_did: "did:icn:creator".to_string(),
        cooperative_id: "coop1".to_string(),
        purpose: "Allocate resources for development".to_string(),
        resource_impact: ResourceImpact {
            cpu_intensity: 10,
            memory_usage: 10,
            network_usage: 10,
            storage_usage: 10,
            bandwidth_usage: 10,
        },
        federation_id: None,
        creation_timestamp: 1635724800,
        last_updated: 1635724800,
        member_count: 1,
        resource_allocation: HashMap::new(),
    };

    let _contract = Contract {
        code: vec![
            (OpCode::AllocateResource, Some(1)),
            (OpCode::CalculateVotingWeight, None),
            (OpCode::Return, None),
        ],
        state: HashMap::new(),
        required_reputation: 50,
        cooperative_metadata: metadata.clone(),
        version: "1.0.0".to_string(),
        dependencies: Vec::new(),
        permissions: vec!["resource.allocate".to_string(), "voting.calculate".to_string()],
    };

    let mut vm = VM::new(100, reputation_system.scores.clone());
    let execution_context = vm::ExecutionContext {
        caller_did: "did:icn:creator".to_string(),
        cooperative_id: "coop1".to_string(),
        block_number: 1,
        timestamp: 1635724800,
        federation_context: None,
    };
    vm.set_execution_context(execution_context);
    
    let result = vm.execute_instruction(&OpCode::AllocateResource, Some(1), &metadata);
    assert!(result.is_ok());
    println!("VM executed contract successfully.");
}

===================
File: ./backend/src/lib.rs
===================
pub mod blockchain;
pub mod identity;
pub mod reputation;
pub mod governance;
pub mod utils;
pub mod vm;


===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
===================




===================
File: ./frontend/src/components/governance/GovernanceDashboard.tsx
===================
import React, { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { AlertCircle, ChevronRight, Users, TrendingUp } from 'lucide-react'

type Proposal = {
  id: string
  title: string
  description: string
  status: 'active' | 'passed' | 'rejected'
  votesFor: number
  votesAgainst: number
  quorum: number
  createdBy: string
  endsAt: string
  totalVoters: number
  delegatedVotes: number
}

type VotingStats = {
  totalProposals: number
  activeProposals: number
  participationRate: number
  monthlyVotes: Array<{ month: string; votes: number }>
}

const GovernanceDashboard = () => {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [votingStats, setVotingStats] = useState<VotingStats>({
    totalProposals: 0,
    activeProposals: 0,
    participationRate: 0,
    monthlyVotes: []
  })
  const [selectedTab, setSelectedTab] = useState('active')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockProposals: Proposal[] = [
      {
        id: '1',
        title: 'Community Resource Allocation Q3',
        description: 'Proposal to allocate community resources for Q3 projects',
        status: 'active',
        votesFor: 750,
        votesAgainst: 250,
        quorum: 1000,
        createdBy: 'did:icn:alice',
        endsAt: '2024-11-01',
        totalVoters: 1500,
        delegatedVotes: 200
      },
      {
        id: '2',
        title: 'New Cooperation Guidelines',
        description: 'Updated guidelines for inter-cooperative collaboration',
        status: 'passed',
        votesFor: 800,
        votesAgainst: 100,
        quorum: 1000,
        createdBy: 'did:icn:bob',
        endsAt: '2024-10-15',
        totalVoters: 1200,
        delegatedVotes: 150
      }
    ]

    const mockStats = {
      totalProposals: 45,
      activeProposals: 3,
      participationRate: 78.5,
      monthlyVotes: [
        { month: 'Jan', votes: 120 },
        { month: 'Feb', votes: 150 },
        { month: 'Mar', votes: 180 },
        { month: 'Apr', votes: 220 }
      ]
    }

    setProposals(mockProposals)
    setVotingStats(mockStats)
    setLoading(false)
  }, [])

  const calculateProgress = (votesFor: number, votesAgainst: number) => {
    const total = votesFor + votesAgainst
    return total > 0 ? (votesFor / total) * 100 : 0
  }

  const ProposalCard = ({ proposal }: { proposal: Proposal }) => (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-semibold">{proposal.title}</h3>
          <p className="text-sm text-gray-600">{proposal.description}</p>
        </div>
        <span className={`px-2 py-1 rounded text-sm ${
          proposal.status === 'active' ? 'bg-blue-100 text-blue-800' :
          proposal.status === 'passed' ? 'bg-green-100 text-green-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        </span>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculateProgress(proposal.votesFor, proposal.votesAgainst).toFixed(1)}%</span>
        </div>
        <Progress 
          value={calculateProgress(proposal.votesFor, proposal.votesAgainst)} 
          className="h-2"
        />
        
        <div className="flex justify-between text-sm text-gray-600">
          <span>For: {proposal.votesFor}</span>
          <span>Against: {proposal.votesAgainst}</span>
        </div>

        <div className="flex justify-between items-center mt-4">
          <div className="text-sm text-gray-600">
            <p>Created by: {proposal.createdBy}</p>
            <p>Ends: {new Date(proposal.endsAt).toLocaleDateString()}</p>
          </div>
          {proposal.status === 'active' && (
            <Button className="space-x-2">
              <span>Vote Now</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </Card>
  )

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Participation Rate</p>
                <h3 className="text-2xl font-bold">{votingStats.participationRate}%</h3>
              </div>
              <Users className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.totalProposals}</h3>
              </div>
              <TrendingUp className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Voting Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={votingStats.monthlyVotes}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="votes" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Proposals</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList>
              <TabsTrigger value="active">Active</TabsTrigger>
              <TabsTrigger value="passed">Passed</TabsTrigger>
              <TabsTrigger value="rejected">Rejected</TabsTrigger>
            </TabsList>

            <TabsContent value="active" className="space-y-4">
              {proposals
                .filter(p => p.status === 'active')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="passed" className="space-y-4">
              {proposals
                .filter(p => p.status === 'passed')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="rejected" className="space-y-4">
              {proposals
                .filter(p => p.status === 'rejected')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      <Alert>
        <AlertDescription>
          You currently have {proposals[0]?.delegatedVotes || 0} votes delegated to you. 
          Visit the delegation page to manage your voting power.
        </AlertDescription>
      </Alert>
    </div>
  )
}

export default GovernanceDashboard

===================
File: ./backend/Cargo.toml
===================
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.28", features = ["full"] }
axum = "0.6"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
secp256k1 = { version = "0.22.2", features = ["rand"] }
sha2 = "0.10"
rand = "0.8"
tracing = "0.1"
tracing-subscriber = "0.3"

===================
File: ./frontend/package.json
===================


===================
File: ./frontend/tsconfig.json
===================


===================
File: ./docker/docker-compose.yml
===================
version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: backend.Dockerfile
    volumes:
      - .:/app
    ports:
      - "8080:8080"
    command: ["cargo", "run", "--release"]

  test:
    build:
      context: .
      dockerfile: backend.Dockerfile
    command: ["cargo", "test", "--release"]


===================
File: ./docker/backend.Dockerfile
===================
# Start from an official Rust image
FROM rust:latest

# Set the working directory
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . .

# Install any needed dependencies
RUN cargo build --release

# Add integration tests step to Dockerfile
RUN cargo test --release

# Run the binary when the container launches
CMD ["cargo", "run", "--release"]


===================
File: ./docker/frontend.Dockerfile
===================
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
CMD ["npm", "start"]


===================
File: ./docs/INDEX.md
===================
# Documentation Index


## Specification

- [Reputation System](specifications/core/2024-11-01-reputation-system.md) (v1.0.0, draft)


===================
File: ./docs/development/guides/documentation-standards.md
===================
# Documentation Standards

## File Organization

- Use appropriate directory for document type
- Follow naming conventions
- Include required metadata

## Writing Style

- Be clear and concise
- Include code examples where appropriate
- Keep documentation up to date
- Use proper Markdown formatting

## Review Process

1. Create new document using tools
2. Submit for review
3. Address feedback
4. Update documentation index

## Templates

Use provided templates in `docs/templates/` for new documents.


===================
File: ./docs/README.md
===================
# ICN Documentation

## Structure

- `architecture/` - System architecture documentation
- `specifications/` - Technical specifications
- `development/` - Development guides and plans
- `user/` - User documentation and tutorials

## Getting Started

1. Install documentation tools:
   ```bash
   cd tools
   pip install -r requirements.txt
   ```

2. Generate documentation index:
   ```bash
   python tools/doctools/docmanager.py index
   ```

## Documentation Standards

Please refer to `development/guides/documentation-standards.md` for our documentation guidelines.


===================
File: ./docs/templates/protocol-template.md
===================
# {title} Protocol Specification

## 1. Protocol Overview

### 1.1 Purpose

### 1.2 Flow

## 2. Message Formats

## 3. State Machine

## 4. Security Model

## 5. Implementation Guidelines

## 6. Compatibility Requirements

## 7. Future Extensions


===================
File: ./docs/templates/api-template.md
===================
# {title} API Specification

## 1. API Overview

### 1.1 Purpose

### 1.2 Endpoints

## 2. Authentication

## 3. Endpoints Detail

## 4. Error Handling

## 5. Rate Limiting

## 6. Security Considerations

## 7. Example Usage


===================
File: ./docs/templates/core-component-template.md
===================
# {title}

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations


===================
File: ./docs/specifications/core/2024-11-01-reputation-system.md
===================
---
authors:
- Developer Name
date: '2024-11-01'
last_updated: '2024-11-01 00:48:30'
related_docs: []
reviewers:
- Tech Lead
status: draft
title: Reputation System
type: specification
version: 1.0.0

---

# Reputation System

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations



