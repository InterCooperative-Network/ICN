Project Code Dump - Generated Tue Nov 19 05:10:15 PM UTC 2024
======================================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── examples
│   │   ├── blockchain_test.rs
│   │   ├── integration_test.rs
│   │   ├── ws_client.rs
│   │   └── ws_client2.rs
│   ├── lib.rs
│   ├── src
│   │   ├── api
│   │   │   ├── cooperative.rs
│   │   │   └── mod.rs
│   │   ├── blockchain
│   │   │   ├── block.rs
│   │   │   ├── chain.rs
│   │   │   ├── mod.rs
│   │   │   └── transaction.rs
│   │   ├── claims
│   │   │   └── mod.rs
│   │   ├── community
│   │   │   └── mod.rs
│   │   ├── consensus
│   │   │   ├── mod.rs
│   │   │   ├── proof_of_cooperation
│   │   │   │   ├── core.rs
│   │   │   │   ├── events.rs
│   │   │   │   ├── metrics.rs
│   │   │   │   ├── mod.rs
│   │   │   │   ├── round.rs
│   │   │   │   └── validator.rs
│   │   │   ├── proof_of_cooperation.rs.old
│   │   │   ├── tests.rs
│   │   │   └── types.rs
│   │   ├── cooperative
│   │   │   └── mod.rs
│   │   ├── governance
│   │   │   ├── mod.rs
│   │   │   └── proposal.rs
│   │   ├── identity
│   │   │   ├── authentication.rs
│   │   │   ├── did.rs
│   │   │   ├── identity_manager.rs
│   │   │   ├── identity_system.rs
│   │   │   ├── key_pair.rs
│   │   │   └── mod.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── monitoring
│   │   │   ├── energy.rs
│   │   │   └── mod.rs
│   │   ├── network
│   │   │   └── mod.rs
│   │   ├── relationship
│   │   │   ├── mod.rs
│   │   │   └── types.rs
│   │   ├── reputation
│   │   │   ├── mod.rs
│   │   │   └── reputation_system.rs
│   │   ├── utils
│   │   │   ├── mod.rs
│   │   │   └── notifications.rs
│   │   ├── vm
│   │   │   ├── contract.rs
│   │   │   ├── contracts
│   │   │   │   └── voting_rules.rs
│   │   │   ├── cooperative_metadata.rs
│   │   │   ├── event.rs
│   │   │   ├── execution_context.rs
│   │   │   ├── mod.rs
│   │   │   ├── opcode.rs
│   │   │   ├── operations
│   │   │   │   ├── arithmetic.rs
│   │   │   │   ├── community.rs
│   │   │   │   ├── cooperative.rs
│   │   │   │   ├── data.rs
│   │   │   │   ├── federation.rs
│   │   │   │   ├── governance.rs
│   │   │   │   ├── memory.rs
│   │   │   │   ├── mod.rs
│   │   │   │   ├── network.rs
│   │   │   │   ├── relationship.rs
│   │   │   │   ├── reputation.rs
│   │   │   │   ├── stack.rs
│   │   │   │   └── system.rs
│   │   │   ├── tests
│   │   │   │   └── vm_tests.rs
│   │   │   └── vm.rs
│   │   └── websocket
│   │       ├── handler.rs
│   │       └── mod.rs
│   └── tests
│       └── integration_test.rs
├── contracts
│   └── cooperative
│       └── src
│           └── lib.rs
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── frontend
│   ├── package.json
│   ├── src
│   │   └── components
│   │       ├── consensus
│   │       │   └── ConsensusMonitor.tsx
│   │       ├── cooperative
│   │       │   └── CooperativeDashboard.tsx
│   │       ├── governance
│   │       │   └── GovernanceDashboard.tsx
│   │       └── relationship
│   │           └── RelationshipIntegration.tsx
│   └── tsconfig.json
├── generate_code_dump.sh
├── project_code_dump.txt
├── project_docs_dump.txt
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── start_docs_server.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── docmanager.cpython-312.pyc
    │   │   └── specgen.cpython-312.pyc
    │   ├── docmanager.py
    │   ├── docsctl
    │   └── specgen.py
    ├── install_docsctl.sh
    └── requirements.txt

38 directories, 100 files


===================
File: ./backend/src/identity/authentication.rs
===================
// src/identity/authentication.rs

pub struct Authentication {
    // Fields and methods for authentication
}


===================
File: ./backend/src/identity/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::{Serialize, Deserialize};
use rand::{thread_rng, RngCore};
use std::str::FromStr;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    #[serde(serialize_with = "serialize_public_key")]
    #[serde(deserialize_with = "deserialize_public_key")]
    pub public_key: PublicKey,
}

impl DID {
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);
        DID { id, public_key }
    }

    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let mut rng = thread_rng();
        
        // Generate random bytes for the secret key
        let mut secret_key_bytes = [0u8; 32];
        rng.fill_bytes(&mut secret_key_bytes);
        
        // Create secret key from the random bytes
        let secret_key = SecretKey::from_slice(&secret_key_bytes)
            .expect("Random bytes should produce valid key");
            
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);
        let did = DID { id, public_key };
        (did, secret_key)
    }
}

fn serialize_public_key<S>(key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&key.to_string())
}

fn deserialize_public_key<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let key_str = String::deserialize(deserializer)?;
    PublicKey::from_str(&key_str).map_err(serde::de::Error::custom)
}

===================
File: ./backend/src/identity/identity_system.rs
===================
use std::collections::HashMap;
use crate::identity::DID;

#[derive(Clone)]
pub struct IdentitySystem {
    permissions: HashMap<String, Vec<String>>,
    registered_dids: HashMap<String, DID>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        IdentitySystem {
            permissions: HashMap::new(),
            registered_dids: HashMap::new(),
        }
    }

    pub fn get_permissions(&self, did: &str) -> Vec<String> {
        self.permissions.get(did)
            .cloned()
            .unwrap_or_default()
    }

    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.permissions.insert(did.id.clone(), permissions);
        self.registered_dids.insert(did.id.clone(), did);
    }

    pub fn is_registered(&self, did: &str) -> bool {
        self.registered_dids.contains_key(did)
    }

    pub fn add_permission(&mut self, did: &str, permission: String) {
        if let Some(perms) = self.permissions.get_mut(did) {
            if !perms.contains(&permission) {
                perms.push(permission);
            }
        }
    }

    pub fn remove_permission(&mut self, did: &str, permission: &str) {
        if let Some(perms) = self.permissions.get_mut(did) {
            perms.retain(|p| p != permission);
        }
    }

    pub fn get_did(&self, did: &str) -> Option<&DID> {
        self.registered_dids.get(did)
    }
}

===================
File: ./backend/src/identity/key_pair.rs
===================
// src/identity/key_pair.rs

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
}


===================
File: ./backend/src/identity/mod.rs
===================
// src/identity/mod.rs

pub mod did;
// pub mod key_pair;
// pub mod identity_manager;
// pub mod authentication;
pub mod identity_system;

pub use did::DID;
// pub use key_pair::KeyPair;
// pub use identity_manager::IdentityManager;
// pub use authentication::Authentication;
pub use identity_system::IdentitySystem;


===================
File: ./backend/src/identity/identity_manager.rs
===================
// src/identity/identity_manager.rs

pub struct IdentityManager {
    // Fields and methods for managing identities
}


===================
File: ./backend/src/websocket/mod.rs
===================
// backend/src/websocket/mod.rs

mod handler;
pub use handler::WebSocketHandler;

===================
File: ./backend/src/websocket/handler.rs
===================
// backend/src/websocket/handler.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::{broadcast, mpsc};
use warp::ws::{Message, WebSocket};
use futures_util::{StreamExt, SinkExt};
use serde::{Serialize, Deserialize};
use chrono::Utc;
use tokio::sync::mpsc::Sender;
use std::sync::atomic::{AtomicU64, Ordering};

use crate::consensus::types::{ConsensusRound, RoundStatus};
use crate::blockchain::Block;
use crate::relationship::{Contribution, MutualAidInteraction};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WebSocketMessage {
    // Existing message types
    ConsensusUpdate {
        round_number: u64,
        status: RoundStatus,
        coordinator: String,
        votes_count: usize,
        participation_rate: f64,
        remaining_time_ms: i64,
    },
    BlockFinalized {
        block_number: u64,
        transactions_count: usize,
        timestamp: u64,
        proposer: String,
    },
    ReputationUpdate {
        did: String,
        change: i64,
        new_total: i64,
        reason: String,
        context: String,
    },
    ValidatorUpdate {
        did: String,
        round: u64,
        status: String,
        reputation: i64,
        performance_score: f64,
    },
    // New relationship message types
    ContributionRecorded {
        contribution: Contribution,
    },
    MutualAidProvided {
        interaction: MutualAidInteraction,
    },
    RelationshipUpdated {
        member_one: String,
        member_two: String,
        update_type: String,
    },
    CommandResponse {
        command: String,
        status: String,
        message: String,
        data: Option<serde_json::Value>,
    },
    Error {
        code: String,
        message: String,
        details: Option<serde_json::Value>,
    },
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
pub enum ClientMessage {
    RegisterValidator {
        did: String,
        initial_reputation: i64,
    },
    SubmitTransaction {
        transaction: serde_json::Value,
    },
    RecordContribution {
        contribution: Contribution,
    },
    RecordMutualAid {
        interaction: MutualAidInteraction,
    },
    QueryStatus,
    Subscribe {
        events: Vec<String>,
    },
}

#[derive(Clone)]
struct ConnectionInfo {
    tx: Sender<WebSocketMessage>,
    subscriptions: Vec<String>,
    connected_at: chrono::DateTime<Utc>,
    last_active: chrono::DateTime<Utc>,
}

pub struct WebSocketHandler {
    connections: Arc<Mutex<HashMap<String, ConnectionInfo>>>,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
    connection_counter: Arc<AtomicU64>,
}

impl WebSocketHandler {
    pub fn new() -> Self {
        let (broadcast_tx, _) = broadcast::channel(100);
        WebSocketHandler {
            connections: Arc::new(Mutex::new(HashMap::new())),
            broadcast_tx,
            connection_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    pub async fn handle_connection(&self, ws: WebSocket, did: String) {
        println!("New WebSocket connection from: {}", did);
        let (mut ws_sink, mut ws_stream) = ws.split();
        let (tx, mut rx) = mpsc::channel(32);

        let connection_id = self.connection_counter.fetch_add(1, Ordering::SeqCst);

        // Register connection
        {
            let mut connections = self.connections.lock().unwrap();
            connections.insert(did.clone(), ConnectionInfo {
                tx: tx.clone(),
                subscriptions: vec!["all".to_string()],
                connected_at: Utc::now(),
                last_active: Utc::now(),
            });
        }

        // Handle outgoing messages
        let connections = Arc::clone(&self.connections);
        let did_for_cleanup = did.clone();
        
        let send_task = tokio::spawn(async move {
            while let Some(msg) = rx.recv().await {
                if let Ok(json) = serde_json::to_string(&msg) {
                    if ws_sink.send(Message::text(json)).await.is_err() {
                        break;
                    }
                }
            }
            let mut connections = connections.lock().unwrap();
            connections.remove(&did_for_cleanup);
            println!("Send task completed for connection {}", connection_id);
        });

        // Handle incoming messages
        let handler = Arc::new(self.clone());
        let did_for_receive = did.clone();

        let receive_task = tokio::spawn(async move {
            while let Some(result) = ws_stream.next().await {
                match result {
                    Ok(message) => {
                        if let Ok(text) = message.to_str() {
                            if let Ok(client_msg) = serde_json::from_str::<ClientMessage>(text) {
                                if let Err(e) = handle_client_message(handler.clone(), &did_for_receive, client_msg).await {
                                    println!("Error handling message: {}", e);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        println!("WebSocket error from {}: {}", did_for_receive, e);
                        break;
                    }
                }
            }
        });

        tokio::select! {
            _ = send_task => println!("Send task completed for {}", did),
            _ = receive_task => println!("Receive task completed for {}", did),
        }
    }

    fn broadcast_message(&self, message: WebSocketMessage) {
        let txs: Vec<_> = {
            let connections = self.connections.lock().unwrap();
            connections.values()
                .map(|info| info.tx.clone())
                .collect()
        };

        for tx in txs {
            let message = message.clone();
            tokio::spawn(async move {
                if let Err(e) = tx.send(message).await {
                    println!("Failed to broadcast message: {}", e);
                }
            });
        }
    }

    async fn send_to_client(&self, did: &str, message: WebSocketMessage) -> Result<(), String> {
        let tx = {
            let connections = self.connections.lock().unwrap();
            connections.get(did)
                .map(|info| info.tx.clone())
        };

        if let Some(tx) = tx {
            tx.send(message)
                .await
                .map_err(|e| format!("Failed to send message: {}", e))?;
        }
        Ok(())
    }

    // Existing broadcast methods remain unchanged
    pub fn broadcast_consensus_update(&self, round: &ConsensusRound) {
        let message = WebSocketMessage::ConsensusUpdate {
            round_number: round.round_number,
            status: round.status.clone(),
            coordinator: round.coordinator.clone(),
            votes_count: round.votes.len(),
            participation_rate: round.stats.participation_rate,
            remaining_time_ms: (round.timeout - Utc::now()).num_milliseconds().max(0),
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_block_finalized(&self, block: &Block) {
        let message = WebSocketMessage::BlockFinalized {
            block_number: block.index,
            transactions_count: block.transactions.len(),
            timestamp: block.timestamp,
            proposer: block.proposer.clone(),
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_reputation_update(
        &self,
        did: String,
        change: i64,
        new_total: i64,
        reason: String,
        context: String
    ) {
        let message = WebSocketMessage::ReputationUpdate {
            did,
            change,
            new_total,
            reason,
            context,
        };
        self.broadcast_message(message);
    }

    // New broadcast methods for relationships
    pub fn broadcast_contribution_recorded(&self, contribution: Contribution) {
        let message = WebSocketMessage::ContributionRecorded {
            contribution
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_mutual_aid_provided(&self, interaction: MutualAidInteraction) {
        let message = WebSocketMessage::MutualAidProvided {
            interaction
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_relationship_updated(
        &self,
        member_one: String,
        member_two: String,
        update_type: String
    ) {
        let message = WebSocketMessage::RelationshipUpdated {
            member_one,
            member_two,
            update_type,
        };
        self.broadcast_message(message);
    }

    pub fn connection_count(&self) -> usize {
        self.connections.lock().unwrap().len()
    }

    pub fn cleanup_inactive_connections(&self, timeout_seconds: i64) {
        let mut connections = self.connections.lock().unwrap();
        let now = Utc::now();
        connections.retain(|_, info| {
            (now - info.last_active).num_seconds() < timeout_seconds
        });
    }
}

async fn handle_client_message(
    handler: Arc<WebSocketHandler>,
    did: &str,
    message: ClientMessage
) -> Result<(), String> {
    match message {
        ClientMessage::Subscribe { events } => {
            let response = WebSocketMessage::CommandResponse {
                command: "subscribe".to_string(),
                status: "success".to_string(),
                message: format!("Subscribed to {} events", events.len()),
                data: Some(serde_json::json!({ "events": events })),
            };
            handler.send_to_client(did, response).await
        },
        ClientMessage::RecordContribution { contribution } => {
            handler.broadcast_contribution_recorded(contribution);
            let response = WebSocketMessage::CommandResponse {
                command: "record_contribution".to_string(),
                status: "success".to_string(),
                message: "Contribution recorded successfully".to_string(),
                data: None,
            };
            handler.send_to_client(did, response).await
        },
        ClientMessage::RecordMutualAid { interaction } => {
            handler.broadcast_mutual_aid_provided(interaction);
            let response = WebSocketMessage::CommandResponse {
                command: "record_mutual_aid".to_string(),
                status: "success".to_string(),
                message: "Mutual aid interaction recorded successfully".to_string(),
                data: None,
            };
            handler.send_to_client(did, response).await
        },
        _ => {
            let response = WebSocketMessage::Error {
                code: "UNSUPPORTED".to_string(),
                message: "Message type not supported".to_string(),
                details: None,
            };
            handler.send_to_client(did, response).await
        }
    }
}

impl Clone for WebSocketHandler {
    fn clone(&self) -> Self {
        WebSocketHandler {
            connections: Arc::clone(&self.connections),
            broadcast_tx: self.broadcast_tx.clone(),
            connection_counter: Arc::clone(&self.connection_counter),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_connection_management() {
        let handler = WebSocketHandler::new();
        assert_eq!(handler.connection_count(), 0);
    }

    #[test]
    fn test_message_serialization() {
        let message = WebSocketMessage::ConsensusUpdate {
            round_number: 1,
            status: RoundStatus::Voting,
            coordinator: "did:icn:test".to_string(),
            votes_count: 3,
            participation_rate: 0.75,
            remaining_time_ms: 5000,
        };

        let serialized = serde_json::to_string(&message).unwrap();
        assert!(!serialized.is_empty());
    }

    #[test]
    fn test_relationship_message_serialization() {
        // Add test for relationship message serialization
        let message = WebSocketMessage::RelationshipUpdated {
            member_one: "did:icn:alice".to_string(),
            member_two: "did:icn:bob".to_string(),
            update_type: "collaboration_started".to_string(),
        };

        let serialized = serde_json::to_string(&message).unwrap();
        assert!(!serialized.is_empty());
    }
}

===================
File: ./backend/src/cooperative/mod.rs
===================
// src/cooperative/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;
use crate::claims::Claim;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, MemberRole>, // DID -> Role mapping
    pub resources: HashMap<String, Resource>,
    pub policies: Vec<Policy>,
    pub federation_ids: Vec<String>, // Other cooperatives this one federates with
    pub community_id: String,        // Associated civic community
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub name: String,
    pub resource_type: ResourceType,
    pub quantity: f64,
    pub unit: String,
    pub availability: ResourceAvailability,
    pub tags: Vec<String>,
    pub shared_with: Vec<String>, // Cooperative IDs
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ResourceType {
    Physical,
    Digital,
    Service,
    Skill,
    Space,
    Equipment,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAvailability {
    pub status: AvailabilityStatus,
    pub schedule: Option<Schedule>,
    pub conditions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AvailabilityStatus {
    Available,
    InUse,
    Reserved,
    Maintenance,
    Unavailable,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schedule {
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub recurring: bool,
    pub frequency: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub policy_type: PolicyType,
    pub description: String,
    pub rules: Vec<Rule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PolicyType {
    ResourceSharing,
    MembershipRequirement,
    FederationRule,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub condition: String,
    pub action: String,
    pub parameters: HashMap<String, String>,
}

impl Cooperative {
    pub fn new(
        id: String,
        name: String,
        description: String,
        community_id: String,
    ) -> Self {
        Cooperative {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            resources: HashMap::new(),
            policies: Vec::new(),
            federation_ids: Vec::new(),
            community_id,
        }
    }

    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }

    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.push(policy);
    }

    pub fn federate_with(&mut self, cooperative_id: String) {
        if !self.federation_ids.contains(&cooperative_id) {
            self.federation_ids.push(cooperative_id);
        }
    }
}

// Implement the trait for cooperative energy tracking
impl crate::monitoring::energy::EnergyAware for Cooperative {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record storage based on resource count
        let storage_size = (self.resources.len() * std::mem::size_of::<Resource>()) as u64;
        monitor.record_storage_operation(storage_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<MemberRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}// src/cooperative/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;
use crate::claims::Claim;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, MemberRole>, // DID -> Role mapping
    pub resources: HashMap<String, Resource>,
    pub policies: Vec<Policy>,
    pub federation_ids: Vec<String>, // Other cooperatives this one federates with
    pub community_id: String,        // Associated civic community
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub name: String,
    pub resource_type: ResourceType,
    pub quantity: f64,
    pub unit: String,
    pub availability: ResourceAvailability,
    pub tags: Vec<String>,
    pub shared_with: Vec<String>, // Cooperative IDs
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ResourceType {
    Physical,
    Digital,
    Service,
    Skill,
    Space,
    Equipment,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAvailability {
    pub status: AvailabilityStatus,
    pub schedule: Option<Schedule>,
    pub conditions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AvailabilityStatus {
    Available,
    InUse,
    Reserved,
    Maintenance,
    Unavailable,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schedule {
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub recurring: bool,
    pub frequency: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub policy_type: PolicyType,
    pub description: String,
    pub rules: Vec<Rule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PolicyType {
    ResourceSharing,
    MembershipRequirement,
    FederationRule,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub condition: String,
    pub action: String,
    pub parameters: HashMap<String, String>,
}

impl Cooperative {
    pub fn new(
        id: String,
        name: String,
        description: String,
        community_id: String,
    ) -> Self {
        Cooperative {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            resources: HashMap::new(),
            policies: Vec::new(),
            federation_ids: Vec::new(),
            community_id,
        }
    }

    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }

    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.push(policy);
    }

    pub fn federate_with(&mut self, cooperative_id: String) {
        if !self.federation_ids.contains(&cooperative_id) {
            self.federation_ids.push(cooperative_id);
        }
    }
}

// Implement the trait for cooperative energy tracking
impl crate::monitoring::energy::EnergyAware for Cooperative {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record storage based on resource count
        let storage_size = (self.resources.len() * std::mem::size_of::<Resource>()) as u64;
        monitor.record_storage_operation(storage_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<MemberRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}

===================
File: ./backend/src/utils/notifications.rs
===================
use chrono::{DateTime, Utc};
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}

===================
File: ./backend/src/utils/mod.rs
===================
pub mod notifications;



===================
File: ./backend/src/vm/operations/stack.rs
===================
// src/vm/operations/stack.rs

use super::{Operation, VMState, VMResult, ensure_stack_size};
use crate::vm::VMError;

/// Stack manipulation operations
pub enum StackOperation {
    /// Push a value onto the stack
    Push(i64),
    
    /// Pop a value from the stack
    Pop,
    
    /// Duplicate the top value on the stack
    Dup,
    
    /// Swap the top two values on the stack
    Swap,
    
    /// Duplicate the nth value on the stack (n=0 is top)
    DupN(usize),
    
    /// Rotate the top n values on the stack
    Rotate(usize),
    
    /// Clear the entire stack
    Clear,
}

impl Operation for StackOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            StackOperation::Push(value) => {
                if state.stack.len() >= 1024 {  // Stack size limit
                    return Err(VMError::StackOverflow);
                }
                state.stack.push(*value);
                Ok(())
            },
            
            StackOperation::Pop => {
                ensure_stack_size(&state.stack, 1)?;
                state.stack.pop()
                    .ok_or(VMError::StackUnderflow)
                    .map(|_| ())
            },
            
            StackOperation::Dup => {
                ensure_stack_size(&state.stack, 1)?;
                let value = *state.stack.last()
                    .ok_or(VMError::StackUnderflow)?;
                state.stack.push(value);
                Ok(())
            },
            
            StackOperation::Swap => {
                ensure_stack_size(&state.stack, 2)?;
                let len = state.stack.len();
                state.stack.swap(len - 1, len - 2);
                Ok(())
            },
            
            StackOperation::DupN(n) => {
                ensure_stack_size(&state.stack, *n + 1)?;
                let len = state.stack.len();
                let value = state.stack[len - 1 - n];
                state.stack.push(value);
                Ok(())
            },
            
            StackOperation::Rotate(n) => {
                let n = *n;
                if n == 0 {
                    return Ok(());
                }
                ensure_stack_size(&state.stack, n)?;
                let len = state.stack.len();
                let temp = state.stack[len - 1];
                for i in (len - n..len).rev() {
                    state.stack[i] = state.stack[i - 1];
                }
                state.stack[len - n] = temp;
                Ok(())
            },
            
            StackOperation::Clear => {
                state.stack.clear();
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            StackOperation::Push(_) => 1,
            StackOperation::Pop => 1,
            StackOperation::Dup => 1,
            StackOperation::Swap => 2,
            StackOperation::DupN(n) => 1 + (*n as u64),
            StackOperation::Rotate(n) => 1 + (*n as u64),
            StackOperation::Clear => 1,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        // Stack operations don't require special permissions
        vec![]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![],
            memory_limit: 1024 * 1024, // 1MB default limit
            memory_address_counter: std::sync::atomic::AtomicU64::new(0),
        }
    }

    #[test]
    fn test_push() {
        let mut state = setup_test_state();
        let op = StackOperation::Push(42);
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![42]);
    }

    #[test]
    fn test_pop() {
        let mut state = setup_test_state();
        state.stack.push(42);
        let op = StackOperation::Pop;
        assert!(op.execute(&mut state).is_ok());
        assert!(state.stack.is_empty());
    }

    #[test]
    fn test_pop_empty() {
        let mut state = setup_test_state();
        let op = StackOperation::Pop;
        assert!(matches!(op.execute(&mut state), Err(VMError::StackUnderflow)));
    }

    #[test]
    fn test_dup() {
        let mut state = setup_test_state();
        state.stack.push(42);
        let op = StackOperation::Dup;
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![42, 42]);
    }

    #[test]
    fn test_swap() {
        let mut state = setup_test_state();
        state.stack.extend([1, 2]);
        let op = StackOperation::Swap;
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![2, 1]);
    }

    #[test]
    fn test_dupn() {
        let mut state = setup_test_state();
        state.stack.extend([1, 2, 3]);
        let op = StackOperation::DupN(2);
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![1, 2, 3, 1]);
    }

    #[test]
    fn test_rotate() {
        let mut state = setup_test_state();
        state.stack.extend([1, 2, 3]);
        let op = StackOperation::Rotate(3);
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![2, 3, 1]);
    }

    #[test]
    fn test_clear() {
        let mut state = setup_test_state();
        state.stack.extend([1, 2, 3]);
        let op = StackOperation::Clear;
        assert!(op.execute(&mut state).is_ok());
        assert!(state.stack.is_empty());
    }

    #[test]
    fn test_stack_overflow() {
        let mut state = setup_test_state();
        for i in 0..1024 {
            state.stack.push(i);
        }
        let op = StackOperation::Push(1024);
        assert!(matches!(op.execute(&mut state), Err(VMError::StackOverflow)));
    }

    #[test]
    fn test_resource_costs() {
        let push_op = StackOperation::Push(1);
        assert_eq!(push_op.resource_cost(), 1);

        let rotate_op = StackOperation::Rotate(3);
        assert_eq!(rotate_op.resource_cost(), 4); // 1 + 3

        let dupn_op = StackOperation::DupN(2);
        assert_eq!(dupn_op.resource_cost(), 3); // 1 + 2
    }
}

===================
File: ./backend/src/vm/operations/federation.rs
===================
// src/vm/operations/federation.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, ensure_reputation, emit_event};
use crate::vm::VMError;

/// Types of federation that can be formed
#[derive(Debug, Clone, PartialEq)]
pub enum FederationType {
    /// Federation between cooperatives for resource sharing
    CooperativeFederation,
    /// Federation between communities for civic coordination
    CommunityFederation,
    /// Hybrid federation involving both cooperatives and communities
    HybridFederation,
}

/// Federation agreement terms and conditions
#[derive(Debug, Clone)]
pub struct FederationTerms {
    /// Type of federation being formed
    federation_type: FederationType,
    /// Minimum reputation required to participate
    min_reputation: i64,
    /// Resource sharing policies
    resource_policies: Vec<String>,
    /// Governance rules for federation
    governance_rules: Vec<String>,
    /// Duration of federation agreement
    duration_days: u64,
}

/// Operations for managing federation between cooperatives and communities
pub enum FederationOperation {
    /// Initiate a new federation
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    
    /// Join an existing federation
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    
    /// Leave a federation
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    
    /// Propose action within federation
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: HashMap<String, u64>,
    },
    
    /// Vote on federation proposal
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    
    /// Share resources within federation
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    
    /// Synchronize federation state
    SyncFederationState {
        federation_id: String,
    },
    
    /// Update federation terms
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
    
    /// Add cross-federation endorsement
    AddEndorsement {
        federation_id: String,
        target_id: String,
        endorsement_type: String,
        content: String,
    },
    
    /// Resolve federation dispute
    ResolveDispute {
        federation_id: String,
        dispute_id: String,
        resolution: String,
        mediators: Vec<String>,
    },
    
    /// Coordinate joint action across federation
    CoordinateAction {
        federation_id: String,
        action_type: String,
        participants: Vec<String>,
        resources: HashMap<String, u64>,
        timeline: String,
    },
}

impl Operation for FederationOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                // Verify permissions based on federation type
                let required_permission = match federation_type {
                    FederationType::CooperativeFederation => "cooperative.federate",
                    FederationType::CommunityFederation => "community.federate",
                    FederationType::HybridFederation => "hybrid.federate",
                };
                
                ensure_permissions(&[required_permission.to_string()], &state.permissions)?;
                ensure_reputation(terms.min_reputation, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_type".to_string(), format!("{:?}", federation_type));
                event_data.insert("partner_id".to_string(), partner_id.clone());
                event_data.insert("min_reputation".to_string(), terms.min_reputation.to_string());
                
                emit_event(state, "FederationInitiated".to_string(), event_data);
                Ok(())
            },

            FederationOperation::JoinFederation { federation_id, commitment } => {
                ensure_permissions(&["federation.join".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("member_did".to_string(), state.caller_did.clone());
                event_data.insert("commitment".to_string(), commitment.join(", "));
                
                emit_event(state, "FederationJoined".to_string(), event_data);
                Ok(())
            },

            FederationOperation::LeaveFederation { federation_id, reason } => {
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("member_did".to_string(), state.caller_did.clone());
                event_data.insert("reason".to_string(), reason.clone());
                
                emit_event(state, "FederationLeft".to_string(), event_data);
                Ok(())
            },

            FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
                ensure_permissions(&["federation.propose".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("action_type".to_string(), action_type.clone());
                event_data.insert("description".to_string(), description.clone());
                
                for (resource, amount) in resources {
                    event_data.insert(format!("resource_{}", resource), amount.to_string());
                }
                
                emit_event(state, "FederationActionProposed".to_string(), event_data);
                Ok(())
            },

            FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
                ensure_permissions(&["federation.vote".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("approve".to_string(), approve.to_string());
                if let Some(note) = notes {
                    event_data.insert("notes".to_string(), note.clone());
                }
                
                emit_event(state, "FederationVoteCast".to_string(), event_data);
                Ok(())
            },

            FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
                ensure_permissions(&["federation.share_resources".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("resource_type".to_string(), resource_type.clone());
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("recipient_id".to_string(), recipient_id.clone());
                
                emit_event(state, "FederationResourceShared".to_string(), event_data);
                Ok(())
            },

            FederationOperation::SyncFederationState { federation_id } => {
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("sync_time".to_string(), state.timestamp.to_string());
                
                emit_event(state, "FederationStateSynced".to_string(), event_data);
                Ok(())
            },

            FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
                ensure_permissions(&["federation.update_terms".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("federation_type".to_string(), format!("{:?}", new_terms.federation_type));
                event_data.insert("min_reputation".to_string(), new_terms.min_reputation.to_string());
                
                emit_event(state, "FederationTermsUpdated".to_string(), event_data);
                Ok(())
            },

            FederationOperation::AddEndorsement { federation_id, target_id, endorsement_type, content } => {
                ensure_permissions(&["federation.endorse".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("target_id".to_string(), target_id.clone());
                event_data.insert("endorsement_type".to_string(), endorsement_type.clone());
                event_data.insert("content".to_string(), content.clone());
                
                emit_event(state, "FederationEndorsementAdded".to_string(), event_data);
                Ok(())
            },

            FederationOperation::ResolveDispute { federation_id, dispute_id, resolution, mediators } => {
                ensure_permissions(&["federation.mediate".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("dispute_id".to_string(), dispute_id.clone());
                event_data.insert("resolution".to_string(), resolution.clone());
                event_data.insert("mediators".to_string(), mediators.join(", "));
                
                emit_event(state, "FederationDisputeResolved".to_string(), event_data);
                Ok(())
            },

            FederationOperation::CoordinateAction { federation_id, action_type, participants, resources, timeline } => {
                ensure_permissions(&["federation.coordinate".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("action_type".to_string(), action_type.clone());
                event_data.insert("participants".to_string(), participants.join(", "));
                event_data.insert("timeline".to_string(), timeline.clone());
                
                for (resource, amount) in resources {
                    event_data.insert(format!("resource_{}", resource), amount.to_string());
                }
                
                emit_event(state, "FederationActionCoordinated".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            FederationOperation::InitiateFederation { .. } => 1000, // High cost for federation creation
            FederationOperation::JoinFederation { .. } => 500,
            FederationOperation::LeaveFederation { .. } => 200,
            FederationOperation::ProposeAction { .. } => 300,
            FederationOperation::VoteOnProposal { .. } => 100,
            FederationOperation::ShareResources { .. } => 400,
            FederationOperation::SyncFederationState { .. } => 200,
            FederationOperation::UpdateFederationTerms { .. } => 500,
            FederationOperation::AddEndorsement { .. } => 100,
            FederationOperation::ResolveDispute { .. } => 400,
            FederationOperation::CoordinateAction { .. } => 600,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            FederationOperation::InitiateFederation { federation_type, .. } => {
                match federation_type {
                    FederationType::CooperativeFederation => vec!["cooperative.federate".to_string()],
                    FederationType::CommunityFederation => vec!["community.federate".to_string()],
                    FederationType::HybridFederation => vec!["hybrid.federate".to_string()],
                }
            },
            FederationOperation::JoinFederation { .. } => vec!["federation.join".to_string()],
            FederationOperation::ProposeAction { .. } => vec!["federation.propose".to_string()],
            FederationOperation::VoteOnProposal { .. } => vec!["federation.vote".to_string()],
            FederationOperation::ShareResources { .. } => vec!["federation.share_resources".to_string()],
            FederationOperation::UpdateFederationTerms { .. } => vec!["federation.update_terms".to_string()],
            FederationOperation::AddEndorsement { .. } => vec!["federation.endorse".to_string()],
            FederationOperation::ResolveDispute { .. } => vec!["federation.mediate".to_string()],
            FederationOperation::CoordinateAction { .. } => vec!["federation.coordinate".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "cooperative.federate".to_string(),
                "community.federate".to_string(),
                "federation.join".to_string(),
                "federation.propose".to_string(),
                "federation.vote".to_string(),
                "federation.share_resources".to_string(),
            ],
        };
        
        state.reputation_context.insert(state.caller_did.clone(), 1000);
        state
    }

    #[test]
    fn test_initiate_cooperative_federation() {
        let mut state = setup_test_state();
        let terms = FederationTerms {
            federation_type: FederationType::CooperativeFederation,
            min_reputation: 500,
            resource_policies: vec!["policy1".to_string()],
            governance_rules: vec!["rule1".to_string()],
            duration_days: 365,
        };
        
        let op = FederationOperation::InitiateFederation {
            federation_type: FederationType::CooperativeFederation,
            partner_id: "partner_coop".to_string(),
            terms,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationInitiated");
    }

    #[test]
    fn test_join_federation() {
        let mut state = setup_test_state();
        let op = FederationOperation::JoinFederation {
            federation_id: "fed1".to_string(),
            commitment: vec!["commit1".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationJoined");
    }

    #[test]
    fn test_share_resources() {
        let mut state = setup_test_state();
        let op = FederationOperation::ShareResources {
            federation_id: "fed1".to_string(),
            resource_type: "computing".to_string(),
            amount: 1000,
            recipient_id: "recipient_coop".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationResourceShared");
    }

    #[test]
    fn test_resolve_dispute() {
        let mut state = setup_test_state();
        state.permissions.push("federation.mediate".to_string());
        
        let op = FederationOperation::ResolveDispute {
            federation_id: "fed1".to_string(),
            dispute_id: "dispute1".to_string(),
            resolution: "Mutual agreement reached".to_string(),
            mediators: vec!["mediator1".to_string(), "mediator2".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationDisputeResolved");
    }

    #[test]
    fn test_coordinate_action() {
        let mut state = setup_test_state();
        state.permissions.push("federation.coordinate".to_string());
        
        let mut resources = HashMap::new();
        resources.insert("computing".to_string(), 500);
        resources.insert("storage".to_string(), 1000);
        
        let op = FederationOperation::CoordinateAction {
            federation_id: "fed1".to_string(),
            action_type: "joint_project".to_string(),
            participants: vec!["coop1".to_string(), "coop2".to_string()],
            resources,
            timeline: "2024-Q2".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationActionCoordinated");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut state = setup_test_state();
        state.reputation_context.insert(state.caller_did.clone(), 100); // Set low reputation
        
        let terms = FederationTerms {
            federation_type: FederationType::CooperativeFederation,
            min_reputation: 500,
            resource_policies: vec![],
            governance_rules: vec![],
            duration_days: 365,
        };
        
        let op = FederationOperation::InitiateFederation {
            federation_type: FederationType::CooperativeFederation,
            partner_id: "partner_coop".to_string(),
            terms,
        };
        
        assert!(matches!(op.execute(&mut state), Err(VMError::InsufficientReputation)));
    }

    #[test]
    fn test_hybrid_federation() {
        let mut state = setup_test_state();
        state.permissions.push("hybrid.federate".to_string());
        
        let terms = FederationTerms {
            federation_type: FederationType::HybridFederation,
            min_reputation: 500,
            resource_policies: vec!["policy1".to_string()],
            governance_rules: vec!["rule1".to_string()],
            duration_days: 365,
        };
        
        let op = FederationOperation::InitiateFederation {
            federation_type: FederationType::HybridFederation,
            partner_id: "community1".to_string(),
            terms,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "FederationInitiated");
    }
}

===================
File: ./backend/src/vm/operations/network.rs
===================
// src/vm/operations/network.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::vm::VMError;

/// Types of network messages that can be sent
#[derive(Debug, Clone, PartialEq)]
pub enum MessageType {
    /// Direct message to another node
    Direct,
    /// Broadcast to all federation members
    FederationBroadcast,
    /// Broadcast to all community members
    CommunityBroadcast,
    /// Network state synchronization
    StateSync,
    /// Resource discovery query
    ResourceDiscovery,
    /// Network health check
    HealthCheck,
}

/// Network message priority levels
#[derive(Debug, Clone, PartialEq)]
pub enum MessagePriority {
    Low,
    Normal,
    High,
    Critical,
}

/// Network message content
#[derive(Debug, Clone)]
pub struct NetworkMessage {
    /// Type of message
    message_type: MessageType,
    /// Message priority
    priority: MessagePriority,
    /// Target DID (for direct messages)
    target: Option<String>,
    /// Message content
    content: String,
    /// Additional metadata
    metadata: HashMap<String, String>,
}

/// Operations for managing network communication
pub enum NetworkOperation {
    /// Send a message to another node
    SendMessage {
        message: NetworkMessage,
    },
    
    /// Subscribe to network topics
    Subscribe {
        topics: Vec<String>,
        filter: Option<String>,
    },
    
    /// Unsubscribe from network topics
    Unsubscribe {
        topics: Vec<String>,
    },
    
    /// Discover available resources on the network
    DiscoverResources {
        resource_type: String,
        max_results: u32,
    },
    
    /// Sync state with federation members
    SyncState {
        federation_id: String,
        state_type: String,
    },
    
    /// Join a network partition
    JoinPartition {
        partition_id: String,
        capabilities: Vec<String>,
    },
    
    /// Leave a network partition
    LeavePartition {
        partition_id: String,
    },
    
    /// Broadcast node capabilities
    BroadcastCapabilities {
        capabilities: Vec<String>,
    },
    
    /// Check network connection health
    HealthCheck {
        target: Option<String>,
        timeout_ms: u64,
    },
    
    /// Configure network settings
    ConfigureNetwork {
        settings: HashMap<String, String>,
    },
    
    /// Request network route to target
    RequestRoute {
        target: String,
        max_hops: u32,
    },
    
    /// Update network topology
    UpdateTopology {
        connections: Vec<(String, String)>,
    },
    
    /// Establish secure channel
    EstablishChannel {
        target: String,
        encryption_params: HashMap<String, String>,
    },
}

impl Operation for NetworkOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            NetworkOperation::SendMessage { message } => {
                let permission = match message.message_type {
                    MessageType::Direct => "network.send_direct",
                    MessageType::FederationBroadcast => "network.broadcast_federation",
                    MessageType::CommunityBroadcast => "network.broadcast_community",
                    MessageType::StateSync => "network.sync_state",
                    MessageType::ResourceDiscovery => "network.discover",
                    MessageType::HealthCheck => "network.health_check",
                };
                
                ensure_permissions(&[permission.to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("message_type".to_string(), format!("{:?}", message.message_type));
                event_data.insert("priority".to_string(), format!("{:?}", message.priority));
                if let Some(target) = &message.target {
                    event_data.insert("target".to_string(), target.clone());
                }
                event_data.insert("content_length".to_string(), message.content.len().to_string());
                
                emit_event(state, "MessageSent".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::Subscribe { topics, filter } => {
                ensure_permissions(&["network.subscribe".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("topics".to_string(), topics.join(","));
                if let Some(f) = filter {
                    event_data.insert("filter".to_string(), f.clone());
                }
                
                emit_event(state, "TopicsSubscribed".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::Unsubscribe { topics } => {
                let mut event_data = HashMap::new();
                event_data.insert("topics".to_string(), topics.join(","));
                
                emit_event(state, "TopicsUnsubscribed".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::DiscoverResources { resource_type, max_results } => {
                ensure_permissions(&["network.discover".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("resource_type".to_string(), resource_type.clone());
                event_data.insert("max_results".to_string(), max_results.to_string());
                
                emit_event(state, "ResourceDiscoveryInitiated".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::SyncState { federation_id, state_type } => {
                ensure_permissions(&["network.sync_state".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("state_type".to_string(), state_type.clone());
                
                emit_event(state, "StateSyncInitiated".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::JoinPartition { partition_id, capabilities } => {
                ensure_permissions(&["network.partition".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("partition_id".to_string(), partition_id.clone());
                event_data.insert("capabilities".to_string(), capabilities.join(","));
                
                emit_event(state, "PartitionJoined".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::LeavePartition { partition_id } => {
                ensure_permissions(&["network.partition".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("partition_id".to_string(), partition_id.clone());
                
                emit_event(state, "PartitionLeft".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::BroadcastCapabilities { capabilities } => {
                ensure_permissions(&["network.broadcast".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("capabilities".to_string(), capabilities.join(","));
                
                emit_event(state, "CapabilitiesBroadcast".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::HealthCheck { target, timeout_ms } => {
                let mut event_data = HashMap::new();
                if let Some(t) = target {
                    event_data.insert("target".to_string(), t.clone());
                }
                event_data.insert("timeout_ms".to_string(), timeout_ms.to_string());
                
                emit_event(state, "HealthCheckInitiated".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::ConfigureNetwork { settings } => {
                ensure_permissions(&["network.configure".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                for (key, value) in settings {
                    event_data.insert(key.clone(), value.clone());
                }
                
                emit_event(state, "NetworkConfigured".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::RequestRoute { target, max_hops } => {
                let mut event_data = HashMap::new();
                event_data.insert("target".to_string(), target.clone());
                event_data.insert("max_hops".to_string(), max_hops.to_string());
                
                emit_event(state, "RouteRequested".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::UpdateTopology { connections } => {
                ensure_permissions(&["network.topology".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("connection_count".to_string(), connections.len().to_string());
                
                emit_event(state, "TopologyUpdated".to_string(), event_data);
                Ok(())
            },

            NetworkOperation::EstablishChannel { target, encryption_params } => {
                ensure_permissions(&["network.secure_channel".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("target".to_string(), target.clone());
                for (key, value) in encryption_params {
                    event_data.insert(format!("param_{}", key), value.clone());
                }
                
                emit_event(state, "SecureChannelEstablished".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            NetworkOperation::SendMessage { message } => {
                let base_cost = match message.priority {
                    MessagePriority::Low => 10,
                    MessagePriority::Normal => 20,
                    MessagePriority::High => 40,
                    MessagePriority::Critical => 80,
                };
                base_cost + (message.content.len() as u64 / 100)
            },
            NetworkOperation::Subscribe { topics, .. } => 20 + (topics.len() as u64 * 5),
            NetworkOperation::Unsubscribe { topics } => 10 + (topics.len() as u64 * 2),
            NetworkOperation::DiscoverResources { .. } => 50,
            NetworkOperation::SyncState { .. } => 100,
            NetworkOperation::JoinPartition { .. } => 30,
            NetworkOperation::LeavePartition { .. } => 20,
            NetworkOperation::BroadcastCapabilities { capabilities } => 20 + (capabilities.len() as u64 * 5),
            NetworkOperation::HealthCheck { .. } => 10,
            NetworkOperation::ConfigureNetwork { settings } => 30 + (settings.len() as u64 * 5),
            NetworkOperation::RequestRoute { .. } => 25,
            NetworkOperation::UpdateTopology { connections } => 40 + (connections.len() as u64 * 5),
            NetworkOperation::EstablishChannel { .. } => 60,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            NetworkOperation::SendMessage { message } => {
                match message.message_type {
                    MessageType::Direct => vec!["network.send_direct".to_string()],
                    MessageType::FederationBroadcast => vec!["network.broadcast_federation".to_string()],
                    MessageType::CommunityBroadcast => vec!["network.broadcast_community".to_string()],
                    MessageType::StateSync => vec!["network.sync_state".to_string()],
                    MessageType::ResourceDiscovery => vec!["network.discover".to_string()],
                    MessageType::HealthCheck => vec!["network.health_check".to_string()],
                }
            },
            NetworkOperation::Subscribe { .. } => vec!["network.subscribe".to_string()],
            NetworkOperation::DiscoverResources { .. } => vec!["network.discover".to_string()],
            NetworkOperation::SyncState { .. } => vec!["network.sync_state".to_string()],
            NetworkOperation::JoinPartition { .. } | NetworkOperation::LeavePartition { .. } => 
                vec!["network.partition".to_string()],
            NetworkOperation::BroadcastCapabilities { .. } => vec!["network.broadcast".to_string()],
            NetworkOperation::ConfigureNetwork { .. } => vec!["network.configure".to_string()],
            NetworkOperation::UpdateTopology { .. } => vec!["network.topology".to_string()],
            NetworkOperation::EstablishChannel { .. } => vec!["network.secure_channel".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "network.send_direct".to_string(),
                "network.broadcast_federation".to_string(),
                "network.subscribe".to_string(),
                "network.discover".to_string(),
                "network.sync_state".to_string(),
            ],
        };
        
        state.reputation_context.insert(state.caller_did.clone(), 100);
        state
    }

    #[test]
    fn test_send_direct_message() {
        let mut state = setup_test_state();
        let message = NetworkMessage {
            message_type: MessageType::Direct,
            priority: MessagePriority::Normal,
            target: Some("recipient".to_string()),
            content: "Hello".to_string(),
            metadata: HashMap::new(),
        };
        
        let op = NetworkOperation::SendMessage { message };
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MessageSent");
    }

    #[test]
    fn test_federation_broadcast() {
        let mut state = setup_test_state();
        let message = NetworkMessage {
            message_type: MessageType::FederationBroadcast,
            priority: MessagePriority::High,
            target: None,
            content: "Federation update".to_string(),
            metadata: HashMap::new(),
        };
        
        let op = NetworkOperation::SendMessage { message };
        assert!(op.execute(&mut state).is_ok());
    }

    #[test]
    fn test_subscribe_topics() {
        let mut state = setup_test_state();
        let op = NetworkOperation::Subscribe {
            topics: vec!["governance".to_string(), "resources".to_string()],
            filter: Some("type = 'update'".to_string()),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "TopicsSubscribed");
    }

    #[test]
    fn test_sync_state() {
        let mut state = setup_test_state();
        let op = NetworkOperation::SyncState {
            federation_id: "fed1".to_string(),
            state_type: "resources".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "StateSyncInitiated");
    }

    #[test]
    fn test_secure_channel() {
        let mut state = setup_test_state();
        state.permissions.push("network.secure_channel".to_string());
        
        let mut encryption_params = HashMap::new();
        encryption_params.insert("algorithm".to_string(), "AES-256-GCM".to_string());
        encryption_params.insert("key_exchange".to_string(), "ECDH".to_string());
        
        let op = NetworkOperation::EstablishChannel {
            target: "peer1".to_string(),
            encryption_params,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "SecureChannelEstablished");
    }

    #[test]
    fn test_resource_discovery() {
        let mut state = setup_test_state();
        let op = NetworkOperation::DiscoverResources {
            resource_type: "computing".to_string(),
            max_results: 10,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "ResourceDiscoveryInitiated");
    }

    #[test]
    fn test_network_partitioning() {
        let mut state = setup_test_state();
        state.permissions.push("network.partition".to_string());
        
        // Test joining partition
        let join_op = NetworkOperation::JoinPartition {
            partition_id: "partition1".to_string(),
            capabilities: vec!["storage".to_string(), "compute".to_string()],
        };
        assert!(join_op.execute(&mut state).is_ok());
        
        // Test leaving partition
        let leave_op = NetworkOperation::LeavePartition {
            partition_id: "partition1".to_string(),
        };
        assert!(leave_op.execute(&mut state).is_ok());
    }

    #[test]
    fn test_topology_update() {
        let mut state = setup_test_state();
        state.permissions.push("network.topology".to_string());
        
        let connections = vec![
            ("node1".to_string(), "node2".to_string()),
            ("node2".to_string(), "node3".to_string()),
        ];
        
        let op = NetworkOperation::UpdateTopology { connections };
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "TopologyUpdated");
    }

    #[test]
    fn test_health_check() {
        let mut state = setup_test_state();
        state.permissions.push("network.health_check".to_string());
        
        let op = NetworkOperation::HealthCheck {
            target: Some("peer1".to_string()),
            timeout_ms: 5000,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "HealthCheckInitiated");
    }

    #[test]
    fn test_network_configuration() {
        let mut state = setup_test_state();
        state.permissions.push("network.configure".to_string());
        
        let mut settings = HashMap::new();
        settings.insert("max_connections".to_string(), "100".to_string());
        settings.insert("timeout_ms".to_string(), "5000".to_string());
        settings.insert("encryption_enabled".to_string(), "true".to_string());
        
        let op = NetworkOperation::ConfigureNetwork { settings };
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "NetworkConfigured");
    }

    #[test]
    fn test_message_priorities() {
        let mut state = setup_test_state();
        
        // Test different message priorities and their resource costs
        let priorities = vec![
            MessagePriority::Low,
            MessagePriority::Normal,
            MessagePriority::High,
            MessagePriority::Critical,
        ];
        
        for priority in priorities {
            let message = NetworkMessage {
                message_type: MessageType::Direct,
                priority: priority.clone(),
                target: Some("recipient".to_string()),
                content: "Test message".to_string(),
                metadata: HashMap::new(),
            };
            
            let op = NetworkOperation::SendMessage { message };
            assert!(op.execute(&mut state).is_ok());
        }
    }

    #[test]
    fn test_route_request() {
        let mut state = setup_test_state();
        
        let op = NetworkOperation::RequestRoute {
            target: "distant_peer".to_string(),
            max_hops: 5,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "RouteRequested");
    }

    #[test]
    fn test_insufficient_permissions() {
        let mut state = setup_test_state();
        state.permissions.clear(); // Remove all permissions
        
        let message = NetworkMessage {
            message_type: MessageType::Direct,
            priority: MessagePriority::Normal,
            target: Some("recipient".to_string()),
            content: "Hello".to_string(),
            metadata: HashMap::new(),
        };
        
        let op = NetworkOperation::SendMessage { message };
        assert!(matches!(op.execute(&mut state), Err(VMError::InsufficientPermissions)));
    }

    #[test]
    fn test_broadcast_capabilities() {
        let mut state = setup_test_state();
        state.permissions.push("network.broadcast".to_string());
        
        let capabilities = vec![
            "storage:100GB".to_string(),
            "compute:4cores".to_string(),
            "bandwidth:1Gbps".to_string(),
        ];
        
        let op = NetworkOperation::BroadcastCapabilities { capabilities };
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "CapabilitiesBroadcast");
    }
}

===================
File: ./backend/src/vm/operations/data.rs
===================
// src/vm/operations/data.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_stack_size, ensure_permissions, emit_event};
use crate::vm::VMError;

/// Operations for handling structured data within the VM
pub enum DataOperation {
    /// Create a new data structure of specified type
    CreateStruct {
        name: String,
        fields: Vec<String>,
    },
    
    /// Set a field value in a structure
    SetField {
        struct_name: String,
        field_name: String,
    },
    
    /// Get a field value from a structure
    GetField {
        struct_name: String,
        field_name: String,
    },
    
    /// Create a new array with initial size
    CreateArray {
        size: usize,
    },
    
    /// Get value at array index
    GetArrayValue {
        index: usize,
    },
    
    /// Set value at array index
    SetArrayValue {
        index: usize,
    },
    
    /// Get array length
    GetArrayLength,
    
    /// Create a new hashmap
    CreateMap,
    
    /// Set key-value pair in map
    SetMapValue,
    
    /// Get value by key from map
    GetMapValue,
    
    /// Check if key exists in map
    HasMapKey,
    
    /// Delete key-value pair from map
    DeleteMapValue,
    
    /// Serialize data structure to bytes
    Serialize,
    
    /// Deserialize bytes to data structure
    Deserialize {
        target_type: String,
    },
}

impl Operation for DataOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            DataOperation::CreateStruct { name, fields } => {
                ensure_permissions(&["data.create".to_string()], &state.permissions)?;
                
                // Create structure data with initialized fields
                let struct_data: HashMap<String, i64> = fields.iter()
                    .map(|field| (field.clone(), 0i64))
                    .collect();

                // Store the structure definition and reference
                state.memory.insert(format!("struct_def:{}", name), fields.len() as i64);
                for (field, value) in &struct_data {
                    state.memory.insert(format!("struct:{}:{}", name, field), *value);
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("struct_name".to_string(), name.clone());
                event_data.insert("field_count".to_string(), fields.len().to_string());
                
                emit_event(state, "StructCreated".to_string(), event_data);
                Ok(())
            },
            
            DataOperation::SetField { struct_name, field_name } => {
                ensure_stack_size(&state.stack, 1)?;
                let value = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                
                let key = format!("struct:{}:{}", struct_name, field_name);
                if !state.memory.contains_key(&format!("struct_def:{}", struct_name)) {
                    return Err(VMError::Custom("Structure not found".to_string()));
                }
                
                state.memory.insert(key, value);
                
                let mut event_data = HashMap::new();
                event_data.insert("struct_name".to_string(), struct_name.clone());
                event_data.insert("field_name".to_string(), field_name.clone());
                event_data.insert("value".to_string(), value.to_string());
                
                emit_event(state, "FieldUpdated".to_string(), event_data);
                Ok(())
            },
            
            DataOperation::GetField { struct_name, field_name } => {
                let key = format!("struct:{}:{}", struct_name, field_name);
                let value = state.memory.get(&key)
                    .copied()
                    .ok_or_else(|| VMError::Custom("Field not found".to_string()))?;
                
                state.stack.push(value);
                Ok(())
            },
            
            DataOperation::CreateArray { size } => {
                ensure_permissions(&["data.create".to_string()], &state.permissions)?;
                
                // Initialize array with zeros
                for i in 0..*size {
                    state.memory.insert(format!("array:{}", i), 0);
                }
                
                state.memory.insert("array:length".to_string(), *size as i64);
                
                let mut event_data = HashMap::new();
                event_data.insert("size".to_string(), size.to_string());
                
                emit_event(state, "ArrayCreated".to_string(), event_data);
                Ok(())
            },
            
            DataOperation::GetArrayValue { index } => {
                let length = state.memory.get("array:length")
                    .copied()
                    .unwrap_or(0) as usize;
                    
                if *index >= length {
                    return Err(VMError::Custom("Array index out of bounds".to_string()));
                }
                
                let key = format!("array:{}", index);
                let value = state.memory.get(&key)
                    .copied()
                    .unwrap_or(0);
                
                state.stack.push(value);
                Ok(())
            },
            
            DataOperation::SetArrayValue { index } => {
                ensure_stack_size(&state.stack, 1)?;
                
                let length = state.memory.get("array:length")
                    .copied()
                    .unwrap_or(0) as usize;
                    
                if *index >= length {
                    return Err(VMError::Custom("Array index out of bounds".to_string()));
                }
                
                let value = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                let key = format!("array:{}", index);
                state.memory.insert(key, value);
                
                let mut event_data = HashMap::new();
                event_data.insert("index".to_string(), index.to_string());
                event_data.insert("value".to_string(), value.to_string());
                
                emit_event(state, "ArrayValueUpdated".to_string(), event_data);
                Ok(())
            },
            
            DataOperation::GetArrayLength => {
                let length = state.memory.get("array:length")
                    .copied()
                    .unwrap_or(0);
                
                state.stack.push(length);
                Ok(())
            },
            
            DataOperation::CreateMap => {
                ensure_permissions(&["data.create".to_string()], &state.permissions)?;
                state.memory.insert("map:size".to_string(), 0);
                
                emit_event(state, "MapCreated".to_string(), HashMap::new());
                Ok(())
            },
            
            DataOperation::SetMapValue => {
                ensure_stack_size(&state.stack, 2)?;
                ensure_permissions(&["data.write".to_string()], &state.permissions)?;
                
                let value = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                let key = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                
                let map_key = format!("map:{}:value", key);
                state.memory.insert(map_key, value);
                
                // Update map size
                let size = state.memory.get("map:size")
                    .copied()
                    .unwrap_or(0);
                state.memory.insert("map:size".to_string(), size + 1);
                
                let mut event_data = HashMap::new();
                event_data.insert("key".to_string(), key.to_string());
                event_data.insert("value".to_string(), value.to_string());
                
                emit_event(state, "MapValueSet".to_string(), event_data);
                Ok(())
            },
            
            DataOperation::GetMapValue => {
                ensure_stack_size(&state.stack, 1)?;
                
                let key = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                let map_key = format!("map:{}:value", key);
                
                let value = state.memory.get(&map_key)
                    .copied()
                    .unwrap_or(0);
                
                state.stack.push(value);
                Ok(())
            },
            
            DataOperation::HasMapKey => {
                ensure_stack_size(&state.stack, 1)?;
                
                let key = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                let map_key = format!("map:{}:value", key);
                
                let exists = state.memory.contains_key(&map_key);
                state.stack.push(if exists { 1 } else { 0 });
                
                Ok(())
            },
            
            DataOperation::DeleteMapValue => {
                ensure_stack_size(&state.stack, 1)?;
                ensure_permissions(&["data.write".to_string()], &state.permissions)?;
                
                let key = state.stack.pop().ok_or(VMError::StackUnderflow)?;
                let map_key = format!("map:{}:value", key);
                
                if state.memory.remove(&map_key).is_some() {
                    let size = state.memory.get("map:size")
                        .copied()
                        .unwrap_or(0);
                    state.memory.insert("map:size".to_string(), size - 1);
                    
                    let mut event_data = HashMap::new();
                    event_data.insert("key".to_string(), key.to_string());
                    
                    emit_event(state, "MapValueDeleted".to_string(), event_data);
                }
                
                Ok(())
            },
            
            DataOperation::Serialize | DataOperation::Deserialize { .. } => {
                // These operations would typically involve more complex serialization logic
                // For now, we just emit an event
                let mut event_data = HashMap::new();
                event_data.insert("operation".to_string(), "serialization".to_string());
                
                emit_event(state, "DataOperation".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            DataOperation::CreateStruct { fields, .. } => 10 + (fields.len() as u64),
            DataOperation::SetField { .. } => 5,
            DataOperation::GetField { .. } => 2,
            DataOperation::CreateArray { size } => 10 + (*size as u64),
            DataOperation::GetArrayValue { .. } => 2,
            DataOperation::SetArrayValue { .. } => 5,
            DataOperation::GetArrayLength => 1,
            DataOperation::CreateMap => 10,
            DataOperation::SetMapValue => 5,
            DataOperation::GetMapValue => 2,
            DataOperation::HasMapKey => 2,
            DataOperation::DeleteMapValue => 5,
            DataOperation::Serialize => 20,
            DataOperation::Deserialize { .. } => 20,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            DataOperation::CreateStruct { .. } |
            DataOperation::CreateArray { .. } |
            DataOperation::CreateMap => vec!["data.create".to_string()],
            
            DataOperation::SetField { .. } |
            DataOperation::SetArrayValue { .. } |
            DataOperation::SetMapValue |
            DataOperation::DeleteMapValue => vec!["data.write".to_string()],
            
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState::default();
        state.permissions = vec!["data.create".to_string(), "data.write".to_string()];
        state
    }

    #[test]
    fn test_create_struct() {
        let mut state = setup_test_state();
        let op = DataOperation::CreateStruct {
            name: "test".to_string(),
            fields: vec!["field1".to_string(), "field2".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert!(state.memory.contains_key("struct_def:test"));
    }

    #[test]
    fn test_array_operations() {
        let mut state = setup_test_state();
        
        // Create array
        let create_op = DataOperation::CreateArray { size: 3 };
        assert!(create_op.execute(&mut state).is_ok());
        
        // Set value
        state.stack.push(42);
        let set_op = DataOperation::SetArrayValue { index: 1 };
        assert!(set_op.execute(&mut state).is_ok());
        
        // Get value
        let get_op = DataOperation::GetArrayValue { index: 1 };
        assert!(get_op.execute(&mut state).is_ok());
        assert_eq!(state.stack.pop().unwrap(), 42);
    }

    #[test]
    fn test_map_operations() {
        let mut state = setup_test_state();
        
        // Create map
        let create_op = DataOperation::CreateMap;
        assert!(create_op.execute(&mut state).is_ok());
        
        // Set value
        state.stack.push(1); // key
        state.stack.push(42); // value
        let set_op = DataOperation::SetMapValue;
        assert!(set_op.execute(&mut state).is_ok());
        
        // Get value
        state.stack.push(1); // key
        let get_op = DataOperation::GetMapValue;
        assert!(get_op.execute(&mut state).is_ok());
        assert_eq!(state.stack.pop().unwrap(), 42);
    }

    #[test]
    fn test_array_bounds() {
        let mut state = setup_test_state();
        
        // Create small array
        let create_op = DataOperation::CreateArray { size: 2 };
        assert!(create_op.execute(&mut state).is_ok());
        
        // Try to access invalid index
        let get_op = DataOperation::GetArrayValue { index: 5 };
        assert!(matches!(
            get_op.execute(&mut state),
            Err(VMError::Custom(_))
        ));
    }

    #[test]
    fn test_permissions() {
        let mut state = setup_test_state();
        state.permissions.clear(); // Remove all permissions
        
        let op = DataOperation::CreateStruct {
            name: "test".to_string(),
            fields: vec!["field1".to_string()],
        };
        
        assert!(matches!(
            op.execute(&mut state),
            Err(VMError::InsufficientPermissions)
        ));
    }
}

===================
File: ./backend/src/vm/operations/memory.rs
===================
// src/vm/operations/memory.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::vm::VMError;
use std::sync::atomic::Ordering;

/// Types of memory segment for different use cases
#[derive(Debug, Clone, PartialEq)]
pub enum MemorySegment {
    /// Private memory for a single cooperative
    Cooperative,
    /// Shared memory between federation members
    Federation,
    /// Temporary computation space
    Scratch,
    /// Persistent storage space
    Persistent,
}

/// Operations for managing memory within the VM
pub enum MemoryOperation {
    /// Allocate new memory space
    Allocate {
        size: u64,
        segment_type: MemorySegment,
        federation_id: Option<String>,
        persistent: bool,
    },
    
    /// Free allocated memory
    Free {
        address: String,
        segment_type: MemorySegment,
    },
    
    /// Create shared memory segment for federation
    CreateSharedSegment {
        federation_id: String,
        size: u64,
        access_control: Vec<String>,
    },
    
    /// Join existing shared memory segment
    JoinSharedSegment {
        federation_id: String,
        segment_id: String,
    },
    
    /// Copy data between memory segments
    CopyMemory {
        source: String,
        destination: String,
        size: u64,
    },
    
    /// Move data between memory segments
    MoveMemory {
        source: String,
        destination: String,
        size: u64,
    },
    
    /// Resize existing memory allocation
    Resize {
        address: String,
        new_size: u64,
    },
    
    /// Get memory segment information
    GetMemoryInfo {
        segment_id: String,
    },
    
    /// Clear memory segment
    ClearMemory {
        segment_id: String,
    },
    
    /// Mark memory region for garbage collection
    MarkForCollection {
        address: String,
    },
    
    /// Run garbage collection
    CollectGarbage,
    
    /// Pin memory to prevent garbage collection
    PinMemory {
        address: String,
    },
    
    /// Unpin previously pinned memory
    UnpinMemory {
        address: String,
    },
    
    /// Compact memory to reduce fragmentation
    CompactMemory {
        segment_type: MemorySegment,
    },
}

impl Operation for MemoryOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            MemoryOperation::Allocate { size, segment_type, federation_id, persistent } => {
                ensure_permissions(&["memory.allocate".to_string()], &state.permissions)?;
                
                // Check if we have enough available memory
                let current_usage = state.memory.len() as u64;
                if current_usage + size > state.memory_limit {
                    return Err(VMError::OutOfMemory);
                }
                
                // Generate unique address
                let address = format!("{}:{}",
                    match segment_type {
                        MemorySegment::Cooperative => "coop",
                        MemorySegment::Federation => "fed", 
                        MemorySegment::Scratch => "scratch",
                        MemorySegment::Persistent => "persist",
                    },
                    state.memory_address_counter.fetch_add(1, Ordering::SeqCst)
                );

                let mut event_data = HashMap::new();
                event_data.insert("address".to_string(), address.clone());
                event_data.insert("size".to_string(), size.to_string());
                event_data.insert("segment_type".to_string(), format!("{:?}", segment_type));
                if let Some(fed_id) = federation_id {
                    event_data.insert("federation_id".to_string(), fed_id.clone());
                }
                event_data.insert("persistent".to_string(), persistent.to_string());
                
                emit_event(state, "MemoryAllocated".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::Free { address, segment_type } => {
                ensure_permissions(&["memory.free".to_string()], &state.permissions)?;
                
                if !state.memory.contains_key(address) {
                    return Err(VMError::InvalidMemoryAddress);
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("address".to_string(), address.clone());
                event_data.insert("segment_type".to_string(), format!("{:?}", segment_type));
                
                emit_event(state, "MemoryFreed".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::CreateSharedSegment { federation_id, size, access_control } => {
                ensure_permissions(&["memory.share".to_string()], &state.permissions)?;
                
                let segment_id = format!("shared:{}:{}", federation_id, 
                    state.memory_address_counter.fetch_add(1, Ordering::SeqCst));
                
                let mut event_data = HashMap::new();
                event_data.insert("segment_id".to_string(), segment_id);
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("size".to_string(), size.to_string());
                event_data.insert("access_control".to_string(), access_control.join(","));
                
                emit_event(state, "SharedMemoryCreated".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::JoinSharedSegment { federation_id, segment_id } => {
                ensure_permissions(&["memory.share".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("federation_id".to_string(), federation_id.clone());
                event_data.insert("segment_id".to_string(), segment_id.clone());
                
                emit_event(state, "SharedMemoryJoined".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::CopyMemory { source, destination, size } => {
                ensure_permissions(&["memory.copy".to_string()], &state.permissions)?;
                
                if !state.memory.contains_key(source) || !state.memory.contains_key(destination) {
                    return Err(VMError::InvalidMemoryAddress);
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("source".to_string(), source.clone());
                event_data.insert("destination".to_string(), destination.clone());
                event_data.insert("size".to_string(), size.to_string());
                
                emit_event(state, "MemoryCopied".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::MoveMemory { source, destination, size } => {
                ensure_permissions(&["memory.move".to_string()], &state.permissions)?;
                
                if !state.memory.contains_key(source) || !state.memory.contains_key(destination) {
                    return Err(VMError::InvalidMemoryAddress);
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("source".to_string(), source.clone());
                event_data.insert("destination".to_string(), destination.clone());
                event_data.insert("size".to_string(), size.to_string());
                
                emit_event(state, "MemoryMoved".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::Resize { address, new_size } => {
                ensure_permissions(&["memory.resize".to_string()], &state.permissions)?;
                
                if !state.memory.contains_key(address) {
                    return Err(VMError::InvalidMemoryAddress);
                }
                
                // Check if we have enough memory for the resize
                let current_usage = state.memory.len() as u64;
                if current_usage + new_size > state.memory_limit {
                    return Err(VMError::OutOfMemory);
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("address".to_string(), address.clone());
                event_data.insert("new_size".to_string(), new_size.to_string());
                
                emit_event(state, "MemoryResized".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::GetMemoryInfo { segment_id } => {
                let mut event_data = HashMap::new();
                event_data.insert("segment_id".to_string(), segment_id.clone());
                
                emit_event(state, "MemoryInfoQueried".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::ClearMemory { segment_id } => {
                ensure_permissions(&["memory.clear".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("segment_id".to_string(), segment_id.clone());
                
                emit_event(state, "MemoryCleared".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::MarkForCollection { address } => {
                let mut event_data = HashMap::new();
                event_data.insert("address".to_string(), address.clone());
                
                emit_event(state, "MemoryMarkedForCollection".to_string(), event_data);
                Ok(())
            },

            MemoryOperation::CollectGarbage => {
                ensure_permissions(&["memory.gc".to_string()], &state.permissions)?;
                
                emit_event(state, "GarbageCollectionRun".to_string(), HashMap::new());
                Ok(())
            },

            MemoryOperation::PinMemory { address } | MemoryOperation::UnpinMemory { address } => {
                ensure_permissions(&["memory.pin".to_string()], &state.permissions)?;
                
                let event_type = match self {
                    MemoryOperation::PinMemory { .. } => "MemoryPinned",
                    _ => "MemoryUnpinned",
                };
                
                let mut event_data = HashMap::new();
                event_data.insert("address".to_string(), address.clone());
                
                emit_event(state, event_type.to_string(), event_data);
                Ok(())
            },

            MemoryOperation::CompactMemory { segment_type } => {
                ensure_permissions(&["memory.compact".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("segment_type".to_string(), format!("{:?}", segment_type));
                
                emit_event(state, "MemoryCompacted".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            MemoryOperation::Allocate { size, .. } => 10 + (size / 1024),
            MemoryOperation::Free { .. } => 5,
            MemoryOperation::CreateSharedSegment { size, .. } => 20 + (size / 1024),
            MemoryOperation::JoinSharedSegment { .. } => 10,
            MemoryOperation::CopyMemory { size, .. } => 5 + (size / 1024),
            MemoryOperation::MoveMemory { size, .. } => 5 + (size / 1024),
            MemoryOperation::Resize { new_size, .. } => 10 + (new_size / 1024),
            MemoryOperation::GetMemoryInfo { .. } => 2,
            MemoryOperation::ClearMemory { .. } => 5,
            MemoryOperation::MarkForCollection { .. } => 2,
            MemoryOperation::CollectGarbage => 50,
            MemoryOperation::PinMemory { .. } => 5,
            MemoryOperation::UnpinMemory { .. } => 5,
            MemoryOperation::CompactMemory { .. } => 30,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            MemoryOperation::Allocate { .. } => vec!["memory.allocate".to_string()],
            MemoryOperation::Free { .. } => vec!["memory.free".to_string()],
            MemoryOperation::CreateSharedSegment { .. } | MemoryOperation::JoinSharedSegment { .. } => 
                vec!["memory.share".to_string()],
            MemoryOperation::CopyMemory { .. } => vec!["memory.copy".to_string()],
            MemoryOperation::MoveMemory { .. } => vec!["memory.move".to_string()],
            MemoryOperation::Resize { .. } => vec!["memory.resize".to_string()],
            MemoryOperation::ClearMemory { .. } => vec!["memory.clear".to_string()],
            MemoryOperation::CollectGarbage => vec!["memory.gc".to_string()],
            MemoryOperation::PinMemory { .. } | MemoryOperation::UnpinMemory { .. } => 
                vec!["memory.pin".to_string()],
            MemoryOperation::CompactMemory { .. } => vec!["memory.compact".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::atomic::AtomicU64;

    fn setup_test_state() -> VMState {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "memory.allocate".to_string(),
                "memory.free".to_string(),
                "memory.share".to_string(),
                "memory.copy".to_string(),
                "memory.move".to_string(),
            ],
            memory_limit: 1024 * 1024, // 1MB
            memory_address_counter: AtomicU64::new(0),
        }
    }

    #[test]
    fn test_allocate_memory() {
        let mut state = setup_test_state();
        let op = MemoryOperation::Allocate { 
            size: 1024,
            segment_type: MemorySegment::Cooperative,
            federation_id: None,
            persistent: false,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MemoryAllocated");
    }

    #[test]
    fn test_out_of_memory() {
        let mut state = setup_test_state();
        state.memory_limit = 1024; // Set small memory limit
        
        let op = MemoryOperation::Allocate {
            size: 2048,
            segment_type: MemorySegment::Cooperative,
            federation_id: None,
            persistent: false,
        };
        
        assert!(matches!(op.execute(&mut state), Err(VMError::OutOfMemory)));
    }

    #[test]
    fn test_shared_memory() {
        let mut state = setup_test_state();
        let op = MemoryOperation::CreateSharedSegment {
            federation_id: "fed1".to_string(),
            size: 2048,
            access_control: vec!["coop1".to_string(), "coop2".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "SharedMemoryCreated");
    }

    #[test]
    fn test_copy_memory() {
        let mut state = setup_test_state();
        // Set up source and destination in memory
        state.memory.insert("source".to_string(), 42);
        state.memory.insert("dest".to_string(), 0);
        
        let op = MemoryOperation::CopyMemory {
            source: "source".to_string(),
            destination: "dest".to_string(),
            size: 8,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MemoryCopied");
    }

    #[test]
    fn test_garbage_collection() {
        let mut state = setup_test_state();
        state.permissions.push("memory.gc".to_string());
        
        // Mark some memory for collection
        let mark_op = MemoryOperation::MarkForCollection {
            address: "unused".to_string(),
        };
        assert!(mark_op.execute(&mut state).is_ok());
        
        // Run garbage collection
        let gc_op = MemoryOperation::CollectGarbage;
        assert!(gc_op.execute(&mut state).is_ok());
        assert_eq!(state.events[1].event_type, "GarbageCollectionRun");
    }

    #[test]
    fn test_memory_pin_unpin() {
        let mut state = setup_test_state();
        state.permissions.push("memory.pin".to_string());
        
        let pin_op = MemoryOperation::PinMemory {
            address: "important".to_string(),
        };
        assert!(pin_op.execute(&mut state).is_ok());
        
        let unpin_op = MemoryOperation::UnpinMemory {
            address: "important".to_string(),
        };
        assert!(unpin_op.execute(&mut state).is_ok());
        
        assert_eq!(state.events[0].event_type, "MemoryPinned");
        assert_eq!(state.events[1].event_type, "MemoryUnpinned");
    }

    #[test]
    fn test_memory_compaction() {
        let mut state = setup_test_state();
        state.permissions.push("memory.compact".to_string());
        
        let op = MemoryOperation::CompactMemory {
            segment_type: MemorySegment::Cooperative,
        };
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MemoryCompacted");
    }

    #[test]
    fn test_invalid_memory_address() {
        let mut state = setup_test_state();
        let op = MemoryOperation::Free {
            address: "nonexistent".to_string(),
            segment_type: MemorySegment::Cooperative,
        };
        
        assert!(matches!(op.execute(&mut state), Err(VMError::InvalidMemoryAddress)));
    }

    #[test]
    fn test_memory_resize() {
        let mut state = setup_test_state();
        state.permissions.push("memory.resize".to_string());
        
        // First allocate some memory
        state.memory.insert("test_segment".to_string(), 0);
        
        let op = MemoryOperation::Resize {
            address: "test_segment".to_string(),
            new_size: 2048,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MemoryResized");
    }

    #[test]
    fn test_permission_checks() {
        let mut state = setup_test_state();
        state.permissions.clear(); // Remove all permissions
        
        let op = MemoryOperation::Allocate {
            size: 1024,
            segment_type: MemorySegment::Cooperative,
            federation_id: None,
            persistent: false,
        };
        
        assert!(matches!(op.execute(&mut state), Err(VMError::InsufficientPermissions)));
    }

    #[test]
    fn test_federation_shared_memory() {
        let mut state = setup_test_state();
        
        // Create shared memory segment
        let create_op = MemoryOperation::CreateSharedSegment {
            federation_id: "fed1".to_string(),
            size: 1024,
            access_control: vec!["coop1".to_string(), "coop2".to_string()],
        };
        assert!(create_op.execute(&mut state).is_ok());
        
        // Join shared memory segment
        let join_op = MemoryOperation::JoinSharedSegment {
            federation_id: "fed1".to_string(),
            segment_id: "shared:fed1:0".to_string(),
        };
        assert!(join_op.execute(&mut state).is_ok());
        
        assert_eq!(state.events[0].event_type, "SharedMemoryCreated");
        assert_eq!(state.events[1].event_type, "SharedMemoryJoined");
    }

    #[test]
    fn test_resource_costs() {
        let alloc_op = MemoryOperation::Allocate {
            size: 1024,
            segment_type: MemorySegment::Cooperative,
            federation_id: None,
            persistent: false,
        };
        assert_eq!(alloc_op.resource_cost(), 11); // 10 + (1024/1024)
        
        let gc_op = MemoryOperation::CollectGarbage;
        assert_eq!(gc_op.resource_cost(), 50);
    }
}

===================
File: ./backend/src/vm/operations/arithmetic.rs
===================
// src/vm/operations/arithmetic.rs

use super::{Operation, VMState, VMResult, ensure_stack_size};
use crate::vm::VMError;
use std::collections::HashMap;

/// Arithmetic operations for the VM
#[derive(Debug, Clone)]
pub enum ArithmeticOperation {
    /// Add the top two values
    Add,
    /// Subtract the top two values
    Sub,    
    /// Multiply the top two values
    Mul,    
    /// Divide the top two values
    Div,    
    /// Compute the modulo of the top two values
    Mod,    
    /// Increment the top value
    Increment,
    /// Decrement the top value
    Decrement,    
    /// Compute the absolute value
    Abs,    
    /// Negate the top value
    Negate,    
    /// Compute the minimum of two values
    Min,    
    /// Compute the maximum of two values
    Max,
}

impl Operation for ArithmeticOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            ArithmeticOperation::Add => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a + b);
                Ok(())
            },
            
            ArithmeticOperation::Sub => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a - b);
                Ok(())
            },
            
            ArithmeticOperation::Mul => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a * b);
                Ok(())
            },
            
            ArithmeticOperation::Div => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                if b == 0 {
                    return Err(VMError::DivisionByZero);
                }
                state.stack.push(a / b);
                Ok(())
            },
            
            ArithmeticOperation::Mod => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                if b == 0 {
                    return Err(VMError::DivisionByZero);
                }
                state.stack.push(a % b);
                Ok(())
            },
            
            ArithmeticOperation::Increment => {
                ensure_stack_size(&state.stack, 1)?;
                let a = state.stack.pop().unwrap();
                state.stack.push(a + 1);
                Ok(())
            },
            
            ArithmeticOperation::Decrement => {
                ensure_stack_size(&state.stack, 1)?;
                let a = state.stack.pop().unwrap();
                state.stack.push(a - 1);
                Ok(())
            },
            
            ArithmeticOperation::Abs => {
                ensure_stack_size(&state.stack, 1)?;
                let a = state.stack.pop().unwrap();
                state.stack.push(a.abs());
                Ok(())
            },
            
            ArithmeticOperation::Negate => {
                ensure_stack_size(&state.stack, 1)?;
                let a = state.stack.pop().unwrap();
                state.stack.push(-a);
                Ok(())
            },
            
            ArithmeticOperation::Min => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a.min(b));
                Ok(())
            },
            
            ArithmeticOperation::Max => {
                ensure_stack_size(&state.stack, 2)?;
                let b = state.stack.pop().unwrap();
                let a = state.stack.pop().unwrap();
                state.stack.push(a.max(b));
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            ArithmeticOperation::Add => 2,
            ArithmeticOperation::Sub => 2,
            ArithmeticOperation::Mul => 3,
            ArithmeticOperation::Div => 3,
            ArithmeticOperation::Mod => 3,
            ArithmeticOperation::Increment => 1,
            ArithmeticOperation::Decrement => 1,
            ArithmeticOperation::Abs => 1,
            ArithmeticOperation::Negate => 1,
            ArithmeticOperation::Min => 2,
            ArithmeticOperation::Max => 2,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        // Arithmetic operations don't require special permissions
        vec![]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn setup_test_state() -> VMState {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![],
            memory_limit: 1024 * 1024, // 1MB default limit
            memory_address_counter: AtomicU64::new(0),
        }
    }

    #[test]
    fn test_stack_operations() {
        let mut state = setup_test_state();
        
        // Test Add
        state.stack.extend([5, 3]);
        let add_op = ArithmeticOperation::Add;
        assert!(add_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![8]);

        // Test Subtract
        state.stack.extend([10]);
        let sub_op = ArithmeticOperation::Sub;
        assert!(sub_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![-2]); // 8 - 10 = -2
    }

    #[test]
    fn test_division_by_zero() {
        let mut state = setup_test_state();
        state.stack.extend([5, 0]);
        let op = ArithmeticOperation::Div;
        assert!(matches!(op.execute(&mut state), Err(VMError::DivisionByZero)));
    }

    #[test]
    fn test_advanced_operations() {
        let mut state = setup_test_state();

        // Test Abs
        state.stack.push(-5);
        let abs_op = ArithmeticOperation::Abs;
        assert!(abs_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![5]);

        // Test Min/Max
        state.stack.extend([10, 3]);
        let min_op = ArithmeticOperation::Min;
        assert!(min_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![5, 3]);

        state.stack.extend([8]);
        let max_op = ArithmeticOperation::Max;
        assert!(max_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![5, 8]);
    }

    #[test]
    fn test_increment_decrement() {
        let mut state = setup_test_state();
        
        // Test Increment
        state.stack.push(5);
        let inc_op = ArithmeticOperation::Increment;
        assert!(inc_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![6]);

        // Test Decrement
        let dec_op = ArithmeticOperation::Decrement;
        assert!(dec_op.execute(&mut state).is_ok());
        assert_eq!(state.stack, vec![5]);
    }
}

===================
File: ./backend/src/vm/operations/cooperative.rs
===================
// src/vm/operations/cooperative.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, ensure_reputation, emit_event};
use crate::vm::cooperative_metadata::CooperativeMetadata;
use std::sync::atomic::AtomicU64;

/// Types of operations that can be performed on cooperatives
pub enum CooperativeOperation {
    /// Create a new cooperative
    CreateCooperative {
        name: String,
        description: String,
        resource_policies: HashMap<String, ResourcePolicy>,
        membership_requirements: Vec<MembershipRequirement>,
    },
    
    /// Join an existing cooperative
    JoinCooperative {
        cooperative_id: String,
        role: String,
        qualifications: Vec<String>,
    },
    
    /// Leave a cooperative
    LeaveCooperative {
        cooperative_id: String,
        exit_reason: String,
    },
    
    /// Allocate resources within a cooperative
    AllocateResource {
        resource_type: String,
        amount: u64,
        recipient: String,
        purpose: String,
    },
    
    /// Transfer resources between cooperatives
    TransferResource {
        from_cooperative: String,
        to_cooperative: String,
        resource_type: String,
        amount: u64,
        terms: Vec<String>,
    },
    
    /// Create resource sharing agreement
    CreateSharingAgreement {
        partner_cooperative: String,
        resources: Vec<ResourceDefinition>,
        duration: u64,
        terms: Vec<String>,
    },
    
    /// Update cooperative metadata
    UpdateMetadata {
        cooperative_id: String,
        updates: HashMap<String, String>,
    },
    
    /// Add role to cooperative
    AddRole {
        role_name: String,
        permissions: Vec<String>,
        requirements: Vec<MembershipRequirement>,
    },
    
    /// Initiate federation with another cooperative
    InitiateFederation {
        partner_cooperative: String,
        federation_type: FederationType,
        terms: Vec<String>,
    },
}

#[derive(Debug, Clone)]
pub struct ResourcePolicy {
    pub resource_type: String,
    pub allocation_limit: u64,
    pub replenishment_rate: u64,
    pub required_reputation: i64,
    pub sharing_permissions: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MembershipRequirement {
    pub requirement_type: RequirementType,
    pub threshold: i64,
    pub verification_method: String,
}

#[derive(Debug, Clone)]
pub enum RequirementType {
    Reputation,
    ContributionCount,
    SkillLevel,
    TimeCommitment,
    ResourceStake,
    Custom(String),
}

#[derive(Debug, Clone)]
pub struct ResourceDefinition {
    pub resource_type: String,
    pub quantity: u64,
    pub access_level: AccessLevel,
    pub conditions: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum AccessLevel {
    ReadOnly,
    ReadWrite,
    FullAccess,
    Custom(String),
}

#[derive(Debug, Clone)]
pub enum FederationType {
    ResourceSharing,
    JointProjects,
    MutualAid,
    FullIntegration,
    Custom(String),
}

impl Operation for CooperativeOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            CooperativeOperation::CreateCooperative { 
                name, 
                description, 
                resource_policies,
                membership_requirements 
            } => {
                ensure_permissions(&["cooperative.create".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(200, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("name".to_string(), name.clone());
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("creator".to_string(), state.caller_did.clone());
                event_data.insert("policy_count".to_string(), resource_policies.len().to_string());
                event_data.insert("requirement_count".to_string(), membership_requirements.len().to_string());
                
                emit_event(state, "CooperativeCreated".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::JoinCooperative { cooperative_id, role, qualifications } => {
                ensure_permissions(&["cooperative.join".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(50, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("cooperative_id".to_string(), cooperative_id.clone());
                event_data.insert("role".to_string(), role.clone());
                event_data.insert("member_did".to_string(), state.caller_did.clone());
                event_data.insert("qualifications".to_string(), qualifications.join(","));
                
                emit_event(state, "CooperativeMemberAdded".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::LeaveCooperative { cooperative_id, exit_reason } => {
                let mut event_data = HashMap::new();
                event_data.insert("cooperative_id".to_string(), cooperative_id.clone());
                event_data.insert("member_did".to_string(), state.caller_did.clone());
                event_data.insert("exit_reason".to_string(), exit_reason.clone());
                
                emit_event(state, "CooperativeMemberLeft".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::AllocateResource { 
                resource_type, 
                amount, 
                recipient, 
                purpose 
            } => {
                ensure_permissions(&["resource.allocate".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(100, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("resource_type".to_string(), resource_type.clone());
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("recipient".to_string(), recipient.clone());
                event_data.insert("purpose".to_string(), purpose.clone());
                
                emit_event(state, "ResourceAllocated".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::TransferResource { 
                from_cooperative, 
                to_cooperative, 
                resource_type, 
                amount, 
                terms 
            } => {
                ensure_permissions(&["resource.transfer".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(150, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("from_cooperative".to_string(), from_cooperative.clone());
                event_data.insert("to_cooperative".to_string(), to_cooperative.clone());
                event_data.insert("resource_type".to_string(), resource_type.clone());
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("terms".to_string(), terms.join(","));
                
                emit_event(state, "ResourceTransferred".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::CreateSharingAgreement { 
                partner_cooperative, 
                resources, 
                duration, 
                terms 
            } => {
                ensure_permissions(&["agreement.create".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(200, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("partner_cooperative".to_string(), partner_cooperative.clone());
                event_data.insert("resource_count".to_string(), resources.len().to_string());
                event_data.insert("duration".to_string(), duration.to_string());
                event_data.insert("terms".to_string(), terms.join(","));
                
                emit_event(state, "SharingAgreementCreated".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::UpdateMetadata { cooperative_id, updates } => {
                ensure_permissions(&["cooperative.update".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("cooperative_id".to_string(), cooperative_id.clone());
                for (key, value) in updates {
                    event_data.insert(format!("update_{}", key), value.clone());
                }
                
                emit_event(state, "CooperativeMetadataUpdated".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::AddRole { 
                role_name, 
                permissions, 
                requirements 
            } => {
                ensure_permissions(&["role.create".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("role_name".to_string(), role_name.clone());
                event_data.insert("permissions".to_string(), permissions.join(","));
                event_data.insert("requirement_count".to_string(), requirements.len().to_string());
                
                emit_event(state, "RoleCreated".to_string(), event_data);
                Ok(())
            },
            
            CooperativeOperation::InitiateFederation { 
                partner_cooperative, 
                federation_type, 
                terms 
            } => {
                ensure_permissions(&["federation.initiate".to_string()], &state.permissions)?;
                
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                ensure_reputation(300, reputation)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("partner_cooperative".to_string(), partner_cooperative.clone());
                event_data.insert("federation_type".to_string(), format!("{:?}", federation_type));
                event_data.insert("terms".to_string(), terms.join(","));
                
                emit_event(state, "FederationInitiated".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            CooperativeOperation::CreateCooperative { .. } => 500,
            CooperativeOperation::JoinCooperative { .. } => 100,
            CooperativeOperation::LeaveCooperative { .. } => 50,
            CooperativeOperation::AllocateResource { .. } => 200,
            CooperativeOperation::TransferResource { .. } => 300,
            CooperativeOperation::CreateSharingAgreement { .. } => 400,
            CooperativeOperation::UpdateMetadata { .. } => 100,
            CooperativeOperation::AddRole { .. } => 150,
            CooperativeOperation::InitiateFederation { .. } => 1000,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            CooperativeOperation::CreateCooperative { .. } => vec!["cooperative.create".to_string()],
            CooperativeOperation::JoinCooperative { .. } => vec!["cooperative.join".to_string()],
            CooperativeOperation::AllocateResource { .. } => vec!["resource.allocate".to_string()],
            CooperativeOperation::TransferResource { .. } => vec!["resource.transfer".to_string()],
            CooperativeOperation::CreateSharingAgreement { .. } => vec!["agreement.create".to_string()],
            CooperativeOperation::UpdateMetadata { .. } => vec!["cooperative.update".to_string()],
            CooperativeOperation::AddRole { .. } => vec!["role.create".to_string()],
            CooperativeOperation::InitiateFederation { .. } => vec!["federation.initiate".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "cooperative.create".to_string(),
                "cooperative.join".to_string(),
                "resource.allocate".to_string(),
                "agreement.create".to_string(),
            ],
            memory_limit: 1024 * 1024, // 1MB default limit
            memory_address_counter: AtomicU64::new(0),
        }
    }

    #[test]
    fn test_create_cooperative() {
        let mut state = setup_test_state();
        let resource_policies = HashMap::new();
        let membership_requirements = vec![];
        
        let op = CooperativeOperation::CreateCooperative {
            name: "Test Coop".to_string(),
            description: "Test Description".to_string(),
            resource_policies,
            membership_requirements,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "CooperativeCreated");
    }

    #[test]
    fn test_allocate_resource() {
        let mut state = setup_test_state();
        let op = CooperativeOperation::AllocateResource {
            resource_type: "computing".to_string(),
            amount: 100,
            recipient: "test_recipient".to_string(),
            purpose: "testing".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "ResourceAllocated");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut state = setup_test_state();
        state.reputation_context.insert(state.caller_did.clone(), 100);
        
        let op = CooperativeOperation::InitiateFederation {
            partner_cooperative: "partner".to_string(),
            federation_type: FederationType::ResourceSharing,
            terms: vec!["term1".to_string()],
        };
        
        assert!(matches!(op.execute(&mut state), Err(_)));
    }
}

===================
File: ./backend/src/vm/operations/system.rs
===================
// src/vm/operations/system.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::vm::VMError;

/// System-level operations for the VM
pub enum SystemOperation {
    /// Log a message to system logs
    Log {
        message: String,
        level: LogLevel,
        metadata: HashMap<String, String>,
    },

    /// Halt VM execution
    Halt,

    /// Emit a custom event
    EmitEvent {
        event_type: String,
        data: HashMap<String, String>,
    },

    /// Get current block number
    GetBlockNumber,

    /// Get current timestamp
    GetTimestamp,

    /// Get caller's DID
    GetCaller,

    /// Record energy metrics
    RecordEnergyMetrics {
        operation_type: String,
        energy_used: u64,
        duration_ms: u64,
    },

    /// Get system statistics
    GetSystemStats {
        stat_types: Vec<StatType>,
    },

    /// Check system health
    CheckHealth {
        components: Vec<String>,
    },

    /// Update system parameters
    UpdateParameter {
        parameter: SystemParameter,
        value: String,
    },
}

#[derive(Debug, Clone)]
pub enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
    Critical,
}

#[derive(Debug, Clone)]
pub enum StatType {
    MemoryUsage,
    CpuLoad,
    NetworkActivity,
    StorageUsage,
    TransactionCount,
    ActiveNodes,
    EnergyMetrics,
}

#[derive(Debug, Clone)]
pub enum SystemParameter {
    MaxBlockSize,
    MaxTransactionsPerBlock,
    MinimumResourceCost,
    ReputationDecayRate,
    NetworkTimeout,
    ConsensusThreshold,
}

impl Operation for SystemOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            SystemOperation::Log { message, level, metadata } => {
                let mut event_data = HashMap::new();
                event_data.insert("message".to_string(), message.clone());
                event_data.insert("level".to_string(), format!("{:?}", level));
                
                for (key, value) in metadata {
                    event_data.insert(format!("metadata_{}", key), value.clone());
                }
                
                emit_event(state, "SystemLog".to_string(), event_data);
                Ok(())
            },

            SystemOperation::Halt => {
                emit_event(
                    state,
                    "SystemHalt".to_string(),
                    HashMap::new(),
                );
                Err(VMError::Custom("Execution halted".to_string()))
            },

            SystemOperation::EmitEvent { event_type, data } => {
                emit_event(state, event_type.clone(), data.clone());
                Ok(())
            },

            SystemOperation::GetBlockNumber => {
                state.stack.push(state.block_number as i64);
                Ok(())
            },

            SystemOperation::GetTimestamp => {
                state.stack.push(state.timestamp as i64);
                Ok(())
            },

            SystemOperation::GetCaller => {
                let caller_hash = state.caller_did.as_bytes().iter()
                    .fold(0i64, |acc, &b| acc + b as i64);
                state.stack.push(caller_hash);
                Ok(())
            },

            SystemOperation::RecordEnergyMetrics { operation_type, energy_used, duration_ms } => {
                ensure_permissions(&["system.metrics".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("operation_type".to_string(), operation_type.clone());
                event_data.insert("energy_used".to_string(), energy_used.to_string());
                event_data.insert("duration_ms".to_string(), duration_ms.to_string());
                
                emit_event(state, "EnergyMetricsRecorded".to_string(), event_data);
                Ok(())
            },

            SystemOperation::GetSystemStats { stat_types } => {
                ensure_permissions(&["system.stats".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("requested_stats".to_string(), 
                    stat_types.iter()
                        .map(|st| format!("{:?}", st))
                        .collect::<Vec<String>>()
                        .join(",")
                );
                
                // In a real implementation, we would collect actual system stats here
                for stat_type in stat_types {
                    match stat_type {
                        StatType::MemoryUsage => event_data.insert("memory_usage".to_string(), "1000".to_string()),
                        StatType::CpuLoad => event_data.insert("cpu_load".to_string(), "50".to_string()),
                        StatType::NetworkActivity => event_data.insert("network_activity".to_string(), "100".to_string()),
                        StatType::StorageUsage => event_data.insert("storage_usage".to_string(), "5000".to_string()),
                        StatType::TransactionCount => event_data.insert("transaction_count".to_string(), "1000".to_string()),
                        StatType::ActiveNodes => event_data.insert("active_nodes".to_string(), "10".to_string()),
                        StatType::EnergyMetrics => event_data.insert("energy_metrics".to_string(), "500".to_string()),
                    };
                }
                
                emit_event(state, "SystemStatsQueried".to_string(), event_data);
                Ok(())
            },

            SystemOperation::CheckHealth { components } => {
                ensure_permissions(&["system.health".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("components".to_string(), components.join(","));
                
                // In a real implementation, we would do actual health checks here
                event_data.insert("status".to_string(), "healthy".to_string());
                
                emit_event(state, "HealthCheckPerformed".to_string(), event_data);
                Ok(())
            },

            SystemOperation::UpdateParameter { parameter, value } => {
                ensure_permissions(&["system.admin".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("parameter".to_string(), format!("{:?}", parameter));
                event_data.insert("value".to_string(), value.clone());
                
                emit_event(state, "SystemParameterUpdated".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            SystemOperation::Log { .. } => 5,
            SystemOperation::Halt => 1,
            SystemOperation::EmitEvent { .. } => 10,
            SystemOperation::GetBlockNumber => 1,
            SystemOperation::GetTimestamp => 1,
            SystemOperation::GetCaller => 1,
            SystemOperation::RecordEnergyMetrics { .. } => 20,
            SystemOperation::GetSystemStats { stat_types } => 10 * (stat_types.len() as u64),
            SystemOperation::CheckHealth { components } => 15 * (components.len() as u64),
            SystemOperation::UpdateParameter { .. } => 50,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            SystemOperation::RecordEnergyMetrics { .. } => vec!["system.metrics".to_string()],
            SystemOperation::GetSystemStats { .. } => vec!["system.stats".to_string()],
            SystemOperation::CheckHealth { .. } => vec!["system.health".to_string()],
            SystemOperation::UpdateParameter { .. } => vec!["system.admin".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "system.metrics".to_string(),
                "system.stats".to_string(),
                "system.health".to_string(),
                "system.admin".to_string(),
            ],
        };
        state.reputation_context.insert(state.caller_did.clone(), 100);
        state
    }

    #[test]
    fn test_system_log() {
        let mut state = setup_test_state();
        let mut metadata = HashMap::new();
        metadata.insert("key".to_string(), "value".to_string());
        
        let op = SystemOperation::Log {
            message: "Test log".to_string(),
            level: LogLevel::Info,
            metadata,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "SystemLog");
    }

    #[test]
    fn test_emit_event() {
        let mut state = setup_test_state();
        let mut data = HashMap::new();
        data.insert("test_key".to_string(), "test_value".to_string());
        
        let op = SystemOperation::EmitEvent {
            event_type: "TestEvent".to_string(),
            data,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "TestEvent");
    }

    #[test]
    fn test_get_system_stats() {
        let mut state = setup_test_state();
        let op = SystemOperation::GetSystemStats {
            stat_types: vec![StatType::MemoryUsage, StatType::CpuLoad],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "SystemStatsQueried");
    }

    #[test]
    fn test_update_parameter() {
        let mut state = setup_test_state();
        let op = SystemOperation::UpdateParameter {
            parameter: SystemParameter::MaxBlockSize,
            value: "1000".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "SystemParameterUpdated");
    }

    #[test]
    fn test_halt() {
        let mut state = setup_test_state();
        let op = SystemOperation::Halt;
        
        assert!(matches!(op.execute(&mut state), Err(VMError::Custom(_))));
    }
}

===================
File: ./backend/src/vm/operations/mod.rs
===================
// src/vm/operations/mod.rs

use std::collections::HashMap;
use crate::vm::{VMError, VMResult};
use crate::vm::event::Event;

// Re-export operation modules
pub mod stack;
pub mod arithmetic;
pub mod cooperative;
pub mod governance;
pub mod reputation;
pub mod relationship;
pub mod system;
pub mod data;
pub mod memory;
pub mod network;
pub mod federation;

// Re-export necessary operation types
pub use stack::StackOperation;
pub use arithmetic::ArithmeticOperation;
pub use system::SystemOperation;
pub use relationship::RelationshipOperation;
pub use memory::MemoryOperation;

/// VM state structure
#[derive(Default)]
pub struct VMState {
    /// Current stack
    pub stack: Vec<i64>,
    
    /// Memory storage
    pub memory: HashMap<String, i64>,
    
    /// Events emitted during execution
    pub events: Vec<Event>,
    
    /// Current instruction pointer
    pub instruction_pointer: usize,
    
    /// Reputation scores for participating DIDs
    pub reputation_context: HashMap<String, i64>,
    
    /// Currently executing DID
    pub caller_did: String,
    
    /// Current block number
    pub block_number: u64,
    
    /// Current timestamp
    pub timestamp: u64,
    
    /// Available permissions
    pub permissions: Vec<String>,
    
    /// Maximum memory usage in bytes
    pub memory_limit: u64,
    
    /// Counter for generating unique memory addresses
    pub memory_address_counter: std::sync::atomic::AtomicU64,
}

/// Trait for implementable VM operations
pub trait Operation {
    /// Execute the operation on the given state
    fn execute(&self, state: &mut VMState) -> VMResult<()>;
    
    /// Get the resource cost of this operation
    fn resource_cost(&self) -> u64;
    
    /// Get required permissions for this operation
    fn required_permissions(&self) -> Vec<String>;
}

/// Helper function to check stack has enough items
pub fn ensure_stack_size(stack: &[i64], required: usize) -> VMResult<()> {
    if stack.len() < required {
        Err(VMError::StackUnderflow)
    } else {
        Ok(())
    }
}

/// Helper function to check caller permissions
pub fn ensure_permissions(required: &[String], available: &[String]) -> VMResult<()> {
    for perm in required {
        if !available.contains(perm) {
            return Err(VMError::InsufficientPermissions);
        }
    }
    Ok(())
}

/// Helper function to check reputation requirements 
pub fn ensure_reputation(required: i64, available: i64) -> VMResult<()> {
    if available < required {
        Err(VMError::InsufficientReputation)
    } else {
        Ok(())
    }
}

/// Helper function to emit an event
pub fn emit_event(state: &mut VMState, event_type: String, data: HashMap<String, String>) {
    let context = crate::vm::event::EventContext {
        triggered_by: state.caller_did.clone(),
        block_number: state.block_number,
        source_module: "vm".to_string(),
        transaction_id: None,
    };

    state.events.push(Event {
        event_type,
        cooperative_id: String::new(),
        data,
        timestamp: state.timestamp,
        context: Some(context)
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ensure_stack_size() {
        let stack = vec![1, 2, 3];
        assert!(ensure_stack_size(&stack, 3).is_ok());
        assert!(ensure_stack_size(&stack, 4).is_err());
    }

    #[test]
    fn test_ensure_permissions() {
        let required = vec!["test.permission".to_string()];
        let available = vec!["test.permission".to_string()];
        assert!(ensure_permissions(&required, &available).is_ok());

        let available = vec!["other.permission".to_string()];
        assert!(ensure_permissions(&required, &available).is_err());
    }

    #[test]
    fn test_ensure_reputation() {
        assert!(ensure_reputation(10, 20).is_ok());
        assert!(ensure_reputation(20, 10).is_err());
    }
}

===================
File: ./backend/src/vm/operations/governance.rs
===================
// src/vm/operations/governance.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::vm::VMError;

/// Operations for governance functionality
pub enum GovernanceOperation {
    /// Create a new proposal
    CreateProposal {
        title: String,
        description: String,
        proposal_type: ProposalType,
        duration: u64,
        required_reputation: i64,
    },

    /// Cast a vote on a proposal
    CastVote {
        proposal_id: String,
        approve: bool,
        comment: Option<String>,
    },

    /// Delegate voting power to another member
    DelegateVotes {
        delegate_to: String,
        scope: DelegationScope,
        duration: Option<u64>,
    },

    /// Execute an approved proposal
    ExecuteProposal {
        proposal_id: String,
    },

    /// Cancel a proposal (only by creator or governance admin)
    CancelProposal {
        proposal_id: String,
        reason: String,
    },

    /// Update quorum requirements
    UpdateQuorum {
        new_quorum: f64,
        proposal_type: Option<ProposalType>,
    },

    /// Extend voting period for a proposal
    ExtendVotingPeriod {
        proposal_id: String,
        additional_time: u64,
    },

    /// Get proposal details
    GetProposalDetails {
        proposal_id: String,
    },

    /// Get voting statistics
    GetVotingStats {
        proposal_id: String,
    },
}

#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    ResourceAllocation,
    PolicyChange,
    MembershipDecision,
    FederationAction,
    TechnicalChange,
    ReputationAdjustment,
    EmergencyAction,
    Custom(String),
}

#[derive(Debug, Clone)]
pub enum DelegationScope {
    All,
    ProposalType(ProposalType),
    SpecificProposal(String),
    Domain(String),
}

impl Operation for GovernanceOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            GovernanceOperation::CreateProposal { 
                title, 
                description, 
                proposal_type, 
                duration, 
                required_reputation 
            } => {
                ensure_permissions(&["governance.create_proposal".to_string()], &state.permissions)?;
                
                // Check if caller has sufficient reputation
                let caller_reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                if caller_reputation < *required_reputation {
                    return Err(VMError::InsufficientReputation);
                }

                let mut event_data = HashMap::new();
                event_data.insert("title".to_string(), title.clone());
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("duration".to_string(), duration.to_string());
                event_data.insert("required_reputation".to_string(), required_reputation.to_string());
                
                emit_event(state, "ProposalCreated".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::CastVote { proposal_id, approve, comment } => {
                ensure_permissions(&["governance.vote".to_string()], &state.permissions)?;

                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);

                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("approve".to_string(), approve.to_string());
                event_data.insert("voter_reputation".to_string(), reputation.to_string());
                
                if let Some(comment) = comment {
                    event_data.insert("comment".to_string(), comment.clone());
                }

                emit_event(state, "VoteCast".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::DelegateVotes { delegate_to, scope, duration } => {
                ensure_permissions(&["governance.delegate".to_string()], &state.permissions)?;

                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);

                if reputation < 100 {  // Minimum reputation required for delegation
                    return Err(VMError::InsufficientReputation);
                }

                let mut event_data = HashMap::new();
                event_data.insert("delegate_to".to_string(), delegate_to.clone());
                event_data.insert("scope".to_string(), format!("{:?}", scope));
                
                if let Some(dur) = duration {
                    event_data.insert("duration".to_string(), dur.to_string());
                }

                emit_event(state, "VotesDelegated".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::ExecuteProposal { proposal_id } => {
                ensure_permissions(&["governance.execute".to_string()], &state.permissions)?;

                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("executor".to_string(), state.caller_did.clone());

                emit_event(state, "ProposalExecuted".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::CancelProposal { proposal_id, reason } => {
                ensure_permissions(&["governance.cancel".to_string()], &state.permissions)?;

                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("reason".to_string(), reason.clone());
                event_data.insert("cancelled_by".to_string(), state.caller_did.clone());

                emit_event(state, "ProposalCancelled".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::UpdateQuorum { new_quorum, proposal_type } => {
                ensure_permissions(&["governance.update_quorum".to_string()], &state.permissions)?;

                if *new_quorum <= 0.0 || *new_quorum > 1.0 {
                    return Err(VMError::Custom("Invalid quorum value".to_string()));
                }

                let mut event_data = HashMap::new();
                event_data.insert("new_quorum".to_string(), new_quorum.to_string());
                
                if let Some(pt) = proposal_type {
                    event_data.insert("proposal_type".to_string(), format!("{:?}", pt));
                }

                emit_event(state, "QuorumUpdated".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::ExtendVotingPeriod { proposal_id, additional_time } => {
                ensure_permissions(&["governance.extend_voting".to_string()], &state.permissions)?;

                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("additional_time".to_string(), additional_time.to_string());

                emit_event(state, "VotingPeriodExtended".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::GetProposalDetails { proposal_id } => {
                // In a real implementation, this would query the proposal storage
                // For now, we just emit an event for tracking
                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("queried_by".to_string(), state.caller_did.clone());

                emit_event(state, "ProposalDetailsQueried".to_string(), event_data);
                Ok(())
            },

            GovernanceOperation::GetVotingStats { proposal_id } => {
                // Similarly, this would query voting statistics in a real implementation
                let mut event_data = HashMap::new();
                event_data.insert("proposal_id".to_string(), proposal_id.clone());
                event_data.insert("queried_by".to_string(), state.caller_did.clone());

                emit_event(state, "VotingStatsQueried".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            GovernanceOperation::CreateProposal { .. } => 100,
            GovernanceOperation::CastVote { .. } => 20,
            GovernanceOperation::DelegateVotes { .. } => 50,
            GovernanceOperation::ExecuteProposal { .. } => 200,
            GovernanceOperation::CancelProposal { .. } => 75,
            GovernanceOperation::UpdateQuorum { .. } => 150,
            GovernanceOperation::ExtendVotingPeriod { .. } => 30,
            GovernanceOperation::GetProposalDetails { .. } => 5,
            GovernanceOperation::GetVotingStats { .. } => 5,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            GovernanceOperation::CreateProposal { .. } => vec!["governance.create_proposal".to_string()],
            GovernanceOperation::CastVote { .. } => vec!["governance.vote".to_string()],
            GovernanceOperation::DelegateVotes { .. } => vec!["governance.delegate".to_string()],
            GovernanceOperation::ExecuteProposal { .. } => vec!["governance.execute".to_string()],
            GovernanceOperation::CancelProposal { .. } => vec!["governance.cancel".to_string()],
            GovernanceOperation::UpdateQuorum { .. } => vec!["governance.update_quorum".to_string()],
            GovernanceOperation::ExtendVotingPeriod { .. } => vec!["governance.extend_voting".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "governance.create_proposal".to_string(),
                "governance.vote".to_string(),
                "governance.execute".to_string(),
            ],
        };
        
        state.reputation_context.insert(state.caller_did.clone(), 200);
        state
    }

    #[test]
    fn test_create_proposal() {
        let mut state = setup_test_state();
        let op = GovernanceOperation::CreateProposal {
            title: "Test Proposal".to_string(),
            description: "Test Description".to_string(),
            proposal_type: ProposalType::PolicyChange,
            duration: 86400,
            required_reputation: 100,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events.len(), 1);
        assert_eq!(state.events[0].event_type, "ProposalCreated");
    }

    #[test]
    fn test_cast_vote() {
        let mut state = setup_test_state();
        let op = GovernanceOperation::CastVote {
            proposal_id: "test_proposal".to_string(),
            approve: true,
            comment: Some("Support this proposal".to_string()),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events.len(), 1);
        assert_eq!(state.events[0].event_type, "VoteCast");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut state = setup_test_state();
        state.reputation_context.insert(state.caller_did.clone(), 50);
        
        let op = GovernanceOperation::CreateProposal {
            title: "Test Proposal".to_string(),
            description: "Test Description".to_string(),
            proposal_type: ProposalType::PolicyChange,
            duration: 86400,
            required_reputation: 100,
        };
        
        assert!(matches!(op.execute(&mut state), Err(VMError::InsufficientReputation)));
    }

    #[test]
    fn test_update_quorum() {
        let mut state = setup_test_state();
        state.permissions.push("governance.update_quorum".to_string());
        
        let op = GovernanceOperation::UpdateQuorum {
            new_quorum: 0.75,
            proposal_type: Some(ProposalType::PolicyChange),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events.len(), 1);
        assert_eq!(state.events[0].event_type, "QuorumUpdated");
    }
}

===================
File: ./backend/src/vm/operations/reputation.rs
===================
// src/vm/operations/reputation.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::vm::VMError;

/// Operations for managing reputation within the system
pub enum ReputationOperation {
    /// Update a member's reputation by a specific amount
    UpdateReputation {
        amount: i64,
        reason: String,
        context: String,
    },
    
    /// Get the current reputation of an account
    GetReputation {
        target_did: String,
    },
    
    /// Burn (remove) reputation from an account
    BurnReputation {
        amount: i64,
        reason: String,
    },
    
    /// Mint new reputation (requires special permissions)
    MintReputation {
        target_did: String,
        amount: i64,
        reason: String,
    },
    
    /// Record contribution impact on reputation
    RecordContributionImpact {
        contribution_id: String,
        impact_score: i64,
        context: String,
    },
    
    /// Calculate voting power based on reputation
    CalculateVotingPower {
        context: String,
    },
    
    /// Decay reputation over time
    ApplyReputationDecay {
        decay_rate: f64,
        minimum_reputation: i64,
    },
    
    /// Get reputation history for an account
    GetReputationHistory {
        target_did: String,
        context: Option<String>,
    },
}

impl Operation for ReputationOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            ReputationOperation::UpdateReputation { amount, reason, context } => {
                ensure_permissions(&["reputation.update".to_string()], &state.permissions)?;
                
                let current_rep = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                let new_rep = current_rep + amount;
                state.reputation_context.insert(state.caller_did.clone(), new_rep);
                
                let mut event_data = HashMap::new();
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("reason".to_string(), reason.clone());
                event_data.insert("context".to_string(), context.clone());
                event_data.insert("new_total".to_string(), new_rep.to_string());
                
                emit_event(state, "ReputationUpdated".to_string(), event_data);
                Ok(())
            },
            
            ReputationOperation::GetReputation { target_did } => {
                let reputation = state.reputation_context
                    .get(target_did)
                    .copied()
                    .unwrap_or(0);
                    
                state.stack.push(reputation);
                Ok(())
            },
            
            ReputationOperation::BurnReputation { amount, reason } => {
                ensure_permissions(&["reputation.burn".to_string()], &state.permissions)?;
                
                let current_rep = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                    
                if current_rep < *amount {
                    return Err(VMError::InsufficientReputation);
                }
                
                let new_rep = current_rep - amount;
                state.reputation_context.insert(state.caller_did.clone(), new_rep);
                
                let mut event_data = HashMap::new();
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("reason".to_string(), reason.clone());
                event_data.insert("new_total".to_string(), new_rep.to_string());
                
                emit_event(state, "ReputationBurned".to_string(), event_data);
                Ok(())
            },
            
            ReputationOperation::MintReputation { target_did, amount, reason } => {
                ensure_permissions(&["reputation.mint".to_string()], &state.permissions)?;
                
                let current_rep = state.reputation_context
                    .get(target_did)
                    .copied()
                    .unwrap_or(0);
                    
                let new_rep = current_rep + amount;
                state.reputation_context.insert(target_did.clone(), new_rep);
                
                let mut event_data = HashMap::new();
                event_data.insert("target_did".to_string(), target_did.clone());
                event_data.insert("amount".to_string(), amount.to_string());
                event_data.insert("reason".to_string(), reason.clone());
                event_data.insert("new_total".to_string(), new_rep.to_string());
                
                emit_event(state, "ReputationMinted".to_string(), event_data);
                Ok(())
            },
            
            ReputationOperation::RecordContributionImpact { contribution_id, impact_score, context } => {
                ensure_permissions(&["contribution.record".to_string()], &state.permissions)?;
                
                // Calculate reputation change based on impact score
                let reputation_change = if *impact_score < -50 {
                    -50
                } else if *impact_score > 50 {
                    50
                } else {
                    *impact_score
                };
                
                let current_rep = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                    
                let new_rep = current_rep + reputation_change;
                state.reputation_context.insert(state.caller_did.clone(), new_rep);
                
                let mut event_data = HashMap::new();
                event_data.insert("contribution_id".to_string(), contribution_id.clone());
                event_data.insert("impact_score".to_string(), impact_score.to_string());
                event_data.insert("context".to_string(), context.clone());
                event_data.insert("reputation_change".to_string(), reputation_change.to_string());
                
                emit_event(state, "ContributionImpactRecorded".to_string(), event_data);
                Ok(())
            },
            
            ReputationOperation::CalculateVotingPower { context: _ } => {
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                
                // Calculate voting power as square root of reputation to prevent excessive concentration
                let voting_power = (reputation as f64).sqrt() as i64;
                state.stack.push(voting_power);
                Ok(())
            },
            
            ReputationOperation::ApplyReputationDecay { decay_rate, minimum_reputation } => {
                ensure_permissions(&["reputation.decay".to_string()], &state.permissions)?;
                
                let mut decayed_accounts = Vec::new();
                
                for (did, rep) in state.reputation_context.iter_mut() {
                    let old_rep = *rep;
                    let new_rep = (*rep as f64 * (1.0 - decay_rate)) as i64;
                    *rep = new_rep.max(*minimum_reputation);
                    
                    if old_rep != *rep {
                        decayed_accounts.push((did.clone(), old_rep, *rep));
                    }
                }
                
                let mut event_data = HashMap::new();
                event_data.insert("decay_rate".to_string(), decay_rate.to_string());
                event_data.insert("accounts_affected".to_string(), decayed_accounts.len().to_string());
                
                emit_event(state, "ReputationDecayApplied".to_string(), event_data);
                Ok(())
            },
            
            ReputationOperation::GetReputationHistory { target_did: _, context: _ } => {
                // In a real implementation, this would query historical reputation data
                // For now, we just return the current reputation
                let reputation = state.reputation_context
                    .get(&state.caller_did)
                    .copied()
                    .unwrap_or(0);
                    
                state.stack.push(reputation);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            ReputationOperation::UpdateReputation { .. } => 5,
            ReputationOperation::GetReputation { .. } => 1,
            ReputationOperation::BurnReputation { .. } => 5,
            ReputationOperation::MintReputation { .. } => 10,
            ReputationOperation::RecordContributionImpact { .. } => 7,
            ReputationOperation::CalculateVotingPower { .. } => 3,
            ReputationOperation::ApplyReputationDecay { .. } => 15,
            ReputationOperation::GetReputationHistory { .. } => 2,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            ReputationOperation::UpdateReputation { .. } => vec!["reputation.update".to_string()],
            ReputationOperation::BurnReputation { .. } => vec!["reputation.burn".to_string()],
            ReputationOperation::MintReputation { .. } => vec!["reputation.mint".to_string()],
            ReputationOperation::RecordContributionImpact { .. } => vec!["contribution.record".to_string()],
            ReputationOperation::ApplyReputationDecay { .. } => vec!["reputation.decay".to_string()],
            _ => vec![],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "reputation.update".to_string(),
                "reputation.mint".to_string(),
                "reputation.burn".to_string(),
                "reputation.decay".to_string(),
                "contribution.record".to_string(),
            ],
            memory_limit: 1024 * 1024, // 1MB
        };
        
        state.reputation_context.insert(state.caller_did.clone(), 100);
        state
    }

    #[test]
    fn test_update_reputation() {
        let mut state = setup_test_state();
        let op = ReputationOperation::UpdateReputation {
            amount: 50,
            reason: "test".to_string(),
            context: "testing".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.reputation_context.get("test_caller"), Some(&150));
    }

    #[test]
    fn test_burn_reputation() {
        let mut state = setup_test_state();
        let op = ReputationOperation::BurnReputation {
            amount: 30,
            reason: "test".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.reputation_context.get("test_caller"), Some(&70));
    }

    #[test]
    fn test_record_contribution_impact() {
        let mut state = setup_test_state();
        let op = ReputationOperation::RecordContributionImpact {
            contribution_id: "test_contrib".to_string(),
            impact_score: 25,
            context: "testing".to_string(),
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.reputation_context.get("test_caller"), Some(&125));
    }

    #[test]
    fn test_reputation_decay() {
        let mut state = setup_test_state();
        let op = ReputationOperation::ApplyReputationDecay {
            decay_rate: 0.1,
            minimum_reputation: 0,
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.reputation_context.get("test_caller"), Some(&90)); // 100 * 0.9 = 90
    }
}

===================
File: ./backend/src/vm/operations/community.rs
===================
// src/vm/operations/community.rs

use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, ensure_reputation, emit_event};
use crate::vm::VMError;

/// Operations specific to community management and civic participation
pub enum CommunityOperation {
    /// Create a new community
    CreateCommunity {
        name: String,
        description: String,
        governance_model: String,
    },
    
    /// Join an existing community
    JoinCommunity {
        community_id: String,
        role: String,
    },
    
    /// Leave a community
    LeaveCommunity {
        community_id: String,
    },
    
    /// Create a civic initiative
    CreateInitiative {
        community_id: String,
        title: String,
        description: String,
        category: String,
    },
    
    /// Support an initiative
    SupportInitiative {
        initiative_id: String,
        support_type: String,
    },
    
    /// Record civic participation
    RecordParticipation {
        community_id: String,
        activity_type: String,
        description: String,
        impact: String,
    },
    
    /// Update community guidelines
    UpdateGuidelines {
        community_id: String,
        updates: HashMap<String, String>,
    },
    
    /// Create working group
    CreateWorkingGroup {
        community_id: String,
        name: String,
        purpose: String,
        membership_criteria: String,
    },
    
    /// Coordinate inter-community action
    CoordinateAction {
        communities: Vec<String>,
        action_type: String,
        description: String,
        resources_needed: HashMap<String, u64>,
    },
}

impl Operation for CommunityOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            CommunityOperation::CreateCommunity { name, description, governance_model } => {
                // Verify permissions
                ensure_permissions(&["community.create".to_string()], &state.permissions)?;
                
                // Verify reputation requirements
                ensure_reputation(100, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                // Record the event
                let mut event_data = HashMap::new();
                event_data.insert("name".to_string(), name.clone());
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("governance_model".to_string(), governance_model.clone());
                
                emit_event(state, "CommunityCreated".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::JoinCommunity { community_id, role } => {
                // Basic reputation check for joining
                ensure_reputation(10, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("community_id".to_string(), community_id.clone());
                event_data.insert("role".to_string(), role.clone());
                
                emit_event(state, "CommunityJoined".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::CreateInitiative { community_id, title, description, category } => {
                // Ensure member has sufficient reputation for creating initiatives
                ensure_reputation(50, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("community_id".to_string(), community_id.clone());
                event_data.insert("title".to_string(), title.clone());
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("category".to_string(), category.clone());
                
                emit_event(state, "InitiativeCreated".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::RecordParticipation { community_id, activity_type, description, impact } => {
                let mut event_data = HashMap::new();
                event_data.insert("community_id".to_string(), community_id.clone());
                event_data.insert("activity_type".to_string(), activity_type.clone());
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("impact".to_string(), impact.clone());
                
                emit_event(state, "ParticipationRecorded".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::UpdateGuidelines { community_id, updates } => {
                // Verify permissions for guideline updates
                ensure_permissions(&["community.update_guidelines".to_string()], &state.permissions)?;
                ensure_reputation(200, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("community_id".to_string(), community_id.clone());
                for (key, value) in updates {
                    event_data.insert(format!("update_{}", key), value.clone());
                }
                
                emit_event(state, "GuidelinesUpdated".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::CreateWorkingGroup { community_id, name, purpose, membership_criteria } => {
                ensure_permissions(&["community.create_group".to_string()], &state.permissions)?;
                ensure_reputation(75, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("community_id".to_string(), community_id.clone());
                event_data.insert("name".to_string(), name.clone());
                event_data.insert("purpose".to_string(), purpose.clone());
                event_data.insert("membership_criteria".to_string(), membership_criteria.clone());
                
                emit_event(state, "WorkingGroupCreated".to_string(), event_data);
                Ok(())
            },

            CommunityOperation::CoordinateAction { communities, action_type, description, resources_needed } => {
                ensure_permissions(&["community.coordinate_action".to_string()], &state.permissions)?;
                ensure_reputation(150, state.reputation_context.get(&state.caller_did).copied().unwrap_or(0))?;
                
                let mut event_data = HashMap::new();
                event_data.insert("communities".to_string(), communities.join(","));
                event_data.insert("action_type".to_string(), action_type.clone());
                event_data.insert("description".to_string(), description.clone());
                
                for (resource, amount) in resources_needed {
                    event_data.insert(format!("resource_{}", resource), amount.to_string());
                }
                
                emit_event(state, "InterCommunityActionCreated".to_string(), event_data);
                Ok(())
            },

            _ => Err(VMError::Custom("Operation not implemented".to_string())),
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            CommunityOperation::CreateCommunity { .. } => 200,
            CommunityOperation::JoinCommunity { .. } => 50,
            CommunityOperation::CreateInitiative { .. } => 100,
            CommunityOperation::RecordParticipation { .. } => 30,
            CommunityOperation::UpdateGuidelines { .. } => 150,
            CommunityOperation::CreateWorkingGroup { .. } => 120,
            CommunityOperation::CoordinateAction { .. } => 180,
            _ => 50, // Default cost for other operations
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            CommunityOperation::CreateCommunity { .. } => vec!["community.create".to_string()],
            CommunityOperation::UpdateGuidelines { .. } => vec!["community.update_guidelines".to_string()],
            CommunityOperation::CreateWorkingGroup { .. } => vec!["community.create_group".to_string()],
            CommunityOperation::CoordinateAction { .. } => vec!["community.coordinate_action".to_string()],
            _ => vec![], // Other operations might not require specific permissions
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_state() -> VMState {
        let mut state = VMState::default();
        state.caller_did = "did:icn:test".to_string();
        state.reputation_context.insert(state.caller_did.clone(), 200);
        state.permissions = vec![
            "community.create".to_string(),
            "community.update_guidelines".to_string(),
            "community.create_group".to_string(),
        ];
        state
    }

    #[test]
    fn test_create_community() {
        let mut state = setup_test_state();
        let op = CommunityOperation::CreateCommunity {
            name: "Test Community".to_string(),
            description: "A test community".to_string(),
            governance_model: "democratic".to_string(),
        };

        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events.len(), 1);
        assert_eq!(state.events[0].event_type, "CommunityCreated");
    }

    // Add more tests for other operations...
}

===================
File: ./backend/src/vm/operations/relationship.rs
===================
// src/vm/operations/relationship.rs


use std::collections::HashMap;
use super::{Operation, VMState, VMResult, ensure_permissions, emit_event};
use crate::relationship::{Contribution, MutualAidInteraction, Relationship, 
                         Interaction, InteractionType, Endorsement};

#[derive(Debug, Clone, PartialEq)]
pub enum RelationType {
    Collaboration,
    Mentorship,
    MutualAid,
    Custom(String),
}

/// Operations for managing relationships between members
pub enum RelationshipOperation {
    /// Record a contribution with impact story
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    /// Record mutual aid interaction
    RecordMutualAid {
        receiver_did: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    /// Update relationship between members
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    /// Add endorsement to relationship
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

impl Operation for RelationshipOperation {
    fn execute(&self, state: &mut VMState) -> VMResult<()> {
        match self {
            RelationshipOperation::RecordContribution { 
                description,
                impact_story,
                context,
                tags 
            } => {
                ensure_permissions(&["contribution.record".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("description".to_string(), description.clone());
                event_data.insert("impact_story".to_string(), impact_story.clone());
                event_data.insert("context".to_string(), context.clone());
                event_data.insert("tags".to_string(), tags.join(","));
                
                emit_event(state, "ContributionRecorded".to_string(), event_data);
                Ok(())
            },

            RelationshipOperation::RecordMutualAid { 
                receiver_did,
                description,
                impact_story,
                reciprocity_notes,
                tags 
            } => {
                ensure_permissions(&["mutual_aid.record".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("receiver_did".to_string(), receiver_did.clone());
                event_data.insert("description".to_string(), description.clone());
                
                if let Some(impact) = impact_story {
                    event_data.insert("impact_story".to_string(), impact.clone());
                }
                
                if let Some(notes) = reciprocity_notes {
                    event_data.insert("reciprocity_notes".to_string(), notes.clone());
                }
                
                event_data.insert("tags".to_string(), tags.join(","));
                
                emit_event(state, "MutualAidRecorded".to_string(), event_data);
                Ok(())
            },

            RelationshipOperation::UpdateRelationship { 
                member_two,
                relationship_type,
                story,
                interaction 
            } => {
                ensure_permissions(&["relationship.update".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("member_two".to_string(), member_two.clone());
                event_data.insert("relationship_type".to_string(), relationship_type.clone());
                event_data.insert("story".to_string(), story.clone());
                
                if let Some(interaction_data) = interaction {
                    event_data.insert("interaction".to_string(), interaction_data.clone());
                }
                
                emit_event(state, "RelationshipUpdated".to_string(), event_data);
                Ok(())
            },

            RelationshipOperation::AddEndorsement { 
                to_did,
                content,
                context,
                skills 
            } => {
                ensure_permissions(&["endorsement.add".to_string()], &state.permissions)?;
                
                let mut event_data = HashMap::new();
                event_data.insert("to_did".to_string(), to_did.clone());
                event_data.insert("content".to_string(), content.clone());
                event_data.insert("context".to_string(), context.clone());
                event_data.insert("skills".to_string(), skills.join(","));
                
                emit_event(state, "EndorsementAdded".to_string(), event_data);
                Ok(())
            },
        }
    }

    fn resource_cost(&self) -> u64 {
        match self {
            RelationshipOperation::RecordContribution { .. } => 100,
            RelationshipOperation::RecordMutualAid { .. } => 80,
            RelationshipOperation::UpdateRelationship { .. } => 60,
            RelationshipOperation::AddEndorsement { .. } => 50,
        }
    }

    fn required_permissions(&self) -> Vec<String> {
        match self {
            RelationshipOperation::RecordContribution { .. } => vec!["contribution.record".to_string()],
            RelationshipOperation::RecordMutualAid { .. } => vec!["mutual_aid.record".to_string()],
            RelationshipOperation::UpdateRelationship { .. } => vec!["relationship.update".to_string()],
            RelationshipOperation::AddEndorsement { .. } => vec!["endorsement.add".to_string()],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::atomic::AtomicU64;

    fn setup_test_state() -> VMState {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did: "test_caller".to_string(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![
                "contribution.record".to_string(),
                "mutual_aid.record".to_string(),
            ],
            memory_limit: 1024 * 1024, // 1MB
            memory_address_counter: AtomicU64::new(0),
        }
    }

    #[test]
    fn test_record_contribution() {
        let mut state = setup_test_state();
        let op = RelationshipOperation::RecordContribution {
            description: "Test contribution".to_string(),
            impact_story: "Made a difference".to_string(),
            context: "Testing".to_string(),
            tags: vec!["test".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "ContributionRecorded");
    }

    #[test]
    fn test_record_mutual_aid() {
        let mut state = setup_test_state();
        let op = RelationshipOperation::RecordMutualAid {
            receiver_did: "receiver".to_string(),
            description: "Help provided".to_string(),
            impact_story: Some("Positive impact".to_string()),
            reciprocity_notes: None,
            tags: vec!["help".to_string()],
        };
        
        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "MutualAidRecorded");
    }

    #[test]
    fn test_insufficient_permissions() {
        let mut state = setup_test_state();
        state.permissions.clear();
        
        let op = RelationshipOperation::RecordContribution {
            description: "Test".to_string(),
            impact_story: "Test".to_string(),
            context: "Test".to_string(),
            tags: vec![],
        };
        
        assert!(op.execute(&mut state).is_err());
    }

    #[test]
    fn test_update_relationship() {
        let mut state = setup_test_state();
        state.permissions.push("relationship.update".to_string());

        let op = RelationshipOperation::UpdateRelationship {
            member_two: "other_member".to_string(),
            relationship_type: "collaboration".to_string(),
            story: "Working together".to_string(),
            interaction: Some("Initial meeting".to_string()),
        };

        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "RelationshipUpdated");
    }

    #[test]
    fn test_add_endorsement() {
        let mut state = setup_test_state();
        state.permissions.push("endorsement.add".to_string());

        let op = RelationshipOperation::AddEndorsement {
            to_did: "endorsed_member".to_string(),
            content: "Great collaboration!".to_string(),
            context: "Project work".to_string(),
            skills: vec!["teamwork".to_string(), "communication".to_string()],
        };

        assert!(op.execute(&mut state).is_ok());
        assert_eq!(state.events[0].event_type, "EndorsementAdded");
    }
}

===================
File: ./backend/src/vm/contract.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use super::opcode::OpCode;
use super::cooperative_metadata::CooperativeMetadata;

#[derive(Clone, Serialize, Deserialize)]
pub struct Contract {
    pub id: String,
    pub code: Vec<OpCode>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/cooperative_metadata.rs
===================
// src/vm/cooperative_metadata.rs

use std::collections::HashMap;
use serde::{Serialize, Deserialize};

/// Resource impact metrics for cooperative operations
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct ResourceImpact {
    /// CPU intensity of operations (0-10)
    pub cpu_intensity: u8,
    
    /// Memory usage in MB
    pub memory_usage: u8,
    
    /// Network usage in MB/s
    pub network_usage: u8,
    
    /// Storage usage in MB
    pub storage_usage: u8,
    
    /// Bandwidth usage in MB/s
    pub bandwidth_usage: u8,
}

/// Metadata about a cooperative's operations and resource usage
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct CooperativeMetadata {
    /// DID of the cooperative's creator
    #[serde(default)]
    pub creator_did: String,
    
    /// Unique identifier for the cooperative
    #[serde(default)]
    pub cooperative_id: String,
    
    /// Description of cooperative's purpose
    #[serde(default)]
    pub purpose: String,
    
    /// Resource impact metrics
    #[serde(default)]
    pub resource_impact: ResourceImpact,
    
    /// Federation ID if part of a federation
    #[serde(default)]
    pub federation_id: Option<String>,
    
    /// When the cooperative was created
    #[serde(default)]
    pub creation_timestamp: u64,
    
    /// When metadata was last updated
    #[serde(default)]
    pub last_updated: u64,
    
    /// Current number of members
    #[serde(default)]
    pub member_count: u64,
    
    /// Resource allocation per member
    #[serde(default)]
    pub resource_allocation: HashMap<String, u64>,

    /// Energy usage metrics in kWh
    #[serde(default)]
    pub energy_usage: HashMap<String, f64>,
}

impl CooperativeMetadata {
    /// Creates new metadata for a cooperative
    pub fn new(
        creator_did: String, 
        cooperative_id: String,
        purpose: String
    ) -> Self {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        CooperativeMetadata {
            creator_did,
            cooperative_id,
            purpose,
            creation_timestamp: now,
            last_updated: now,
            member_count: 1, // Start with creator as member
            resource_impact: ResourceImpact::default(),
            federation_id: None,
            resource_allocation: HashMap::new(),
            energy_usage: HashMap::new(),
        }
    }

    /// Updates the metadata timestamp
    pub fn update_timestamp(&mut self) {
        self.last_updated = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
    }

    /// Adds a member and updates count
    pub fn add_member(&mut self) -> u64 {
        self.member_count += 1;
        self.update_timestamp();
        self.member_count
    }

    /// Removes a member and updates count
    pub fn remove_member(&mut self) -> u64 {
        if self.member_count > 0 {
            self.member_count -= 1;
        }
        self.update_timestamp();
        self.member_count
    }

    /// Allocates resources to a member
    pub fn allocate_resources(&mut self, member_did: String, amount: u64) {
        self.resource_allocation.insert(member_did, amount);
        self.update_timestamp();
    }

    /// Records energy usage for a specific operation
    pub fn record_energy_usage(&mut self, operation: &str, kwh: f64) {
        let current = self.energy_usage.get(operation).copied().unwrap_or(0.0);
        self.energy_usage.insert(operation.to_string(), current + kwh);
        self.update_timestamp();
    }

    /// Gets total energy usage across all operations
    pub fn total_energy_usage(&self) -> f64 {
        self.energy_usage.values().sum()
    }

    /// Checks if cooperative is part of federation
    pub fn is_federated(&self) -> bool {
        self.federation_id.is_some()
    }

    /// Sets federation membership
    pub fn join_federation(&mut self, federation_id: String) {
        self.federation_id = Some(federation_id);
        self.update_timestamp();
    }

    /// Removes federation membership
    pub fn leave_federation(&mut self) {
        self.federation_id = None;
        self.update_timestamp();
    }

    /// Gets resource allocation for a member
    pub fn get_member_resources(&self, member_did: &str) -> u64 {
        self.resource_allocation.get(member_did).copied().unwrap_or(0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    fn create_test_metadata() -> CooperativeMetadata {
        CooperativeMetadata::new(
            "did:icn:test".to_string(),
            "coop-1".to_string(),
            "Test cooperative".to_string()
        )
    }

    #[test]
    fn test_metadata_creation() {
        let metadata = create_test_metadata();
        assert_eq!(metadata.creator_did, "did:icn:test");
        assert_eq!(metadata.cooperative_id, "coop-1");
        assert_eq!(metadata.member_count, 1);
    }

    #[test]
    fn test_member_management() {
        let mut metadata = create_test_metadata();
        assert_eq!(metadata.add_member(), 2);
        assert_eq!(metadata.add_member(), 3);
        assert_eq!(metadata.remove_member(), 2);
    }

    #[test]
    fn test_resource_allocation() {
        let mut metadata = create_test_metadata();
        metadata.allocate_resources("member1".to_string(), 100);
        assert_eq!(metadata.get_member_resources("member1"), 100);
        assert_eq!(metadata.get_member_resources("nonexistent"), 0);
    }

    #[test]
    fn test_federation_membership() {
        let mut metadata = create_test_metadata();
        assert!(!metadata.is_federated());
        
        metadata.join_federation("fed-1".to_string());
        assert!(metadata.is_federated());
        assert_eq!(metadata.federation_id, Some("fed-1".to_string()));
        
        metadata.leave_federation();
        assert!(!metadata.is_federated());
    }

    #[test]
    fn test_energy_usage_tracking() {
        let mut metadata = create_test_metadata();
        metadata.record_energy_usage("compute", 10.5);
        metadata.record_energy_usage("storage", 5.2);
        metadata.record_energy_usage("compute", 4.5);
        
        assert_eq!(metadata.energy_usage.get("compute"), Some(&15.0));
        assert!(metadata.total_energy_usage() > 20.0);
    }

    #[test]
    fn test_default_implementation() {
        let metadata = CooperativeMetadata::default();
        assert!(metadata.creator_did.is_empty());
        assert!(metadata.cooperative_id.is_empty());
        assert_eq!(metadata.member_count, 0);
        assert!(metadata.resource_allocation.is_empty());
    }
}

===================
File: ./backend/src/vm/vm.rs
===================
use std::collections::HashMap;
use crate::vm::opcode::OpCode;
use crate::vm::operations::{Operation, VMState};
use crate::vm::{Contract, ExecutionContext, VMError, VMResult}; 
use crate::vm::operations::{
    StackOperation,
    ArithmeticOperation,
    SystemOperation,
    RelationshipOperation,
    MemoryOperation,
};
use std::sync::atomic::AtomicU64;

/// Virtual Machine implementation for executing cooperative operations
pub struct VM {
    /// Current state of the virtual machine
    state: VMState,
    /// Maximum number of instructions that can be executed
    instruction_limit: usize,
    /// Current instruction pointer
    instruction_pointer: usize,
}

impl VM {
    /// Creates a new VM instance
    pub fn new(instruction_limit: usize, reputation_context: HashMap<String, i64>) -> Self {
        let state = VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context,
            caller_did: String::new(),
            block_number: 1,
            timestamp: 1000,
            permissions: vec![],
            memory_limit: 1024 * 1024, // 1MB default limit
            memory_address_counter: AtomicU64::new(0),
        };
        
        VM {
            state,
            instruction_limit,
            instruction_pointer: 0,
        }
    }

    /// Sets the execution context for the VM 
    pub fn set_execution_context(&mut self, context: ExecutionContext) {
        self.state.caller_did = context.caller_did;
        self.state.block_number = context.block_number;
        self.state.timestamp = context.timestamp;
        self.state.permissions = context.permissions;
    }

    /// Executes a smart contract
    pub fn execute_contract(&mut self, contract: &Contract) -> VMResult<()> {
        // Validate contract
        if !self.validate_contract(contract)? {
            return Err(VMError::ValidationError);
        }

        // Reset instruction pointer
        self.instruction_pointer = 0;

        // Execute each instruction
        while self.instruction_pointer < contract.code.len() {
            if self.instruction_pointer >= self.instruction_limit {
                return Err(VMError::ExecutionLimitExceeded);
            }

            let op = &contract.code[self.instruction_pointer];
            self.execute_instruction(op)?;

            self.instruction_pointer += 1;
        }

        Ok(())
    }

    /// Executes a single instruction
    pub fn execute_instruction(&mut self, op: &OpCode) -> VMResult<()> {
        match op {
            OpCode::Push(val) => StackOperation::Push(*val).execute(&mut self.state),
            OpCode::Pop => StackOperation::Pop.execute(&mut self.state),
            OpCode::Dup => StackOperation::Dup.execute(&mut self.state),
            OpCode::Swap => StackOperation::Swap.execute(&mut self.state),
            
            OpCode::Add => ArithmeticOperation::Add.execute(&mut self.state),
            OpCode::Sub => ArithmeticOperation::Sub.execute(&mut self.state),
            OpCode::Mul => ArithmeticOperation::Mul.execute(&mut self.state),
            OpCode::Div => ArithmeticOperation::Div.execute(&mut self.state),
            OpCode::Mod => ArithmeticOperation::Mod.execute(&mut self.state),

            OpCode::Store(key) => {
                if let Some(value) = self.state.stack.pop() {
                    self.state.memory.insert(key.clone(), value);
                }
                Ok(())
            },

            OpCode::Load(key) => {
                if let Some(&value) = self.state.memory.get(key) {
                    self.state.stack.push(value);
                    Ok(())
                } else {
                    Err(VMError::InvalidMemoryAccess)
                }
            },

            OpCode::RecordContribution { description, impact_story, context, tags } => {
                RelationshipOperation::RecordContribution {
                    description: description.clone(),
                    impact_story: impact_story.clone(), 
                    context: context.clone(),
                    tags: tags.clone(),
                }.execute(&mut self.state)
            },

            OpCode::Log(msg) => SystemOperation::Log {
                message: msg.clone(),
                level: crate::vm::operations::system::LogLevel::Info,
                metadata: HashMap::new(),
            }.execute(&mut self.state),

            OpCode::Halt => SystemOperation::Halt.execute(&mut self.state),
            OpCode::Nop => Ok(()),
            
            _ => Err(VMError::InvalidOperand),
        }
    }

    /// Validates a contract before execution
    fn validate_contract(&self, contract: &Contract) -> VMResult<bool> {
        // Check reputation requirement
        let reputation = self.state.reputation_context.get(&self.state.caller_did)
            .copied()
            .unwrap_or(0);
            
        if reputation < contract.required_reputation {
            return Ok(false);
        }

        // Check permissions
        for permission in &contract.permissions {
            if !self.state.permissions.contains(permission) {
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Gets the current VM state
    pub fn get_state(&self) -> &VMState {
        &self.state
    }

    /// Gets events from the current execution
    pub fn get_events(&self) -> &[crate::vm::event::Event] {
        &self.state.events
    }

    /// Gets the current reputation context
    pub fn get_reputation_context(&self) -> &HashMap<String, i64> {
        &self.state.reputation_context
    }

    /// Gets number of instructions executed
    pub fn get_instruction_count(&self) -> usize {
        self.instruction_pointer
    }

    /// Gets the memory stack
    pub fn get_stack(&self) -> &[i64] {
        &self.state.stack
    }

    /// Gets the memory heap
    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.state.memory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_contract() -> Contract {
        Contract {
            id: "test".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(20),
                OpCode::Add,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: Default::default(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        }
    }

    #[test]
    fn test_contract_execution() {
        let mut reputation_context = HashMap::new();
        reputation_context.insert("test_caller".to_string(), 100);
        
        let mut vm = VM::new(1000, reputation_context);
        let context = ExecutionContext {
            caller_did: "test_caller".to_string(),
            cooperative_id: "test_coop".to_string(),
            timestamp: 1000,
            block_number: 1,
            reputation_score: 100,
            permissions: vec![],
        };
        
        vm.set_execution_context(context);
        
        let contract = setup_test_contract();
        assert!(vm.execute_contract(&contract).is_ok());
        assert_eq!(vm.get_stack(), &[30]); // 10 + 20 = 30
    }
}


===================
File: ./backend/src/vm/tests/vm_tests.rs
===================
#[cfg(test)]
mod tests {
    use super::super::*;
    use std::collections::HashMap;

    fn setup_vm() -> VM {
        let instruction_limit = 1000;
        let reputation_context = HashMap::new();
        VM::new(instruction_limit, reputation_context)
    }

    fn default_execution_context() -> ExecutionContext {
        ExecutionContext {
            caller_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            timestamp: 1620000000,
            block_number: 1,
            reputation_score: 100,
            permissions: vec!["cooperative.create".to_string(), "proposal.create".to_string()],
        }
    }

    fn default_cooperative_metadata() -> CooperativeMetadata {
        CooperativeMetadata {
            creator_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            purpose: "Test Cooperative".to_string(),
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: 1620000000,
            last_updated: 1620000000,
            member_count: 1,
            resource_allocation: HashMap::new(),
        }
    }

    #[test]
    fn test_push_pop() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "test_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(20),
                OpCode::Pop,
                OpCode::Push(30),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 10);
        assert_eq!(stack[1], 30);
    }

    #[test]
    fn test_arithmetic_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "arithmetic_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(5),
                OpCode::Add,
                OpCode::Push(2),
                OpCode::Mul,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 30); // (10 + 5) * 2 = 30
    }

    #[test]
    fn test_memory_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "memory_contract".to_string(),
            code: vec![
                OpCode::Push(42),
                OpCode::Store("answer".to_string()),
                OpCode::Load("answer".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 42);
    }

    #[test]
    fn test_control_flow_jump() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_contract".to_string(),
            code: vec![
                OpCode::Push(1),             // 0
                OpCode::Jump(4),             // 1
                OpCode::Push(999),           // 2 (should be skipped)
                OpCode::Halt,                // 3 (should be skipped)
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 1);
        assert_eq!(stack[1], 2);
    }

    #[test]
    fn test_control_flow_jumpif() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_jumpif_contract".to_string(),
            code: vec![
                OpCode::Push(0),             // 0
                OpCode::JumpIf(4),           // 1 (should not jump)
                OpCode::Push(1),             // 2
                OpCode::Halt,                // 3
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1);
    }

    #[test]
    fn test_comparison_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "comparison_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(10),
                OpCode::Equal,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1); // 1 for true
    }

    #[test]
    fn test_cooperative_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "cooperative_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CooperativeCreated");
    }

    #[test]
    fn test_reputation_operations() {
        let mut reputation_context = HashMap::new();
        reputation_context.insert("did:icn:12345".to_string(), 50);

        let mut vm = VM::new(1000, reputation_context);
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "reputation_contract".to_string(),
            code: vec![
                OpCode::UpdateReputation(25),
                OpCode::GetReputation,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 75);

        let updated_reputation = vm.reputation_context.get("did:icn:12345").copied().unwrap_or(0);
        assert_eq!(updated_reputation, 75);
    }

    #[test]
    fn test_error_handling_division_by_zero() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "error_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(0),
                OpCode::Div,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero".to_string());
    }

    #[test]
    fn test_event_emission() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "event_contract".to_string(),
            code: vec![
                OpCode::EmitEvent("CustomEvent".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CustomEvent");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "high_reputation_contract".to_string(),
            code: vec![
                OpCode::Push(1),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 200,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient reputation to execute contract".to_string());
    }

    #[test]
    fn test_missing_permission() {
        let mut vm = setup_vm();
        let mut context = default_execution_context();
        context.permissions = vec![]; // No permissions
        vm.set_execution_context(context);

        let contract = Contract {
            id: "permission_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Missing permission: cooperative.create".to_string());
    }
}


===================
File: ./backend/src/vm/mod.rs
===================
// src/vm/mod.rs

pub mod opcode;
pub mod contract;
pub mod execution_context;
pub mod cooperative_metadata;
pub mod event;
pub mod operations;
pub mod vm;

use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};

pub use contract::Contract;
pub use vm::VM;
pub use execution_context::ExecutionContext;
pub use event::Event;
pub use opcode::OpCode;

#[derive(Debug, Clone, PartialEq)]
pub enum VMError {
    StackUnderflow,
    StackOverflow,
    DivisionByZero,
    InvalidMemoryAccess,
    InvalidJumpDestination,
    InsufficientPermissions,
    InsufficientReputation,
    InvalidOperand,
    ExecutionLimitExceeded,
    OutOfMemory,
    InvalidMemoryAddress,
    ValidationError,
    Custom(String),
}

impl std::fmt::Display for VMError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VMError::StackUnderflow => write!(f, "Stack underflow"),
            VMError::StackOverflow => write!(f, "Stack overflow"),
            VMError::DivisionByZero => write!(f, "Division by zero"),
            VMError::InvalidMemoryAccess => write!(f, "Invalid memory access"),
            VMError::InvalidJumpDestination => write!(f, "Invalid jump destination"),
            VMError::InsufficientPermissions => write!(f, "Insufficient permissions"),
            VMError::InsufficientReputation => write!(f, "Insufficient reputation"),
            VMError::InvalidOperand => write!(f, "Invalid operand"),
            VMError::ExecutionLimitExceeded => write!(f, "Execution limit exceeded"),
            VMError::OutOfMemory => write!(f, "Out of memory"),
            VMError::InvalidMemoryAddress => write!(f, "Invalid memory address"),
            VMError::ValidationError => write!(f, "Validation failed"),
            VMError::Custom(msg) => write!(f, "{}", msg),
        }
    }
}

impl From<VMError> for String {
    fn from(error: VMError) -> String {
        error.to_string()
    }
}

pub type VMResult<T> = Result<T, VMError>;

#[derive(Default)]
pub struct VMState {
    /// Current stack
    pub stack: Vec<i64>,
    
    /// Memory storage
    pub memory: HashMap<String, i64>,
    
    /// Events emitted during execution
    pub events: Vec<Event>,
    
    /// Current instruction pointer
    pub instruction_pointer: usize,
    
    /// Reputation scores for participating DIDs
    pub reputation_context: HashMap<String, i64>,
    
    /// Currently executing DID
    pub caller_did: String,
    
    /// Current block number
    pub block_number: u64,
    
    /// Current timestamp
    pub timestamp: u64,
    
    /// Available permissions
    pub permissions: Vec<String>,
    
    /// Maximum memory usage in bytes
    pub memory_limit: u64,
    
    /// Counter for generating unique memory addresses
    pub memory_address_counter: AtomicU64,
}

impl VMState {
    pub fn new(caller_did: String, block_number: u64, timestamp: u64) -> Self {
        VMState {
            stack: Vec::new(),
            memory: HashMap::new(),
            events: Vec::new(),
            instruction_pointer: 0,
            reputation_context: HashMap::new(),
            caller_did,
            block_number,
            timestamp,
            permissions: Vec::new(),
            memory_limit: 1024 * 1024, // 1MB default limit
            memory_address_counter: AtomicU64::new(0),
        }
    }

    pub fn next_memory_address(&self) -> u64 {
        self.memory_address_counter.fetch_add(1, Ordering::SeqCst)
    }

    pub fn get_reputation(&self) -> i64 {
        self.reputation_context.get(&self.caller_did).copied().unwrap_or(0)
    }

    pub fn incr_memory_usage(&mut self, size: u64) -> Result<(), VMError> {
        let current_usage = self.memory.len() as u64 * std::mem::size_of::<i64>() as u64;
        if current_usage + size > self.memory_limit {
            Err(VMError::OutOfMemory)
        } else {
            Ok(())
        }
    }

    pub fn get_stack(&self) -> &[i64] {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.memory
    }

    pub fn get_events(&self) -> &[Event] {
        &self.events
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vm_state_new() {
        let state = VMState::new(
            "test_did".to_string(),
            1,
            1000
        );
        assert_eq!(state.caller_did, "test_did");
        assert_eq!(state.block_number, 1);
        assert_eq!(state.timestamp, 1000);
    }

    #[test]
    fn test_memory_limit() {
        let mut state = VMState::new("test_did".to_string(), 1, 1000);
        state.memory_limit = 100;
        assert!(state.incr_memory_usage(200).is_err());
        assert!(state.incr_memory_usage(50).is_ok());
    }
}

===================
File: ./backend/src/vm/opcode.rs
===================
// src/vm/opcode.rs

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

/// Enum representing the various operations (`OpCode`) that can be executed in the virtual machine.
/// Each variant is an operation that affects the VM stack, memory, or interacts with other subsystems.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Stack Operations
    /// Push a value onto the stack.
    Push(i64),        
    /// Pop the top value from the stack.
    Pop,              
    /// Duplicate the top value on the stack.
    Dup,              
    /// Swap the top two values on the stack.
    Swap,             

    // Arithmetic Operations
    /// Add the top two values on the stack.
    Add,              
    /// Subtract the top two values on the stack.
    Sub,              
    /// Multiply the top two values on the stack.
    Mul,              
    /// Divide the top two values on the stack.
    Div,              
    /// Compute the modulo of the top two values on the stack.
    Mod,              

    // Memory Operations
    /// Store a value in memory with a specific key.
    Store(String),    
    /// Load a value from memory using a specific key.
    Load(String),     

    // Control Flow Operations
    /// Unconditional jump to a specified instruction index.
    Jump(usize),      
    /// Conditional jump to an instruction index if the top of the stack is non-zero.
    JumpIf(usize),    

    // Cooperative Operations
    /// Create a new cooperative entity.
    CreateCooperative {
        name: String,
        description: String,
        resources: HashMap<String, u64>,
        federation_id: Option<String>,
    },
    /// Join an existing cooperative.
    JoinCooperative {
        cooperative_id: String,
        role: String,
        commitment: String,
    },
    /// Leave a cooperative.
    LeaveCooperative {
        cooperative_id: String,
        reason: String,
    },
    /// Allocate resources within a cooperative.
    AllocateResource {
        resource_type: String,
        amount: u64,
        recipient: String,
        purpose: String,
    },
    /// Transfer resources within or between cooperatives.
    TransferResource {
        from_cooperative: String,
        to_cooperative: String,
        resource_type: String,
        amount: u64,
        purpose: String,
    },

    // Governance Operations
    /// Create a new governance proposal.
    CreateProposal {
        title: String,
        description: String,
        proposal_type: String,
        voting_period: u64,
        required_reputation: i64,
    },
    /// Cast a vote on a proposal.
    CastVote {
        proposal_id: String,
        approve: bool,
        comment: Option<String>,
    },
    /// Delegate voting rights to another member.
    DelegateVotes {
        delegate_to: String,
        scope: String,
        duration: Option<u64>,
    },
    /// Execute an approved proposal.
    ExecuteProposal {
        proposal_id: String,
    },

    // Reputation Operations
    /// Update a member's reputation by a specific amount.
    UpdateReputation {
        target: String,
        amount: i64,
        reason: String,
        context: String,
    },
    /// Get the current reputation of a member.
    GetReputation {
        target: String,
    },
    /// Burn (remove) reputation from a member.
    BurnReputation {
        amount: i64,
        reason: String,
    },

    // Relationship Operations
    /// Record a contribution with impact story.
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    /// Record mutual aid interaction between members.
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    /// Update relationship between members.
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    /// Add endorsement to a relationship.
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
    /// Record a relationship interaction.
    RecordInteraction {
        with_did: String,
        description: String,
        impact: Option<String>,
        interaction_type: String,
    },

    // Identity Operations
    /// Verify a Decentralized Identifier (DID).
    VerifyDID {
        did: String,
    },
    /// Update a DID document.
    UpdateDIDDocument {
        did: String,
        updates: HashMap<String, String>,
    },
    /// Create a new credential.
    CreateCredential {
        recipient: String,
        credential_type: String,
        claims: HashMap<String, String>,
    },
    /// Verify a credential.
    VerifyCredential {
        credential_id: String,
    },

    // Federation Operations
    /// Initiate a new federation.
    InitiateFederation {
        name: String,
        description: String,
        rules: Vec<String>,
        initial_members: Vec<String>,
    },
    /// Join an existing federation.
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    /// Leave a federation.
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    /// Synchronize federation state.
    SyncFederationState {
        federation_id: String,
    },

    // System Operations
    /// Log a message.
    Log(String),
    /// Halt execution.
    Halt,
    /// Emit an event.
    EmitEvent {
        event_type: String,
        data: HashMap<String, String>,
    },
    /// Get current block number.
    GetBlockNumber,
    /// Get current timestamp.
    GetTimestamp,
    /// Get caller's DID.
    GetCaller,

    // Comparison Operations
    /// Check if values are equal.
    Equal,
    /// Check if values are not equal.
    NotEqual,
    /// Check if greater than.
    GreaterThan,
    /// Check if less than.
    LessThan,

    // Logical Operations
    /// Logical AND.
    And,
    /// Logical OR.
    Or,
    /// Logical NOT.
    Not,

    // No Operation
    /// No operation (used for padding or delays).
    Nop,
}

impl OpCode {
    /// Returns the gas cost of executing this operation
    pub fn gas_cost(&self) -> u64 {
        match self {
            // Stack operations are cheap
            OpCode::Push(_) | OpCode::Pop | OpCode::Dup | OpCode::Swap => 1,
            
            // Arithmetic operations have fixed costs
            OpCode::Add | OpCode::Sub | OpCode::Mul | OpCode::Div | OpCode::Mod => 2,
            
            // Memory operations are more expensive
            OpCode::Store(_) | OpCode::Load(_) => 5,
            
            // Control flow has moderate cost
            OpCode::Jump(_) | OpCode::JumpIf(_) => 8,
            
            // Cooperative operations are expensive
            OpCode::CreateCooperative { .. } => 1000,
            OpCode::JoinCooperative { .. } => 500,
            OpCode::LeaveCooperative { .. } => 200,
            OpCode::AllocateResource { .. } => 300,
            OpCode::TransferResource { .. } => 400,
            
            // Governance operations have high costs
            OpCode::CreateProposal { .. } => 1000,
            OpCode::CastVote { .. } => 100,
            OpCode::DelegateVotes { .. } => 200,
            OpCode::ExecuteProposal { .. } => 500,
            
            // Reputation operations are moderate
            OpCode::UpdateReputation { .. } => 200,
            OpCode::GetReputation { .. } => 50,
            OpCode::BurnReputation { .. } => 300,
            
            // Relationship operations
            OpCode::RecordContribution { .. } => 200,
            OpCode::RecordMutualAid { .. } => 150,
            OpCode::UpdateRelationship { .. } => 100,
            OpCode::AddEndorsement { .. } => 100,
            OpCode::RecordInteraction { .. } => 50,
            
            // Identity operations are expensive
            OpCode::VerifyDID { .. } => 300,
            OpCode::UpdateDIDDocument { .. } => 500,
            OpCode::CreateCredential { .. } => 400,
            OpCode::VerifyCredential { .. } => 200,
            
            // Federation operations
            OpCode::InitiateFederation { .. } => 1000,
            OpCode::JoinFederation { .. } => 500,
            OpCode::LeaveFederation { .. } => 200,
            OpCode::SyncFederationState { .. } => 300,
            
            // System operations are cheap
            OpCode::Log(_) => 5,
            OpCode::Halt => 1,
            OpCode::EmitEvent { .. } => 10,
            OpCode::GetBlockNumber | OpCode::GetTimestamp | OpCode::GetCaller => 1,
            
            // Basic operations are very cheap
            OpCode::Equal | OpCode::NotEqual | OpCode::GreaterThan | OpCode::LessThan => 1,
            OpCode::And | OpCode::Or | OpCode::Not => 1,
            OpCode::Nop => 1,
        }
    }

    /// Returns whether this operation modifies state
    pub fn is_state_modifying(&self) -> bool {
        !matches!(self,
            OpCode::GetReputation { .. } |
            OpCode::GetBlockNumber |
            OpCode::GetTimestamp |
            OpCode::GetCaller |
            OpCode::Equal |
            OpCode::NotEqual |
            OpCode::GreaterThan |
            OpCode::LessThan |
            OpCode::Nop
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gas_costs() {
        // Test basic operations
        assert_eq!(OpCode::Push(1).gas_cost(), 1);
        assert_eq!(OpCode::Add.gas_cost(), 2);
        
        // Test expensive operations
        assert_eq!(OpCode::CreateCooperative {
            name: "test".to_string(),
            description: "test".to_string(),
            resources: HashMap::new(),
            federation_id: None,
        }.gas_cost(), 1000);
    }

    #[test]
    fn test_state_modification() {
        assert!(!OpCode::GetBlockNumber.is_state_modifying());
        assert!(OpCode::CreateProposal {
            title: "test".to_string(),
            description: "test".to_string(),
            proposal_type: "test".to_string(),
            voting_period: 100,
            required_reputation: 10,
        }.is_state_modifying());
    }
}

===================
File: ./backend/src/vm/event.rs
===================
// src/vm/event.rs

use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    /// Type of event that occurred (e.g., "ContractCreated", "ProposalSubmitted")
    pub event_type: String,
    
    /// ID of the cooperative that generated the event
    pub cooperative_id: String,
    
    /// Additional event-specific data as key-value pairs
    pub data: HashMap<String, String>,
    
    /// When the event occurred
    pub timestamp: u64,
    
    /// Additional context for the event
    pub context: Option<EventContext>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventContext {
    /// DID of the entity that triggered the event
    pub triggered_by: String,
    
    /// Block number when event occurred
    pub block_number: u64,
    
    /// Module that generated the event (e.g., "governance", "reputation")
    pub source_module: String,
    
    /// Any related transaction ID
    pub transaction_id: Option<String>,
}

impl Event {
    pub fn new(
        event_type: String,
        cooperative_id: String,
        data: HashMap<String, String>,
        timestamp: u64
    ) -> Self {
        Event {
            event_type,
            cooperative_id,
            data,
            timestamp,
            context: None,
        }
    }

    pub fn with_context(
        event_type: String,
        cooperative_id: String,
        data: HashMap<String, String>,
        timestamp: u64,
        context: EventContext
    ) -> Self {
        Event {
            event_type,
            cooperative_id,
            data,
            timestamp,
            context: Some(context),
        }
    }

    /// Add additional data to the event
    pub fn add_data(&mut self, key: &str, value: &str) {
        self.data.insert(key.to_string(), value.to_string());
    }

    /// Set the event context
    pub fn set_context(&mut self, context: EventContext) {
        self.context = Some(context);
    }

    /// Get formatted timestamp
    pub fn get_timestamp_utc(&self) -> DateTime<Utc> {
        DateTime::from_timestamp(self.timestamp as i64, 0)
            .unwrap_or_else(|| Utc::now())
    }
}

impl EventContext {
    pub fn new(
        triggered_by: String,
        block_number: u64,
        source_module: String
    ) -> Self {
        EventContext {
            triggered_by,
            block_number,
            source_module,
            transaction_id: None,
        }
    }

    pub fn with_transaction(
        triggered_by: String,
        block_number: u64,
        source_module: String,
        transaction_id: String
    ) -> Self {
        EventContext {
            triggered_by,
            block_number,
            source_module,
            transaction_id: Some(transaction_id),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_creation() {
        let mut data = HashMap::new();
        data.insert("key".to_string(), "value".to_string());
        
        let event = Event::new(
            "TestEvent".to_string(),
            "coop-1".to_string(),
            data,
            1000,
        );

        assert_eq!(event.event_type, "TestEvent");
        assert_eq!(event.cooperative_id, "coop-1");
        assert_eq!(event.data.get("key").unwrap(), "value");
    }

    #[test]
    fn test_event_with_context() {
        let mut data = HashMap::new();
        data.insert("key".to_string(), "value".to_string());
        
        let context = EventContext::new(
            "did:icn:test".to_string(),
            1,
            "test_module".to_string(),
        );

        let event = Event::with_context(
            "TestEvent".to_string(),
            "coop-1".to_string(),
            data,
            1000,
            context,
        );

        assert!(event.context.is_some());
        let context = event.context.unwrap();
        assert_eq!(context.triggered_by, "did:icn:test");
        assert_eq!(context.block_number, 1);
        assert_eq!(context.source_module, "test_module");
    }

    #[test]
    fn test_add_data() {
        let mut event = Event::new(
            "TestEvent".to_string(),
            "coop-1".to_string(),
            HashMap::new(),
            1000,
        );

        event.add_data("test_key", "test_value");
        assert_eq!(event.data.get("test_key").unwrap(), "test_value");
    }

    #[test]
    fn test_set_context() {
        let mut event = Event::new(
            "TestEvent".to_string(),
            "coop-1".to_string(),
            HashMap::new(),
            1000,
        );

        let context = EventContext::new(
            "did:icn:test".to_string(),
            1,
            "test_module".to_string(),
        );

        event.set_context(context);
        assert!(event.context.is_some());
    }

    #[test]
    fn test_event_context_with_transaction() {
        let context = EventContext::with_transaction(
            "did:icn:test".to_string(),
            1,
            "test_module".to_string(),
            "tx-1".to_string(),
        );

        assert_eq!(context.transaction_id.unwrap(), "tx-1");
    }
}

===================
File: ./backend/src/vm/execution_context.rs
===================
pub struct ExecutionContext {
    pub caller_did: String,
    pub cooperative_id: String,
    pub timestamp: u64,
    pub block_number: u64,
    pub reputation_score: i64,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/contracts/voting_rules.rs
===================
// src/vm/contracts/voting_rules.rs

#[derive(Clone, Serialize, Deserialize)]
pub struct CustomVotingRules {
    pub cooperative_id: String,
    pub use_reputation_weighting: bool,
    pub min_reputation_to_vote: Option<i64>,
    pub max_vote_weight: Option<f64>,
    pub quorum_requirement: f64,
    pub special_majority_requirement: Option<f64>,
    pub proposal_categories: HashMap<String, ProposalRules>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct ProposalRules {
    pub category: String,
    pub quorum_requirement: f64,
    pub approval_threshold: f64,
    pub reputation_multiplier: Option<f64>,
}

impl VotingRules for CustomVotingRules {
    fn calculate_vote_weight(&self, voter: &str, context: &VotingContext) -> f64 {
        if !self.use_reputation_weighting {
            return 1.0;
        }

        let reputation = context.reputation_scores
            .as_ref()
            .and_then(|scores| scores.get(voter))
            .copied()
            .unwrap_or(0);

        // Check minimum reputation requirement
        if let Some(min_rep) = self.min_reputation_to_vote {
            if reputation < min_rep {
                return 0.0;
            }
        }

        let category_rules = self.proposal_categories
            .get(&context.proposal_type)
            .cloned()
            .unwrap_or_default();

        // Calculate weight based on reputation
        let base_weight = if reputation <= 0 { 
            0.0 
        } else {
            1.0 + (reputation as f64 * category_rules.reputation_multiplier.unwrap_or(0.0))
        };

        // Apply maximum weight cap if configured
        if let Some(max_weight) = self.max_vote_weight {
            base_weight.min(max_weight)
        } else {
            base_weight
        }
    }

    fn is_proposal_approved(&self, votes: &HashMap<String, Vote>, context: &VotingContext) -> bool {
        let total_weights: f64 = votes.keys()
            .map(|voter| self.calculate_vote_weight(voter, context))
            .sum();

        let approval_weights: f64 = votes.iter()
            .filter(|(_, vote)| vote.approve)
            .map(|(voter, _)| self.calculate_vote_weight(voter, context))
            .sum();

        // Get category-specific rules
        let category_rules = self.proposal_categories
            .get(&context.proposal_type)
            .cloned()
            .unwrap_or_default();

        // Check quorum
        let quorum = category_rules.quorum_requirement.max(self.quorum_requirement);
        let participation_rate = votes.len() as f64 / context.total_members as f64;
        
        if participation_rate < quorum {
            return false;
        }

        // Check approval threshold
        let approval_rate = if total_weights > 0.0 {
            approval_weights / total_weights
        } else {
            0.0
        };

        approval_rate >= category_rules.approval_threshold
    }

    fn get_quorum_requirement(&self, context: &VotingContext) -> f64 {
        self.proposal_categories
            .get(&context.proposal_type)
            .map(|rules| rules.quorum_requirement)
            .unwrap_or(self.quorum_requirement)
    }
}

// Helper to create common voting rule configurations
pub fn create_voting_rules(cooperative_id: String) -> CustomVotingRules {
    let mut proposal_categories = HashMap::new();
    
    // Standard proposals - simple majority
    proposal_categories.insert("standard".to_string(), ProposalRules {
        category: "standard".to_string(),
        quorum_requirement: 0.5,
        approval_threshold: 0.5,
        reputation_multiplier: None,
    });
    
    // Resource allocation - higher requirements
    proposal_categories.insert("resource".to_string(), ProposalRules {
        category: "resource".to_string(),
        quorum_requirement: 0.6,
        approval_threshold: 0.6,
        reputation_multiplier: None,
    });
    
    // Critical changes - supermajority required
    proposal_categories.insert("critical".to_string(), ProposalRules {
        category: "critical".to_string(),
        quorum_requirement: 0.75,
        approval_threshold: 0.75,
        reputation_multiplier: None,
    });

    CustomVotingRules {
        cooperative_id,
        use_reputation_weighting: false,
        min_reputation_to_vote: None,
        max_vote_weight: None,
        quorum_requirement: 0.5,
        special_majority_requirement: None,
        proposal_categories,
    }
}

===================
File: ./backend/src/monitoring/energy.rs
===================
// src/monitoring/energy.rs

use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Instant;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnergyMetrics {
    pub cpu_cycles: u64,
    pub instructions_executed: u64,
    pub memory_reads: u64,
    pub memory_writes: u64,
    pub peak_memory_usage: usize,
    pub network_packets_sent: u64,
    pub network_bytes_transferred: u64,
    pub storage_reads: u64,
    pub storage_writes: u64,
    pub storage_bytes_written: u64,
    pub consensus_rounds: u64,
    pub validator_operations: u64,
    pub operation_duration_ms: u64,
    pub estimated_energy_consumption: f64,
    pub estimated_carbon_footprint: f64,
    pub node_location: Option<String>,
    pub power_source: Option<String>,
}

pub struct EnergyMonitor {
    start_time: Instant,
    cpu_cycles: AtomicU64,
    instructions: AtomicU64,
    memory_ops: AtomicU64,
    network_ops: AtomicU64,
    consensus_ops: AtomicU64,
    storage_ops: AtomicU64,
    node_config: NodeEnergyConfig,
}

#[derive(Clone)]
pub struct NodeEnergyConfig {
    pub location: Option<String>,
    pub power_source: Option<String>,
    pub carbon_factor: f64,
    pub cpu_energy_factor: f64,
    pub memory_energy_factor: f64,
    pub network_energy_factor: f64,
    pub storage_energy_factor: f64,
}

impl Default for NodeEnergyConfig {
    fn default() -> Self {
        NodeEnergyConfig {
            location: None,
            power_source: None,
            carbon_factor: 500.0,
            cpu_energy_factor: 0.0000001,
            memory_energy_factor: 0.0000002,
            network_energy_factor: 0.0000005,
            storage_energy_factor: 0.0000003,
        }
    }
}

impl EnergyMonitor {
    pub fn new(config: NodeEnergyConfig) -> Self {
        EnergyMonitor {
            start_time: Instant::now(),
            cpu_cycles: AtomicU64::new(0),
            instructions: AtomicU64::new(0),
            memory_ops: AtomicU64::new(0),
            network_ops: AtomicU64::new(0),
            consensus_ops: AtomicU64::new(0),
            storage_ops: AtomicU64::new(0),
            node_config: config,
        }
    }

    pub fn record_cpu_cycles(&self, cycles: u64) {
        self.cpu_cycles.fetch_add(cycles, Ordering::Relaxed);
    }

    pub fn record_instruction(&self) {
        self.instructions.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_memory_operation(&self, bytes: u64) {
        self.memory_ops.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn record_network_operation(&self, bytes: u64) {
        self.network_ops.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn record_consensus_operation(&self) {
        self.consensus_ops.fetch_add(1, Ordering::Relaxed);
    }

    pub fn record_storage_operation(&self, bytes: u64) {
        self.storage_ops.fetch_add(bytes, Ordering::Relaxed);
    }

    pub fn estimate_energy_consumption(&self) -> f64 {
        let cpu_energy = self.cpu_cycles.load(Ordering::Relaxed) as f64 
            * self.node_config.cpu_energy_factor;
        let memory_energy = self.memory_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.memory_energy_factor;
        let network_energy = self.network_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.network_energy_factor;
        let storage_energy = self.storage_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.storage_energy_factor;

        cpu_energy + memory_energy + network_energy + storage_energy
    }

    pub fn estimate_carbon_footprint(&self) -> f64 {
        let energy_kwh = self.estimate_energy_consumption() / 3_600_000.0;
        energy_kwh * self.node_config.carbon_factor
    }

    pub fn get_metrics(&self) -> EnergyMetrics {
        let total_memory_ops = self.memory_ops.load(Ordering::Relaxed);
        let total_network_ops = self.network_ops.load(Ordering::Relaxed);
        let total_storage_ops = self.storage_ops.load(Ordering::Relaxed);

        EnergyMetrics {
            cpu_cycles: self.cpu_cycles.load(Ordering::Relaxed),
            instructions_executed: self.instructions.load(Ordering::Relaxed),
            memory_reads: total_memory_ops / 2,
            memory_writes: total_memory_ops / 2,
            peak_memory_usage: 0,
            network_packets_sent: total_network_ops,
            network_bytes_transferred: total_network_ops,
            storage_reads: total_storage_ops / 2,
            storage_writes: total_storage_ops / 2,
            storage_bytes_written: total_storage_ops,
            consensus_rounds: self.consensus_ops.load(Ordering::Relaxed),
            validator_operations: 0,
            operation_duration_ms: self.start_time.elapsed().as_millis() as u64,
            estimated_energy_consumption: self.estimate_energy_consumption(),
            estimated_carbon_footprint: self.estimate_carbon_footprint(),
            node_location: self.node_config.location.clone(),
            power_source: self.node_config.power_source.clone(),
        }
    }
}

pub trait EnergyAware {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_energy_monitoring() {
        let config = NodeEnergyConfig::default();
        let monitor = EnergyMonitor::new(config);

        monitor.record_cpu_cycles(1000);
        monitor.record_instruction();
        monitor.record_memory_operation(1024);
        monitor.record_network_operation(512);
        monitor.record_storage_operation(2048);
        monitor.record_consensus_operation();

        let metrics = monitor.get_metrics();
        assert_eq!(metrics.cpu_cycles, 1000);
        assert_eq!(metrics.instructions_executed, 1);
        assert!(metrics.estimated_energy_consumption > 0.0);
        assert!(metrics.estimated_carbon_footprint > 0.0);
    }

    #[test]
    fn test_carbon_footprint_calculation() {
        let mut config = NodeEnergyConfig::default();
        config.carbon_factor = 100.0;
        let monitor = EnergyMonitor::new(config);

        monitor.record_cpu_cycles(1000000);
        let metrics = monitor.get_metrics();
        
        assert!(metrics.estimated_carbon_footprint > 0.0);
        assert!(metrics.estimated_carbon_footprint < metrics.estimated_carbon_footprint * 5.0);
    }
}

===================
File: ./backend/src/monitoring/mod.rs
===================
// src/monitoring/mod.rs

pub mod energy;

===================
File: ./backend/src/network/mod.rs
===================
// src/network/mod.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::mpsc;
use tokio::net::{TcpListener, TcpStream};
use serde::{Serialize, Deserialize};
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::Message;

use crate::blockchain::Block;
use crate::consensus::ConsensusRound;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum NetworkMessage {
    // Peer discovery and management
    PeerAnnouncement {
        node_id: String,
        address: String,
    },
    PeerList {
        peers: Vec<(String, String)>,
    },
    
    // Consensus messages
    ConsensusProposal {
        round: ConsensusRound,
        block: Block,
    },
    ConsensusVote {
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    },
    
    // Block and transaction propagation
    NewBlock(Block),
    TransactionAnnouncement {
        tx_hash: String,
        from: String,
    },
    
    // Federation protocol messages
    FederationJoinRequest {
        cooperative_id: String,
        federation_id: String,
    },
    FederationResponse {
        approved: bool,
        federation_id: String,
        metadata: HashMap<String, String>,
    },
    
    // Cooperative synchronization
    ResourceStateSync {
        cooperative_id: String,
        resource_updates: HashMap<String, i64>,
    },
    
    // Status and health checks
    Ping(u64),
    Pong(u64),
}

pub struct NetworkHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    message_tx: mpsc::Sender<NetworkMessage>,
    message_rx: mpsc::Receiver<NetworkMessage>,
    listener_address: String,
}

struct PeerConnection {
    address: String,
    tx: mpsc::Sender<Message>,
    last_seen: std::time::Instant,
    reputation: i64,
}

impl NetworkHandler {
    pub fn new(node_id: String, listener_address: String) -> Self {
        let (tx, rx) = mpsc::channel(100);
        
        NetworkHandler {
            node_id,
            peers: Arc::new(Mutex::new(HashMap::new())),
            message_tx: tx,
            message_rx: rx,
            listener_address,
        }
    }

    pub async fn start(&mut self) -> Result<(), String> {
        let listener = TcpListener::bind(&self.listener_address)
            .await
            .map_err(|e| format!("Failed to bind listener: {}", e))?;
            
        println!("Network handler listening on: {}", self.listener_address);

        let peers = self.peers.clone();
        let node_id = self.node_id.clone();
        
        tokio::spawn(async move {
            while let Ok((stream, addr)) = listener.accept().await {
                println!("New connection from: {}", addr);
                
                let peer_handler = PeerHandler::new(
                    node_id.clone(),
                    peers.clone(),
                );
                
                tokio::spawn(async move {
                    if let Err(e) = peer_handler.handle_connection(stream).await {
                        eprintln!("Error handling connection: {}", e);
                    }
                });
            }
        });

        self.process_messages().await?;

        Ok(())
    }

    async fn process_messages(&mut self) -> Result<(), String> {
        while let Some(message) = self.message_rx.recv().await {
            match message {
                NetworkMessage::PeerAnnouncement { node_id, address } => {
                    self.handle_peer_announcement(node_id, address).await?;
                }
                NetworkMessage::NewBlock(block) => {
                    self.broadcast_block(block).await?;
                }
                NetworkMessage::ConsensusProposal { round, block } => {
                    self.broadcast_consensus_proposal(round, block).await?;
                }
                NetworkMessage::ConsensusVote { round_number, voter, approved, signature } => {
                    self.broadcast_consensus_vote(round_number, voter, approved, signature).await?;
                }
                _ => {}
            }
        }
        Ok(())
    }

    async fn handle_peer_announcement(&mut self, peer_id: String, address: String) -> Result<(), String> {
        let mut peers = self.peers.lock().unwrap();
        
        if !peers.contains_key(&peer_id) {
            match self.connect_to_peer(&address).await {
                Ok(connection) => {
                    peers.insert(peer_id.clone(), connection);
                    println!("Connected to peer: {}", peer_id);
                }
                Err(e) => {
                    eprintln!("Failed to connect to peer {}: {}", peer_id, e);
                }
            }
        }
        
        Ok(())
    }

    async fn connect_to_peer(&self, address: &str) -> Result<PeerConnection, String> {
        let url = format!("ws://{}", address);
        let (ws_stream, _) = connect_async(&url)
            .await
            .map_err(|e| format!("Failed to connect to peer: {}", e))?;
            
        let (sink, stream) = ws_stream.split();
        let (tx, mut rx) = mpsc::channel(32);

        tokio::spawn(async move {
            let mut sink = sink;
            while let Some(message) = rx.recv().await {
                if let Err(e) = sink.send(message).await {
                    eprintln!("Failed to send message: {}", e);
                    break;
                }
            }
        });

        tokio::spawn(async move {
            let mut stream = stream;
            while let Some(result) = stream.next().await {
                match result {
                    Ok(msg) => {
                        if let Ok(text) = msg.to_text() {
                            println!("Received message from peer: {}", text);
                        }
                    }
                    Err(e) => {
                        eprintln!("Error reading message: {}", e);
                        break;
                    }
                }
            }
        });

        Ok(PeerConnection {
            address: address.to_string(),
            tx,
            last_seen: std::time::Instant::now(),
            reputation: 0,
        })
    }

    async fn broadcast_block(&self, block: Block) -> Result<(), String> {
        let message = NetworkMessage::NewBlock(block);
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_proposal(&self, round: ConsensusRound, block: Block) -> Result<(), String> {
        let message = NetworkMessage::ConsensusProposal { round, block };
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_vote(
        &self,
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    ) -> Result<(), String> {
        let message = NetworkMessage::ConsensusVote {
            round_number,
            voter,
            approved,
            signature,
        };
        self.broadcast_message(&message).await
    }

    async fn broadcast_message(&self, message: &NetworkMessage) -> Result<(), String> {
        let message_json = serde_json::to_string(message)
            .map_err(|e| format!("Failed to serialize message: {}", e))?;
            
        let peers = self.peers.lock().unwrap();
        
        for (peer_id, connection) in peers.iter() {
            if let Err(e) = connection.tx.send(Message::Text(message_json.clone())).await {
                eprintln!("Failed to send message to peer {}: {}", peer_id, e);
            }
        }
        
        Ok(())
    }
}

struct PeerHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
}

impl PeerHandler {
    fn new(
        node_id: String,
        peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    ) -> Self {
        PeerHandler {
            node_id,
            peers,
        }
    }

    async fn handle_connection(&self, stream: TcpStream) -> Result<(), String> {
        let ws_stream = tokio_tungstenite::accept_async(stream)
            .await
            .map_err(|e| format!("Failed to accept WebSocket connection: {}", e))?;
            
        let (_sink, mut stream) = ws_stream.split();
        
        while let Some(message) = stream.next().await {
            match message {
                Ok(msg) => {
                    if let Ok(text) = msg.to_text() {
                        if let Ok(network_msg) = serde_json::from_str::<NetworkMessage>(text) {
                            self.handle_network_message(network_msg).await?;
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Error reading from WebSocket: {}", e);
                    break;
                }
            }
        }
        
        Ok(())
    }

    async fn handle_network_message(&self, message: NetworkMessage) -> Result<(), String> {
        match message {
            NetworkMessage::PeerAnnouncement { node_id, address } => {
                println!("Received peer announcement from {} at {}", node_id, address);
            }
            NetworkMessage::NewBlock(block) => {
                println!("Received new block: {}", block.index);
            }
            NetworkMessage::ConsensusProposal { round, block: _ } => {
                println!("Received consensus proposal for round {}", round.round_number);
            }
            NetworkMessage::ConsensusVote { round_number, voter, approved: _, signature: _ } => {
                println!("Received consensus vote from {} for round {}", voter, round_number);
            }
            _ => {
                println!("Received other network message type");
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_network_handler() {
        let handler = NetworkHandler::new(
            "test_node".to_string(),
            "127.0.0.1:0".to_string(),
        );
        assert_eq!(handler.node_id, "test_node");
    }
}

===================
File: ./backend/src/api/cooperative.rs
===================
<EMPTY FILE>


===================
File: ./backend/src/api/mod.rs
===================
<EMPTY FILE>


===================
File: ./backend/src/relationship/types.rs
===================
// src/relationship/types.rs

use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RelationshipType {
    Collaboration,
    Mentorship,
    ResourceSharing,
    MutualAid,
    ProjectPartnership,
    Custom(String),
}

impl RelationshipType {
    pub fn from_str(relationship_type: &str) -> Self {
        match relationship_type.to_lowercase().as_str() {
            "collaboration" => RelationshipType::Collaboration,
            "mentorship" => RelationshipType::Mentorship,
            "resource_sharing" => RelationshipType::ResourceSharing,
            "mutual_aid" => RelationshipType::MutualAid,
            "project_partnership" => RelationshipType::ProjectPartnership,
            other => RelationshipType::Custom(other.to_string()),
        }
    }

    pub fn as_str(&self) -> &str {
        match self {
            RelationshipType::Collaboration => "collaboration",
            RelationshipType::Mentorship => "mentorship",
            RelationshipType::ResourceSharing => "resource_sharing",
            RelationshipType::MutualAid => "mutual_aid",
            RelationshipType::ProjectPartnership => "project_partnership",
            RelationshipType::Custom(s) => s,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relationship_type_conversion() {
        assert!(matches!(
            RelationshipType::from_str("collaboration"),
            RelationshipType::Collaboration
        ));
        assert!(matches!(
            RelationshipType::from_str("custom_type"),
            RelationshipType::Custom(s) if s == "custom_type"
        ));
    }

    #[test]
    fn test_relationship_type_as_str() {
        assert_eq!(RelationshipType::Collaboration.as_str(), "collaboration");
        assert_eq!(
            RelationshipType::Custom("test".to_string()).as_str(),
            "test"
        );
    }
}

===================
File: ./backend/src/relationship/mod.rs
===================
//! Relationship System for Inter-Cooperative Network
//!
//! This module implements the core relationship tracking functionality for ICN,
//! focusing on human connections, mutual aid, and cooperative bonds rather than
//! purely transactional interactions.

use std::collections::{HashMap, HashSet};
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::monitoring::energy::{EnergyAware, EnergyMonitor};

mod types;
pub use types::RelationshipType;

/// Records a concrete contribution made to the cooperative community.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contribution {
    /// DID of the contributing member
    pub contributor_did: String,
    
    /// Brief description of the contribution
    pub description: String,
    
    /// Detailed story about the contribution's impact on the community
    pub impact_story: String,
    
    /// When the contribution occurred
    pub date: DateTime<Utc>,
    
    /// Context or category of the contribution
    pub context: String,
    
    /// DIDs of members who witnessed or verified the contribution
    pub witnesses: Vec<String>,
    
    /// Feedback and endorsements from other members
    pub feedback: Vec<Feedback>,
    
    /// Tags for categorizing and finding related contributions
    pub tags: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feedback {
    /// DID of the member providing feedback
    pub from_did: String,
    
    /// The actual feedback content
    pub content: String,
    
    /// When the feedback was given
    pub date: DateTime<Utc>,
    
    /// Type of endorsement this feedback represents
    pub endorsement_type: EndorsementType,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EndorsementType {
    /// Confirms the contribution occurred as described
    Verification,
    
    /// Speaks to the contribution's effect on the community
    Impact,
    
    /// Endorses the contributor's character and reliability
    Character,
    
    /// Validates specific skills demonstrated
    Skill,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MutualAidInteraction {
    /// When the interaction occurred
    pub date: DateTime<Utc>,
    
    /// DID of the member providing aid
    pub provider_did: String,
    
    /// DID of the member receiving aid
    pub receiver_did: String,
    
    /// Description of what was shared or exchanged
    pub description: String,
    
    /// Story about how this aid impacted the community
    pub impact_story: Option<String>,
    
    /// Notes about reciprocity and relationship building
    pub reciprocity_notes: Option<String>,
    
    /// Tags for categorizing types of mutual aid
    pub tags: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Relationship {
    /// DID of the first member
    pub member_one: String,
    
    /// DID of the second member
    pub member_two: String,
    
    /// Type of relationship
    pub relationship_type: RelationshipType,
    
    /// When the relationship began
    pub started: DateTime<Utc>,
    
    /// Story of how the relationship formed and evolved
    pub story: String,
    
    /// History of interactions between members
    pub interactions: Vec<Interaction>,
    
    /// Endorsements members have given each other
    pub mutual_endorsements: Vec<Endorsement>,
    
    /// Notes about the relationship
    pub notes: Vec<RelationshipNote>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Interaction {
    /// When the interaction occurred
    pub date: DateTime<Utc>,
    
    /// Description of what happened
    pub description: String,
    
    /// Impact or outcome of the interaction
    pub impact: Option<String>,
    
    /// Type of interaction
    pub interaction_type: InteractionType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InteractionType {
    /// Working together
    Collaboration,
    
    /// Providing support
    Support,
    
    /// Exchanging resources
    ResourceExchange,
    
    /// Sharing knowledge
    KnowledgeSharing,
    
    /// Working through challenges
    ConflictResolution,
    
    /// Other types of interactions
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Endorsement {
    /// DID of the endorsing member
    pub from_did: String,
    
    /// Content of the endorsement
    pub content: String,
    
    /// When the endorsement was given
    pub date: DateTime<Utc>,
    
    /// Context in which the skills were demonstrated
    pub context: String,
    
    /// Specific skills being endorsed
    pub skills: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelationshipNote {
    /// DID of the note author
    pub author_did: String,
    
    /// Content of the note
    pub content: String,
    
    /// When the note was written
    pub date: DateTime<Utc>,
    
    /// Who can see this note
    pub visibility: Visibility,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Visibility {
    /// Visible to everyone
    Public,
    
    /// Only visible to those in the relationship
    RelationshipParticipants,
    
    /// Visible to all cooperative members
    CooperativeMembers,
    
    /// Only visible to the author
    Private,
}

/// Main system for managing cooperative relationships
pub struct RelationshipSystem {
    /// Record of all contributions
    contributions: Vec<Contribution>,
    
    /// Record of mutual aid interactions
    mutual_aid: Vec<MutualAidInteraction>,
    
    /// Active relationships between members
    relationships: HashMap<(String, String), Relationship>,
    
    /// Internal trust scores for security validation
    /// Not exposed to users - used only for system security
    security_trust_scores: HashMap<String, i64>,
    
    /// Cached member validation info
    valid_members: HashSet<String>,
}

impl RelationshipSystem {
    /// Creates a new relationship system
    pub fn new() -> Self {
        RelationshipSystem {
            contributions: Vec::new(),
            mutual_aid: Vec::new(),
            relationships: HashMap::new(),
            security_trust_scores: HashMap::new(),
            valid_members: HashSet::new(),
        }
    }

    /// Records a new contribution with its story and impact
    pub fn record_contribution(&mut self, contribution: Contribution) -> Result<(), String> {
        if !self.is_valid_member(&contribution.contributor_did) {
            return Err("Contributor not found".to_string());
        }

        // Update internal security score (not exposed to users)
        self.update_security_score(&contribution.contributor_did, 1);
        
        // Record the contribution
        self.contributions.push(contribution);
        Ok(())
    }

    /// Records mutual aid interaction between members
    pub fn record_mutual_aid(&mut self, interaction: MutualAidInteraction) -> Result<(), String> {
        // Validate both members
        if !self.is_valid_member(&interaction.provider_did) || 
           !self.is_valid_member(&interaction.receiver_did) {
            return Err("Invalid member DID".to_string());
        }

        // Update relationship
        self.update_or_create_relationship(
            &interaction.provider_did,
            &interaction.receiver_did,
            &interaction.description,
        );

        // Record interaction
        self.mutual_aid.push(interaction);
        Ok(())
    }

    /// Creates or updates a relationship between members
    pub fn update_relationship(&mut self, relationship: Relationship) -> Result<(), String> {
        // Make relationship key consistent
        let key = self.make_relationship_key(
            &relationship.member_one,
            &relationship.member_two
        );
        
        // Validate members
        if !self.is_valid_member(&relationship.member_one) || 
           !self.is_valid_member(&relationship.member_two) {
            return Err("Invalid member DID".to_string());
        }

        self.relationships.insert(key, relationship);
        Ok(())
    }

    /// Adds an endorsement to an existing relationship
    pub fn add_endorsement(
        &mut self,
        member_one: &str,
        member_two: &str,
        endorsement: Endorsement
    ) -> Result<(), String> {
        let key = self.make_relationship_key(member_one, member_two);
        
        if let Some(relationship) = self.relationships.get_mut(&key) {
            relationship.mutual_endorsements.push(endorsement);
            Ok(())
        } else {
            Err("Relationship not found".to_string())
        }
    }

    /// Gets member's contribution history with impact stories
    pub fn get_member_contributions(&self, did: &str) -> Vec<&Contribution> {
        self.contributions.iter()
            .filter(|c| c.contributor_did == did)
            .collect()
    }

    /// Gets mutual aid history for a member
    pub fn get_mutual_aid_history(&self, did: &str) -> Vec<&MutualAidInteraction> {
        self.mutual_aid.iter()
            .filter(|m| m.provider_did == did || m.receiver_did == did)
            .collect()
    }

    /// Gets all relationships for a member
    pub fn get_member_relationships(&self, did: &str) -> Vec<&Relationship> {
        self.relationships.values()
            .filter(|r| r.member_one == did || r.member_two == did)
            .collect()
    }

    /// Register a valid member DID
    pub fn register_member(&mut self, did: String) {
        self.valid_members.insert(did);
    }

    // Internal helper methods

    /// Validates that a member exists in the system
    fn is_valid_member(&self, did: &str) -> bool {
        self.valid_members.contains(did)
    }

    /// Creates a consistent key for relationships regardless of member order
    fn make_relationship_key(&self, member_one: &str, member_two: &str) -> (String, String) {
        if member_one < member_two {
            (member_one.to_string(), member_two.to_string())
        } else {
            (member_two.to_string(), member_one.to_string())
        }
    }

    /// Updates internal security score
    fn update_security_score(&mut self, did: &str, amount: i64) {
        *self.security_trust_scores.entry(did.to_string()).or_insert(0) += amount;
    }

    /// Creates or updates a relationship based on an interaction
    fn update_or_create_relationship(
        &mut self,
        member_one: &str,
        member_two: &str,
        context: &str
    ) {
        let key = self.make_relationship_key(member_one, member_two);
        
        if let Some(relationship) = self.relationships.get_mut(&key) {
            let interaction = Interaction {
                date: Utc::now(),
                description: context.to_string(),
                impact: None,
                interaction_type: InteractionType::ResourceExchange,
            };
            relationship.interactions.push(interaction);
        } else {
            let new_relationship = Relationship {
                member_one: member_one.to_string(),
                member_two: member_two.to_string(),
                relationship_type: RelationshipType::MutualAid,
                started: Utc::now(),
                story: format!("Relationship started with mutual aid: {}", context),
                interactions: vec![Interaction {
                    date: Utc::now(),
                    description: context.to_string(),
                    impact: None,
                    interaction_type: InteractionType::ResourceExchange,
                }],
                mutual_endorsements: Vec::new(),
                notes: Vec::new(),
            };
            self.relationships.insert(key, new_relationship);
        }
    }
}

impl EnergyAware for RelationshipSystem {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record storage based on relationship count
        let storage_size = (self.relationships.len() * std::mem::size_of::<Relationship>()) as u64;
        monitor.record_storage_operation(storage_size);
        
        // Record contribution operations
        let contributions_size = (self.contributions.len() * std::mem::size_of::<Contribution>()) as u64;
        monitor.record_memory_operation(contributions_size);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_system() -> RelationshipSystem {
        let mut system = RelationshipSystem::new();
        system.register_member("test_did".to_string());
        system.register_member("test_did2".to_string());
        system
    }

    #[test]
    fn test_record_contribution() {
        let mut system = setup_test_system();
        
        let contribution = Contribution {
            contributor_did: "test_did".to_string(),
            description: "Test contribution".to_string(),
            impact_story: "Made an impact".to_string(),
            date: Utc::now(),
            context: "test".to_string(),
            witnesses: vec![],
            feedback: vec![],
            tags: vec!["test".to_string()],
        };

        assert!(system.record_contribution(contribution).is_ok());
    }

    #[test]
    fn test_mutual_aid() {
        let mut system = setup_test_system();
        
        let interaction = MutualAidInteraction {
            date: Utc::now(),
            provider_did: "test_did".to_string(),
            receiver_did: "test_did2".to_string(),
            description: "Helped with project".to_string(),
            impact_story: Some("Great collaboration".to_string()),
            reciprocity_notes: None,
            tags: vec!["help".to_string()],
        };

        assert!(system.record_mutual_aid(interaction).is_ok());
    }

    #[test]
    fn test_invalid_member() {
        let mut system = setup_test_system();
        
        let contribution = Contribution {
            contributor_did: "invalid_did".to_string(),
            description: "Test".to_string(),
            impact_story: "Test".to_string(),
            date: Utc::now(),
            context: "test".to_string(),
            witnesses: vec![],
            feedback: vec![],
            tags: vec![],
        };

        assert!(system.record_contribution(contribution).is_err());
    }
}

===================
File: ./backend/src/blockchain/chain.rs
===================
// src/blockchain/chain.rs

use std::sync::{Arc, Mutex};
use chrono::Utc;
use std::collections::HashMap;
use crate::consensus::{ProofOfCooperation, ConsensusRound};
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::vm::{VM, Contract, ExecutionContext, Event};
use crate::blockchain::{Block, Transaction};
use crate::blockchain::transaction::{TransactionType, ResourceAllocation};
use crate::relationship::{
    RelationshipSystem,
    Contribution,
    MutualAidInteraction,
    Relationship,
    RelationshipType,
    Interaction,
    InteractionType
};

/// Main blockchain implementation with cooperative-specific features
pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub consensus: Arc<Mutex<ProofOfCooperation>>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub relationship_system: Arc<Mutex<RelationshipSystem>>,
    pub resource_allocations: HashMap<String, ResourceAllocation>,
    pub current_block_number: u64,
    coordinator_did: String,
}


impl Blockchain {
    /// Creates a new blockchain instance with required subsystems
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>, 
        reputation_system: Arc<Mutex<ReputationSystem>>,
        relationship_system: Arc<Mutex<RelationshipSystem>>,
        consensus: Arc<Mutex<ProofOfCooperation>>,
    ) -> Self {
        Blockchain {
            chain: vec![Block::new(0, String::from("0"), vec![], String::from("genesis"))],
            pending_transactions: vec![],
            consensus,
            identity_system,
            reputation_system,
            relationship_system,
            resource_allocations: HashMap::new(),
            current_block_number: 1,
            coordinator_did: "did:icn:genesis".to_string(),
        }
    }

    /// Processes a new transaction
    pub async fn process_transaction(&mut self, transaction: &Transaction) -> Result<(), String> {
        self.validate_transaction(transaction)?;
        self.check_and_update_resources(&transaction.sender)?;

        let tx = transaction.clone();
        let sender = tx.sender.clone();

        {
            let resource_allocation = self.resource_allocations.get_mut(&sender)
                .ok_or("Resource allocation not found")?;
            
            if !resource_allocation.can_afford(tx.resource_cost) {
                return Err("Insufficient resources".to_string());
            }

            resource_allocation.consume_resources(tx.resource_cost)?;
        }

        match &tx.transaction_type {
            TransactionType::Transfer { amount, receiver } => {
                println!(
                    "Processing transfer of {} from {} to {}",
                    amount, tx.sender, receiver
                );
                self.pending_transactions.push(tx);
                Ok(())
            },

            TransactionType::ContractExecution { contract_id, input_data } => {
                let contract = self.get_contract(contract_id)?;
                
                let reputation_context = {
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                    reputation_system.get_reputation_context()
                };

                let mut vm = VM::new(1000, reputation_context);
                
                let reputation_score = {
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation system lock".to_string())?;
                    reputation_system.get_reputation(&tx.sender)
                };

                let permissions = {
                    let identity_system = self.identity_system.lock()
                        .map_err(|_| "Failed to acquire identity system lock".to_string())?;
                    identity_system.get_permissions(&tx.sender)
                };

                let execution_context = ExecutionContext {
                    caller_did: tx.sender.clone(),
                    cooperative_id: contract.cooperative_metadata.cooperative_id.clone(),
                    timestamp: tx.timestamp as u64,
                    block_number: self.current_block_number,
                    reputation_score,
                    permissions,
                };

                vm.set_execution_context(execution_context);

                match vm.execute_contract(&contract) {
                    Ok(_) => {
                        self.handle_vm_events(vm.get_events());
                        let mut reputation_system = self.reputation_system.lock()
                            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                        reputation_system.update_reputations(&vm.get_reputation_context());
                        self.pending_transactions.push(tx);
                        Ok(())
                    }
                    Err(e) => Err(format!("Contract execution failed: {}", e)),
                }
            },

            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                let mut relationship_system = self.relationship_system.lock()
                    .map_err(|_| "Failed to acquire relationship lock".to_string())?;
                
                let contribution = Contribution {
                    contributor_did: tx.sender.clone(),
                    description: description.clone(),
                    impact_story: impact_story.clone(),
                    date: Utc::now(),
                    context: context.clone(),
                    witnesses: vec![],
                    feedback: vec![],
                    tags: tags.clone(),
                };
                
                relationship_system.record_contribution(contribution)?;
                self.pending_transactions.push(tx);
                Ok(())
            },

            TransactionType::RecordMutualAid { 
                receiver, description, impact_story, reciprocity_notes, tags 
            } => {
                let mut relationship_system = self.relationship_system.lock()
                    .map_err(|_| "Failed to acquire relationship lock".to_string())?;
                
                let interaction = MutualAidInteraction {
                    date: Utc::now(),
                    provider_did: tx.sender.clone(),
                    receiver_did: receiver.clone(),
                    description: description.clone(),
                    impact_story: impact_story.clone(),
                    reciprocity_notes: reciprocity_notes.clone(),
                    tags: tags.clone(),
                };
                
                relationship_system.record_mutual_aid(interaction)?;
                self.pending_transactions.push(tx);
                Ok(())
            },

            TransactionType::UpdateRelationship { 
                member_two, relationship_type, story, interaction 
            } => {
                let mut relationship_system = self.relationship_system.lock()
                    .map_err(|_| "Failed to acquire relationship lock".to_string())?;
                
                let mut relationship = Relationship {
                    member_one: tx.sender.clone(),
                    member_two: member_two.clone(),
                    relationship_type: RelationshipType::from_str(relationship_type),
                    started: Utc::now(),
                    story: story.clone(),
                    interactions: vec![],
                    mutual_endorsements: vec![],
                    notes: vec![],
                };

                if let Some(interaction_text) = interaction {
                    let new_interaction = Interaction {
                        date: Utc::now(),
                        description: interaction_text.clone(),
                        impact: None,
                        interaction_type: InteractionType::Collaboration,
                    };
                    relationship.interactions.push(new_interaction);
                }
                
                relationship_system.update_relationship(relationship)?;
                self.pending_transactions.push(tx);
                Ok(())
            },

            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                let mut relationship_system = self.relationship_system.lock()
                    .map_err(|_| "Failed to acquire relationship lock".to_string())?;
                
                let endorsement = crate::relationship::Endorsement {
                    from_did: tx.sender.clone(),
                    content: content.clone(),
                    date: Utc::now(),
                    context: context.clone(),
                    skills: skills.clone(),
                };
                
                relationship_system.add_endorsement(&tx.sender, to_did, endorsement)?;
                self.pending_transactions.push(tx);
                Ok(())
            },
        }
    }

    /// Checks and updates resource allocations for a DID
    fn check_and_update_resources(&mut self, did: &str) -> Result<(), String> {
        let reputation_score = {
            let reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation lock".to_string())?;
            reputation_system.get_reputation(did)
        };

        let resource_allocation = self.resource_allocations
            .entry(did.to_string())
            .or_insert_with(|| ResourceAllocation::new(reputation_score));

        resource_allocation.update_resources();
        Ok(())
    }

    /// Validates a transaction before processing
    fn validate_transaction(&self, transaction: &Transaction) -> Result<(), String> {
        let identity_valid = {
            let identity_system = self.identity_system.lock()
                .map_err(|_| "Failed to acquire identity system lock".to_string())?;
            identity_system.is_registered(&transaction.sender)
        };

        if !identity_valid {
            return Err("Invalid sender DID".to_string());
        }

        let reputation_valid = {
            let reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation lock".to_string())?;
            reputation_system.get_reputation(&transaction.sender) >= 10
        };

        if !reputation_valid {
            return Err("Insufficient reputation".to_string());
        }

        Ok(())
    }

    /// Retrieves a contract by ID
    fn get_contract(&self, _contract_id: &str) -> Result<Contract, String> {
        // TODO: Implement contract storage and retrieval
        Err("Contract not found".to_string())
    }

    /// Handles events emitted by the VM
    fn handle_vm_events(&self, events: &[Event]) {
        for event in events {
            match event.event_type.as_str() {
                "CooperativeCreated" => {
                    println!("Cooperative created: {:?}", event.data);
                }
                "ProposalCreated" => {
                    println!("Proposal created: {:?}", event.data);
                }
                _ => {
                    println!("Unknown event type: {}", event.event_type);
                }
            }
        }
    }

    /// Adds a new transaction to the pending pool
    pub async fn add_transaction(&mut self, transaction: Transaction) -> Result<(), String> {
        self.process_transaction(&transaction).await?;
        
        if self.pending_transactions.len() >= 10 {
            self.finalize_block().await?;
        }
        
        Ok(())
    }

    /// Finalizes the current block and starts a new consensus round
    pub async fn finalize_block(&mut self) -> Result<(), String> {
        let previous_hash = self.chain.last()
            .map(|block| block.hash.clone())
            .unwrap_or_default();

        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
            self.coordinator_did.clone(),
        );

        let mut consensus_guard = self.consensus.lock()
            .map_err(|_| "Failed to acquire consensus lock".to_string())?;

        consensus_guard.start_round().await?;
        
        let validators = self.get_active_validators();
        if validators.is_empty() {
            return Err("No active validators available".to_string());
        }

        self.coordinator_did = validators[0].clone();

        consensus_guard.propose_block(&self.coordinator_did, new_block.clone()).await?;

        for validator in &validators {
            let signature = String::from("dummy_signature"); // TODO: Implement real signatures
            consensus_guard.submit_vote(validator, true, signature).await?;
        }

        let block = consensus_guard.finalize_round().await?;

        drop(consensus_guard);

        self.chain.push(block);
        self.pending_transactions.clear();
        self.current_block_number += 1;
        
        Ok(())
    }

    /// Gets a list of active validators
    fn get_active_validators(&self) -> Vec<String> {
        // TODO: Implement real validator selection based on reputation and stake
        vec![
            "did:icn:validator1".to_string(),
            "did:icn:validator2".to_string(),
            "did:icn:validator3".to_string(),
        ]
    }

    /// Gets a block by index
    pub fn get_block(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    /// Gets the latest block
    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    /// Gets the total number of transactions processed
    pub fn get_transaction_count(&self) -> usize {
        self.chain.iter().map(|block| block.transactions.len()).sum()
    }

    /// Gets the total number of blocks in the chain
    pub fn get_block_count(&self) -> usize {
        self.chain.len()
    }

    /// Gets the current consensus round
    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.consensus.try_lock()
            .ok()
            .and_then(|consensus| consensus.get_current_round().cloned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_test_blockchain() -> Blockchain {
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let relationship_system = Arc::new(Mutex::new(RelationshipSystem::new()));
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            crate::consensus::types::ConsensusConfig::default(),
            Arc::new(crate::websocket::WebSocketHandler::new()),
        )));

        Blockchain::new(
            identity_system,
            reputation_system,
            relationship_system,
            consensus,
        )
    }

    #[tokio::test]
    async fn test_blockchain_creation() {
        let blockchain = setup_test_blockchain().await;
        assert_eq!(blockchain.current_block_number, 1);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.pending_transactions.len(), 0);
    }

    // Rest of the tests...
}

===================
File: ./backend/src/blockchain/mod.rs
===================
// src/blockchain/mod.rs

mod block;
mod transaction;
mod chain;

// Re-export the core types
pub use block::Block;
pub use transaction::{Transaction, TransactionType};
pub use chain::Blockchain;

// Module-level constants
pub const MAX_BLOCK_SIZE: usize = 1000; // Maximum transactions per block
pub const MIN_REPUTATION_FOR_TXN: i64 = 10; // Minimum reputation to submit transactions

===================
File: ./backend/src/blockchain/block.rs
===================
// src/blockchain/block.rs

use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

use super::Transaction;

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    /// Sequential index of this block in the chain
    pub index: u64,
    
    /// Hash of the previous block
    pub previous_hash: String,
    
    /// Unix timestamp in milliseconds when block was created
    pub timestamp: u64,
    
    /// List of transactions included in this block
    pub transactions: Vec<Transaction>,
    
    /// Hash of this block's contents
    pub hash: String,
    
    /// The DID of the validator that proposed this block
    pub proposer: String,
    
    /// Collection of validator signatures approving this block
    pub signatures: Vec<BlockSignature>,
    
    /// Metadata about the block creation
    pub metadata: BlockMetadata,
}

/// Signature from a validator approving a block
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    /// DID of the signing validator
    pub validator_did: String,
    
    /// The signature itself
    pub signature: String,
    
    /// Timestamp when signature was created
    pub timestamp: DateTime<Utc>,
    
    /// Voting power of the validator at time of signing
    pub voting_power: f64,
}

/// Additional metadata about block creation and validation
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    /// Time taken to reach consensus (milliseconds)
    pub consensus_duration_ms: u64,
    
    /// Number of validators that participated
    pub validator_count: u32,
    
    /// Total voting power that approved the block
    pub total_voting_power: f64,
    
    /// Total resources consumed by transactions in the block
    pub resources_used: u64,
    
    /// Size of the block in bytes
    pub size: u64,
    
    /// Summary of relationship transactions
    pub relationship_updates: RelationshipMetadata,
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            signatures: Vec::new(),
            metadata,
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        // Add block header fields
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        // Add transaction hashes
        for tx in &self.transactions {
            hasher.update(&tx.hash);
        }
        
        // Add proposer
        hasher.update(&self.proposer);
        
        // Convert hash to hex string
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        self.signatures.push(BlockSignature {
            validator_did,
            signature,
            timestamp: Utc::now(),
            voting_power,
        });

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub fn verify(&self, previous_block: Option<&Block>) -> Result<(), String> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err("Invalid block hash".to_string());
        }

        // Verify previous hash and index if we have a parent block
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err("Previous hash mismatch".to_string());
            }

            if self.index != prev.index + 1 {
                return Err("Invalid block index".to_string());
            }

            if self.timestamp <= prev.timestamp {
                return Err("Invalid timestamp".to_string());
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err("Block timestamp is in the future".to_string());
        }

        // Verify all transactions
        for tx in &self.transactions {
            if !tx.validate() {
                return Err(format!("Invalid transaction: {}", tx.hash));
            }
        }

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err("Resource usage mismatch".to_string());
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err("Relationship metadata mismatch".to_string());
        }

        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> RelationshipMetadata {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                super::TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                super::TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                super::TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                super::TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        metadata
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_block() -> Block {
        Block::new(
            1,
            "previous_hash".to_string(),
            vec![],
            "did:icn:proposer".to_string()
        )
    }

    #[test]
    fn test_block_creation() {
        let block = create_test_block();
        assert_eq!(block.index, 1);
        assert_eq!(block.previous_hash, "previous_hash");
        assert!(!block.hash.is_empty());
        assert_eq!(block.proposer, "did:icn:proposer");
    }

    #[test]
    fn test_block_hash_calculation() {
        let block = create_test_block();
        let hash = block.hash.clone();
        assert_eq!(block.calculate_hash(), hash);
    }

    #[test]
    fn test_signature_addition() {
        let mut block = create_test_block();
        assert!(block.add_signature(
            "did:icn:validator1".to_string(),
            "signature1".to_string(),
            0.5
        ));

        // Try adding same validator again
        assert!(!block.add_signature(
            "did:icn:validator1".to_string(),
            "signature2".to_string(),
            0.5
        ));

        assert_eq!(block.signatures.len(), 1);
        assert_eq!(block.metadata.validator_count, 1);
        assert_eq!(block.metadata.total_voting_power, 0.5);
    }

    #[test]
    fn test_block_verification() {
        let mut block = create_test_block();
        assert!(block.verify(None).is_ok());

        // Test invalid hash
        block.hash = "invalid".to_string();
        assert!(block.verify(None).is_err());
    }

    #[test]
    fn test_relationship_metadata() {
        use super::super::TransactionType;
        
        let transactions = vec![
            Transaction::new(
                "did:icn:alice".to_string(),
                TransactionType::RecordContribution {
                    description: "test".to_string(),
                    impact_story: "test".to_string(),
                    context: "test".to_string(),
                    tags: vec!["test".to_string()],
                }
            ),
            Transaction::new(
                "did:icn:bob".to_string(),
                TransactionType::RecordMutualAid {
                    receiver: "did:icn:charlie".to_string(),
                    description: "test".to_string(),
                    impact_story: None,
                    reciprocity_notes: None,
                    tags: vec!["test".to_string()],
                }
            ),
        ];

        let block = Block::new(1, "hash".to_string(), transactions, "proposer".to_string());
        
        assert_eq!(block.metadata.relationship_updates.contribution_count, 1);
        assert_eq!(block.metadata.relationship_updates.mutual_aid_count, 1);
        assert_eq!(block.metadata.relationship_updates.total_participants, 3);
    }
}

===================
File: ./backend/src/blockchain/transaction.rs
===================
// src/blockchain/transaction.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,
    pub transaction_type: TransactionType,
    pub timestamp: u128,
    pub hash: String,
    pub resource_cost: u64,      // Resource points required for this transaction
    pub resource_priority: u8,    // Priority level for resource allocation (1-10)
}

#[derive(Debug, Clone)]
pub struct ResourceAllocation {
    pub max_resources: u64,      // Maximum resource points available
    pub current_resources: u64,  // Current resource points
    pub recovery_rate: u64,      // Points recovered per hour
    pub last_update: u128,       // Last resource update timestamp
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);
        
        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
            resource_cost,
            resource_priority: 5, // Default priority level
        }
    }

    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                // Base cost plus percentage of transfer amount
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                // Base cost plus data size cost
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                // Cost based on content size and complexity
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                // Base cost plus content size
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                // Base cost plus story length
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                // Base cost plus content and skills
                60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        // Ensure sender is not empty
        if self.sender.is_empty() {
            return false;
        }

        // Validate based on transaction type
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && 
                !impact_story.is_empty() && 
                !context.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && 
                !description.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && 
                !relationship_type.is_empty() && 
                !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && 
                !content.is_empty() && 
                !context.is_empty() && 
                !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend(self.sender.as_bytes());
        bytes.extend(self.hash.as_bytes());
        bytes.extend(&self.timestamp.to_be_bytes());
        bytes
    }
}

impl ResourceAllocation {
    pub fn new(reputation: i64) -> Self {
        // Calculate resource limits based on reputation
        let max_resources = 1000 + (reputation.max(0) as u64 * 100);
        let recovery_rate = 10 + (reputation.max(0) as u64 / 10);
        
        ResourceAllocation {
            max_resources,
            current_resources: max_resources,
            recovery_rate,
            last_update: Utc::now().timestamp_millis() as u128,
        }
    }

    pub fn update_resources(&mut self) {
        let now = Utc::now().timestamp_millis() as u128;
        let hours_elapsed = ((now - self.last_update) / (1000 * 60 * 60)) as u64;
        
        if hours_elapsed > 0 {
            let recovery = self.recovery_rate * hours_elapsed;
            self.current_resources = (self.current_resources + recovery).min(self.max_resources);
            self.last_update = now;
        }
    }

    pub fn can_afford(&self, cost: u64) -> bool {
        self.current_resources >= cost
    }

    pub fn consume_resources(&mut self, cost: u64) -> Result<(), String> {
        if !self.can_afford(cost) {
            return Err("Insufficient resources".to_string());
        }
        
        self.current_resources -= cost;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transfer_transaction_creation() {
        let sender = "did:icn:sender".to_string();
        let transaction = Transaction::new(
            sender.clone(),
            TransactionType::Transfer {
                receiver: "did:icn:receiver".to_string(),
                amount: 100,
            },
        );

        assert_eq!(transaction.sender, sender);
        assert!(!transaction.hash.is_empty());
        assert!(transaction.validate());
    }

    #[test]
    fn test_contribution_transaction() {
        let transaction = Transaction::new(
            "did:icn:sender".to_string(),
            TransactionType::RecordContribution {
                description: "Test contribution".to_string(),
                impact_story: "Made a difference".to_string(),
                context: "Testing".to_string(),
                tags: vec!["test".to_string()],
            },
        );

        assert!(transaction.validate());
        assert!(transaction.resource_cost > 0);
    }

    #[test]
    fn test_invalid_transaction() {
        let transaction = Transaction::new(
            "".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:receiver".to_string(),
                amount: 0,
            },
        );

        assert!(!transaction.validate());
    }

    #[test]
    fn test_resource_allocation() {
        let mut resources = ResourceAllocation::new(1000);
        assert!(resources.can_afford(500));
        assert!(resources.consume_resources(500).is_ok());
        assert_eq!(resources.current_resources, resources.max_resources - 500);
    }

    #[test]
    fn test_resource_recovery() {
        let mut resources = ResourceAllocation::new(1000);
        resources.consume_resources(500).unwrap();
        resources.last_update -= 3600 * 1000; // Subtract one hour in milliseconds
        resources.update_resources();
        assert!(resources.current_resources > resources.max_resources - 500);
    }

    #[test]
    fn test_priority_setting() {
        let mut transaction = Transaction::new(
            "did:icn:sender".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:receiver".to_string(),
                amount: 100,
            },
        );

        transaction.set_priority(15); // Should be capped at 10
        assert_eq!(transaction.resource_priority, 10);
    }
}

===================
File: ./backend/src/reputation/reputation_system.rs
===================
// src/reputation/reputation_system.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;

/// Represents a change in reputation with context
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReputationChange {
    /// Amount of reputation changed (positive or negative)
    pub amount: i64,
    
    /// Reason for the reputation change
    pub reason: String,
    
    /// When the change occurred
    pub timestamp: DateTime<Utc>,
    
    /// Context or category of the change
    pub context: ReputationContext,
    
    /// DID of the entity that triggered the change
    pub trigger_did: Option<String>,
}

/// Different contexts where reputation can be earned or lost
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum ReputationContext {
    /// Consensus participation and validation
    Consensus,
    
    /// Governance participation (proposals, voting)
    Governance,
    
    /// Resource sharing and allocation
    Resources,
    
    /// Cooperative membership and participation
    Membership,
    
    /// General cooperative contributions
    Contribution,
}

/// Configuration for the reputation system
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReputationConfig {
    /// Minimum possible reputation score
    pub min_reputation: i64,
    
    /// Maximum possible reputation score
    pub max_reputation: i64,
    
    /// Base amount earned for positive actions
    pub base_reward: i64,
    
    /// Base amount lost for negative actions
    pub base_penalty: i64,
    
    /// How quickly reputation decays (percentage per day)
    pub decay_rate: f64,
    
    /// Minimum time between reputation updates
    pub update_cooldown_ms: u64,
}

impl Default for ReputationConfig {
    fn default() -> Self {
        ReputationConfig {
            min_reputation: 0,
            max_reputation: 10000,
            base_reward: 10,
            base_penalty: 10,
            decay_rate: 0.01, // 1% per day
            update_cooldown_ms: 60000, // 1 minute
        }
    }
}

/// Main reputation system implementation
pub struct ReputationSystem {
    /// Current reputation scores for all DIDs
    scores: HashMap<String, i64>,
    
    /// History of reputation changes
    history: HashMap<String, Vec<ReputationChange>>,
    
    /// Last update timestamp for each DID
    last_updated: HashMap<String, DateTime<Utc>>,
    
    /// System configuration
    config: ReputationConfig,
    
    /// Context-specific multipliers
    context_multipliers: HashMap<ReputationContext, f64>,
}

impl ReputationSystem {
    /// Creates a new reputation system with default configuration
    pub fn new() -> Self {
        let mut context_multipliers = HashMap::new();
        context_multipliers.insert(ReputationContext::Consensus, 1.5);
        context_multipliers.insert(ReputationContext::Governance, 1.2);
        context_multipliers.insert(ReputationContext::Resources, 1.0);
        context_multipliers.insert(ReputationContext::Membership, 1.0);
        context_multipliers.insert(ReputationContext::Contribution, 1.1);

        ReputationSystem {
            scores: HashMap::new(),
            history: HashMap::new(),
            last_updated: HashMap::new(),
            config: ReputationConfig::default(),
            context_multipliers,
        }
    }

    /// Gets the current reputation score for a DID
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Gets the reputation history for a DID
    pub fn get_history(&self, did: &str) -> Vec<ReputationChange> {
        self.history.get(did)
            .cloned()
            .unwrap_or_default()
    }

    /// Updates reputation with context and reason
    pub fn update_reputation(
        &mut self,
        did: &str,
        change: i64,
        context: ReputationContext,
        reason: String,
        trigger_did: Option<String>
    ) -> Result<i64, String> {
        // Check update cooldown
        let now = Utc::now();
        if let Some(last_update) = self.last_updated.get(did) {
            let elapsed = now.signed_duration_since(*last_update).num_milliseconds();
            if elapsed < self.config.update_cooldown_ms as i64 {
                return Err("Reputation update too soon".to_string());
            }
        }

        // Apply context multiplier
        let multiplier = self.context_multipliers
            .get(&context)
            .unwrap_or(&1.0);
        let adjusted_change = (change as f64 * multiplier) as i64;

        // Update score
        let current_score = self.get_reputation(did);
        let new_score = (current_score + adjusted_change)
            .max(self.config.min_reputation)
            .min(self.config.max_reputation);

        self.scores.insert(did.to_string(), new_score);
        self.last_updated.insert(did.to_string(), now);

        // Record change in history
        let change_record = ReputationChange {
            amount: adjusted_change,
            reason,
            timestamp: now,
            context,
            trigger_did,
        };

        self.history
            .entry(did.to_string())
            .or_insert_with(Vec::new)
            .push(change_record);

        Ok(new_score)
    }

    /// Increases reputation with context
    pub fn increase_reputation(
        &mut self,
        did: &str,
        amount: i64,
        context: ReputationContext,
        reason: String
    ) -> Result<i64, String> {
        self.update_reputation(did, amount.abs(), context, reason, None)
    }

    /// Decreases reputation with context
    pub fn decrease_reputation(
        &mut self,
        did: &str,
        amount: i64,
        context: ReputationContext,
        reason: String
    ) -> Result<i64, String> {
        self.update_reputation(did, -amount.abs(), context, reason, None)
    }

    /// Gets a copy of the current reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates multiple reputation scores at once
    pub fn update_reputations(&mut self, updates: &HashMap<String, i64>) {
        for (did, score) in updates {
            self.scores.insert(did.clone(), *score);
            self.last_updated.insert(did.clone(), Utc::now());
        }
    }

    /// Applies reputation decay to all scores
    pub fn apply_decay(&mut self) {
        let now = Utc::now();
        
        for (did, score) in self.scores.iter_mut() {
            if let Some(last_update) = self.last_updated.get(did) {
                let days = now.signed_duration_since(*last_update).num_days() as f64;
                if days > 0.0 {
                    let decay_factor = (1.0 - self.config.decay_rate).powi(days as i32);
                    *score = (*score as f64 * decay_factor) as i64;
                    self.last_updated.insert(did.clone(), now);
                }
            }
        }
    }

    /// Checks if a DID meets a reputation threshold
    pub fn meets_threshold(&self, did: &str, threshold: i64) -> bool {
        self.get_reputation(did) >= threshold
    }

    /// Gets top contributors by reputation
    pub fn get_top_contributors(&self, limit: usize) -> Vec<(String, i64)> {
        let mut contributors: Vec<_> = self.scores.iter()
            .map(|(k, v)| (k.clone(), *v))
            .collect();
        
        contributors.sort_by(|a, b| b.1.cmp(&a.1));
        contributors.truncate(limit);
        
        contributors
    }

    /// Calculates the total reputation in the system
    pub fn total_reputation(&self) -> i64 {
        self.scores.values().sum()
    }

    /// Updates the configuration
    pub fn update_config(&mut self, config: ReputationConfig) {
        self.config = config;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_system() -> ReputationSystem {
        ReputationSystem::new()
    }

    #[test]
    fn test_initial_reputation() {
        let system = setup_test_system();
        assert_eq!(system.get_reputation("test_did"), 0);
    }

    #[test]
    fn test_reputation_increase() {
        let mut system = setup_test_system();
        let result = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test increase".to_string()
        );
        
        assert!(result.is_ok());
        assert_eq!(system.get_reputation("test_did"), 150); // With 1.5x multiplier
    }

    #[test]
    fn test_reputation_decrease() {
        let mut system = setup_test_system();
        
        // First increase reputation
        system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test increase".to_string()
        ).unwrap();
        
        // Then decrease it
        let result = system.decrease_reputation(
            "test_did",
            50,
            ReputationContext::Consensus,
            "test decrease".to_string()
        );
        
        assert!(result.is_ok());
        assert_eq!(system.get_reputation("test_did"), 75); // 150 - (50 * 1.5)
    }

    #[test]
    fn test_reputation_limits() {
        let mut system = setup_test_system();
        
        // Test maximum
        system.increase_reputation(
            "test_did",
            system.config.max_reputation * 2,
            ReputationContext::Consensus,
            "test max".to_string()
        ).unwrap();
        
        assert_eq!(system.get_reputation("test_did"), system.config.max_reputation);
        
        // Test minimum
        system.decrease_reputation(
            "test_did",
            system.config.max_reputation * 2,
            ReputationContext::Consensus,
            "test min".to_string()
        ).unwrap();
        
        assert_eq!(system.get_reputation("test_did"), system.config.min_reputation);
    }

    #[test]
    fn test_reputation_decay() {
        let mut system = setup_test_system();
        
        // Set initial reputation
        system.increase_reputation(
            "test_did",
            1000,
            ReputationContext::Consensus,
            "initial".to_string()
        ).unwrap();
        
        // Force last_updated to be one day ago
        let one_day_ago = Utc::now() - chrono::Duration::days(1);
        system.last_updated.insert("test_did".to_string(), one_day_ago);
        
        // Apply decay
        system.apply_decay();
        
        // Check that reputation has decayed by decay_rate
        let expected = (1500.0 * (1.0 - system.config.decay_rate)) as i64;
        assert_eq!(system.get_reputation("test_did"), expected);
    }

    #[test]
    fn test_top_contributors() {
        let mut system = setup_test_system();
        
        // Add some test data
        system.increase_reputation(
            "did1",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        ).unwrap();
        
        system.increase_reputation(
            "did2",
            200,
            ReputationContext::Consensus,
            "test".to_string()
        ).unwrap();
        
        let top = system.get_top_contributors(2);
        assert_eq!(top.len(), 2);
        assert_eq!(top[0].0, "did2");
        assert_eq!(top[1].0, "did1");
    }

    #[test]
    fn test_update_cooldown() {
        let mut system = setup_test_system();
        
        // First update should succeed
        let result1 = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        );
        assert!(result1.is_ok());
        
        // Immediate second update should fail
        let result2 = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        );
        assert!(result2.is_err());
    }
}

===================
File: ./backend/src/reputation/mod.rs
===================
// src/reputation/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationChange {
    pub did: String,
    pub change: i64,
    pub timestamp: DateTime<Utc>,
    pub reason: String,
    pub context: String,
}

#[derive(Clone)]
pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
    history: HashMap<String, Vec<ReputationChange>>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
            history: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: amount,
            timestamp: Utc::now(),
            reason: "Positive contribution".to_string(),
            context: "general".to_string(),
        };
        
        self.apply_reputation_change(did, change);
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: -amount,
            timestamp: Utc::now(),
            reason: "Negative action".to_string(),
            context: "general".to_string(),
        };
        
        self.apply_reputation_change(did, change);
    }

    /// Applies a reputation change with context and history tracking
    fn apply_reputation_change(&mut self, did: &str, change: ReputationChange) {
        let score = self.scores.entry(did.to_string()).or_insert(0);
        *score += change.change;
        
        // Ensure score doesn't go below zero
        if *score < 0 {
            *score = 0;
        }
        
        // Record the change in history
        self.history.entry(did.to_string())
            .or_insert_with(Vec::new)
            .push(change);
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: reward_points,
            timestamp: Utc::now(),
            reason: "Voting participation".to_string(),
            context: "governance".to_string(),
        };
        
        self.apply_reputation_change(did, change);
        
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }

    /// Returns a clone of the reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates the reputation context with changes from the VM execution
    pub fn update_reputations(&mut self, updated_reputations: &HashMap<String, i64>) {
        for (did, reputation) in updated_reputations {
            let change = ReputationChange {
                did: did.clone(),
                change: reputation - self.get_reputation(did),
                timestamp: Utc::now(),
                reason: "VM execution update".to_string(),
                context: "contract".to_string(),
            };
            
            self.apply_reputation_change(did, change);
        }
    }

    /// Gets the reputation history for a given DID
    pub fn get_history(&self, did: &str) -> Vec<ReputationChange> {
        self.history.get(did)
            .cloned()
            .unwrap_or_default()
    }

    /// Gets the total reputation in the system
    pub fn total_reputation(&self) -> i64 {
        self.scores.values().sum()
    }

    /// Gets the top contributors by reputation score
    pub fn get_top_contributors(&self, limit: usize) -> Vec<(String, i64)> {
        let mut contributors: Vec<_> = self.scores.iter()
            .map(|(k, v)| (k.clone(), *v))
            .collect();
        
        contributors.sort_by(|a, b| b.1.cmp(&a.1));
        contributors.truncate(limit);
        
        contributors
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_reputation_increase() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        assert_eq!(system.get_reputation("did:icn:test"), 100);
    }
    
    #[test]
    fn test_reputation_decrease() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        system.decrease_reputation("did:icn:test", 50);
        assert_eq!(system.get_reputation("did:icn:test"), 50);
    }
    
    #[test]
    fn test_reputation_floor() {
        let mut system = ReputationSystem::new();
        system.decrease_reputation("did:icn:test", 100);
        assert_eq!(system.get_reputation("did:icn:test"), 0);
    }
    
    #[test]
    fn test_reputation_history() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        system.decrease_reputation("did:icn:test", 50);
        
        let history = system.get_history("did:icn:test");
        assert_eq!(history.len(), 2);
        assert_eq!(history[0].change, 100);
        assert_eq!(history[1].change, -50);
    }
    
    #[test]
    fn test_voting_reward() {
        let mut system = ReputationSystem::new();
        system.reward_voting("did:icn:test", 10);
        assert_eq!(system.get_reputation("did:icn:test"), 10);
    }
}

===================
File: ./backend/src/governance/proposal.rs
===================
// src/governance/proposal.rs

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64, // Minimum reputation required to submit a proposal
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(
        id: u64,
        proposal_type: ProposalType,
        description: String,
        required_reputation: i64,
        duration: u64,
    ) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>, // Track proposals by ID for easier access
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/governance/mod.rs
===================
use std::collections::HashMap;

// ProposalType defines different types of proposals
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

// ProposalStatus represents the current status of a proposal
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

// Proposal struct holds data about each individual proposal
#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String, required_reputation: i64) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

// ProposalHistory struct holds a history of proposals and notifications
#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>,
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/main.rs
===================
// src/main.rs

mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;
mod websocket;
mod consensus;

use std::sync::{Arc, Mutex};
use warp::Filter;
use crate::websocket::WebSocketHandler;
use crate::blockchain::Blockchain;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::consensus::{ProofOfCooperation, types::ConsensusConfig};

#[tokio::main]
async fn main() {
    // Initialize core systems
    let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
    let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
    
    // Create WebSocket handler for real-time updates
    let ws_handler = Arc::new(WebSocketHandler::new());
    
    // Initialize consensus system
    let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
        ConsensusConfig::default(),
        ws_handler.clone(),
    )));

    // Initialize the blockchain with all required systems
    let blockchain = Arc::new(Mutex::new(Blockchain::new(
        identity_system.clone(),
        reputation_system.clone(),
        consensus.clone(),
    )));

    // Define WebSocket route with DID header for user identification
    let ws_handler = ws_handler.clone();
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .and(warp::header::<String>("X-DID"))
        .and(warp::any().map(move || ws_handler.clone()))
        .map(|ws: warp::ws::Ws, did: String, handler: Arc<WebSocketHandler>| {
            ws.on_upgrade(move |socket| async move {
                handler.handle_connection(socket, did).await;
            })
        });

    println!("Starting WebSocket server on localhost:8088");
    warp::serve(ws_route)
        .run(([127, 0, 0, 1], 8088))
        .await;
}

===================
File: ./backend/src/claims/mod.rs
===================
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claim {
    pub id: String,
    pub issuer: String,
    pub subject: String,
    pub claim_type: ClaimType,
    pub value: String,
    pub issued_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub verification_method: String,
    pub proof: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ClaimType {
    Skill,
    Reputation,
    Membership,
    Role,
    Contribution,
    Verification,
    Custom(String),
}

impl Claim {
    pub fn new(
        issuer: String,
        subject: String,
        claim_type: ClaimType,
        value: String,
        verification_method: String,
    ) -> Self {
        Claim {
            id: uuid::Uuid::new_v4().to_string(),
            issuer,
            subject,
            claim_type,
            value,
            issued_at: Utc::now(),
            expires_at: None,
            verification_method,
            proof: None,
        }
    }

    pub fn verify(&self) -> bool {
        // Basic validation
        if self.issuer.is_empty() || self.subject.is_empty() {
            return false;
        }

        // Check expiration
        if let Some(expires_at) = self.expires_at {
            if Utc::now() > expires_at {
                return false;
            }
        }

        // Check proof if present
        if let Some(proof) = &self.proof {
            if proof.is_empty() {
                return false;
            }
        }

        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_claim_creation() {
        let claim = Claim::new(
            "issuer".to_string(),
            "subject".to_string(),
            ClaimType::Skill,
            "programming".to_string(),
            "manual".to_string(),
        );

        assert!(!claim.id.is_empty());
        assert_eq!(claim.issuer, "issuer");
        assert_eq!(claim.subject, "subject");
        assert!(matches!(claim.claim_type, ClaimType::Skill));
        assert!(claim.verify());
    }

    #[test]
    fn test_claim_verification() {
        let mut claim = Claim::new(
            "issuer".to_string(),
            "subject".to_string(),
            ClaimType::Skill,
            "programming".to_string(),
            "manual".to_string(),
        );

        assert!(claim.verify());

        claim.issuer = "".to_string();
        assert!(!claim.verify());
    }
}

===================
File: ./backend/src/community/mod.rs
===================
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::claims::Claim;
use crate::governance::Proposal;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Community {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, CivicRole>, // DID -> Role mapping
    pub governance_model: GovernanceModel,
    #[serde(default)]
    pub active_proposals: Vec<String>, // Store proposal IDs instead of whole proposals
    pub policies: Vec<CivicPolicy>,
    pub cooperative_ids: Vec<String>, // Associated cooperatives
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CivicRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
    pub voting_history: Vec<VoteRecord>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceModel {
    pub model_type: GovernanceType,
    pub voting_rules: VotingRules,
    pub quorum_requirement: f64,
    pub decision_threshold: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GovernanceType {
    DirectDemocracy,
    DelegativeDemocracy,
    ConsensusBase,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VotingRules {
    pub voting_period_days: u32,
    pub min_participation: f64,
    pub allow_delegation: bool,
    pub require_claims: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoteRecord {
    pub proposal_id: String,
    pub vote: Vote,
    pub timestamp: DateTime<Utc>,
    pub weight: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Vote {
    For,
    Against,
    Abstain,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CivicPolicy {
    pub id: String,
    pub policy_type: CivicPolicyType,
    pub description: String,
    pub rules: Vec<PolicyRule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CivicPolicyType {
    Membership,
    Voting,
    DisputeResolution,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyRule {
    pub condition: String,
    pub action: String,
    pub parameters: HashMap<String, String>,
}

impl Community {
    pub fn new(
        id: String,
        name: String,
        description: String,
        governance_model: GovernanceModel,
    ) -> Self {
        Community {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            governance_model,
            active_proposals: Vec::new(),
            policies: Vec::new(),
            cooperative_ids: Vec::new(),
        }
    }

    pub fn add_member(&mut self, did: String, role: CivicRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_proposal(&mut self, proposal_id: String) {
        if !self.active_proposals.contains(&proposal_id) {
            self.active_proposals.push(proposal_id);
        }
    }

    pub fn add_policy(&mut self, policy: CivicPolicy) {
        self.policies.push(policy);
    }

    pub fn associate_cooperative(&mut self, cooperative_id: String) {
        if !self.cooperative_ids.contains(&cooperative_id) {
            self.cooperative_ids.push(cooperative_id);
        }
    }

    pub fn record_vote(&mut self, did: &str, proposal_id: &str, vote: Vote) -> Result<(), String> {
        if let Some(member) = self.members.get_mut(did) {
            let vote_record = VoteRecord {
                proposal_id: proposal_id.to_string(),
                vote,
                timestamp: Utc::now(),
                weight: 1.0, // Basic weight, could be modified based on reputation/claims
            };
            member.voting_history.push(vote_record);
            Ok(())
        } else {
            Err("Member not found".to_string())
        }
    }
}

impl crate::monitoring::energy::EnergyAware for Community {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record proposal storage
        let proposals_size = (self.active_proposals.len() * std::mem::size_of::<String>()) as u64;
        monitor.record_storage_operation(proposals_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<CivicRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_governance_model() -> GovernanceModel {
        GovernanceModel {
            model_type: GovernanceType::DirectDemocracy,
            voting_rules: VotingRules {
                voting_period_days: 7,
                min_participation: 0.5,
                allow_delegation: false,
                require_claims: vec![],
            },
            quorum_requirement: 0.5,
            decision_threshold: 0.66,
        }
    }

    #[test]
    fn test_community_creation() {
        let community = Community::new(
            "test_id".to_string(),
            "Test Community".to_string(),
            "Test Description".to_string(),
            create_test_governance_model(),
        );

        assert_eq!(community.name, "Test Community");
        assert_eq!(community.members.len(), 0);
        assert_eq!(community.active_proposals.len(), 0);
    }

    #[test]
    fn test_member_management() {
        let mut community = Community::new(
            "test_id".to_string(),
            "Test Community".to_string(),
            "Test Description".to_string(),
            create_test_governance_model(),
        );

        let role = CivicRole {
            role: "member".to_string(),
            permissions: vec!["vote".to_string()],
            joined_at: Utc::now(),
            verified_claims: vec![],
            voting_history: vec![],
        };

        assert!(community.add_member("test_did".to_string(), role).is_ok());
        assert!(community.add_member("test_did".to_string(), role).is_err());
    }
}

===================
File: ./backend/src/lib.rs
===================
// src/lib.rs

pub mod blockchain;
pub mod claims;
pub mod identity;
pub mod reputation;
pub mod governance;
pub mod utils;
pub mod vm;
pub mod websocket;
pub mod consensus;
pub mod network;
pub mod monitoring;
pub mod relationship;
pub mod community;

pub use blockchain::{Block, Blockchain, Transaction, TransactionType};
pub use identity::IdentitySystem;
pub use reputation::ReputationSystem;
pub use governance::Proposal;
pub use consensus::{ProofOfCooperation, types::ConsensusConfig};
pub use consensus::types::ConsensusRound;
pub use vm::{VM, Contract, ExecutionContext};
pub use vm::cooperative_metadata::{CooperativeMetadata, ResourceImpact};
pub use websocket::WebSocketHandler;
pub use monitoring::energy::{EnergyAware, EnergyMonitor};
pub use relationship::RelationshipSystem;
use relationship::{Contribution, MutualAidInteraction, Relationship};

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::broadcast;
use uuid;
use chrono::{DateTime, Utc};

/// Events emitted by the ICN system
#[derive(Clone, Debug)]
pub enum SystemEvent {
    BlockCreated(Block),
    ProposalSubmitted(Proposal),
    VoteCast { proposal_id: u64, voter: String, vote: bool },
    ReputationChanged { did: String, change: i64, reason: String },
    ConsensusStarted(ConsensusRound),
    ConsensusFinished(Block),
    CooperativeCreated { id: String, creator: String },
    CooperativeJoined { id: String, member: String },
    ContributionRecorded(Contribution),
    MutualAidProvided(MutualAidInteraction),
    RelationshipUpdated { member_one: String, member_two: String },
}

/// Core system for the Inter-Cooperative Network
pub struct ICNCore {
    blockchain: Arc<Mutex<Blockchain>>,
    identity_system: Arc<Mutex<IdentitySystem>>,
    reputation_system: Arc<Mutex<ReputationSystem>>,
    relationship_system: Arc<Mutex<RelationshipSystem>>,
    vm: Arc<Mutex<VM>>,
    event_bus: broadcast::Sender<SystemEvent>,
    start_time: DateTime<Utc>,
}

impl ICNCore {
    /// Creates a new instance of the ICN core system
    pub fn new() -> Self {
        let (event_tx, _) = broadcast::channel(100);
        
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let relationship_system = Arc::new(Mutex::new(RelationshipSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());

        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler.clone(),
        )));

        let blockchain = Arc::new(Mutex::new(Blockchain::new(
            identity_system.clone(),
            reputation_system.clone(),
            relationship_system.clone(),
            consensus.clone()
        )));

        let reputation_context = reputation_system.lock()
            .unwrap()
            .get_reputation_context();
            
        let vm = VM::new(1000, reputation_context);
        let vm = Arc::new(Mutex::new(vm));

        ICNCore {
            blockchain,
            identity_system,
            reputation_system,
            relationship_system,
            vm,
            event_bus: event_tx,
            start_time: Utc::now(),
        }
    }

    /// Creates a new cooperative with the given creator and metadata
    pub async fn create_cooperative(
        &self,
        creator_did: String,
        metadata: CooperativeMetadata
    ) -> Result<String, String> {
        // Validate creator's identity
        let identity = self.identity_system.lock()
            .map_err(|_| "Failed to acquire identity lock".to_string())?;
        if !identity.is_registered(&creator_did) {
            return Err("Creator DID not registered".to_string());
        }
        drop(identity);

        // Check reputation requirements
        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        if reputation.get_reputation(&creator_did) < 100 {
            return Err("Insufficient reputation to create cooperative".to_string());
        }
        let reputation_score = reputation.get_reputation(&creator_did);
        drop(reputation);

        // Create and execute contract
        let contract = Contract {
            id: uuid::Uuid::new_v4().to_string(),
            code: vec![vm::opcode::OpCode::CreateCooperative {
                name: metadata.cooperative_id.clone(),
                description: metadata.purpose.clone(),
                resources: HashMap::new(),
                federation_id: metadata.federation_id.clone(),
            }],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: metadata.clone(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let context = ExecutionContext {
            caller_did: creator_did.clone(),
            cooperative_id: contract.id.clone(),
            timestamp: Utc::now().timestamp() as u64,
            block_number: {
                let blockchain = self.blockchain.lock()
                    .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
                blockchain.current_block_number
            },
            reputation_score,
            permissions: vec!["cooperative.create".to_string()],
        };

        // Execute contract
        {
            let mut vm = self.vm.lock()
                .map_err(|_| "Failed to acquire VM lock".to_string())?;
            vm.set_execution_context(context);
            vm.execute_contract(&contract)?;
        }

        // Create and submit transaction
        let transaction = Transaction::new(
            creator_did.clone(),
            TransactionType::ContractExecution {
                contract_id: contract.id.clone(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        // Emit creation event
        let event = SystemEvent::CooperativeCreated {
            id: contract.id.clone(),
            creator: creator_did,
        };
        let _ = self.event_bus.send(event);

        Ok(contract.id)
    }

    /// Records a new contribution in the system
    pub async fn record_contribution(
        &self,
        contribution: Contribution
    ) -> Result<(), String> {
        let mut relationship_system = self.relationship_system.lock()
            .map_err(|_| "Failed to acquire relationship lock".to_string())?;
        
        relationship_system.record_contribution(contribution.clone())?;

        let event = SystemEvent::ContributionRecorded(contribution);
        let _ = self.event_bus.send(event);

        Ok(())
    }

    /// Records a mutual aid interaction between members
    pub async fn record_mutual_aid(
        &self,
        interaction: MutualAidInteraction
    ) -> Result<(), String> {
        let mut relationship_system = self.relationship_system.lock()
            .map_err(|_| "Failed to acquire relationship lock".to_string())?;
        
        relationship_system.record_mutual_aid(interaction.clone())?;

        let event = SystemEvent::MutualAidProvided(interaction);
        let _ = self.event_bus.send(event);

        Ok(())
    }

    /// Starts a new consensus round
    pub async fn start_consensus_round(&self) -> Result<(), String> {
        let blockchain = self.blockchain.lock()
            .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
        
        if let Some(round) = blockchain.get_current_round() {
            drop(blockchain);
            let event = SystemEvent::ConsensusStarted(round);
            let _ = self.event_bus.send(event);
        }

        Ok(())
    }

    /// Submits a new proposal for voting
    pub async fn submit_proposal(
        &self,
        creator_did: String,
        proposal: Proposal
    ) -> Result<u64, String> {
        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        
        if reputation.get_reputation(&creator_did) < proposal.required_reputation {
            return Err("Insufficient reputation to create proposal".to_string());
        }
        drop(reputation);

        let transaction = Transaction::new(
            creator_did,
            TransactionType::ContractExecution {
                contract_id: "governance".to_string(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        let event = SystemEvent::ProposalSubmitted(proposal.clone());
        let _ = self.event_bus.send(event);

        Ok(proposal.id)
    }

    /// Subscribes to system events
    pub fn subscribe_to_events(&self) -> broadcast::Receiver<SystemEvent> {
        self.event_bus.subscribe()
    }

    /// Gets system uptime in seconds
    pub fn get_uptime(&self) -> i64 {
        (Utc::now() - self.start_time).num_seconds()
    }

    /// Gets system statistics
    pub fn get_stats(&self) -> HashMap<String, String> {
        let mut stats = HashMap::new();
        stats.insert("uptime".to_string(), self.get_uptime().to_string());
        
        if let Ok(blockchain) = self.blockchain.lock() {
            stats.insert("block_count".to_string(), blockchain.get_block_count().to_string());
            stats.insert("tx_count".to_string(), blockchain.get_transaction_count().to_string());
        }

        stats
    }
}

/// Manager for cooperative-specific operations
pub struct CooperativeManager {
    core: Arc<ICNCore>,
}

impl CooperativeManager {
    pub fn new(core: Arc<ICNCore>) -> Self {
        CooperativeManager { core }
    }

    pub async fn create_cooperative(
        &self, 
        creator_did: String, 
        name: String,
        purpose: String
    ) -> Result<String, String> {
        let metadata = CooperativeMetadata {
            creator_did: creator_did.clone(),
            cooperative_id: uuid::Uuid::new_v4().to_string(),
            purpose,
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: Utc::now().timestamp() as u64,
            last_updated: Utc::now().timestamp() as u64,
            member_count: 1,
            resource_allocation: HashMap::new(),
            energy_usage: HashMap::new(),
        };

        self.core.create_cooperative(creator_did, metadata).await
    }

    pub async fn join_cooperative(&self, cooperative_id: String, member_did: String) -> Result<(), String> {
        let event = SystemEvent::CooperativeJoined {
            id: cooperative_id,
            member: member_did,
        };
        let _ = self.core.event_bus.send(event);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_icn_core_creation() {
        let core = ICNCore::new();
        let _receiver = core.subscribe_to_events();
        assert!(core.get_uptime() >= 0);
    }

    #[tokio::test]
    async fn test_cooperative_creation() {
        let core = Arc::new(ICNCore::new());
        let manager = CooperativeManager::new(core);
        
        let result = manager.create_cooperative(
            "did:icn:test".to_string(),
            "Test Cooperative".to_string(),
            "Test Purpose".to_string()
        ).await;
        
        assert!(result.is_err()); // Should fail because DID not registered
    }

    #[test]
    fn test_system_stats() {
        let core = ICNCore::new();
        let stats = core.get_stats();
        assert!(stats.contains_key("uptime"));
        assert!(stats.contains_key("block_count"));
        assert!(stats.contains_key("tx_count"));
    }
}

===================
File: ./backend/src/consensus/tests.rs
===================
# File: ./backend/src/consensus/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::blockchain::Blockchain;
    use crate::identity::IdentitySystem;
    use crate::reputation::ReputationSystem;

    fn setup_test_blockchain() -> Blockchain {
        let identity_system = IdentitySystem::new();
        let reputation_system = ReputationSystem::new();
        let mut blockchain = Blockchain::new(identity_system, reputation_system);
        
        // Register test validators
        blockchain.consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:3".to_string(), 100).unwrap();
        
        blockchain
    }

    #[test]
    fn test_consensus_integration() {
        let mut blockchain = setup_test_blockchain();
        
        // Add some test transactions
        let transaction = Transaction::new(
            "did:icn:1".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:2".to_string(),
                amount: 100,
            },
        );
        blockchain.add_transaction(transaction);

        // Try to finalize block through consensus
        assert!(blockchain.finalize_block().is_ok());
        
        // Verify block was added
        assert_eq!(blockchain.chain.len(), 2);
        
        // Verify reputation updates were applied
        let reputation_updates = blockchain.consensus.get_reputation_updates();
        assert!(!reputation_updates.is_empty());
    }

    #[test]
    fn test_consensus_failure_recovery() {
        let mut blockchain = setup_test_blockchain();
        
        // Simulate a failed consensus round
        blockchain.consensus.start_round().unwrap();
        blockchain.consensus.check_timeout();
        
        // Verify we can start a new round after failure
        assert!(blockchain.finalize_block().is_ok());
    }
}

===================
File: ./backend/src/consensus/types.rs
===================
// src/consensus/types.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::blockchain::Block;

/// Events emitted during consensus process
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ConsensusEvent {
    /// Round started event
    RoundStarted {
        round: u64,
        coordinator: String,
        timeout: u64,
    },
    
    /// Block proposed event
    BlockProposed {
        round: u64,
        proposer: String,
        block_hash: String,
        transactions: usize,
    },
    
    /// Vote received event
    VoteReceived {
        round: u64,
        validator: String,
        approve: bool,
        voting_power: f64,
    },
    
    /// Round completed event
    RoundCompleted {
        round: u64,
        block_hash: String,
        validators: Vec<String>,
        duration_ms: u64,
    },
    
    /// Round failed event
    RoundFailed {
        round: u64,
        reason: String,
    },
    
    /// Validator status update
    ValidatorUpdate {
        did: String,
        reputation: i64,
        voting_power: f64,
        performance_score: f64,
    },
}

/// Information about a validator in the network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatorInfo {
    /// Decentralized Identifier of the validator
    pub did: String,
    
    /// Current reputation score
    pub reputation: i64,
    
    /// Calculated voting power (0.0 to 1.0)
    pub voting_power: f64,
    
    /// Last consensus round the validator participated in
    pub last_active_round: u64,
    
    /// Number of consecutive rounds missed
    pub consecutive_missed_rounds: u32,
    
    /// Total number of blocks validated
    pub total_blocks_validated: u64,
    
    /// Performance score based on historical participation (0.0 to 1.0)
    pub performance_score: f64,
}

/// Statistics for a consensus round
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRoundStats {
    /// Total available voting power in the round
    pub total_voting_power: f64,
    
    /// Percentage of validators who participated
    pub participation_rate: f64,
    
    /// Percentage of voting power that approved the block
    pub approval_rate: f64,
    
    /// Duration of the round in milliseconds
    pub round_duration_ms: u64,
    
    /// Number of validators eligible to participate
    pub validator_count: usize,
}

/// A vote cast by a validator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeightedVote {
    /// DID of the validator casting the vote
    pub validator: String,
    
    /// Whether the validator approves the block
    pub approve: bool,
    
    /// Voting power of the validator
    pub voting_power: f64,
    
    /// When the vote was cast
    pub timestamp: DateTime<Utc>,
    
    /// Cryptographic signature of the vote
    pub signature: String,
}

/// State of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    /// Sequential number of this round
    pub round_number: u64,
    
    /// DID of the coordinator for this round
    pub coordinator: String,
    
    /// When the round started
    pub start_time: DateTime<Utc>,
    
    /// When the round will timeout
    pub timeout: DateTime<Utc>,
    
    /// Current status of the round
    pub status: RoundStatus,
    
    /// The block being proposed (if any)
    pub proposed_block: Option<Block>,
    
    /// Votes received, keyed by validator DID
    pub votes: HashMap<String, WeightedVote>,
    
    /// Statistics for the round
    pub stats: ConsensusRoundStats,
}

/// Status of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    /// Waiting for block proposal
    Proposing,
    
    /// Collecting votes from validators
    Voting,
    
    /// Preparing to commit the block
    Finalizing,
    
    /// Round successfully completed
    Completed,
    
    /// Round failed to reach consensus
    Failed,
}

/// Configuration parameters for the consensus mechanism
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusConfig {
    /// Minimum reputation required to be a validator
    pub min_validator_reputation: i64,
    
    /// Maximum voting power any validator can have
    pub max_voting_power: f64,
    
    /// Minimum participation required for valid consensus
    pub min_participation_rate: f64,
    
    /// Minimum approval required for valid consensus
    pub min_approval_rate: f64,
    
    /// How long before a round times out (milliseconds)
    pub round_timeout_ms: u64,
    
    /// Base reputation reward for participation
    pub base_reward: i64,
    
    /// Multiplier for consecutive missed rounds
    pub penalty_factor: f64,
    
    /// Minimum number of validators needed
    pub min_validators: usize,
    
    /// Maximum consecutive missed rounds before ejection
    pub max_missed_rounds: u32,
    
    /// Minimum performance score to remain eligible 
    pub min_performance_score: f64,
}

impl Default for ConsensusConfig {
    fn default() -> Self {
        ConsensusConfig {
            min_validator_reputation: 100,
            max_voting_power: 0.1,
            min_participation_rate: 0.67,  // 2/3 participation required
            min_approval_rate: 0.67,       // 2/3 approval required
            round_timeout_ms: 30_000,      // 30 second timeout
            base_reward: 10,
            penalty_factor: 1.5,
            min_validators: 3,
            max_missed_rounds: 5,
            min_performance_score: 0.5,
        }
    }
}

/// Possible consensus-related errors
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusError {
    /// Not enough validators available
    InsufficientValidators,
    
    /// Invalid coordinator for this round
    InvalidCoordinator,
    
    /// Round already in progress
    RoundInProgress,
    
    /// No active round found
    NoActiveRound,
    
    /// Invalid state for operation
    InvalidRoundState,
    
    /// Round timed out
    TimedOut,
    
    /// Block validation failed
    ValidationFailed,
    
    /// Not a registered validator
    NotValidator,
    
    /// Insufficient reputation
    InsufficientReputation,
    
    /// Custom error message
    Custom(String),
}

impl std::fmt::Display for ConsensusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConsensusError::InsufficientValidators => 
                write!(f, "Insufficient number of active validators"),
            ConsensusError::InvalidCoordinator => 
                write!(f, "Invalid coordinator for this round"),
            ConsensusError::RoundInProgress => 
                write!(f, "Consensus round already in progress"),
            ConsensusError::NoActiveRound => 
                write!(f, "No active consensus round"),
            ConsensusError::InvalidRoundState => 
                write!(f, "Invalid round state for requested operation"),
            ConsensusError::TimedOut => 
                write!(f, "Consensus round timed out"),
            ConsensusError::ValidationFailed => 
                write!(f, "Block validation failed"),
            ConsensusError::NotValidator => 
                write!(f, "Not a registered validator"),
            ConsensusError::InsufficientReputation => 
                write!(f, "Insufficient reputation for operation"),
            ConsensusError::Custom(msg) => 
                write!(f, "{}", msg),
        }
    }
}

impl std::error::Error for ConsensusError {}

impl From<ConsensusError> for String {
    fn from(error: ConsensusError) -> String {
        error.to_string()
    }
}

/// Utility functions for consensus calculations
pub mod utils {
    /// Calculate voting power based on reputation
    pub fn calculate_voting_power(reputation: i64, total_reputation: i64, max_power: f64) -> f64 {
        let raw_power = reputation as f64 / total_reputation as f64;
        raw_power.min(max_power)
    }

    /// Calculate penalty for missed rounds
    pub fn calculate_penalty(base_penalty: i64, consecutive_misses: u32, factor: f64) -> i64 {
        -(base_penalty as f64 * factor * consecutive_misses as f64) as i64
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_voting_power_calculation() {
        let power = utils::calculate_voting_power(500, 1000, 0.1);
        assert!(power <= 0.1);
        assert!(power > 0.0);
        assert_eq!(power, 0.1); // Should be capped at max_power
        
        let power = utils::calculate_voting_power(100, 1000, 0.1);
        assert_eq!(power, 0.1);
    }

    #[test]
    fn test_penalty_calculation() {
        let penalty = utils::calculate_penalty(10, 3, 1.5);
        assert_eq!(penalty, -45); // -10 * 1.5 * 3

        let penalty1 = utils::calculate_penalty(10, 1, 1.5);
        let penalty2 = utils::calculate_penalty(10, 2, 1.5);
        assert!(penalty2 < penalty1); 
    }

    #[test]
    fn test_consensus_config_default() {
        let config = ConsensusConfig::default();
        assert_eq!(config.min_validator_reputation, 100);
        assert_eq!(config.max_voting_power, 0.1);
        assert_eq!(config.min_participation_rate, 0.67);
        assert_eq!(config.min_approval_rate, 0.67);
        assert_eq!(config.round_timeout_ms, 30_000);
    }
}

===================
File: ./backend/src/consensus/mod.rs
===================
// src/consensus/mod.rs

pub mod proof_of_cooperation;
pub mod types;

// Re-export key types and modules
pub use types::{
    ConsensusConfig,
    ConsensusRound,
    ConsensusError,
    ValidatorInfo,
    WeightedVote,
    RoundStatus,
};

pub use proof_of_cooperation::core::ProofOfCooperation;

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio;
    use crate::websocket::WebSocketHandler;

    #[tokio::test]
    async fn test_consensus_integration() {
        let ws_handler = Arc::new(WebSocketHandler::new());
        let config = ConsensusConfig::default();
        
        let mut consensus = ProofOfCooperation::new(config, ws_handler);
        
        // Register test validators
        consensus.register_validator("did:icn:test1".to_string(), 1000).unwrap();
        consensus.register_validator("did:icn:test2".to_string(), 1000).unwrap();
        consensus.register_validator("did:icn:test3".to_string(), 1000).unwrap();
        
        assert!(consensus.start_round().await.is_ok());
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation/events.rs
===================
// src/consensus/proof_of_cooperation/events.rs

use serde::{Serialize, Deserialize};

/// Events emitted during consensus process
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ConsensusEvent {
    /// Round started event
    RoundStarted {
        round: u64,
        coordinator: String,
        timeout: u64,
    },
    
    /// Block proposed event
    BlockProposed {
        round: u64,
        proposer: String,
        block_hash: String,
        transactions: usize,
    },
    
    /// Vote received event
    VoteReceived {
        round: u64,
        validator: String,
        approve: bool,
        voting_power: f64,
    },
    
    /// Round completed event
    RoundCompleted {
        round: u64,
        block_hash: String,
        validators: Vec<String>,
        duration_ms: u64,
    },
    
    /// Round failed event
    RoundFailed {
        round: u64,
        reason: String,
    },
    
    /// Validator status update
    ValidatorUpdate {
        did: String,
        reputation: i64,
        voting_power: f64,
        performance_score: f64,
    },
}

===================
File: ./backend/src/consensus/proof_of_cooperation/metrics.rs
===================
// src/consensus/proof_of_cooperation/metrics.rs

use crate::monitoring::energy::{EnergyAware, EnergyMonitor};
use crate::consensus::types::ValidatorInfo;
use super::core::ProofOfCooperation;

impl EnergyAware for ProofOfCooperation {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record voting operations
        if let Some(round) = self.round_manager.get_current_round() {
            let vote_count = round.votes.len();
            monitor.record_consensus_operation();
            monitor.record_network_operation((vote_count * 256) as u64); // Estimate network usage
        }
        
        // Record validator state size
        let validator_size = (self.validator_manager.get_validators().len() * std::mem::size_of::<ValidatorInfo>()) as u64;
        monitor.record_memory_operation(validator_size);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::monitoring::energy::NodeEnergyConfig;
    use crate::websocket::WebSocketHandler;
    use crate::consensus::types::ConsensusConfig;
    use std::sync::Arc;

    #[test]
    fn test_energy_metrics() {
        let ws_handler = Arc::new(WebSocketHandler::new());
        let config = ConsensusConfig::default();
        let consensus = ProofOfCooperation::new(config, ws_handler);
        let monitor = EnergyMonitor::new(NodeEnergyConfig::default());
        
        consensus.record_energy_metrics(&monitor);
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation/validator.rs
===================
// src/consensus/proof_of_cooperation/validator.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use rand::{thread_rng, Rng};
use crate::consensus::types::{ValidatorInfo, ConsensusConfig, ConsensusError};

pub struct ValidatorManager {
    validators: HashMap<String, ValidatorInfo>,
    config: ConsensusConfig,
    total_voting_power: f64,
    last_cleanup: DateTime<Utc>,
}

impl ValidatorManager {
    pub fn new(config: ConsensusConfig) -> Self {
        ValidatorManager {
            validators: HashMap::new(),
            config,
            total_voting_power: 0.0,
            last_cleanup: Utc::now(),
        }
    }

    pub fn register_validator(&mut self, did: String, initial_reputation: i64) -> Result<(), ConsensusError> {
        let validator = ValidatorInfo {
            did: did.clone(),
            reputation: initial_reputation,
            voting_power: self.calculate_voting_power(initial_reputation),
            last_active_round: 0,
            consecutive_missed_rounds: 0,
            total_blocks_validated: 0,
            performance_score: 1.0,
        };

        self.validators.insert(did, validator);
        self.update_total_voting_power();
        Ok(())
    }

    pub fn get_validator(&self, did: &str) -> Option<&ValidatorInfo> {
        self.validators.get(did)
    }

    pub fn get_validators(&self) -> &HashMap<String, ValidatorInfo> {
        &self.validators
    }

    pub fn select_coordinator<'a>(&self, active_validators: &'a [&ValidatorInfo]) 
        -> Result<&'a ValidatorInfo, ConsensusError> 
    {
        let mut rng = thread_rng();

        let weights: Vec<f64> = active_validators.iter()
            .map(|v| (v.reputation as f64) * v.performance_score)
            .collect();

        let total_weight: f64 = weights.iter().sum();
        if total_weight <= 0.0 {
            return Err(ConsensusError::Custom("No valid validators".to_string()));
        }

        let selection_point = rng.gen_range(0.0..total_weight);
        let mut cumulative_weight = 0.0;

        for (i, weight) in weights.iter().enumerate() {
            cumulative_weight += weight;
            if cumulative_weight >= selection_point {
                return Ok(active_validators[i]);
            }
        }

        Err(ConsensusError::Custom("Failed to select coordinator".to_string()))
    }

    pub fn update_validator_stats(
        &mut self,
        round_number: u64,
        votes: &HashMap<String, bool>,
        coordinator: &str
    ) {
        for (validator_id, validator) in self.validators.iter_mut() {
            if let Some(&approved) = votes.get(validator_id) {
                // Reset consecutive misses
                validator.consecutive_missed_rounds = 0;
                validator.last_active_round = round_number;
                validator.total_blocks_validated += 1;

                // Calculate reward
                let base_reward = if validator_id == coordinator {
                    self.config.base_reward * 2 // Double reward for coordinator
                } else {
                    self.config.base_reward
                };

                let performance_multiplier = if approved {
                    1.0 + (validator.performance_score * 0.5)
                } else {
                    1.0
                };

                let reward = (base_reward as f64 * performance_multiplier) as i64;
                validator.reputation += reward;

                // Update performance score
                validator.performance_score = validator.performance_score * 0.95 + 0.05;
            } else {
                // Penalize non-participation
                validator.consecutive_missed_rounds += 1;
                
                let penalty = -(self.config.base_reward as f64 *
                    self.config.penalty_factor *
                    validator.consecutive_missed_rounds as f64) as i64;
                
                validator.reputation += penalty;
                validator.performance_score = validator.performance_score * 0.95;
            }
        }

        self.update_total_voting_power();
    }

    pub fn cleanup_inactive_validators(&mut self) {
        let now = Utc::now();
        if (now - self.last_cleanup).num_hours() >= 24 {
            self.validators.retain(|_, v| {
                v.consecutive_missed_rounds < self.config.max_missed_rounds &&
                v.performance_score >= self.config.min_performance_score
            });
            self.last_cleanup = now;
            self.update_total_voting_power();
        }
    }

    fn calculate_voting_power(&self, reputation: i64) -> f64 {
        let base_power = (reputation as f64) / 1000.0;
        base_power.min(self.config.max_voting_power)
    }

    fn update_total_voting_power(&mut self) {
        self.total_voting_power = self.validators.values()
            .map(|v| v.voting_power)
            .sum();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_manager() -> ValidatorManager {
        ValidatorManager::new(ConsensusConfig::default())
    }

    #[test]
    fn test_register_validator() {
        let mut manager = setup_test_manager();
        assert!(manager.register_validator(
            "did:icn:test".to_string(),
            1000
        ).is_ok());
        
        let validator = manager.get_validator("did:icn:test").unwrap();
        assert_eq!(validator.reputation, 1000);
    }

    #[test]
    fn test_validator_selection() {
        let mut manager = setup_test_manager();
        
        // Add some test validators
        for i in 1..=3 {
            manager.register_validator(
                format!("did:icn:test{}", i),
                1000
            ).unwrap();
        }

        let active_validators: Vec<_> = manager.validators.values().collect();
        let coordinator = manager.select_coordinator(&active_validators);
        assert!(coordinator.is_ok());
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation/core.rs
===================
// src/consensus/proof_of_cooperation/core.rs

use std::sync::Arc;
use tokio::sync::broadcast;
use crate::websocket::WebSocketHandler;
use crate::blockchain::Block;
use crate::consensus::types::{ConsensusConfig, ConsensusError, ConsensusRound};
use super::{
    validator::ValidatorManager,
    round::RoundManager,
    events::ConsensusEvent,
};

pub struct ProofOfCooperation {
    // Make these public to fix the access error
    pub validator_manager: ValidatorManager,
    pub round_manager: RoundManager,
    
    config: ConsensusConfig,
    reputation_updates: Vec<(String, i64)>,
    ws_handler: Arc<WebSocketHandler>,
    event_tx: broadcast::Sender<ConsensusEvent>,
}

impl ProofOfCooperation {
    pub fn new(config: ConsensusConfig, ws_handler: Arc<WebSocketHandler>) -> Self {
        let (event_tx, _) = broadcast::channel(100);
        
        ProofOfCooperation {
            validator_manager: ValidatorManager::new(config.clone()),
            round_manager: RoundManager::new(config.clone()),
            config,
            reputation_updates: Vec::new(),
            ws_handler,
            event_tx,
        }
    }

    pub async fn start_round(&mut self) -> Result<(), ConsensusError> {
        // Clean up inactive validators periodically
        self.validator_manager.cleanup_inactive_validators();

        // Get active validators meeting reputation threshold
        let active_validators: Vec<_> = self.validator_manager.get_validators().values()
            .filter(|v| v.reputation >= self.config.min_validator_reputation &&
                      v.performance_score >= self.config.min_performance_score)
            .collect();

        if active_validators.len() < self.config.min_validators {
            return Err(ConsensusError::InsufficientValidators);
        }

        // Select coordinator
        let coordinator = self.validator_manager.select_coordinator(&active_validators)?;

        // Calculate total voting power
        let total_voting_power: f64 = active_validators.iter()
            .map(|v| v.voting_power)
            .sum();

        // Start new round
        let event = self.round_manager.start_round(
            self.get_next_round_number(),
            coordinator.did.clone(),
            total_voting_power,
            active_validators.len(),
        )?;

        // Broadcast updates
        if let Some(round) = self.round_manager.get_current_round() {
            self.ws_handler.broadcast_consensus_update(round);
        }
        let _ = self.event_tx.send(event);

        Ok(())
    }

    pub async fn propose_block(&mut self, proposer_did: &str, block: Block) -> Result<(), ConsensusError> {
        // Validate proposer
        let validator = self.validator_manager.get_validator(proposer_did)
            .ok_or(ConsensusError::NotValidator)?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err(ConsensusError::InsufficientReputation);
        }

        // Process proposal
        let event = self.round_manager.propose_block(proposer_did, block.clone())?;

        // Broadcast updates
        self.ws_handler.broadcast_block_finalized(&block);
        let _ = self.event_tx.send(event);

        Ok(())
    }

    pub async fn submit_vote(
        &mut self,
        validator_did: &str,
        approve: bool,
        signature: String,
    ) -> Result<(), ConsensusError> {
        // Validate validator
        let validator = self.validator_manager.get_validator(validator_did)
            .ok_or(ConsensusError::NotValidator)?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err(ConsensusError::InsufficientReputation);
        }

        // Submit vote
        let event = self.round_manager.submit_vote(
            validator_did.to_string(),
            approve,
            validator.voting_power,
            signature,
        )?;

        // Broadcast updates
        if let Some(round) = self.round_manager.get_current_round() {
            self.ws_handler.broadcast_consensus_update(round);
        }
        let _ = self.event_tx.send(event);

        Ok(())
    }

    pub async fn finalize_round(&mut self) -> Result<Block, ConsensusError> {
        // Finalize the round
        let (block, stats) = self.round_manager.finalize_round()?;

        // Update validator statistics
        let round = self.round_manager.get_current_round()
            .ok_or(ConsensusError::NoActiveRound)?;

        self.validator_manager.update_validator_stats(
            round.round_number,
            &round.votes.iter().map(|(k, v)| (k.clone(), v.approve)).collect(),
            &round.coordinator,
        );

        // Create round completed event
        let event = ConsensusEvent::RoundCompleted {
            round: round.round_number,
            block_hash: block.hash.clone(),
            validators: round.votes.keys().cloned().collect(),
            duration_ms: stats.round_duration_ms,
        };

        // Broadcast completion
        self.ws_handler.broadcast_block_finalized(&block);
        let _ = self.event_tx.send(event);

        Ok(block)
    }

    pub fn register_validator(&mut self, did: String, initial_reputation: i64) -> Result<(), ConsensusError> {
        self.validator_manager.register_validator(did, initial_reputation)
    }

    pub fn get_current_round(&self) -> Option<&ConsensusRound> {
        self.round_manager.get_current_round()
    }

    pub fn get_reputation_updates(&self) -> &[(String, i64)] {
        &self.reputation_updates
    }

    pub fn subscribe_to_events(&self) -> broadcast::Receiver<ConsensusEvent> {
        self.event_tx.subscribe()
    }

    fn get_next_round_number(&self) -> u64 {
        self.round_manager.get_round_history().len() as u64 + 1
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_test_consensus() -> ProofOfCooperation {
        let ws_handler = Arc::new(WebSocketHandler::new());
        let config = ConsensusConfig::default();
        ProofOfCooperation::new(config, ws_handler)
    }

    #[tokio::test]
    async fn test_start_round() {
        let mut consensus = setup_test_consensus().await;
        
        // Add test validators
        consensus.register_validator("did:icn:test1".to_string(), 1000).unwrap();
        consensus.register_validator("did:icn:test2".to_string(), 1000).unwrap();
        consensus.register_validator("did:icn:test3".to_string(), 1000).unwrap();
        
        assert!(consensus.start_round().await.is_ok());
        assert!(consensus.get_current_round().is_some());
    }

    #[tokio::test]
    async fn test_full_consensus_cycle() {
        let mut consensus = setup_test_consensus().await;
        
        // Set up validators
        for i in 1..=3 {
            consensus.register_validator(format!("did:icn:test{}", i), 1000).unwrap();
        }
        
        // Start round
        consensus.start_round().await.unwrap();
        let coordinator_did = consensus.get_current_round().unwrap().coordinator.clone();
        
        // Propose block
        let block = Block::new(1, "prev_hash".to_string(), vec![], coordinator_did.clone());
        consensus.propose_block(&coordinator_did, block).await.unwrap();
        
        // Submit votes
        for i in 1..=3 {
            consensus.submit_vote(
                &format!("did:icn:test{}", i),
                true,
                "signature".to_string()
            ).await.unwrap();
        }
        
        // Finalize
        let result = consensus.finalize_round().await;
        assert!(result.is_ok());
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation/mod.rs
===================
// src/consensus/proof_of_cooperation/mod.rs

pub mod core;
pub mod events;
pub mod metrics;
pub mod round;
pub mod validator;

// Re-export key components
pub use core::ProofOfCooperation;
pub use events::ConsensusEvent;
pub use validator::ValidatorManager;
pub use round::RoundManager;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::consensus::types::ConsensusConfig;
    use crate::websocket::WebSocketHandler;
    use std::sync::Arc;

    async fn setup_test_consensus() -> ProofOfCooperation {
        let ws_handler = Arc::new(WebSocketHandler::new());
        let config = ConsensusConfig::default();
        ProofOfCooperation::new(config, ws_handler)
    }

    #[tokio::test]
    async fn test_consensus_initialization() {
        let consensus = setup_test_consensus().await;
        assert!(consensus.get_current_round().is_none());
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation/round.rs
===================
// src/consensus/proof_of_cooperation/round.rs

use std::collections::HashMap;
use chrono::{Utc, Duration};
use crate::blockchain::Block;
use crate::consensus::types::{
    ConsensusRound,
    ConsensusError,
    RoundStatus,
    WeightedVote,
    ConsensusConfig,
    ConsensusRoundStats
};
use super::events::ConsensusEvent;

pub struct RoundManager {
    config: ConsensusConfig,
    current_round: Option<ConsensusRound>,
    round_history: Vec<ConsensusRoundStats>,
    total_voting_power: f64,
}

impl RoundManager {
    pub fn new(config: ConsensusConfig) -> Self {
        RoundManager {
            config,
            current_round: None,
            round_history: Vec::new(),
            total_voting_power: 0.0,
        }
    }

    pub fn start_round(
        &mut self,
        round_number: u64,
        coordinator: String,
        total_voting_power: f64,
        validator_count: usize,
    ) -> Result<ConsensusEvent, ConsensusError> {
        if self.current_round.is_some() {
            return Err(ConsensusError::RoundInProgress);
        }

        self.total_voting_power = total_voting_power;

        let round = ConsensusRound {
            round_number,
            coordinator: coordinator.clone(),
            start_time: Utc::now(),
            timeout: Utc::now() + Duration::milliseconds(self.config.round_timeout_ms as i64),
            status: RoundStatus::Proposing,
            proposed_block: None,
            votes: HashMap::new(),
            stats: ConsensusRoundStats {
                total_voting_power,
                participation_rate: 0.0,
                approval_rate: 0.0,
                round_duration_ms: 0,
                validator_count,
            },
        };

        self.current_round = Some(round);

        Ok(ConsensusEvent::RoundStarted { 
            round: round_number,
            coordinator,
            timeout: self.config.round_timeout_ms,
        })
    }

    pub fn propose_block(
        &mut self,
        proposer: &str,
        block: Block,
    ) -> Result<ConsensusEvent, ConsensusError> {
        let round = self.current_round.as_mut()
            .ok_or(ConsensusError::NoActiveRound)?;

        if round.coordinator != proposer {
            return Err(ConsensusError::InvalidCoordinator);
        }

        if round.status != RoundStatus::Proposing {
            return Err(ConsensusError::InvalidRoundState);
        }

        let event = ConsensusEvent::BlockProposed {
            round: round.round_number,
            proposer: proposer.to_string(),
            block_hash: block.hash.clone(),
            transactions: block.transactions.len(),
        };

        round.proposed_block = Some(block);
        round.status = RoundStatus::Voting;

        Ok(event)
    }

    pub fn submit_vote(
        &mut self,
        validator: String,
        approve: bool,
        voting_power: f64,
        signature: String,
    ) -> Result<ConsensusEvent, ConsensusError> {
        // First get all the data we need from the current state
        let round_number;
        let current_votes_power: f64;
        let current_approval_power: f64;
        {
            let round = self.current_round.as_ref()
                .ok_or(ConsensusError::NoActiveRound)?;

            if round.status != RoundStatus::Voting {
                return Err(ConsensusError::InvalidRoundState);
            }

            if round.votes.contains_key(&validator) {
                return Err(ConsensusError::Custom("Already voted".to_string()));
            }

            round_number = round.round_number;
            current_votes_power = round.votes.values()
                .map(|v| v.voting_power)
                .sum();
            current_approval_power = round.votes.values()
                .filter(|v| v.approve)
                .map(|v| v.voting_power)
                .sum();
        }

        // Create the new vote
        let vote = WeightedVote {
            validator: validator.clone(),
            approve,
            voting_power,
            timestamp: Utc::now(),
            signature,
        };

        // Calculate new stats
        let new_total_power = current_votes_power + voting_power;
        let new_approval_power = if approve {
            current_approval_power + voting_power
        } else {
            current_approval_power
        };

        let participation_rate = new_total_power / self.total_voting_power;
        let approval_rate = if new_total_power > 0.0 {
            new_approval_power / new_total_power
        } else {
            0.0
        };

        // Now update the round with all our calculations
        let round = self.current_round.as_mut()
            .ok_or(ConsensusError::NoActiveRound)?;

        round.votes.insert(validator.clone(), vote);
        round.stats.participation_rate = participation_rate;
        round.stats.approval_rate = approval_rate;

        // Check if consensus is reached
        if participation_rate >= self.config.min_participation_rate && 
           approval_rate >= self.config.min_approval_rate {
            round.status = RoundStatus::Finalizing;
        }

        Ok(ConsensusEvent::VoteReceived {
            round: round_number,
            validator,
            approve,
            voting_power,
        })
    }

    pub fn finalize_round(&mut self) -> Result<(Block, ConsensusRoundStats), ConsensusError> {
        let round = self.current_round.take()
            .ok_or(ConsensusError::NoActiveRound)?;

        if round.status != RoundStatus::Finalizing {
            self.current_round = Some(round);
            return Err(ConsensusError::InvalidRoundState);
        }

        let block = round.proposed_block.clone()
            .ok_or_else(|| ConsensusError::Custom("No proposed block".to_string()))?;

        let mut stats = round.stats;
        stats.round_duration_ms = Utc::now()
            .signed_duration_since(round.start_time)
            .num_milliseconds() as u64;

        self.round_history.push(stats.clone());

        Ok((block, stats))
    }

    pub fn check_timeout(&mut self) -> bool {
        if let Some(round) = &mut self.current_round {
            if Utc::now() > round.timeout {
                round.status = RoundStatus::Failed;
                return true;
            }
        }
        false
    }

    pub fn get_current_round(&self) -> Option<&ConsensusRound> {
        self.current_round.as_ref()
    }

    pub fn get_round_history(&self) -> &[ConsensusRoundStats] {
        &self.round_history
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_round_manager() -> RoundManager {
        RoundManager::new(ConsensusConfig::default())
    }

    #[test]
    fn test_start_round() {
        let mut manager = setup_test_round_manager();
        let result = manager.start_round(1, "did:icn:test".to_string(), 1.0, 3);
        assert!(result.is_ok());
        assert!(manager.get_current_round().is_some());
    }

    #[test]
    fn test_propose_block() {
        let mut manager = setup_test_round_manager();
        manager.start_round(1, "did:icn:test".to_string(), 1.0, 3).unwrap();
        
        let block = Block::new(1, "prev_hash".to_string(), vec![], "did:icn:test".to_string());
        let result = manager.propose_block("did:icn:test", block);
        assert!(result.is_ok());
    }

    #[test]
    fn test_vote_flow() {
        let mut manager = setup_test_round_manager();
        
        // Setup round
        manager.start_round(1, "did:icn:test".to_string(), 1.0, 3).unwrap();
        let block = Block::new(1, "prev_hash".to_string(), vec![], "did:icn:test".to_string());
        manager.propose_block("did:icn:test", block).unwrap();
        
        // Submit enough votes for consensus
        let vote_result = manager.submit_vote(
            "validator1".to_string(),
            true,
            0.7,
            "signature1".to_string()
        );
        
        assert!(vote_result.is_ok());
        assert_eq!(
            manager.get_current_round().unwrap().status,
            RoundStatus::Finalizing
        );
    }

    #[test]
    fn test_duplicate_vote() {
        let mut manager = setup_test_round_manager();
        manager.start_round(1, "did:icn:test".to_string(), 1.0, 3).unwrap();
        
        let block = Block::new(1, "prev_hash".to_string(), vec![], "did:icn:test".to_string());
        manager.propose_block("did:icn:test", block).unwrap();
        
        // First vote should succeed
        assert!(manager.submit_vote(
            "validator1".to_string(),
            true,
            0.3,
            "signature1".to_string()
        ).is_ok());
        
        // Second vote from same validator should fail
        assert!(matches!(
            manager.submit_vote(
                "validator1".to_string(),
                true,
                0.3,
                "signature2".to_string()
            ),
            Err(ConsensusError::Custom(_))
        ));
    }

    #[test]
    fn test_timeout() {
        let mut manager = setup_test_round_manager();
        manager.start_round(1, "did:icn:test".to_string(), 1.0, 3).unwrap();
        
        // Modify timeout to be in the past
        if let Some(round) = &mut manager.current_round {
            round.timeout = Utc::now() - Duration::seconds(1);
        }
        
        assert!(manager.check_timeout());
        assert_eq!(
            manager.get_current_round().unwrap().status,
            RoundStatus::Failed
        );
    }

    #[test]
    fn test_finalize_round() {
        let mut manager = setup_test_round_manager();
        
        // Setup and get to finalization state
        manager.start_round(1, "did:icn:test".to_string(), 1.0, 3).unwrap();
        let block = Block::new(1, "prev_hash".to_string(), vec![], "did:icn:test".to_string());
        manager.propose_block("did:icn:test", block).unwrap();
        
        // Submit vote with enough power for consensus
        manager.submit_vote(
            "validator1".to_string(),
            true,
            0.7,
            "signature1".to_string()
        ).unwrap();
        
        // Finalize
        let result = manager.finalize_round();
        assert!(result.is_ok());
        assert!(manager.get_current_round().is_none());
        assert_eq!(manager.get_round_history().len(), 1);
    }
}

===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
===================
import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { AlertCircle, Users, Activity, BarChart3 } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

const CooperativeDashboard = () => {
  const [metrics, setMetrics] = useState({
    totalMembers: 0,
    activeProposals: 0,
    resourceUtilization: 0,
    monthlyActivity: []
  });
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockData = {
      totalMembers: 156,
      activeProposals: 3,
      resourceUtilization: 78,
      monthlyActivity: [
        { month: 'Jan', activity: 65 },
        { month: 'Feb', activity: 75 },
        { month: 'Mar', activity: 85 },
        { month: 'Apr', activity: 90 }
      ]
    };

    setMetrics(mockData);
    setLoading(false);
  }, []);

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Members</p>
                <h3 className="text-2xl font-bold">{metrics.totalMembers}</h3>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{metrics.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Resource Utilization</p>
                <h3 className="text-2xl font-bold">{metrics.resourceUtilization}%</h3>
              </div>
              <Activity className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Monthly Growth</p>
                <h3 className="text-2xl font-bold">+12%</h3>
              </div>
              <BarChart3 className="h-8 w-8 text-orange-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Cooperative Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={metrics.monthlyActivity}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="activity" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Resource Allocation</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Computing Resources</span>
                <span>75%</span>
              </div>
              <Progress value={75} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Storage Resources</span>
                <span>60%</span>
              </div>
              <Progress value={60} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Network Resources</span>
                <span>85%</span>
              </div>
              <Progress value={85} className="h-2" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default CooperativeDashboard;

===================
File: ./frontend/src/components/relationship/RelationshipIntegration.tsx
===================
import React, { useEffect, useState } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { HandHeart, MessageCircle, Users } from 'lucide-react';

// Types for our relationship data
interface Contribution {
  contributorDid: string;
  description: string;
  impactStory: string;
  date: string;
  context: string;
  witnesses: string[];
  feedback: Array<{
    fromDid: string;
    content: string;
    date: string;
    endorsementType: 'Verification' | 'Impact' | 'Character' | 'Skill';
  }>;
  tags: string[];
}

interface MutualAidInteraction {
  date: string;
  providerDid: string;
  receiverDid: string;
  description: string;
  impactStory?: string;
  reciprocityNotes?: string;
  tags: string[];
}

interface Relationship {
  memberOne: string;
  memberTwo: string;
  relationshipType: string;
  started: string;
  story: string;
  interactions: Array<{
    date: string;
    description: string;
    impact?: string;
    interactionType: string;
  }>;
  mutualEndorsements: Array<{
    fromDid: string;
    content: string;
    date: string;
    context: string;
    skills: string[];
  }>;
}

export default function RelationshipIntegration() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [contributions, setContributions] = useState<Contribution[]>([]);
  const [relationships, setRelationships] = useState<Relationship[]>([]);
  const [mutualAid, setMutualAid] = useState<MutualAidInteraction[]>([]);
  const [activeTab, setActiveTab] = useState('overview');

  useEffect(() => {
    // Load initial data
    const loadData = async () => {
      try {
        setLoading(true);
        
        // Example of data fetching - replace with actual API endpoints
        const response = await fetch('/api/relationships/current-user');
        const data = await response.json();
        
        setContributions(data.contributions);
        setRelationships(data.relationships);
        setMutualAid(data.mutualAid);
        
        // Set up WebSocket connection for real-time updates
        const ws = new WebSocket('ws://localhost:8088/ws');
        
        ws.onmessage = (event) => {
          const update = JSON.parse(event.data);
          switch (update.type) {
            case 'contribution':
              setContributions(prev => [...prev, update.data]);
              break;
            case 'mutualAid':
              setMutualAid(prev => [...prev, update.data]);
              break;
            case 'relationship':
              setRelationships(prev => 
                prev.map(r => 
                  r.memberOne === update.data.memberOne ? update.data : r
                )
              );
              break;
          }
        };

        return () => ws.close();

      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load relationships');
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, []);

  if (loading) {
    return <div className="p-4">Loading relationships...</div>;
  }

  if (error) {
    return (
      <Alert>
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="container mx-auto p-4 space-y-8">
      <Alert>
        <AlertDescription>
          Build stronger cooperative bonds through mutual aid, contributions, and shared stories.
        </AlertDescription>
      </Alert>

      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="overview">
            <Users className="h-4 w-4 mr-2" />
            Overview
          </TabsTrigger>
          <TabsTrigger value="mutual-aid">
            <HandHeart className="h-4 w-4 mr-2" />
            Mutual Aid
          </TabsTrigger>
          <TabsTrigger value="relationships">
            <MessageCircle className="h-4 w-4 mr-2" />
            Relationships
          </TabsTrigger>
        </TabsList>

        <TabsContent value="overview">
          <Card>
            <CardHeader>
              <CardTitle>Community Activity</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {/* Recent Activity Overview */}
                <div className="grid gap-4 md:grid-cols-2">
                  {/* Latest Contributions */}
                  <Card className="p-4">
                    <h3 className="font-medium mb-2">Recent Contributions</h3>
                    {contributions.slice(-3).map((contribution, i) => (
                      <div key={i} className="mb-2 text-sm">
                        <p className="font-medium">{contribution.description}</p>
                        <p className="text-gray-600">{contribution.impactStory}</p>
                      </div>
                    ))}
                  </Card>

                  {/* Latest Mutual Aid */}
                  <Card className="p-4">
                    <h3 className="font-medium mb-2">Recent Mutual Aid</h3>
                    {mutualAid.slice(-3).map((interaction, i) => (
                      <div key={i} className="mb-2 text-sm">
                        <p className="font-medium">{interaction.description}</p>
                        {interaction.impactStory && (
                          <p className="text-gray-600">{interaction.impactStory}</p>
                        )}
                      </div>
                    ))}
                  </Card>
                </div>

                {/* Active Relationships */}
                <div>
                  <h3 className="font-medium mb-2">Active Relationships</h3>
                  <div className="space-y-2">
                    {relationships.slice(-3).map((relationship, i) => (
                      <Card key={i} className="p-4">
                        <p className="font-medium">
                          With {relationship.memberTwo}
                        </p>
                        <p className="text-sm text-gray-600">{relationship.story}</p>
                        <div className="mt-2">
                          <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                            {relationship.relationshipType}
                          </span>
                        </div>
                      </Card>
                    ))}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="mutual-aid">
          <Card>
            <CardHeader>
              <CardTitle>Mutual Aid Network</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {mutualAid.map((interaction, i) => (
                  <Card key={i} className="p-4">
                    <div className="flex items-start gap-4">
                      <HandHeart className="h-5 w-5 text-green-500 mt-1" />
                      <div>
                        <h3 className="font-medium">{interaction.description}</h3>
                        <p className="text-sm text-gray-500">
                          {new Date(interaction.date).toLocaleDateString()}
                        </p>
                        {interaction.impactStory && (
                          <p className="mt-2 text-gray-600">{interaction.impactStory}</p>
                        )}
                        {interaction.reciprocityNotes && (
                          <p className="mt-2 text-sm text-gray-600 italic">
                            {interaction.reciprocityNotes}
                          </p>
                        )}
                      </div>
                    </div>
                  </Card>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="relationships">
          <Card>
            <CardHeader>
              <CardTitle>Your Relationships</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {relationships.map((relationship, i) => (
                  <Card key={i} className="p-4">
                    <div className="space-y-4">
                      <div>
                        <h3 className="font-medium">
                          Relationship with {relationship.memberTwo}
                        </h3>
                        <p className="text-sm text-gray-500">
                          Since {new Date(relationship.started).toLocaleDateString()}
                        </p>
                      </div>
                      
                      <div className="bg-gray-50 p-4 rounded">
                        <h4 className="text-sm font-medium mb-1">Our Story</h4>
                        <p className="text-gray-600">{relationship.story}</p>
                      </div>

                      <div>
                        <h4 className="text-sm font-medium mb-2">Recent Interactions</h4>
                        {relationship.interactions.slice(-3).map((interaction, j) => (
                          <div key={j} className="mb-2 text-sm">
                            <p className="font-medium">{interaction.description}</p>
                            <p className="text-gray-600">
                              {new Date(interaction.date).toLocaleDateString()}
                            </p>
                          </div>
                        ))}
                      </div>
                    </div>
                  </Card>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

===================
File: ./frontend/src/components/governance/GovernanceDashboard.tsx
===================
import React, { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { AlertCircle, ChevronRight, Users, TrendingUp } from 'lucide-react'

type Proposal = {
  id: string
  title: string
  description: string
  status: 'active' | 'passed' | 'rejected'
  votesFor: number
  votesAgainst: number
  quorum: number
  createdBy: string
  endsAt: string
  totalVoters: number
  delegatedVotes: number
}

type VotingStats = {
  totalProposals: number
  activeProposals: number
  participationRate: number
  monthlyVotes: Array<{ month: string; votes: number }>
}

const GovernanceDashboard = () => {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [votingStats, setVotingStats] = useState<VotingStats>({
    totalProposals: 0,
    activeProposals: 0,
    participationRate: 0,
    monthlyVotes: []
  })
  const [selectedTab, setSelectedTab] = useState('active')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockProposals: Proposal[] = [
      {
        id: '1',
        title: 'Community Resource Allocation Q3',
        description: 'Proposal to allocate community resources for Q3 projects',
        status: 'active',
        votesFor: 750,
        votesAgainst: 250,
        quorum: 1000,
        createdBy: 'did:icn:alice',
        endsAt: '2024-11-01',
        totalVoters: 1500,
        delegatedVotes: 200
      },
      {
        id: '2',
        title: 'New Cooperation Guidelines',
        description: 'Updated guidelines for inter-cooperative collaboration',
        status: 'passed',
        votesFor: 800,
        votesAgainst: 100,
        quorum: 1000,
        createdBy: 'did:icn:bob',
        endsAt: '2024-10-15',
        totalVoters: 1200,
        delegatedVotes: 150
      }
    ]

    const mockStats = {
      totalProposals: 45,
      activeProposals: 3,
      participationRate: 78.5,
      monthlyVotes: [
        { month: 'Jan', votes: 120 },
        { month: 'Feb', votes: 150 },
        { month: 'Mar', votes: 180 },
        { month: 'Apr', votes: 220 }
      ]
    }

    setProposals(mockProposals)
    setVotingStats(mockStats)
    setLoading(false)
  }, [])

  const calculateProgress = (votesFor: number, votesAgainst: number) => {
    const total = votesFor + votesAgainst
    return total > 0 ? (votesFor / total) * 100 : 0
  }

  const ProposalCard = ({ proposal }: { proposal: Proposal }) => (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-semibold">{proposal.title}</h3>
          <p className="text-sm text-gray-600">{proposal.description}</p>
        </div>
        <span className={`px-2 py-1 rounded text-sm ${
          proposal.status === 'active' ? 'bg-blue-100 text-blue-800' :
          proposal.status === 'passed' ? 'bg-green-100 text-green-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        </span>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculateProgress(proposal.votesFor, proposal.votesAgainst).toFixed(1)}%</span>
        </div>
        <Progress 
          value={calculateProgress(proposal.votesFor, proposal.votesAgainst)} 
          className="h-2"
        />
        
        <div className="flex justify-between text-sm text-gray-600">
          <span>For: {proposal.votesFor}</span>
          <span>Against: {proposal.votesAgainst}</span>
        </div>

        <div className="flex justify-between items-center mt-4">
          <div className="text-sm text-gray-600">
            <p>Created by: {proposal.createdBy}</p>
            <p>Ends: {new Date(proposal.endsAt).toLocaleDateString()}</p>
          </div>
          {proposal.status === 'active' && (
            <Button className="space-x-2">
              <span>Vote Now</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </Card>
  )

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Participation Rate</p>
                <h3 className="text-2xl font-bold">{votingStats.participationRate}%</h3>
              </div>
              <Users className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.totalProposals}</h3>
              </div>
              <TrendingUp className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Voting Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={votingStats.monthlyVotes}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="votes" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Proposals</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList>
              <TabsTrigger value="active">Active</TabsTrigger>
              <TabsTrigger value="passed">Passed</TabsTrigger>
              <TabsTrigger value="rejected">Rejected</TabsTrigger>
            </TabsList>

            <TabsContent value="active" className="space-y-4">
              {proposals
                .filter(p => p.status === 'active')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="passed" className="space-y-4">
              {proposals
                .filter(p => p.status === 'passed')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="rejected" className="space-y-4">
              {proposals
                .filter(p => p.status === 'rejected')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      <Alert>
        <AlertDescription>
          You currently have {proposals[0]?.delegatedVotes || 0} votes delegated to you. 
          Visit the delegation page to manage your voting power.
        </AlertDescription>
      </Alert>
    </div>
  )
}

export default GovernanceDashboard

===================
File: ./frontend/src/components/consensus/ConsensusMonitor.tsx
===================
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';

type ConsensusStatus = 'Proposing' | 'Voting' | 'Finalizing' | 'Completed' | 'Failed';

interface ConsensusUpdate {
  round_number: number;
  status: ConsensusStatus;
  coordinator: string;
  votes_count: number;
}

interface BlockFinalized {
  block_number: number;
  transactions_count: number;
  timestamp: number;
}

interface ReputationUpdate {
  did: string;
  change: number;
  new_total: number;
}

interface ErrorMessage {
  code: string;
  message: string;
}

interface WebSocketMessage {
  type: 'ConsensusUpdate' | 'BlockFinalized' | 'ReputationUpdate' | 'Error';
  data: ConsensusUpdate | BlockFinalized | ReputationUpdate | ErrorMessage;
}

const ConsensusMonitor: React.FC = () => {
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);
  const [connected, setConnected] = useState(false);
  const ws = useRef<WebSocket | null>(null);

  useEffect(() => {
    // Get DID from local storage or context
    const did = localStorage.getItem('userDid') || 'default-did';

    const connectWebSocket = () => {
      try {
        ws.current = new WebSocket('ws://localhost:8080/ws');
        
        ws.current.onopen = () => {
          setConnected(true);
          // Send DID in a message after connection
          ws.current?.send(JSON.stringify({ type: 'identify', did }));
        };

        ws.current.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            setMessages((prev) => [...prev, message].slice(-5)); // Keep last 5 messages
          } catch (e) {
            console.error('Failed to parse WebSocket message:', e);
          }
        };

        ws.current.onclose = () => {
          setConnected(false);
          // Try to reconnect after 5 seconds
          setTimeout(connectWebSocket, 5000);
        };

        ws.current.onerror = (error) => {
          console.error('WebSocket error:', error);
          ws.current?.close();
        };
      } catch (error) {
        console.error('Failed to establish WebSocket connection:', error);
        setTimeout(connectWebSocket, 5000);
      }
    };

    connectWebSocket();

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const renderConsensusUpdate = (data: ConsensusUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Consensus Round {data.round_number}</p>
          <Badge variant={
            data.status === 'Completed' ? 'default' :
            data.status === 'Failed' ? 'destructive' :
            'secondary'
          }>
            {data.status}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">Coordinator: {data.coordinator}</p>
        <p className="text-sm text-gray-600">Votes: {data.votes_count}</p>
      </CardContent>
    </Card>
  );

  const renderBlockFinalized = (data: BlockFinalized) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">New Block #{data.block_number}</p>
          <Badge>Finalized</Badge>
        </div>
        <p className="text-sm text-gray-600">Transactions: {data.transactions_count}</p>
        <p className="text-sm text-gray-600">
          Time: {new Date(data.timestamp * 1000).toLocaleString()}
        </p>
      </CardContent>
    </Card>
  );

  const renderReputationUpdate = (data: ReputationUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Reputation Change</p>
          <Badge variant={data.change > 0 ? 'default' : 'destructive'}>
            {data.change > 0 ? '+' : ''}{data.change}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">DID: {data.did}</p>
        <p className="text-sm text-gray-600">New Total: {data.new_total}</p>
      </CardContent>
    </Card>
  );

  const renderMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'ConsensusUpdate':
        return renderConsensusUpdate(message.data as ConsensusUpdate);
      case 'BlockFinalized':
        return renderBlockFinalized(message.data as BlockFinalized);
      case 'ReputationUpdate':
        return renderReputationUpdate(message.data as ReputationUpdate);
      case 'Error':
        const errorData = message.data as ErrorMessage;
        return (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>
              Error {errorData.code}: {errorData.message}
            </AlertDescription>
          </Alert>
        );
      default:
        return null;
    }
  };

  return (
    <div className="space-y-4 p-4">
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Consensus Monitor</CardTitle>
            <Badge variant={connected ? "default" : "destructive"}>
              {connected ? 'Connected' : 'Disconnected'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {messages.map((msg, i) => (
              <div key={i}>{renderMessage(msg)}</div>
            ))}
            {messages.length === 0 && (
              <p className="text-gray-500 text-center py-4">
                No consensus updates yet
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ConsensusMonitor;

===================
File: ./backend/Cargo.toml
===================
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[[example]]
name = "blockchain_test"
path = "examples/blockchain_test.rs"

[[example]]
name = "ws_client"
path = "examples/ws_client.rs"

[[example]]
name = "integration_test"
path = "examples/integration_test.rs"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
futures = "0.3"
futures-util = "0.3"
rand = "0.8"
secp256k1 = { version = "0.24.3", features = ["rand"] }
sha2 = "0.10"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
tokio-tungstenite = "0.20"
url = "2.4"
http = "0.2"

[dev-dependencies]
tokio-tungstenite = { version = "0.20", features = ["native-tls"] }
url = "2.4"
http = "0.2"

===================
File: ./frontend/package.json
===================
<EMPTY FILE>


===================
File: ./frontend/tsconfig.json
===================
<EMPTY FILE>


===================
File: ./docker/docker-compose.yml
===================
version: '3.8'

services:
  backend:
    build:
      context: ../backend                        
      dockerfile: ../docker/backend.Dockerfile   
    ports:
      - "8081:8081"  
    environment:
      - DATABASE_URL=postgres://icnuser:icnpass@db:5432/icndb

  frontend:
    build:
      context: ../frontend                       
      dockerfile: ../docker/frontend.Dockerfile  
    ports:
      - "3000:3000"

  db:
    image: postgres:latest
    environment:
      POSTGRES_USER: icnuser
      POSTGRES_PASSWORD: icnpass
      POSTGRES_DB: icndb
    ports:
      - "5432:5432"

  docs:
    image: squidfunk/mkdocs-material:latest
    volumes:
      - ../docs:/docs          
    ports:
      - "8000:8000"
    working_dir: /docs
    command: /bin/sh -c "pip install mkdocs-mermaid2-plugin && mkdocs serve -a 0.0.0.0:8000"


===================
File: ./docker/backend.Dockerfile
===================
# backend.Dockerfile

# Stage 1: Build the Rust app
FROM rust:1.71.0 AS builder

WORKDIR /app

# Copy Cargo.toml and Cargo.lock
COPY Cargo.toml Cargo.lock ./

# Build dependencies
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release
RUN rm -rf src

# Copy the rest of the project
COPY . .

# Build the project
RUN cargo build --release
RUN cargo test --release

# Stage 2: Create a smaller image to run the binary
FROM debian:bullseye-slim AS runner
WORKDIR /app
COPY --from=builder /app/target/release/icn-backend /usr/local/bin/icn-backend

EXPOSE 8081

CMD ["icn-backend"]


===================
File: ./docker/frontend.Dockerfile
===================
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
CMD ["npm", "start"]


