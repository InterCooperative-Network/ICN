Project Code Dump - Generated Thu Dec 12 04:10:13 UTC 2024
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

File Organization:
- /backend/src/: Core Rust implementation
- /frontend/src/: React frontend application
- /contracts/: Smart contract implementations
- /docker/: Deployment configurations

======================

Project Tree:
=============
.
├── Cargo.lock
├── Cargo.toml
├── ICN.code-workspace
├── contracts
│   ├── cooperative
│   │   └── src
│   └── governance
├── crates
│   ├── icn-consensus
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-core
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   ├── lib.rs,old
│   │   └── src
│   ├── icn-crypto
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-p2p
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-runtime
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-storage
│   │   ├── Cargo.toml
│   │   ├── migrations
│   │   └── src
│   └── icn-types
│       ├── Cargo.toml
│       └── src
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── icn_backup_20241207.tar.gz
├── improved-setup.sh
├── inventory_nodes.sh
├── old_src_backup
│   ├── api
│   │   ├── cooperative.rs
│   │   └── mod.rs
│   ├── blockchain
│   │   ├── block.rs
│   │   ├── chain.rs
│   │   ├── mod.rs
│   │   └── transaction.rs
│   ├── claims
│   │   └── mod.rs
│   ├── community
│   │   └── mod.rs
│   ├── config
│   ├── consensus
│   ├── cooperative
│   │   └── mod.rs
│   ├── governance
│   │   ├── mod.rs
│   │   └── proposal.rs
│   ├── identity
│   │   ├── authentication.rs
│   │   ├── did.rs
│   │   ├── identity_manager.rs
│   │   ├── identity_system.rs
│   │   ├── key_pair.rs
│   │   └── mod.rs
│   ├── lib.rs
│   ├── main.rs
│   ├── monitoring
│   │   ├── energy.rs
│   │   ├── metrics.rs
│   │   ├── mod.rs
│   │   ├── prometheus.rs
│   │   └── service.rs
│   ├── network
│   ├── relationship
│   │   ├── mod.rs
│   │   ├── models
│   │   ├── system.rs
│   │   └── types.rs
│   ├── reputation
│   │   ├── mod.rs
│   │   └── reputation_system.rs
│   ├── state
│   │   ├── merkle_tree.rs
│   │   ├── migrations.rs
│   │   ├── mod.rs
│   │   ├── persistence.rs
│   │   ├── state_migrations.rs
│   │   └── validation.rs
│   ├── storage
│   ├── utils
│   │   ├── mod.rs
│   │   └── notifications.rs
│   ├── vm
│   └── websocket
│       ├── backend.code-workspace
│       ├── handler.rs
│       └── mod.rs
├── project_code_dump.txt
├── project_docs_dump.txt
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── start_docs_server.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── docmanager.py
    │   ├── docsctl
    │   ├── specgen.py
    │   └── venv
    ├── install_docsctl.sh
    └── requirements.txt

===================
File: ./docker/docker-compose.yml
Size: 829 bytes
Modified: 2024-11-20 22:07:42.247802666 +0000

===================

===================
File: ./crates/icn-storage/src/lib.rs
Size: 908 bytes
Modified: 2024-12-08 05:34:52.756969543 +0000
Dependencies:
mod error;
mod integration_tests {
mod tests;

===================
```rs
//! ICN Storage implementation
//! 
//! This crate provides persistent storage and state management for the ICN network.

mod error;
pub mod storage;
pub mod state;
#[cfg(test)]
mod tests;

pub use error::{StorageError, StorageResult};
pub use storage::{StorageManager, StorageConfig};
pub use state::{StateManager, NetworkState};

/// Initialize the storage system
pub async fn init(config: StorageConfig) -> StorageResult<StorageManager> {
    let storage = StorageManager::new(config).await?;
    
    // Run any pending migrations
    storage.run_migrations().await?;
    
    Ok(storage)
}

#[cfg(test)]
mod integration_tests {
    use super::*;
    use tokio;

    #[tokio::test]
    async fn test_storage_initialization() {
        let config = StorageConfig::default();
        let storage = init(config).await.unwrap();
        assert!(storage.get_latest_block_height().await.unwrap() >= 0);
    }
}```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 4017 bytes
Modified: 2024-12-08 11:37:39.204130619 +0000
Dependencies:
mod config;
mod error;
mod metrics;
mod proof_of_cooperation;
mod tests {
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

===================
```rs
// src/lib.rs

use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

mod config;
mod error;
mod metrics;
mod proof_of_cooperation;

pub use config::ConsensusConfig;
pub use error::{ConsensusError, ConsensusResult};
pub use metrics::ConsensusMetrics;
pub use proof_of_cooperation::{ProofOfCooperation, ConsensusEvent};

/// Atomic round counter for unique round identification
static ROUND_COUNTER: AtomicU64 = AtomicU64::new(0);

/// Core consensus engine interface
#[async_trait::async_trait]
pub trait ConsensusEngine: Send + Sync {
    async fn start_round(&mut self) -> ConsensusResult<()>;
    async fn propose_block(&mut self, block: icn_types::Block) -> ConsensusResult<()>;
    async fn verify_block(&self, block: &icn_types::Block) -> ConsensusResult<()>;
    async fn submit_vote(&mut self, validator_did: String, approve: bool, signature: Vec<u8>) -> ConsensusResult<()>;
    async fn has_consensus(&self) -> ConsensusResult<bool>;
}

/// Vote tracking with signature verification
#[derive(Debug, Clone)]
struct Vote {
    validator: String,
    approve: bool,
    signature: Vec<u8>,
    timestamp: Instant,
}

/// Round state management
#[derive(Debug)]
pub struct ConsensusRound {
    id: u64,
    start_time: Instant,
    timeout: Duration,
    votes: RwLock<HashMap<String, Vote>>,
    proposed_block: Option<icn_types::Block>,
    finalized: bool,
}

impl ConsensusRound {
    fn new(timeout: Duration) -> Self {
        Self {
            id: ROUND_COUNTER.fetch_add(1, Ordering::SeqCst),
            start_time: Instant::now(),
            timeout,
            votes: RwLock::new(HashMap::new()),
            proposed_block: None,
            finalized: false,
        }
    }

    async fn add_vote(&self, vote: Vote) -> ConsensusResult<()> {
        let mut votes = self.votes.write().await;
        
        // Check for duplicate votes
        if votes.contains_key(&vote.validator) {
            return Err(ConsensusError::DuplicateVote);
        }
        
        // Verify vote signature
        if !self.verify_vote_signature(&vote).await? {
            return Err(ConsensusError::InvalidSignature);
        }
        
        votes.insert(vote.validator.clone(), vote);
        Ok(())
    }

    async fn verify_vote_signature(&self, vote: &Vote) -> ConsensusResult<bool> {
        // TODO: Implement actual signature verification
        Ok(true)
    }

    fn is_timed_out(&self) -> bool {
        self.start_time.elapsed() > self.timeout
    }
}

/// Configuration options
#[derive(Debug, Clone)]
pub struct ConsensusOpts {
    pub min_validators: usize,
    pub round_timeout: Duration,
    pub consensus_threshold: f64,
    pub max_timestamp_diff: Duration,
    pub event_channel_size: usize,
    pub signature_verification: bool,
}

impl Default for ConsensusOpts {
    fn default() -> Self {
        Self {
            min_validators: 4,
            round_timeout: Duration::from_secs(30),
            consensus_threshold: 0.66,
            max_timestamp_diff: Duration::from_secs(60),
            event_channel_size: 1000,
            signature_verification: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio;

    #[tokio::test]
    async fn test_consensus_round_voting() {
        let round = ConsensusRound::new(Duration::from_secs(30));
        
        let vote = Vote {
            validator: "test_validator".to_string(),
            approve: true,
            signature: vec![],
            timestamp: Instant::now(),
        };
        
        assert!(round.add_vote(vote.clone()).await.is_ok());
        assert!(round.add_vote(vote.clone()).await.is_err()); // Duplicate vote
    }

    #[tokio::test]
    async fn test_round_timeout() {
        let round = ConsensusRound::new(Duration::from_millis(1));
        tokio::time::sleep(Duration::from_millis(2)).await;
        assert!(round.is_timed_out());
    }
}```

===================
File: ./crates/icn-types/src/lib.rs
Size: 658 bytes
Modified: 2024-12-07 23:22:29.894333983 +0000
Dependencies:
mod block;
mod error;  // Add this line
mod identity;
mod relationship;
mod reputation;
mod transaction;

===================
```rs
// crates/icn-types/src/lib.rs

mod block;
mod transaction;
mod identity;
mod relationship;
mod reputation;
mod error;  // Add this line

pub use block::Block;
pub use transaction::{Transaction, TransactionType};
pub use identity::DID;
pub use relationship::{Relationship, RelationshipType};
pub use reputation::{ReputationSystem, ReputationContext, ReputationScore};
// Export error types
pub use error::{
    CoreError, StorageError, ConsensusError, NetworkError, IdentityError,
    CoreResult, StorageResult, ConsensusResult, NetworkResult, IdentityResult,
};

pub trait Validate {
    fn validate(&self) -> CoreResult<()>;  // Updated to use CoreResult
}```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 56 bytes
Modified: 2024-12-07 10:58:37.661642490 +0000
Dependencies:
use icn_types::*;

===================
```rs
pub mod protocol;
pub mod websocket;

use icn_types::*;
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 49 bytes
Modified: 2024-12-07 10:58:37.663642511 +0000
Dependencies:
use icn_types::*;

===================
```rs
pub mod vm;
pub mod executor;

use icn_types::*;
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 789 bytes
Modified: 2024-12-10 05:00:22.902056268 +0000
Dependencies:
mod crypto;
mod engine;
mod error;
mod proof_of_cooperation;
mod state;

===================
```rs
// crates/icn-consensus/src/lib.rs

mod crypto;
mod error;
mod state;
mod proof_of_cooperation;
mod engine;

pub use crypto::{CryptoManager, CryptoError, CryptoResult};
pub use error::{ConsensusError, ConsensusResult};
pub use state::{StateManager, ConsensusState};
pub use proof_of_cooperation::{ProofOfCooperation, ConsensusEvent, ConsensusConfig, RoundStatus};
pub use engine::ConsensusEngine;

// Re-export main types
pub type ValidatorSet = std::collections::HashMap<String, ValidatorInfo>;

#[derive(Debug, Clone)]
pub struct ValidatorInfo {
    pub did: String,
    pub reputation: i64,
    pub consecutive_rounds: usize,
}

/// Initialize the consensus system
pub async fn init(config: ConsensusConfig) -> ConsensusResult<ConsensusEngine> {
    ConsensusEngine::new(config).await
}```

===================
File: ./crates/icn-core/src/main.rs
Size: 3811 bytes
Modified: 2024-12-08 11:07:03.369157426 +0000
Dependencies:
use anyhow::Result;
use config::{Config, File};
use icn_consensus::{ConsensusConfig, ProofOfCooperation};
use icn_p2p::websocket::WebSocketHandler;
use icn_storage::state::StateManager;
use icn_types::*;
use serde::Deserialize;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, error, Level};
use tracing_subscriber::{FmtSubscriber, EnvFilter};
use warp::Filter;

===================
```rs
// crates/icn-core/src/main.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use warp::Filter;
use tracing::{info, error, Level};
use tracing_subscriber::{FmtSubscriber, EnvFilter};
use config::{Config, File};
use anyhow::Result;
use serde::Deserialize;

use icn_types::*;
use icn_consensus::{ConsensusConfig, ProofOfCooperation};
use icn_p2p::websocket::WebSocketHandler;
use icn_storage::state::StateManager;

#[derive(Debug, Deserialize)]
struct AppConfig {
    server: ServerConfig,
    consensus: ConsensusConfig,
    storage: StorageConfig,
}

#[derive(Debug, Deserialize)]
struct ServerConfig {
    host: String,
    port: u16,
}

#[derive(Debug, Deserialize)]
struct StorageConfig {
    url: String,
    max_connections: u32,
}

async fn setup_config() -> Result<AppConfig> {
    let config = Config::builder()
        .add_source(File::with_name("config/default"))
        .add_source(File::with_name("config/local").required(false))
        .build()?;

    Ok(config.try_deserialize()?)
}

async fn setup_logging() -> Result<()> {
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env()
            .add_directive(Level::INFO.into())
            .add_directive("icn_core=debug".parse()?))
        .with_thread_ids(true)
        .with_target(false)
        .with_file(true)
        .with_line_number(true)
        .pretty()
        .try_init()?;

    Ok(())
}

async fn setup_metrics() -> Result<()> {
    // TODO: Implement metrics setup with prometheus
    Ok(())
}

async fn setup_storage(config: &StorageConfig) -> Result<Arc<StateManager>> {
    let storage = StateManager::with_config(config.url.clone(), config.max_connections).await?;
    Ok(Arc::new(storage))
}

async fn setup_consensus(
    config: ConsensusConfig,
    ws_handler: Arc<WebSocketHandler>,
) -> Result<Arc<RwLock<ProofOfCooperation>>> {
    let consensus = ProofOfCooperation::new(config, ws_handler);
    Ok(Arc::new(RwLock::new(consensus)))
}

fn setup_routes(
    ws_handler: Arc<WebSocketHandler>,
    storage: Arc<StateManager>,
    consensus: Arc<RwLock<ProofOfCooperation>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .and(warp::header::<String>("X-DID"))
        .and(warp::any().map(move || ws_handler.clone()))
        .map(|ws: warp::ws::Ws, did: String, handler: Arc<WebSocketHandler>| {
            ws.on_upgrade(move |socket| async move {
                if let Err(e) = handler.handle_connection(socket, did).await {
                    error!("WebSocket connection error: {}", e);
                }
            })
        });

    let health_route = warp::path("health")
        .and(warp::get())
        .map(|| "OK");

    ws_route.or(health_route)
}

#[tokio::main]
async fn main() -> Result<()> {
    // Setup phase
    setup_logging().await?;
    info!("Starting ICN node...");

    let config = setup_config().await?;
    info!("Configuration loaded");

    setup_metrics().await?;
    info!("Metrics initialized");

    // Initialize core systems
    let storage = setup_storage(&config.storage).await?;
    info!("Storage system initialized");

    let ws_handler = Arc::new(WebSocketHandler::new());
    info!("WebSocket handler initialized");
    
    let consensus = setup_consensus(config.consensus, ws_handler.clone()).await?;
    info!("Consensus system initialized");

    // Setup routes
    let routes = setup_routes(ws_handler, storage, consensus);
    info!("Routes configured");

    // Start server
    let addr = format!("{}:{}", config.server.host, config.server.port)
        .parse()
        .expect("Invalid address");

    info!("Starting server on {}", addr);
    warp::serve(routes)
        .run(addr)
        .await;

    Ok(())
}```

===================
File: ./crates/icn-core/src/lib.rs
Size: 198 bytes
Modified: 2024-12-07 10:58:37.655642427 +0000
Dependencies:
use icn_consensus as consensus;
use icn_p2p as p2p;
use icn_runtime as runtime;
use icn_storage as storage;
use icn_types::*;

===================
```rs
pub mod api;
pub mod cooperative;
pub mod governance;
pub mod service;

use icn_types::*;
use icn_consensus as consensus;
use icn_storage as storage;
use icn_p2p as p2p;
use icn_runtime as runtime;
```

