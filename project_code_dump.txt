Project Code Dump - Generated Sat 08 Mar 2025 04:04:59 AM UTC
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

File Organization:
- /backend/src/: Core Rust implementation
- /frontend/src/: React frontend application
- /contracts/: Smart contract implementations
- /docker/: Deployment configurations

======================

Project Tree:
=============
.
├── backend
│   ├── benches
│   │   └── governance_benchmarks.rs
│   ├── Cargo.toml
│   ├── migrations
│   │   ├── 20240218000000_initial.sql
│   │   ├── 20240301000000_add_optimized_indexes.sql
│   │   └── test
│   └── src
│       ├── api
│       ├── api.rs
│       ├── blockchain.rs
│       ├── core
│       ├── core.rs
│       ├── database
│       ├── database.rs
│       ├── db
│       ├── db.rs
│       ├── federation.rs
│       ├── governance.rs
│       ├── identity.rs
│       ├── lib.rs
│       ├── main.rs
│       ├── middleware
│       ├── models.rs
│       ├── networking
│       ├── networking.rs
│       ├── notification.rs
│       ├── reputation.rs
│       ├── resources.rs
│       ├── services
│       ├── services.rs
│       ├── storage.rs
│       ├── test_config.rs
│       ├── test_macros.rs
│       ├── test_utils.rs
│       ├── vm.rs
│       └── websocket
├── bridges
│   └── cross_chain
│       └── mod.rs
├── Cargo.lock
├── Cargo.toml
├── config
│   ├── feature-flags.json
│   └── log4rs.yaml
├── consensus
│   ├── engine.py
│   └── validation.py
├── contracts
│   ├── Cargo.toml
│   └── cooperative
│       └── src
├── crates
│   ├── consensus
│   │   └── Cargo.toml
│   ├── core
│   │   └── Cargo.toml
│   ├── icn-common
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-consensus
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   ├── icn-core
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-crypto
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-dsl
│   │   └── src
│   ├── icn-federation
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-governance
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-identity
│   │   └── src
│   ├── icn-mutual-credit
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-p2p
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-reputation
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-resource
│   │   └── src
│   ├── icn-runtime
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-storage
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-types
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-zk
│   │   ├── Cargo.toml
│   │   └── src
│   ├── networking
│   │   └── Cargo.toml
│   ├── storage
│   │   └── Cargo.toml
│   └── zk_snarks
│       └── src
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── docker-compose.test.yml
├── Dockerfile.test
├── DSL_ICN.txt
├── federation
│   ├── federation.py
│   └── signature.py
├── fraudDetection.ts
├── frontend
│   ├── Cargo.toml
│   ├── package.json
│   ├── postcss.config.js
│   ├── src
│   │   ├── components
│   │   └── styles
│   ├── tailwind.config.js
│   └── tsconfig.json
├── fsprovider-sample
│   ├── CHANGELOG.md
│   ├── eslint.config.mjs
│   ├── package.json
│   ├── package-lock.json
│   ├── README.md
│   ├── sample.png
│   ├── src
│   │   ├── extension.ts
│   │   └── fileSystemProvider.ts
│   └── tsconfig.json
├── generate_code_dump.sh
├── grammar
│   ├── coop_lang.pest
│   └── did_grammar.peg
├── ICN.code-workspace
├── icn-consensus
│   └── src
│       └── lib.rs
├── icn-core
│   └── src
│       ├── storage.rs
│       └── transaction.rs
├── identity
│   ├── did.rs
│   ├── identity_system.rs
│   ├── key_manager.rs
│   ├── mod.rs
│   └── service.py
├── improved-setup.sh
├── inventory_nodes.sh
├── messaging
│   └── server.rs
├── MyNewFile.ts
├── poc-zk-snarks-overview.md
├── project_code_dump.txt
├── project_docs_dump.txt
├── README.md
├── reputation
│   ├── errors.rs
│   └── reputation_manager.rs
├── resourceAllocation.ts
├── rust-toolchain.toml
├── scripts
│   ├── backend
│   │   └── src
│   ├── frontend
│   │   └── package-lock.json
│   ├── make_scripts_executable.sh
│   ├── run_load_tests.sh
│   ├── run_tests.sh
│   ├── setup.sh
│   └── setup_test_env.sh
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── src
│   ├── api
│   │   ├── handlers.rs
│   │   ├── mod.rs
│   │   ├── routes.rs
│   │   └── types.ts
│   ├── attestation
│   │   └── mod.rs
│   ├── blockchain
│   │   └── validation.py
│   ├── block.rs
│   ├── cache.js
│   ├── consensus
│   │   └── mod.rs
│   ├── dsl
│   │   ├── governance.rs
│   │   ├── grammar.pest
│   │   ├── mod.rs
│   │   ├── parser.rs
│   │   └── vm.rs
│   ├── errors.js
│   ├── federation
│   │   └── federation.py
│   ├── governance
│   │   ├── mod.rs
│   │   └── rollback.rs
│   ├── identity
│   │   └── identity_service.py
│   ├── lib.rs
│   ├── logger.js
│   ├── main.rs
│   ├── network
│   │   ├── communication.rs
│   │   └── mod.rs
│   ├── parser.rs
│   ├── security.js
│   ├── services
│   │   ├── event_service.rs
│   │   └── mod.rs
│   └── storage
│       ├── event_store.rs
│       └── mod.rs
├── start_docs_server.sh
├── Technical_Architecture.md
└── tools
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── docmanager.py
    │   ├── docsctl
    │   ├── __init__.py
    │   └── specgen.py
    ├── install_docsctl.sh
    ├── README.md
    └── requirements.txt

===================
File: ./backend/Cargo.toml
Size: 1158 bytes
Modified: 2025-03-07 14:26:30.343663358 +0000

===================
```toml
[package]
name = "backend"
version = "0.1.0"
edition = "2021"

[dependencies]
sqlx = { workspace = true }
tokio = { workspace = true }
warp = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
async-trait = { workspace = true }
chrono = { workspace = true }
log = { workspace = true }
env_logger = { workspace = true }
thiserror = { workspace = true }
icn-types = { workspace = true }
icn-federation = { path = "../crates/icn-federation" }
tower = { version = "0.4", features = ["limit"] }
tower-http = { version = "0.6", features = ["limit"] }
bls-signatures = "=0.7.1"  # Pinned to older version compatible with Rust 1.71.1
didcomm-rs = "0.1"
tokio-tungstenite = "=0.18.0"
tungstenite = "=0.18.0"
url = "=2.3.1"

[dev-dependencies]
criterion = { version = "0.5", features = ["async_tokio"] }
quickcheck = "1.0"
quickcheck_async = "0.1"
quickcheck_macros = "1.0"
tokio-test = "0.4"
test-log = "0.2"
pretty_assertions = "1.4"
fake = { version = "2.8", features = ["derive"] }
rstest = "0.25"
mockall = "0.11"
futures = "0.3"

[[bench]]
name = "governance_benchmarks"
harness = false
```

===================
File: ./backend/src/lib.rs
Size: 982 bytes
Modified: 2025-03-07 09:37:23.560766185 +0000
Dependencies:

===================
```rs
pub mod api;
pub mod services;
pub mod database;
pub mod networking;
pub mod core;
pub mod main;

pub mod db;
pub mod models;
pub mod blockchain;
pub mod federation;
pub mod governance;
pub mod identity;
pub mod notification;
pub mod reputation;
pub mod resources;
pub mod vm;

// Re-export for the integration tests
pub use blockchain::Blockchain;
pub use governance::{Proposal, ProposalType, ProposalStatus, ProposalHistory, Federation, FederationType, FederationTerms, MemberRole, MemberStatus, handle_federation_operation};
pub use identity::{DID, Algorithm, DIDError, IdentitySystem};
pub use reputation::ReputationSystem;
pub use vm::{VM, opcode, cooperative_metadata};
pub use notification::NotificationManager;

#[cfg(test)]
pub mod test_utils;
#[cfg(test)]
pub mod test_config;
#[cfg(test)]
pub mod test_macros;

// Re-export test utilities for integration tests
#[cfg(test)]
pub use test_utils::*;
#[cfg(test)]
pub use test_config::*;
#[cfg(test)]
pub use test_macros::*;
```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
Modified: 2025-03-07 09:09:46.468758092 +0000
Dependencies:

===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./backend/src/main.rs
Size: 7420 bytes
Modified: 2025-03-07 09:40:20.491383674 +0000
Dependencies:
mod api;
mod config;
mod core;
mod db;
mod federation;
mod middleware;
mod networking; // Add networking module
mod notification;
mod reputation;
mod websocket;
use async_trait::async_trait;
use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::create_pool;
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use dashmap::DashMap;
use dotenv::dotenv;
use env_logger;
use futures_util::StreamExt;
use icn_backend::api::ApiServer;
use icn_backend::core::Core;
use icn_backend::database::Database;
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use log::{info, error};
use middleware::rate_limit::with_rate_limit;
use middleware::rate_limit::with_reputation_rate_limit;
use networking::p2p::{P2PManager, FederationEvent, GovernanceEvent, IdentityEvent, ReputationEvent}; // Import P2PManager and events
use reqwest::Client;
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::env;
use std::sync::Arc;
use thiserror::Error;
use tokio;
use tokio::signal;
use warp::cors::Cors;
use warp::{Filter, ws::{WebSocket, Message}};
use warp::http::Method;

===================
```rs
mod config;
mod core;
mod db;
mod federation;
mod notification;
mod reputation;
mod websocket;
mod middleware;
mod api;
mod networking; // Add networking module

use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use tokio;
use log::{info, error};
use env_logger;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use futures_util::StreamExt;
use warp::{Filter, ws::{WebSocket, Message}};
use dashmap::DashMap;
use sqlx::PgPool;
use thiserror::Error;
use reqwest::Client;
use tokio::signal;
use async_trait::async_trait;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use warp::http::Method;
use warp::cors::Cors;
use crate::db::create_pool;
use middleware::rate_limit::with_rate_limit;
use middleware::rate_limit::with_reputation_rate_limit;
use networking::p2p::{P2PManager, FederationEvent, GovernanceEvent, IdentityEvent, ReputationEvent}; // Import P2PManager and events
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_backend::api::ApiServer;
use icn_backend::core::Core;
use icn_backend::database::Database;
use dotenv::dotenv;
use std::env;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    #[error("Validation error: {0}")]
    ValidationError(String),
}

#[derive(Serialize, Deserialize)]
struct Proposal {
    id: String,
    title: String,
    description: String,
    status: String,
    votes_for: i64,
    votes_against: i64,
    created_by: String,
    ends_at: String,
}

#[derive(Serialize, Deserialize)]
struct Vote {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Serialize, Deserialize)]
struct TokenizedResource {
    resource_id: String,
    owner: String,
    quantity: u64,
    price_per_unit: f64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Load environment variables from .env file if present
    dotenv().ok();
    
    // Initialize logging
    env_logger::init();
    
    info!("Starting ICN backend...");
    
    // Get port from environment variable or default to 8080
    let port = env::var("PORT")
        .unwrap_or_else(|_| "8080".to_string())
        .parse::<u16>()
        .unwrap_or(8080);
    
    // Create the core system
    let core = Core::new();
    
    // Start core services
    core.start().await?;
    
    info!("Core services started.");
    
    // Create API server with core services
    let api_server = ApiServer::new(
        port,
        core.blockchain_service.clone(),
        core.identity_service.clone(),
        core.governance_service.clone(),
    );
    
    info!("Starting API server on port {}", port);
    
    // Run the server (this will block until the server exits)
    api_server.run().await?;
    
    info!("API server stopped. Shutting down...");
    
    // Graceful shutdown
    core.shutdown().await?;
    
    info!("ICN backend stopped.");
    
    Ok(())
}

async fn handle_federation_operation(operation: FederationOperation, notification_manager: NotificationManager) -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle federation operations
    let subject = match &operation {
        FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
            format!("Federation Initiated: {:?}", federation_type)
        }
        FederationOperation::JoinFederation { federation_id, commitment } => {
            format!("Joined Federation: {}", federation_id)
        }
        FederationOperation::LeaveFederation { federation_id, reason } => {
            format!("Left Federation: {}", federation_id)
        }
        FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
            format!("Action Proposed in Federation: {}", federation_id)
        }
        FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
            format!("Vote on Federation Proposal: {}", proposal_id)
        }
        FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
            format!("Resources Shared in Federation: {}", federation_id)
        }
        FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
            format!("Federation Terms Updated: {}", federation_id)
        }
    };

    let body = format!("Federation operation executed: {:?}", operation);
    notification_manager.send_notification(&subject, &body).await;
    Ok(warp::reply::json(&operation))
}

async fn handle_query_shared_resources() -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle querying shared resources
    let resources = vec![
        TokenizedResource {
            resource_id: "resource1".to_string(),
            owner: "did:icn:owner1".to_string(),
            quantity: 100,
            price_per_unit: 10.0,
        },
        TokenizedResource {
            resource_id: "resource2".to_string(),
            owner: "did:icn:owner2".to_string(),
            quantity: 200,
            price_per_unit: 20.0,
        },
    ];
    Ok(warp::reply::json(&resources))
}

struct DatabaseStorageBackend {
    pool: PgPool,
}

impl DatabaseStorageBackend {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.exists.unwrap_or(false))
    }
}

fn main() {
    println!("ICN backend is running!");
}
```

===================
File: ./frontend/package.json
Size: 499 bytes
Modified: 2025-03-07 09:09:46.458765887 +0000

===================
```json
{
  "name": "icn-frontend",
  "version": "1.0.0",
  "description": "Frontend for the Inter-Cooperative Network",
  "main": "index.js",
  "scripts": {
    "start": "next start",
    "build": "next build",
    "dev": "next dev",
    "lint": "eslint .",
    "format": "prettier --write ."
  },
  "dependencies": {
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
  "devDependencies": {
main
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

===================
File: ./contracts/cooperative/src/lib.rs
Size: 1284 bytes
Modified: 2025-03-07 09:09:46.438781479 +0000
Dependencies:
mod proposals;
use ethers::prelude::*;
use icn_zkp::{RollupBatch, VerificationKey};
use proposals::{ProposalContract, Proposal};

===================
```rs
mod proposals;

use proposals::{ProposalContract, Proposal};
use icn_zkp::{RollupBatch, VerificationKey};
use ethers::prelude::*;

pub struct CooperativeContract {
    proposal_contract: ProposalContract,
    contract_address: Address,
    // ...existing code...
}

impl CooperativeContract {
    pub fn new(contract_address: Address, verification_key: VerificationKey) -> Self {
        Self {
            proposal_contract: ProposalContract::new(
                3,
                verification_key,
                contract_address
            ),
            contract_address,
            // ...existing code...
        }
    }

    pub async fn submit_vote_batch(&mut self, batch: RollupBatch) -> Result<(), String> {
        self.proposal_contract.submit_vote_batch(batch).await
    }

    pub async fn execute_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        self.proposal_contract.execute_proposal(proposal_id).await
    }

    pub async fn submit_zk_snark_proof(&self, proof: Vec<u8>) -> Result<(), String> {
        // Implement zk-SNARK proof submission logic
        Ok(())
    }

    pub async fn verify_zk_snark_proof(&self, proof: Vec<u8>) -> Result<bool, String> {
        // Implement zk-SNARK proof verification logic
        Ok(true)
    }
}
```

===================
File: ./.devcontainer/docker-compose.yml
Size: 973 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000

===================

===================
File: ./docker/docker-compose.yml
Size: 1347 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000

===================

===================
File: ./src/api/handlers.rs
Size: 1240 bytes
Modified: 2025-03-07 19:09:53.131549319 +0000
Dependencies:
use crate::network::communication::NetworkEvent;
use crate::network::communication::NetworkLayer;
use crate::services::event_service::DomainEvent;
use crate::services::event_service::EventService;
use crate::storage::event_store::EventStore;
use icn_types::IcnResult;
use warp::Reply;

===================
```rs
use icn_types::IcnResult;
use crate::network::communication::NetworkLayer;
use crate::services::event_service::EventService;
use crate::services::event_service::DomainEvent;
use crate::storage::event_store::EventStore;
use crate::network::communication::NetworkEvent;
use warp::Reply;

pub async fn health_check() -> IcnResult<&'static str> {
    Ok("OK")
}

pub struct ApiHandlers {
    network: NetworkLayer,
    event_service: EventService,
    event_store: EventStore,
}

impl ApiHandlers {
    pub async fn new() -> Self {
        Self {
            network: NetworkLayer::new().await,
            event_service: EventService::new(),
            event_store: EventStore::new(),
        }
    }

    pub async fn handle_vote(&self, proposal_id: String, vote: bool) -> impl Reply {
        // Handle vote through all layers
        self.event_service.publish(DomainEvent::VoteCast {
            proposal_id: proposal_id.clone(),
            voter: "user".to_string(),
            vote,
        }).await;

        self.network.broadcast_event(NetworkEvent::VoteUpdate {
            proposal_id,
            votes: 1,
        }).await;

        warp::reply::json(&"Vote recorded")
    }

    // Add more handlers for other API endpoints
}
```

===================
File: ./src/api/routes.rs
Size: 213 bytes
Modified: 2025-03-07 09:09:46.498734708 +0000
Dependencies:
use warp::Filter;

===================
```rs
use warp::Filter;

pub fn icn_routes() -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path!("health")
        .and(warp::get())
        .map(|| warp::reply::json(&"OK"))
}
```

===================
File: ./src/api/mod.rs
Size: 160 bytes
Modified: 2025-03-07 09:09:46.498734708 +0000
Dependencies:
use crate::icn_types::IcnResult;

===================
```rs
// API module for the ICN system
pub mod routes;
pub mod handlers;

use crate::icn_types::IcnResult;

pub async fn initialize() -> IcnResult<()> {
    Ok(())
} ```

===================
File: ./src/lib.rs
Size: 301 bytes
Modified: 2025-03-07 19:09:57.353450421 +0000
Dependencies:
mod tests {

===================
```rs
pub mod api;
pub mod governance;
pub mod dsl;
pub mod attestation;
pub mod consensus;
pub mod network;
pub mod services;
pub mod storage;

/// Re-export commonly used types and functions
pub use icn_types;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}```

===================
File: ./src/main.rs
Size: 4057 bytes
Modified: 2025-03-07 20:24:31.169756834 +0000
Dependencies:
use icn_core::{
use log::{info, error};
use std::sync::Arc;

===================
```rs
use std::sync::Arc;
use log::{info, error};
use icn_core::{
    core::Core,
    telemetry::{TelemetryManager, PrometheusMetrics, Logger, TracingSystem},
    storage::{StorageInterface, MemoryStorage},
    networking::{NetworkInterface, NetworkManager},
    identity::{IdentityInterface, IdentityManager},
    reputation::{ReputationInterface, ReputationSystem},
    models::{ResourceAllocationSystem, FederationManager},
    RuntimeManager, RuntimeInterface
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("info"));
    info!("Starting ICN node initialization...");

    // Initialize core components
    let storage_manager = MemoryStorage::new();
    let network_manager = NetworkManager::new();
    let prometheus = PrometheusMetrics::new();
    let logger = Logger::new();
    let tracing = TracingSystem::new();
    let telemetry_manager = TelemetryManager::new(prometheus, logger, tracing);
    let identity_manager = IdentityManager::new();
    let reputation_manager = ReputationSystem::new();
    let runtime_manager = RuntimeManager::new();
    let resource_system = Arc::new(ResourceAllocationSystem::new());
    let federation_manager = Arc::new(FederationManager::new(resource_system.clone()));

    // Wrap components in Arc for shared ownership
    let storage: Arc<dyn StorageInterface> = Arc::new(storage_manager);
    let network: Arc<dyn NetworkInterface> = Arc::new(network_manager);
    let identity: Arc<dyn IdentityInterface> = Arc::new(identity_manager);
    let reputation: Arc<dyn ReputationInterface> = Arc::new(reputation_manager);
    let runtime: Arc<dyn RuntimeInterface> = Arc::new(runtime_manager);
    let _telemetry = Arc::new(telemetry_manager);

    // Create core system with the components it needs
    let core = Arc::new(Core::new(
        storage.clone(),
        network.clone(),
        identity.clone(),
        reputation.clone(),
        runtime.clone()
    ));

    // Start the core system
    info!("Starting core system components...");
    match core.start().await {
        Ok(_) => info!("Core system started successfully"),
        Err(e) => {
            error!("Failed to start core system: {}", e);
            std::process::exit(1);
        }
    }

    // Initialize P2P networking
    info!("Initializing P2P networking...");
    if let Err(e) = network.start().await {
        error!("Failed to start P2P networking: {}", e);
        std::process::exit(1);
    }

    // Start consensus engine
    info!("Starting consensus engine...");
    if let Err(e) = core.start_consensus().await {
        error!("Failed to start consensus engine: {}", e);
        std::process::exit(1);
    }

    // Start federation manager
    info!("Starting federation manager...");
    if let Err(e) = federation_manager.start().await {
        error!("Failed to start federation manager: {}", e);
        std::process::exit(1);
    }

    // Set up signal handlers for graceful shutdown
    let core_clone = core.clone();
    let network_clone = network.clone();
    let federation_clone = federation_manager.clone();
    
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.expect("Failed to listen for ctrl+c");
        info!("Received shutdown signal, initiating graceful shutdown...");
        
        // Shutdown sequence
        if let Err(e) = federation_clone.stop().await {
            error!("Error stopping federation manager: {}", e);
        }
        if let Err(e) = network_clone.stop().await {
            error!("Error stopping P2P networking: {}", e);
        }
        if let Err(e) = core_clone.stop().await {
            error!("Error stopping core system: {}", e);
        }
        
        info!("Node shutdown completed");
        std::process::exit(0);
    });

    info!("ICN node startup complete - running...");

    // Keep the main thread alive
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
}```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
Modified: 2025-03-07 09:09:46.468758092 +0000
Dependencies:

===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./backend/src/api/resources.rs
Size: 10498 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000
Dependencies:
mod tests {
use crate::services::resource_service::{ResourceService, ResourceQuery};
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::resource_service::{ResourceService, ResourceQuery};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct QuerySharedResourcesRequest {
    resource_type: String,
    owner: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
    signature: String, // Add signature field
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingResponse {
    success: bool,
    message: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct TransferResourceRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct AllocateResourceSharesRequest {
    resource_id: String,
    shares: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct CreateLocalClusterRequest {
    cluster_name: String,
    region: String,
    members: Vec<String>,
}

pub fn resource_routes(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(query_shared_resources_handler);

    let share_resource = warp::path!("api" / "v1" / "resources" / "share")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(share_resource_handler);

    let transfer_resource = warp::path!("api" / "v1" / "resources" / "transfer")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(transfer_resource_handler);

    let allocate_resource_shares = warp::path!("api" / "v1" / "resources" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(allocate_resource_shares_handler);

    let create_local_cluster = warp::path!("api" / "v1" / "resources" / "local_cluster" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(create_local_cluster_handler);

    query_shared_resources
        .or(share_resource)
        .or(transfer_resource)
        .or(allocate_resource_shares)
        .or(create_local_cluster)
}

fn with_resource_service(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = (Arc<Mutex<ResourceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || resource_service.clone())
}

async fn query_shared_resources_handler(
    request: QuerySharedResourcesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let query = ResourceQuery {
        resource_type: request.resource_type,
        owner: request.owner,
    };

    let mut service = resource_service.lock().await;
    match service.query_shared_resources(query).await {
        Ok(resources) => {
            // Use EXPLAIN ANALYZE to verify index usage
            let explain_query = format!(
                "EXPLAIN ANALYZE SELECT * FROM resources WHERE resource_type = '{}' AND owner = '{}'",
                request.resource_type,
                request.owner.clone().unwrap_or_default()
            );
            let explain_result = sqlx::query(&explain_query)
                .fetch_all(&service.pool)
                .await
                .map_err(|e| warp::reject::custom(e))?;
            println!("EXPLAIN ANALYZE result: {:?}", explain_result);

            Ok(warp::reply::json(&resources))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn share_resource_handler(
    request: ResourceSharingRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.resource_id, &request.signature, &request.recipient_id).await {
        return Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: "Invalid signature".to_string(),
        }));
    }

    let mut service = resource_service.lock().await;
    match service.share_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: true,
            message: "Resource shared successfully".to_string(),
        })),
        Err(e) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: format!("Failed to share resource: {}", e),
        })),
    }
}

async fn transfer_resource_handler(
    request: TransferResourceRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.transfer_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&"Resource transferred successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn allocate_resource_shares_handler(
    request: AllocateResourceSharesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.allocate_resource_shares(request.resource_id, request.shares).await {
        Ok(_) => Ok(warp::reply::json(&"Resource shares allocated successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn create_local_cluster_handler(
    request: CreateLocalClusterRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = ResourceOperation::CreateLocalCluster {
        cluster_name: request.cluster_name,
        region: request.region,
        members: request.members,
    };

    let mut service = resource_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => Ok(warp::reply::json(&"Local cluster created")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn verify_signature(resource_id: &str, signature: &str, recipient_id: &str) -> bool {
    // Retrieve public key from IdentityService (placeholder)
    let public_key = vec![]; // Replace with actual public key retrieval logic
    let key_pair = KeyPair {
        public_key,
        private_key: vec![], // Not needed for verification
        algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
    };
    key_pair.verify(resource_id.as_bytes(), signature.as_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::resource_service::ResourceService;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_query_shared_resources() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = QuerySharedResourcesRequest {
            resource_type: "test_type".to_string(),
            owner: Some("test_owner".to_string()),
        };

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/resources/query")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_share_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = ResourceSharingRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
            signature: "test_signature".to_string(), // Add signature field
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/share")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_transfer_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = TransferResourceRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/transfer")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_allocate_resource_shares() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = AllocateResourceSharesRequest {
            resource_id: "test_resource".to_string(),
            shares: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_create_local_cluster() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = CreateLocalClusterRequest {
            cluster_name: "test_cluster".to_string(),
            region: "test_region".to_string(),
            members: vec!["member1".to_string(), "member2".to_string()],
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/local_cluster/create")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/identity.rs
Size: 6469 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000
Dependencies:
mod tests {
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use icn_core::verifiable_credentials::{VerifiableCredential, Proof}; // Import VerifiableCredential and Proof
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_zkp::zk_snark; // Import zk-SNARK
use std::sync::Arc;
use warp::Filter;

===================
```rs
use warp::Filter;
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use std::sync::Arc;
use icn_core::verifiable_credentials::{VerifiableCredential, Proof}; // Import VerifiableCredential and Proof
use icn_zkp::zk_snark; // Import zk-SNARK
use icn_crypto::KeyPair; // Import KeyPair for signature verification

pub fn identity_routes(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_identity = warp::path!("api" / "v1" / "identity" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_create_identity);

    let get_identity = warp::path!("api" / "v1" / "identity" / "get" / String)
        .and(warp::get())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_get_identity);

    let rotate_key = warp::path!("api" / "v1" / "identity" / "rotate_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_rotate_key);

    let revoke_key = warp::path!("api" / "v1" / "identity" / "revoke_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_revoke_key);

    create_identity.or(get_identity).or(rotate_key).or(revoke_key)
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn handle_create_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&identity, &identity_service).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    identity_service.create_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate ICN-compliant verifiable credential
    let credential = VerifiableCredential {
        credential_type: "IdentityCredential".to_string(),
        issuer_did: "did:icn:issuer".to_string(),
        subject_did: identity.clone(),
        issuance_date: chrono::Utc::now().to_rfc3339(),
        expiration_date: None,
        credential_status: None,
        credential_schema: None,
        proof: Proof {
            type_: "Ed25519Signature2018".to_string(),
            created: chrono::Utc::now().to_rfc3339(),
            proof_purpose: "assertionMethod".to_string(),
            verification_method: "did:icn:issuer#keys-1".to_string(),
            jws: "example-jws".to_string(),
        },
    };

    Ok(warp::reply::json(&credential))
}

async fn handle_get_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let data = identity_service.get_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate zk-SNARK proof for identity validation
    let proof = zk_snark::generate_proof(&data);

    Ok(warp::reply::json(&proof))
}

async fn handle_rotate_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.rotate_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key rotated", warp::http::StatusCode::OK))
}

async fn handle_revoke_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.revoke_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key revoked", warp::http::StatusCode::OK))
}

async fn verify_signature(identity: &str, identity_service: &Arc<dyn IdentityService>) -> bool {
    if let Some(public_key) = identity_service.get_public_key(identity).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(identity.as_bytes(), identity.as_bytes());
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::identity_service::IdentityServiceImpl;
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_create_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/create")
            .json(&"did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::CREATED);
    }

    #[tokio::test]
    async fn test_get_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/identity/get/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_rotate_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/rotate_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_revoke_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/revoke_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/federation.rs
Size: 25289 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000
Dependencies:
use futures::future::join_all; // Import join_all for concurrency
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_federation::{FederationService, FederationOperation};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_federation::{FederationService, FederationOperation};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use futures::future::join_all; // Import join_all for concurrency

#[derive(Debug, Deserialize, Serialize)]
struct InitiateFederationRequest {
    federation_type: String,
    partner_id: String,
    terms: String,
    signature: String, // Add signature field
}

#[derive(Debug, Deserialize, Serialize)]
struct JoinFederationRequest {
    federation_id: String,
    commitment: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct SubmitProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize, Serialize)]
struct SubmitDisputeRequest {
    federation_id: String,
    reason: String,
    evidence: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct DisputeVoteRequest {
    dispute_id: String,
    support: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct TransferResourceRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct AllocateResourceSharesRequest {
    resource_id: String,
    shares: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct CreateLocalClusterRequest {
    cluster_name: String,
    region: String,
    members: Vec<String>,
}

pub fn federation_routes(
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to federation_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let initiate_federation = warp::path!("api" / "v1" / "federation" / "initiate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(initiate_federation_handler);

    let join_federation = warp::path!("api" / "v1" / "federation" / "join")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(join_federation_handler);

    let initiate_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolve")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(initiate_federation_dissolution_handler);

    let get_dissolution_status = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "status")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_dissolution_status_handler);

    let cancel_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "cancel")
        .and(warp::post())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(cancel_federation_dissolution_handler);

    let get_asset_distribution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "assets")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_asset_distribution_handler);

    let get_debt_settlements = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "debts")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(get_debt_settlements_handler);

    let submit_proposal = warp::path!("api" / "v1" / "federation" / "proposals" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(submit_proposal_handler);

    let vote = warp::path!("api" / "v1" / "federation" / "proposals" / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(vote_handler);

    let sybil_resistance = warp::path!("api" / "v1" / "federation" / "sybil_resistance")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(sybil_resistance_handler);

    let reputation_decay = warp::path!("api" / "v1" / "federation" / "reputation_decay")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(reputation_decay_handler);

    let submit_dissolution_dispute = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "dispute")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(submit_dissolution_dispute_handler);

    let vote_on_dispute = warp::path!("api" / "v1" / "federation" / "disputes" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(vote_on_dispute_handler);

    let federation_lifecycle = warp::path!("api" / "v1" / "federation" / "lifecycle")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(federation_lifecycle_handler);

    let transfer_resource = warp::path!("api" / "v1" / "federation" / "resources" / "transfer")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(transfer_resource_handler);

    let allocate_resource_shares = warp::path!("api" / "v1" / "federation" / "resources" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(allocate_resource_shares_handler);

    let create_local_cluster = warp::path!("api" / "v1" / "federation" / "local_cluster" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(create_local_cluster_handler);

    initiate_federation
        .or(join_federation)
        .or(initiate_federation_dissolution)
        .or(get_dissolution_status)
        .or(cancel_federation_dissolution)
        .or(get_asset_distribution)
        .or(get_debt_settlements)
        .or(submit_proposal)
        .or(vote)
        .or(sybil_resistance)
        .or(reputation_decay)
        .or(submit_dissolution_dispute)
        .or(vote_on_dispute)
        .or(federation_lifecycle)
        .or(transfer_resource)
        .or(allocate_resource_shares)
        .or(create_local_cluster)
}

fn with_federation_service(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = (Arc<Mutex<FederationService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || federation_service.clone())
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

// Replace direct error returns with the unified error type
async fn initiate_federation_handler(
    request: InitiateFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.partner_id, &request.signature, &request.federation_type).await {
        return Err(warp::reject::custom(IcnError::ValidationError("Invalid signature".to_string())));
    }

    let operation = FederationOperation::InitiateFederation {
        federation_type: request.federation_type,
        partner_id: request.partner_id,
        terms: request.terms,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::InitiateFederation {
                federation_type: request.federation_type,
                partner_id: request.partner_id,
                terms: request.terms,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(IcnError::NetworkError(e.to_string())));
            }
            Ok(warp::reply::json(&"Federation initiated"))
        },
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e))),
    }
}

async fn join_federation_handler(
    request: JoinFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::JoinFederation {
        federation_id: request.federation_id.clone(),
        commitment: request.commitment.clone(),
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::JoinRequest {
                federation_id: request.federation_id,
                member_did: request.commitment,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Joined federation"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn initiate_federation_dissolution_handler(
    federation_id: String,
    request: DissolutionRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    let protocol = service.initiate_dissolution(&federation_id, &request.initiator_id, request.reason.clone()).await?;
    // Publish event
    let event = FederationEvent::InitiateDissolution {
        federation_id: federation_id.clone(),
        initiator_id: request.initiator_id.clone(),
        reason: request.reason.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&protocol))
}

async fn get_dissolution_status_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let status = service.get_federation_dissolution_status(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetDissolutionStatus {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&status))
}

async fn cancel_federation_dissolution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    service.cancel_dissolution(&federation_id).await?;
    // Publish event
    let event = FederationEvent::CancelDissolution {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&"Dissolution cancelled"))
}

async fn get_asset_distribution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let distribution = service.calculate_asset_distribution(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetAssetDistribution {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&distribution))
}

async fn get_debt_settlements_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let settlements = service.settle_outstanding_debts(&federation_id).await?;
    // Publish event
    let event = FederationEvent::GetDebtSettlements {
        federation_id: federation_id.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }
    Ok(warp::reply::json(&settlements))
}

async fn submit_proposal_handler(
    request: SubmitProposalRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.submit_proposal(request.title, request.description, request.created_by, request.ends_at).await {
        Ok(proposal_id) => {
            // Publish event
            let event = FederationEvent::SubmitProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_handler(
    request: VoteRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.vote(request.proposal_id, request.voter, request.approve).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn sybil_resistance_handler(
    request: SybilResistanceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.handle_sybil_resistance(request.did, request.reputation_score).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::SybilResistance {
                did: request.did,
                reputation_score: request.reputation_score,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Sybil resistance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn reputation_decay_handler(
    request: ReputationDecayRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.apply_reputation_decay(request.did, request.decay_rate).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::ReputationDecay {
                did: request.did,
                decay_rate: request.decay_rate,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Reputation decay applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn submit_dissolution_dispute_handler(
    federation_id: String,
    request: SubmitDisputeRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.submit_dissolution_dispute(&federation_id, request.reason, request.evidence).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::SubmitDissolutionDispute {
                federation_id: federation_id.clone(),
                reason: request.reason,
                evidence: request.evidence.clone(),
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Dispute submitted successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_dispute_handler(
    dispute_id: String,
    request: DisputeVoteRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.vote_on_dispute(&dispute_id, request.support).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::VoteOnDispute {
                dispute_id: dispute_id.clone(),
                support: request.support,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn federation_lifecycle_handler(
    request: FederationLifecycleRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::Lifecycle {
        federation_id: request.federation_id,
        action: request.action,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::Lifecycle {
                federation_id: request.federation_id,
                action: request.action,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Federation lifecycle operation completed"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn transfer_resource_handler(
    request: TransferResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.transfer_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::TransferResource {
                resource_id: request.resource_id,
                recipient_id: request.recipient_id,
                amount: request.amount,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Resource transferred successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn allocate_resource_shares_handler(
    request: AllocateResourceSharesRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    match service.allocate_resource_shares(request.resource_id, request.shares).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::AllocateResourceShares {
                resource_id: request.resource_id,
                shares: request.shares,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Resource shares allocated successfully"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn create_local_cluster_handler(
    request: CreateLocalClusterRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::CreateLocalCluster {
        cluster_name: request.cluster_name,
        region: request.region,
        members: request.members,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::CreateLocalCluster {
                cluster_name: request.cluster_name,
                region: request.region,
                members: request.members,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Local cluster created"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn verify_signature(did: &str, signature: &str, message: &str) -> bool {
    // Retrieve public key from IdentityService (placeholder)
    let public_key = vec![]; // Replace with actual public key retrieval logic
    let key_pair = KeyPair {
        public_key,
        private_key: vec![], // Not needed for verification
        algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
    };
    key_pair.verify(message.as_bytes(), signature.as_bytes())
}
```

===================
File: ./backend/src/api/reputation.rs
Size: 10381 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000
Dependencies:
mod tests {
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution, handle_sybil_resistance, apply_reputation_decay, batch_reputation_updates};
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use icn_networking::p2p::{P2PManager, ReputationEvent}; // Import P2PManager and ReputationEvent
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;
use zk_snarks::verify_proof; // Import zk-SNARK verification function

===================
```rs
use warp::Filter;
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution, handle_sybil_resistance, apply_reputation_decay, batch_reputation_updates};
use icn_networking::p2p::{P2PManager, ReputationEvent}; // Import P2PManager and ReputationEvent
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct ZkSnarkProofRequest {
    proof: String,
    did: String,
    signature: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize, Serialize)]
struct BatchReputationUpdateRequest {
    events: Vec<ReputationEvent>,
}

pub fn reputation_routes(
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to reputation_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path("api")
        .and(
            warp::path("v1")
                .and(
                    warp::path("reputation")
                        .and(
                            warp::path("get")
                                .and(warp::get())
                                .and(warp::query::<String>())
                                .and_then(get_reputation)
                        )
                        .or(
                            warp::path("adjust")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(adjust_reputation)
                        )
                        .or(
                            warp::path("verify")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(verify_contribution)
                        )
                        .or(
                            warp::path("zk_snark_proof")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(submit_zk_snark_proof_handler)
                        )
                        .or(
                            warp::path("sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance)
                        )
                        .or(
                            warp::path("reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay)
                        )
                        .or(
                            warp::path("apply_reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay_handler)
                        )
                        .or(
                            warp::path("handle_sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance_handler)
                        )
                        .or(
                            warp::path("batch_updates")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(batch_reputation_updates_handler)
                        )
                )
        )
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

async fn submit_zk_snark_proof_handler(
    request: ZkSnarkProofRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.did, &request.signature, &request.proof).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    // Verify zk-SNARK proof
    if !verify_proof(&request.proof) {
        return Err(warp::reject::custom("Invalid zk-SNARK proof"));
    }

    // Publish event
    let event = ReputationEvent::ZkSnarkProofSubmitted {
        proof: request.proof.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }

    // Placeholder logic for zk-SNARK proof submission
    Ok(warp::reply::json(&"zk-SNARK proof submitted"))
}

async fn verify_signature(did: &str, signature: &str, message: &str) -> bool {
    // Retrieve public key from IdentityService
    if let Some(public_key) = get_public_key(did).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(message.as_bytes(), signature.as_bytes());
    }
    false
}

async fn get_public_key(did: &str) -> Option<Vec<u8>> {
    // Placeholder function to retrieve public key
    Some(vec![]) // Replace with actual implementation
}

async fn apply_reputation_decay_handler(
    request: ReputationDecayRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to apply reputation decay
    apply_reputation_decay_in_ledger(&request.did, request.decay_rate).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Reputation decay applied"))
}

async fn handle_sybil_resistance_handler(
    request: SybilResistanceRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to handle sybil resistance
    handle_sybil_resistance_in_ledger(&request.did, request.reputation_score).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Sybil resistance handled"))
}

async fn batch_reputation_updates_handler(
    request: BatchReputationUpdateRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Publish events
    let publish_futures = request.events.iter().map(|event| {
        let p2p = p2p_manager.clone();
        async move {
            let mut p2p = p2p.lock().await;
            p2p.publish(event.clone()).await
        }
    });

    let results = futures::future::join_all(publish_futures).await;
    for result in results {
        if let Err(e) = result {
            return Err(warp::reject::custom(e));
        }
    }

    // Placeholder logic for batch reputation updates
    Ok(warp::reply::json(&"Batch reputation updates applied"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::reputation_service::{ReputationService, ReputationServiceImpl};
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_submit_zk_snark_proof() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/zk_snark_proof")
            .json(&ZkSnarkProofRequest { proof: "test_proof".to_string(), did: "did:icn:test".to_string(), signature: "test_signature".to_string() })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/reputation_decay")
            .json(&ReputationDecayRequest { did: "did:icn:test".to_string(), decay_rate: 0.1 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/sybil_resistance")
            .json(&SybilResistanceRequest { did: "did:icn:test".to_string(), reputation_score: 50 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_batch_reputation_updates() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let events = vec![
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof1".to_string() },
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof2".to_string() },
        ];

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/batch_updates")
            .json(&BatchReputationUpdateRequest { events })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/governance.rs
Size: 15526 bytes
Modified: 2025-03-07 09:09:46.428789273 +0000
Dependencies:
use crate::services::governance_service::{GovernanceService, Proposal, Vote};
use crate::services::identity_service::IdentityService; // Import IdentityService
use futures::future::join_all; // Import join_all for concurrency
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_networking::p2p::{P2PManager, GovernanceEvent}; // Import P2PManager and GovernanceEvent
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::governance_service::{GovernanceService, Proposal, Vote};
use icn_networking::p2p::{P2PManager, GovernanceEvent}; // Import P2PManager and GovernanceEvent
use crate::services::identity_service::IdentityService; // Import IdentityService
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use futures::future::join_all; // Import join_all for concurrency

#[derive(Debug, Deserialize, Serialize)]
struct CreateProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
    did: String, // Add did field for DID-based access control
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
    zk_snark_proof: String, // Added zk-SNARK proof field
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize)]
struct RecallVoteRequest {
    target_member: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct DelegatedGovernanceRequest {
    federation_id: String,
    representative_id: String,
}

pub fn governance_routes(
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to governance_routes
    identity_service: Arc<dyn IdentityService>, // Add IdentityService to governance_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_proposal = warp::path!("api" / "v1" / "governance" / "proposals")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(create_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let sybil_resistance = warp::path!("api" / "v1" / "governance" / "sybil_resistance")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(sybil_resistance_handler);

    let reputation_decay = warp::path!("api" / "v1" / "governance" / "reputation_decay")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(reputation_decay_handler);

    let proposal_status = warp::path!("api" / "v1" / "governance" / "proposals" / String / "status")
        .and(warp::get())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(proposal_status_handler);

    let submit_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(submit_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let delegated_governance = warp::path!("api" / "v1" / "governance" / "delegated")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(delegated_governance_handler);

    create_proposal
        .or(vote_on_proposal)
        .or(sybil_resistance)
        .or(reputation_decay)
        .or(proposal_status)
        .or(submit_proposal)
        .or(vote_on_proposal)
        .or(delegated_governance)
}

fn with_governance_service(
    governance_service: Arc<Mutex<GovernanceService>>,
) -> impl Filter<Extract = (Arc<Mutex<GovernanceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || governance_service.clone())
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn create_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::CreateProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn sybil_resistance_handler(
    request: SybilResistanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_sybil_resistance(request.did, request.reputation_score).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::SybilResistance {
                did: request.did,
                reputation_score: request.reputation_score,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Sybil resistance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn reputation_decay_handler(
    request: ReputationDecayRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.apply_reputation_decay(request.did, request.decay_rate).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::ReputationDecay {
                did: request.did,
                decay_rate: request.decay_rate,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Reputation decay applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn proposal_status_handler(
    proposal_id: String,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = governance_service.lock().await;
    match service.get_proposal_status(&proposal_id).await {
        Ok(status) => {
            // Publish event
            let event = GovernanceEvent::ProposalStatus {
                proposal_id: proposal_id.clone(),
                status: status.clone(),
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&status))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn submit_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::SubmitProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn delegated_governance_handler(
    request: DelegatedGovernanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_delegated_governance(request.federation_id, request.representative_id).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::DelegatedGovernance {
                federation_id: request.federation_id,
                representative_id: request.representative_id,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Delegated governance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}
```

===================
File: ./backend/src/lib.rs
Size: 982 bytes
Modified: 2025-03-07 09:37:23.560766185 +0000
Dependencies:

===================
```rs
pub mod api;
pub mod services;
pub mod database;
pub mod networking;
pub mod core;
pub mod main;

pub mod db;
pub mod models;
pub mod blockchain;
pub mod federation;
pub mod governance;
pub mod identity;
pub mod notification;
pub mod reputation;
pub mod resources;
pub mod vm;

// Re-export for the integration tests
pub use blockchain::Blockchain;
pub use governance::{Proposal, ProposalType, ProposalStatus, ProposalHistory, Federation, FederationType, FederationTerms, MemberRole, MemberStatus, handle_federation_operation};
pub use identity::{DID, Algorithm, DIDError, IdentitySystem};
pub use reputation::ReputationSystem;
pub use vm::{VM, opcode, cooperative_metadata};
pub use notification::NotificationManager;

#[cfg(test)]
pub mod test_utils;
#[cfg(test)]
pub mod test_config;
#[cfg(test)]
pub mod test_macros;

// Re-export test utilities for integration tests
#[cfg(test)]
pub use test_utils::*;
#[cfg(test)]
pub use test_config::*;
#[cfg(test)]
pub use test_macros::*;
```

===================
File: ./backend/src/main.rs
Size: 7420 bytes
Modified: 2025-03-07 09:40:20.491383674 +0000
Dependencies:
mod api;
mod config;
mod core;
mod db;
mod federation;
mod middleware;
mod networking; // Add networking module
mod notification;
mod reputation;
mod websocket;
use async_trait::async_trait;
use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::create_pool;
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use dashmap::DashMap;
use dotenv::dotenv;
use env_logger;
use futures_util::StreamExt;
use icn_backend::api::ApiServer;
use icn_backend::core::Core;
use icn_backend::database::Database;
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use log::{info, error};
use middleware::rate_limit::with_rate_limit;
use middleware::rate_limit::with_reputation_rate_limit;
use networking::p2p::{P2PManager, FederationEvent, GovernanceEvent, IdentityEvent, ReputationEvent}; // Import P2PManager and events
use reqwest::Client;
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::env;
use std::sync::Arc;
use thiserror::Error;
use tokio;
use tokio::signal;
use warp::cors::Cors;
use warp::{Filter, ws::{WebSocket, Message}};
use warp::http::Method;

===================
```rs
mod config;
mod core;
mod db;
mod federation;
mod notification;
mod reputation;
mod websocket;
mod middleware;
mod api;
mod networking; // Add networking module

use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use tokio;
use log::{info, error};
use env_logger;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use futures_util::StreamExt;
use warp::{Filter, ws::{WebSocket, Message}};
use dashmap::DashMap;
use sqlx::PgPool;
use thiserror::Error;
use reqwest::Client;
use tokio::signal;
use async_trait::async_trait;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use warp::http::Method;
use warp::cors::Cors;
use crate::db::create_pool;
use middleware::rate_limit::with_rate_limit;
use middleware::rate_limit::with_reputation_rate_limit;
use networking::p2p::{P2PManager, FederationEvent, GovernanceEvent, IdentityEvent, ReputationEvent}; // Import P2PManager and events
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_backend::api::ApiServer;
use icn_backend::core::Core;
use icn_backend::database::Database;
use dotenv::dotenv;
use std::env;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    #[error("Validation error: {0}")]
    ValidationError(String),
}

#[derive(Serialize, Deserialize)]
struct Proposal {
    id: String,
    title: String,
    description: String,
    status: String,
    votes_for: i64,
    votes_against: i64,
    created_by: String,
    ends_at: String,
}

#[derive(Serialize, Deserialize)]
struct Vote {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Serialize, Deserialize)]
struct TokenizedResource {
    resource_id: String,
    owner: String,
    quantity: u64,
    price_per_unit: f64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Load environment variables from .env file if present
    dotenv().ok();
    
    // Initialize logging
    env_logger::init();
    
    info!("Starting ICN backend...");
    
    // Get port from environment variable or default to 8080
    let port = env::var("PORT")
        .unwrap_or_else(|_| "8080".to_string())
        .parse::<u16>()
        .unwrap_or(8080);
    
    // Create the core system
    let core = Core::new();
    
    // Start core services
    core.start().await?;
    
    info!("Core services started.");
    
    // Create API server with core services
    let api_server = ApiServer::new(
        port,
        core.blockchain_service.clone(),
        core.identity_service.clone(),
        core.governance_service.clone(),
    );
    
    info!("Starting API server on port {}", port);
    
    // Run the server (this will block until the server exits)
    api_server.run().await?;
    
    info!("API server stopped. Shutting down...");
    
    // Graceful shutdown
    core.shutdown().await?;
    
    info!("ICN backend stopped.");
    
    Ok(())
}

async fn handle_federation_operation(operation: FederationOperation, notification_manager: NotificationManager) -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle federation operations
    let subject = match &operation {
        FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
            format!("Federation Initiated: {:?}", federation_type)
        }
        FederationOperation::JoinFederation { federation_id, commitment } => {
            format!("Joined Federation: {}", federation_id)
        }
        FederationOperation::LeaveFederation { federation_id, reason } => {
            format!("Left Federation: {}", federation_id)
        }
        FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
            format!("Action Proposed in Federation: {}", federation_id)
        }
        FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
            format!("Vote on Federation Proposal: {}", proposal_id)
        }
        FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
            format!("Resources Shared in Federation: {}", federation_id)
        }
        FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
            format!("Federation Terms Updated: {}", federation_id)
        }
    };

    let body = format!("Federation operation executed: {:?}", operation);
    notification_manager.send_notification(&subject, &body).await;
    Ok(warp::reply::json(&operation))
}

async fn handle_query_shared_resources() -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle querying shared resources
    let resources = vec![
        TokenizedResource {
            resource_id: "resource1".to_string(),
            owner: "did:icn:owner1".to_string(),
            quantity: 100,
            price_per_unit: 10.0,
        },
        TokenizedResource {
            resource_id: "resource2".to_string(),
            owner: "did:icn:owner2".to_string(),
            quantity: 200,
            price_per_unit: 20.0,
        },
    ];
    Ok(warp::reply::json(&resources))
}

struct DatabaseStorageBackend {
    pool: PgPool,
}

impl DatabaseStorageBackend {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.exists.unwrap_or(false))
    }
}

fn main() {
    println!("ICN backend is running!");
}
```

===================
File: ./icn-consensus/src/lib.rs
Size: 1234 bytes
Modified: 2025-03-07 09:09:46.468758092 +0000
Dependencies:

===================
```rs
// ...existing code...

// Define the structure for cooperative governance rules
struct GovernanceRules {
    max_validators: usize,
    min_stake: u64,
    election_period: u64,
    // ...other rules...
}

// Define the structure for a validator
struct Validator {
    id: String,
    stake: u64,
    // ...other properties...
}

// Define the structure for the genesis block
struct GenesisBlock {
    initial_validators: Vec<Validator>,
    // ...other properties...
}

// Function to enforce cooperative governance rules
fn enforce_governance_rules(validators: &mut Vec<Validator>, rules: &GovernanceRules) {
    // Implement rules to prevent centralized control
    // ...code to enforce rules...
}

// Function to finalize the genesis block format
fn finalize_genesis_block(validators: Vec<Validator>) -> GenesisBlock {
    GenesisBlock {
        initial_validators: validators,
        // ...initialize other properties...
    }
}

// Function to develop a validator election mechanism
fn elect_validators(current_validators: &Vec<Validator>, candidates: &Vec<Validator>, rules: &GovernanceRules) -> Vec<Validator> {
    // Implement democratic election mechanism
    // ...code to elect validators...
}

// ...existing code...
```

===================
File: ./contracts/cooperative/src/lib.rs
Size: 1284 bytes
Modified: 2025-03-07 09:09:46.438781479 +0000
Dependencies:
mod proposals;
use ethers::prelude::*;
use icn_zkp::{RollupBatch, VerificationKey};
use proposals::{ProposalContract, Proposal};

===================
```rs
mod proposals;

use proposals::{ProposalContract, Proposal};
use icn_zkp::{RollupBatch, VerificationKey};
use ethers::prelude::*;

pub struct CooperativeContract {
    proposal_contract: ProposalContract,
    contract_address: Address,
    // ...existing code...
}

impl CooperativeContract {
    pub fn new(contract_address: Address, verification_key: VerificationKey) -> Self {
        Self {
            proposal_contract: ProposalContract::new(
                3,
                verification_key,
                contract_address
            ),
            contract_address,
            // ...existing code...
        }
    }

    pub async fn submit_vote_batch(&mut self, batch: RollupBatch) -> Result<(), String> {
        self.proposal_contract.submit_vote_batch(batch).await
    }

    pub async fn execute_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        self.proposal_contract.execute_proposal(proposal_id).await
    }

    pub async fn submit_zk_snark_proof(&self, proof: Vec<u8>) -> Result<(), String> {
        // Implement zk-SNARK proof submission logic
        Ok(())
    }

    pub async fn verify_zk_snark_proof(&self, proof: Vec<u8>) -> Result<bool, String> {
        // Implement zk-SNARK proof verification logic
        Ok(true)
    }
}
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 7207 bytes
Modified: 2025-03-07 09:37:25.309018331 +0000
Dependencies:
mod tests {
use async_trait::async_trait;
use icn_dsl::CoopLangAST;
use icn_types::{
use std::collections::HashMap;
use tracing::{info, warn, error};
use zk_snarks::verify_proof; // Import zk-SNARK verification function

===================
```rs
use async_trait::async_trait;
use icn_types::{
    Block, Transaction, RuntimeError, RuntimeResult, ExecutionContext,
    ValidationNode, GovernanceNode, MarketplaceNode, Check, StateValidation,
    RuntimeConfig
};
use icn_dsl::CoopLangAST;
use tracing::{info, warn, error};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::collections::HashMap;

/// Runtime interface trait for blockchain execution
#[async_trait]
pub trait VM {
    /// Executes a single transaction
    async fn execute_transaction(&self, transaction: Transaction) -> RuntimeResult<()>;
    
    /// Executes all transactions in a block
    async fn execute_block(&self, block: Block) -> RuntimeResult<()>;
}

/// Contract execution handler
pub struct ContractExecution {
    /// Map of contract addresses to their byte code
    contracts: HashMap<String, Vec<u8>>,
    /// Storage for contract state
    state: HashMap<String, Vec<u8>>,
    /// Maximum gas allowed for execution
    max_gas: u64,
}

impl ContractExecution {
    /// Create a new contract execution environment
    pub fn new(max_gas: u64) -> Self {
        Self {
            contracts: HashMap::new(),
            state: HashMap::new(),
            max_gas,
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        if self.contracts.contains_key(&address) {
            return Err("Contract already exists at this address".to_string());
        }
        self.contracts.insert(address, bytecode);
        Ok(())
    }
    
    /// Execute a contract call
    pub async fn execute_contract_call(&mut self, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        if gas > self.max_gas {
            return Err("Gas limit exceeded".to_string());
        }
        
        let contract = self.contracts.get(address).ok_or("Contract not found")?;
        
        // In a real implementation, this would actually execute the bytecode
        // For testing purposes, we just return a dummy result
        Ok(vec![1, 2, 3])
    }
}

/// Runtime manager for handling contract execution
pub struct RuntimeManager {
    /// Execution environment
    execution: ContractExecution,
    /// Map of transaction hashes to execution results
    results: HashMap<String, Vec<u8>>,
}

impl RuntimeManager {
    /// Create a new runtime manager
    pub fn new(max_gas: u64) -> Self {
        Self {
            execution: ContractExecution::new(max_gas),
            results: HashMap::new(),
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        self.execution.deploy_contract(address, bytecode)
    }
    
    /// Execute a transaction
    pub async fn execute_transaction(&mut self, tx_hash: String, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        let result = self.execution.execute_contract_call(address, input, gas).await?;
        self.results.insert(tx_hash, result.clone());
        Ok(result)
    }
    
    /// Get transaction result
    pub fn get_transaction_result(&self, tx_hash: &str) -> Option<&Vec<u8>> {
        self.results.get(tx_hash)
    }
}

#[async_trait]
pub trait ValidationExecutor {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()>;
}

#[async_trait]
impl ValidationExecutor for RuntimeManager {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()> {
        // Execute pre-checks
        for check in &validation.pre_checks {
            info!("Executing pre-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        // Validate state if specified
        if let Some(state_validation) = &validation.state_validation {
            info!("Validating state");
            self.validate_state(state_validation, context).await?;
        }

        // Execute post-checks
        for check in &validation.post_checks {
            info!("Executing post-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        Ok(())
    }

    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()> {
        let condition_result = self.evaluate_condition(&check.condition, context).await?;
        if !condition_result {
            error!("Check failed: {}", check.action);
            return Err(RuntimeError::ValidationFailed(check.action.clone()));
        }
        Ok(())
    }

    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()> {
        let current_state = self.get_current_state(context).await?;

        // Validate current state if specified
        if let Some(expected_current) = &validation.current {
            if current_state != *expected_current {
                error!("Invalid state. Expected: {}, Found: {}", expected_current, current_state);
                return Err(RuntimeError::InvalidState);
            }
        }

        // Validate expected state transitions
        if let Some(expected) = &validation.expected {
            if !validation.transitions.contains(expected) {
                error!("Invalid state transition to: {}", expected);
                return Err(RuntimeError::InvalidState);
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_types::{Block, Transaction};

    #[tokio::test]
    async fn test_runtime_initialization() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        assert!(runtime.dsl_context.is_none());
    }

    #[tokio::test]
    async fn test_validation_rules() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        
        let context = ExecutionContext {
            transaction: None,
            block: None,
            state: HashMap::new(),
            metadata: HashMap::new(),
        };

        let validation = ValidationNode {
            pre_checks: vec![
                Check {
                    condition: "true".to_string(),
                    action: "test".to_string(),
                }
            ],
            post_checks: vec![],
            state_validation: None,
        };

        runtime.execute_validation_rules(&validation, &context).await.unwrap();
    }
}
```

===================
File: ./crates/icn-reputation/src/lib.rs
Size: 2471 bytes
Modified: 2025-03-07 11:34:43.196692022 +0000
Dependencies:
use async_trait::async_trait;
use icn_storage::StorageInterface;
use icn_types::ReputationError;
use icn_zkp::zk_snark;
use serde::{Serialize, Deserialize};
use std::sync::Arc;

===================
```rs
use serde::{Serialize, Deserialize};
use icn_zkp::zk_snark;
use std::sync::Arc;
use async_trait::async_trait;
use icn_types::ReputationError;
use icn_storage::StorageInterface;

#[derive(Debug, Serialize, Deserialize)]
pub struct ReputationScore {
    pub score: i64,
}

impl ReputationScore {
    pub fn generate_proof(&self) -> Vec<u8> {
        // Generate zk-SNARK proof for the reputation score
        zk_snark::generate_proof(self.score)
    }

    pub fn verify_proof(proof: &[u8], expected_score: i64) -> bool {
        // Verify zk-SNARK proof for the reputation score
        zk_snark::verify_proof(proof, expected_score)
    }
}

#[async_trait::async_trait]
pub trait ReputationInterface: Send + Sync {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError>;
    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError>;
    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError>;
}

pub struct ReputationManager {
    store: Arc<dyn StorageInterface>,
}

impl ReputationManager {
    pub fn new(store: Arc<dyn StorageInterface>) -> Self {
        Self { store }
    }
}

#[async_trait::async_trait]
impl ReputationInterface for ReputationManager {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError> {
        let current = self.get_reputation(member_id).await.unwrap_or(0);
        let new_score = current + delta;
        
        self.store.store(&format!("reputation:{}", member_id), &new_score.to_le_bytes())
            .await
            .map_err(|e| ReputationError { message: e.to_string() })
    }

    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError> {
        match self.store.get(&format!("reputation:{}", member_id)).await {
            Ok(bytes) => {
                let score = i64::from_le_bytes(bytes.try_into().map_err(|_| ReputationError {
                    message: "Invalid reputation data format".to_string()
                })?);
                Ok(score)
            }
            Err(_) => Ok(0) // New members start with 0 reputation
        }
    }

    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError> {
        let current = self.get_reputation(member_id).await?;
        Ok(current >= min_required)
    }
}
```

===================
File: ./crates/icn-governance/src/lib.rs
Size: 9171 bytes
Modified: 2025-03-07 14:33:28.818355410 +0000
Dependencies:
mod tests {
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use thiserror::Error;
use zk_snarks::verify_proof; // Import zk-SNARK verification function

===================
```rs
use thiserror::Error;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use zk_snarks::verify_proof; // Import zk-SNARK verification function

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Invalid rollback - proposal is not in pending state")]
    InvalidRollback,
    #[error("Dispute already exists")]
    DisputeExists,
    #[error("Insufficient reputation to dispute")]
    InsufficientReputation,
    #[error("Invalid dispute resolution")]
    InvalidResolution,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub status: ProposalStatus,
    pub created_at: DateTime<Utc>,
    pub votes: HashMap<String, Vote>,
    pub disputes: Vec<Dispute>,
    pub execution_history: Vec<ExecutionEvent>,
    pub phase: ProposalPhase,
    pub required_signers: Vec<String>,
    pub collected_signatures: Vec<String>,
    pub state: ProposalState,
    pub dispute_resolution: Option<DisputeResolution>,
    pub timeout_timestamp: u64,
    pub zk_snark_proof: Option<String>, // Added zk-SNARK proof field
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Active,
    Approved,
    Rejected,
    Disputed,
    RolledBack,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalPhase {
    Submission,
    Deliberation { ends_at: DateTime<Utc> },
    Voting { ends_at: DateTime<Utc> },
    Execution,
    Reconsideration { reason: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
    pub reputation: i64,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dispute {
    pub id: String,
    pub proposal_id: String,
    pub disputer: String,
    pub reason: String,
    pub evidence: String,
    pub arbitrator_did: Option<String>,
    pub resolution: Option<Resolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resolution {
    pub decision: DecisionType,
    pub rationale: String,
    pub signatures: Vec<String>, // Requires 75% of arbitrators
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DissolutionProtocol {
    pub federation_id: String,
    pub initiated_by: String,
    pub reason: DissolutionReason,
    pub status: DissolutionStatus,
    pub asset_distribution: HashMap<String, u64>,
    pub debt_settlements: Vec<String>,
    pub member_reassignments: Vec<String>,
    pub dispute_period_ends: std::time::SystemTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionReason {
    Voluntary,
    InactivityThreshold,
    GovernanceFailure,
    ResourceDepletion,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionStatus {
    Initiated,
    UnderReview,
    Approved,
    Rejected,
    Completed,
}

#[derive(Debug)]
pub struct AssetAllocation {
    asset_id: String,
    recipient_id: String,
    allocation_share: f64,
}

#[derive(Debug)]
pub struct DebtSettlement {
    creditor_id: String,
    debtor_id: String,
    amount: f64,
    due_date: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct MemberReassignment {
    member_id: String,
    new_federation_id: Option<String>,
    transition_period: chrono::Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionThresholds {
    pub resource_allocation_threshold: u64,
    pub technical_effort_threshold: u32, // in days
    pub financial_impact_threshold: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationControls {
    pub max_gap_multiplier: f64,
    pub decay_threshold_multiplier: f64,
    pub monthly_decay_rate: f64,
    pub equity_bonus_groups: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VotingModel {
    Equal,
    Proportional { cap_percentage: u8 },
    Hybrid {
        governance_model: Box<VotingModel>,
        resource_model: Box<VotingModel>,
    },
}

impl VotingModel {
    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match self {
            VotingModel::Equal => 1.0,
            VotingModel::Proportional { cap_percentage } => {
                let power = federation.get_cooperative_weight(cooperative_id);
                power.min(*cap_percentage as f64 / 100.0)
            },
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Use different models based on proposal type
                // ...existing code...
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationManager {
    pub controls: ReputationControls,
    reputation_scores: HashMap<String, f64>,
    last_decay_check: DateTime<Utc>,
}

impl ReputationManager {
    pub fn apply_anti_oppression_mechanisms(&mut self) {
        let avg_reputation = self.calculate_average_reputation();
        
        for score in self.reputation_scores.values_mut() {
            if *score > avg_reputation * self.controls.decay_threshold_multiplier {
                *score *= 1.0 - self.controls.monthly_decay_rate;
            }
        }
    }
    
    // ...existing code...
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalState {
    Draft,
    UnderReview,
    Voting,
    DisputeResolution,
    Finalized,
    TimedOut,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub initiator: String,
    pub reason: String, 
    pub mediators: Vec<String>,
    pub resolution: Option<String>,
    pub votes: HashMap<String, bool>,
    pub evidence: Vec<EvidenceItem>,
}

impl Proposal {
    pub fn transition_state(&mut self, new_state: ProposalState) -> Result<(), String> {
        match (&self.state, &new_state) {
            (ProposalState::Draft, ProposalState::UnderReview) => Ok(()),
            (ProposalState::UnderReview, ProposalState::Voting) => Ok(()),
            (ProposalState::Voting, ProposalState::DisputeResolution) => Ok(()),
            (ProposalState::DisputeResolution, ProposalState::Finalized) => Ok(()),
            _ => Err("Invalid state transition".to_string())
        }
        self.state = new_state;
        Ok(())
    }
    
    pub fn initiate_dispute(&mut self, initiator: String, reason: String) -> Result<(), String> {
        if self.state != ProposalState::Voting {
            return Err("Can only initiate dispute during voting phase".to_string());
        }
        
        if let Some(proof) = &self.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        
        self.dispute_resolution = Some(DisputeResolution {
            initiator,
            reason,
            mediators: vec![],
            resolution: None,
            votes: HashMap::new(),
            evidence: vec![],
        });
        
        self.transition_state(ProposalState::DisputeResolution)
    }

    pub async fn execute_proposal(&self) -> bool {
        if let Some(proof) = &self.zk_snark_proof {
            if verify_proof(proof) {
                execute_approved_action();
                return true;
            }
        }
        false
    }
}

fn verify_proof(proof: &str) -> bool {
    // Implement zk-SNARK proof verification logic
    true
}

fn execute_approved_action() {
    // Implement the action to be executed upon proposal approval
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_reputation_decay() {
        let gov = GovernanceService::new(db_pool).await;
        
        // Test normal decay
        let result = gov.apply_decay("did:icn:test", 0.1).await;
        assert!(result.is_ok());
        
        // Test maximum decay limit
        let result = gov.apply_decay("did:icn:test", 0.9).await;
        assert!(result.is_err());
        
        // Test decay exemption
        let result = gov.apply_decay("did:icn:exempt", 0.1).await;
        assert!(result.is_ok());
        assert_eq!(gov.get_reputation("did:icn:exempt").await.unwrap(), 100);
    }

    #[tokio::test]
    async fn test_voting_edge_cases() {
        let gov = GovernanceService::new(db_pool).await;

        // Test vote after period ends
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 0).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", true).await;
        assert!(matches!(result, Err(GovernanceError::VotingPeriodEnded(_))));

        // Test double voting
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 3600).await.unwrap();
        gov.vote(&proposal.id, "did:icn:voter", true).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", false).await;
        assert!(matches!(result, Err(GovernanceError::AlreadyVoted(_))));
    }
}
```

===================
File: ./crates/zk_snarks/src/lib.rs
Size: 446 bytes
Modified: 2025-03-07 09:37:24.429897252 +0000
Dependencies:

===================
```rs
//! Mock implementation of ZK-SNARKs for integration testing

/// Verify a ZK-SNARK proof
/// 
/// This is a mock implementation that always returns true
pub fn verify_proof(proof: &str) -> bool {
    // In a real implementation, this would verify the proof
    println!("Verifying ZK-SNARK proof: {}", proof);
    true
}

/// Generate a dummy proof for testing
pub fn generate_test_proof() -> String {
    "dummy_proof_for_testing".to_string()
}```

===================
File: ./crates/icn-zk/src/lib.rs
Size: 905 bytes
Modified: 2025-03-07 14:36:39.074978442 +0000
Dependencies:
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use ff::PrimeField;
use serde::{Deserialize, Serialize};

===================
```rs
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use ff::PrimeField;
use serde::{Deserialize, Serialize};

pub struct ProofOfCooperation<F: PrimeField> {
    pub reputation_score: Option<F>,
    pub cooperation_proof: Option<F>,
}

impl<F: PrimeField> Circuit<F> for ProofOfCooperation<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS
    ) -> Result<(), SynthesisError> {
        // Basic circuit implementation - to be expanded
        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RollupBatch {
    pub proposal_id: String,
    pub votes: Vec<Vote>,
    pub rollup_root: [u8; 32],
    pub proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
}

pub fn verify_proof(_proof: &str) -> bool {
    // TODO: Implement actual zk-SNARK verification
    true
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 33812 bytes
Modified: 2025-03-07 14:27:57.248652728 +0000
Dependencies:
mod errors;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use lazy_static::lazy_static;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;
use std::sync::Mutex;
use std::time::SystemTime;
use thiserror::Error;
use tokio::task;

===================
```rs
//! Core types for the ICN (Inter-Cooperative Network) system
//! 
//! This crate provides the fundamental types used across all ICN modules.
//! It serves as a central repository for shared data structures, ensuring
//! consistency across the codebase.

use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use tokio::task;
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;
use thiserror::Error;
use async_trait::async_trait;

mod errors;
pub use errors::{IcnError, IcnResult, log_error};

#[derive(Debug, Error)]
pub enum BlockError {
    #[error("Invalid block index")]
    InvalidIndex,
    #[error("Invalid previous hash")]
    InvalidPreviousHash,
    #[error("Invalid transaction")]
    InvalidTransaction,
    #[error("Invalid proposer")]
    InvalidProposer,
    #[error("Consensus error")]
    ConsensusError,
    #[error("Database error")]
    DatabaseError,
}

#[derive(Debug)]
pub struct ResourceDebt {
    pub cpu_debt: u64,
    pub memory_debt: u64,
    pub bandwidth_debt: u64,
}

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
    pub proposer: String,
    pub metadata: BlockMetadata,
    pub signatures: Vec<BlockSignature>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    pub validator_did: String,
    pub signature: String,
    pub timestamp: DateTime<Utc>,
    pub voting_power: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub height: u64,
    pub state_root: String,
    pub transaction_root: String,
    pub consensus_data: HashMap<String, String>,
    pub validator_signatures: Vec<String>,
    pub consensus_duration_ms: u64,
    pub validator_count: u32,
    pub total_voting_power: f64,
    pub size: u64,
    pub resources_used: u64,
    pub relationship_updates: Option<RelationshipMetadata>,
    pub fault_tolerance: Option<u32>,
}

impl Default for BlockMetadata {
    fn default() -> Self {
        Self {
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            size: 0,
            resources_used: 0,
            relationship_updates: None,
            fault_tolerance: None,
        }
    }
}

impl BlockMetadata {
    pub fn with_bft_info(&mut self, quorum_size: u32, fault_tolerance: u32) {
        self.validator_count = quorum_size;
        self.fault_tolerance = Some(fault_tolerance);
        self.consensus_duration_ms = 0; // Will be set during finalization
    }

    pub fn is_bft_valid(&self) -> bool {
        if let Some(fault_tolerance) = self.fault_tolerance {
            // Check if we have enough validators (3f + 1)
            self.validator_count >= (fault_tolerance * 3) + 1
        } else {
            false
        }
    }
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

lazy_static! {
    static ref TRANSACTION_CACHE: Mutex<HashMap<String, bool>> = {
        let m = HashMap::new();
        Mutex::new(m)
    };
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
            fault_tolerance: None,
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            metadata,
            signatures: Vec::new(),
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        for tx in &self.transactions {
            if let Ok(tx_json) = serde_json::to_string(tx) {
                hasher.update(tx_json);
            }
        }
        
        hasher.update(&self.proposer);
        
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub async fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        let signature_task = task::spawn(async move {
            BlockSignature {
                validator_did,
                signature,
                timestamp: Utc::now(),
                voting_power,
            }
        });

        let new_signature = signature_task.await.unwrap();
        self.signatures.push(new_signature);

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub async fn verify(&self, previous_block: Option<&Block>) -> Result<(), BlockError> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify previous block linkage
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err(BlockError::InvalidPreviousHash);
            }
            if self.index != prev.index + 1 {
                return Err(BlockError::InvalidIndex);
            }
            if self.timestamp <= prev.timestamp {
                return Err(BlockError::InvalidTransaction);
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err(BlockError::InvalidTransaction);
        }

        // Validate transactions
        self.validate_transactions().await?;

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Validates the transactions in the block
    async fn validate_transactions(&self) -> Result<(), BlockError> {
        for tx in &self.transactions {
            let mut cache = TRANSACTION_CACHE.lock().unwrap();
            
            // Check if transaction is already processed
            if cache.contains_key(&tx.hash) {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Validate the transaction
            if !tx.validate() {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Add to cache
            cache.insert(tx.hash.clone(), true);
        }
        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> Option<RelationshipMetadata> {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        Some(metadata)
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }

    /// Finalizes the block and ensures all validations pass
    pub async fn finalize(&mut self) -> Result<(), BlockError> {
        self.verify(None).await?;
        
        let resource_usage: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
            
        self.metadata.resources_used = resource_usage;
        
        self.metadata.size = bincode::serialize(&self)
            .map_err(|_| BlockError::InvalidTransaction)?
            .len() as u64;
            
        self.hash = self.calculate_hash();

        Ok(())
    }

    /// Initiates a consensus round among the validators
    pub async fn start_consensus_round(&mut self) -> Result<(), BlockError> {
        // Simulate consensus process
        let validator = "validator1";
        let signature = format!("signature_of_{}", validator);
        
        if !self.add_signature(validator.to_string(), signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Records a validator's vote on the block
    pub async fn vote_on_block(&mut self, validator_did: String, vote: bool) -> Result<(), BlockError> {
        if !vote {
            return Err(BlockError::InvalidTransaction);
        }

        let signature = "signature".to_string(); // In real implementation, this would be a proper signature
        
        if !self.add_signature(validator_did, signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    pub fn update_validator_metadata(&mut self, validator: String, reputation: i64) {
        let validator_meta = BlockSignature {
            validator_did: validator,
            signature: String::new(),
            timestamp: Utc::now(),
            voting_power: reputation as f64,
        };
        self.signatures.push(validator_meta);
        
        // Update validator count and total voting power
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: std::collections::HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

impl TransactionType {
    pub fn as_str(&self) -> &str {
        match self {
            TransactionType::Transfer { .. } => "Transfer",
            TransactionType::ContractExecution { .. } => "ContractExecution",
            TransactionType::RecordContribution { .. } => "RecordContribution",
            TransactionType::RecordMutualAid { .. } => "RecordMutualAid",
            TransactionType::UpdateRelationship { .. } => "UpdateRelationship",
            TransactionType::AddEndorsement { .. } => "AddEndorsement",
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub id: String,
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType,
    pub timestamp: i64,
    pub hash: String,
    pub signature: Option<String>,
    pub resource_cost: u64,
    pub resource_priority: u8,
    pub zk_snark_proof: Option<String>,
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos();

        let receiver = match &transaction_type {
            TransactionType::Transfer { receiver, .. } => receiver.clone(),
            TransactionType::RecordMutualAid { receiver, .. } => receiver.clone(),
            TransactionType::UpdateRelationship { member_two, .. } => member_two.clone(),
            TransactionType::AddEndorsement { to_did, .. } => to_did.clone(),
            _ => String::new(),
        };

        let amount = match &transaction_type {
            TransactionType::Transfer { amount, .. } => *amount,
            _ => 0,
        };

        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);

        Transaction {
            id: String::new(),
            sender,
            receiver,
            amount,
            transaction_type,
            timestamp: timestamp as i64,
            hash,
            signature: None,
            resource_cost,
            resource_priority: 5, // Default priority
            zk_snark_proof: None,
        }
    }

    pub fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    pub fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                   60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        if self.sender.is_empty() {
            return false;
        }
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0 && self.sender != *receiver
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && !impact_story.is_empty() && !context.is_empty() && !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && !description.is_empty() && !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && !relationship_type.is_empty() && !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && !content.is_empty() && !context.is_empty() && !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp as u128
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap_or_else(|_| Vec::new())
    }
    
    pub fn get_zk_snark_inputs(&self) -> Vec<u8> {
        // A simple implementation that concatenates transaction data
        let mut inputs = Vec::new();
        inputs.extend_from_slice(self.sender.as_bytes());
        inputs.extend_from_slice(self.receiver.as_bytes());
        inputs.extend_from_slice(&self.amount.to_le_bytes());
        inputs.extend_from_slice(self.hash.as_bytes());
        inputs
    }
}

#[derive(Debug, Clone)]
pub struct AuthError(String);

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for AuthError {}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistryTransaction {
    pub registry_data: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AttestMembershipTransaction {
    pub member_did: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64, // positive value; sender's balance decreases and receiver's increases
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceTransaction {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceTransaction {
    pub resource_id: String,
    pub operation: String,
    pub metadata: String,
    pub did_proof: DidProof,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidProof {
    pub did: String,
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ElectionTransaction {
    pub candidate_id: String,
    pub votes: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VoteProposal {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub voter_did: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistry;

impl DidRegistry {
    pub fn new() -> Self {
        DidRegistry
    }

    pub fn get_did(&self, _did: &str) -> Option<DidDocument> {
        // Placeholder implementation
        Some(DidDocument { is_verified: true })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidDocument {
    pub is_verified: bool,
}

impl Transaction {
    pub fn verify_did_signature(_did: &str, _signature: &str, _message: &str) -> Result<bool, AuthError> {
        Ok(true)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

/// Represents a unique identifier for a federation
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct FederationId(pub String);

/// Represents a unique identifier for a cooperative
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct CooperativeId(pub String);

/// Represents a member's identity within the system
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct MemberId {
    pub did: String,
    pub cooperative_id: CooperativeId,
}

/// Represents the status of a federation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationStatus {
    Active,
    Suspended,
    Inactive,
}

/// Represents a governance proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: MemberId,
    pub created_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub votes: HashMap<MemberId, VoteChoice>,
}

/// Represents the status of a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Draft,
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VoteChoice {
    Yes,
    No,
    Abstain,
}

/// Represents a member's reputation score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    pub member_id: MemberId,
    pub score: f64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

/// Represents a resource in the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub owner: CooperativeId,
    pub resource_type: String,
    pub metadata: HashMap<String, String>,
    pub availability: ResourceAvailability,
}

/// Represents the availability status of a resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResourceAvailability {
    Available,
    InUse,
    Maintenance,
    Offline,
}

/// Storage-related error types
#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
    
    #[error("Storage reference already exists")]
    ReferenceAlreadyExists,
    
    #[error("Storage reference not found")]
    ReferenceNotFound,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageReference {
    pub id: String,
    pub storage_type: StorageType,
    pub location: String,
    pub status: StorageStatus,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageType {
    Local,
    Distributed,
    Cloud,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageStatus {
    Available,
    Unavailable,
    Syncing,
}

#[async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn store(&self, data: &[u8]) -> Result<String, StorageError>;
    
    /// Retrieve a value by key
    async fn retrieve(&self, id: &str) -> Result<Vec<u8>, StorageError>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Result type for storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Storage configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub backend_type: String,
    pub cache_size: usize,
    pub cache_ttl_seconds: u64,
    pub ipfs_url: String,
    pub database_url: Option<String>,
}

/// Runtime-related error types
#[derive(Debug, thiserror::Error)]
pub enum RuntimeError {
    #[error("Validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Invalid state")]
    InvalidState,
    
    #[error("Execution error: {0}")]
    ExecutionError(String),
    
    #[error("DSL error: {0}")]
    DslError(String),
    
    #[error("Contract error: {0}")]
    ContractError(String),
}

impl From<RuntimeError> for IcnError {
    fn from(err: RuntimeError) -> Self {
        IcnError::RuntimeError(err.to_string())
    }
}

pub type RuntimeResult<T> = Result<T, RuntimeError>;

/// Represents the execution context for runtime operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub transaction: Option<Transaction>,
    pub block: Option<Block>,
    pub state: HashMap<String, Vec<u8>>,
    pub metadata: HashMap<String, String>,
}

/// Represents a validation check in the runtime
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

/// Represents state validation rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transitions: Vec<String>,
}

/// Represents a validation node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
}

/// Represents a governance node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceNode {
    pub rules: Vec<String>,
    pub voting_config: HashMap<String, String>,
    pub permissions: HashMap<String, Vec<String>>,
}

/// Represents a marketplace node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplaceNode {
    pub rules: Vec<String>,
    pub pricing_model: String,
    pub constraints: Vec<String>,
}

/// Runtime configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuntimeConfig {
    pub vm_type: String,
    pub max_execution_time: u64,
    pub max_memory: u64,
    pub enable_debugging: bool,
    pub log_level: String,
}

#[derive(Debug, Clone)]
pub struct ReputationError {
    pub message: String,
}

impl std::fmt::Display for ReputationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ReputationError {}

#[derive(Debug, Clone)]
pub struct ExecutionError {
    pub message: String,
}

impl std::fmt::Display for ExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ExecutionError {}

#[derive(Debug, Clone)]
pub struct ContractInput {
    pub contract_id: String,
    pub method: String,
    pub args: Vec<u8>,
}

#[async_trait::async_trait]
pub trait RuntimeInterface: Send + Sync {
    async fn execute_transaction(&self, transaction: &Transaction) -> Result<(), RuntimeError>;
    async fn execute_block(&self, block: &Block) -> Result<(), RuntimeError>;
    async fn execute_contract(&self, input: ContractInput) -> Result<Vec<u8>, ExecutionError>;
    async fn get_contract_state(&self, contract_id: &str) -> Result<Vec<u8>, ExecutionError>;
}
```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 168 bytes
Modified: 2025-03-07 20:33:06.873522794 +0000
Dependencies:

===================
```rs
pub mod websocket;
pub mod protocol;
pub mod networking;
pub mod sdp;

// Re-export necessary types
pub use x25519_dalek::PublicKey;
pub use sdp::SDPManager;

```

===================
File: ./crates/icn-common/src/lib.rs
Size: 1095 bytes
Modified: 2025-03-07 09:09:46.438781479 +0000
Dependencies:
use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use thiserror::Error;

===================
```rs
use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use thiserror::Error;

#[async_trait]
pub trait ReputationManager: Send + Sync {
    fn get_reputation(&self, participant: &str, context: &str) -> i64;
    fn is_eligible(&self, participant: &str, threshold: i64, context: &str) -> bool;
    async fn update_reputation(&self, participant: &str, change: i64, context: &str);
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self);
    async fn stop(&self);
    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError>;
    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError>;
}
```

===================
File: ./crates/icn-storage/src/lib.rs
Size: 6298 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000
Dependencies:
mod cache;
mod tests {
use cache::StorageCache;
use futures::TryStreamExt;
use icn_types::{StorageError, StorageResult, StorageBackend, StorageConfig};
use ipfs_api_backend_actix::{IpfsClient, TryFromUri};
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;

===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use icn_types::{StorageError, StorageResult, StorageBackend, StorageConfig};
use std::time::Duration;
use ipfs_api_backend_actix::{IpfsClient, TryFromUri};
use futures::TryStreamExt;

mod cache;
use cache::StorageCache;

/// Errors that can occur in storage operations
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
}

/// Represents the result of storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Core storage interface for the system
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    
    /// Retrieve a value by key
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Manages persistent storage for the system
pub struct StorageManager {
    backend: Arc<Mutex<Box<dyn StorageBackend>>>,
    cache: Arc<StorageCache>,
    ipfs_client: IpfsClient,
}

impl StorageManager {
    /// Create a new storage manager with the given backend and configuration
    pub fn new(backend: Box<dyn StorageBackend>, config: StorageConfig) -> Self {
        Self {
            backend: Arc::new(Mutex::new(backend)),
            cache: Arc::new(StorageCache::new(
                config.cache_size,
                Duration::from_secs(config.cache_ttl_seconds)
            )),
            ipfs_client: IpfsClient::from_str(&config.ipfs_url).expect("Invalid IPFS URL"),
        }
    }
    
    /// Store a serializable value
    pub async fn store<T: Serialize>(&self, key: &str, value: &T) -> StorageResult<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| StorageError::SerializationError(e.to_string()))?;
            
        // Update backend
        let backend = self.backend.lock().await;
        backend.set(key, &serialized).await?;
        
        // Update cache
        self.cache.set(key.to_string(), serialized);
        
        Ok(())
    }
    
    /// Retrieve and deserialize a value
    pub async fn retrieve<T: for<'de> Deserialize<'de>>(&self, key: &str) -> StorageResult<T> {
        // Try cache first
        if let Some(cached_data) = self.cache.get(key) {
            return serde_json::from_slice(&cached_data)
                .map_err(|e| StorageError::SerializationError(e.to_string()));
        }

        // Fall back to backend
        let backend = self.backend.lock().await;
        let data = backend.get(key).await?;
        
        // Update cache
        self.cache.set(key.to_string(), data.clone());
        
        serde_json::from_slice(&data)
            .map_err(|e| StorageError::SerializationError(e.to_string()))
    }
    
    /// Delete a stored value
    pub async fn remove(&self, key: &str) -> StorageResult<()> {
        let backend = self.backend.lock().await;
        backend.delete(key).await
    }
    
    /// Check if a key exists in storage
    pub async fn has_key(&self, key: &str) -> StorageResult<bool> {
        let backend = self.backend.lock().await;
        backend.exists(key).await
    }

    /// Store data using IPFS
    pub async fn store_ipfs(&self, data: &[u8]) -> StorageResult<String> {
        let result = self.ipfs_client.add(data).await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(result.hash)
    }

    /// Retrieve data from IPFS
    pub async fn retrieve_ipfs(&self, hash: &str) -> StorageResult<Vec<u8>> {
        let data = self.ipfs_client.cat(hash).map_ok(|chunk| chunk.to_vec()).try_concat().await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Mock storage backend for testing
    struct MockStorage {
        data: HashMap<String, Vec<u8>>,
    }
    
    #[async_trait::async_trait]
    impl StorageBackend for MockStorage {
        async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
            self.data.insert(key.to_string(), value.to_vec());
            Ok(())
        }
        
        async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
            self.data.get(key)
                .cloned()
                .ok_or_else(|| StorageError::NotFound(key.to_string()))
        }
        
        async fn delete(&self, key: &str) -> StorageResult<()> {
            self.data.remove(key);
            Ok(())
        }
        
        async fn exists(&self, key: &str) -> StorageResult<bool> {
            Ok(self.data.contains_key(key))
        }
    }
    
    #[tokio::test]
    async fn test_basic_storage_operations() {
        let config = StorageConfig {
            backend_type: "mock".to_string(),
            cache_size: 1000,
            cache_ttl_seconds: 300,
            ipfs_url: "http://localhost:5001".to_string(),
            database_url: None,
        };
        
        let storage = StorageManager::new(
            Box::new(MockStorage { data: HashMap::new() }),
            config
        );

        // Test store and retrieve
        let key = "test_key";
        let value = "test_value";
        storage.store(key, &value).await.unwrap();
        
        let retrieved: String = storage.retrieve(key).await.unwrap();
        assert_eq!(retrieved, value);
        
        // Test exists
        assert!(storage.has_key(key).await.unwrap());
        
        // Test delete
        storage.remove(key).await.unwrap();
        assert!(!storage.has_key(key).await.unwrap());
    }
}
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 19357 bytes
Modified: 2025-03-07 09:09:46.438781479 +0000
Dependencies:
use async_trait::async_trait;
use bit_set::BitSet;
use federation::{Federation, FederationError};
use icn_common::{ReputationManager, ConsensusEngine, Vote, VoteStatus, GovernanceError};
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use icn_types::{Block, Transaction}; // Import Transaction
use serde::{Serialize, Deserialize};
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use std::time::Duration;
use thiserror::Error;
use tokio::task;
use tokio::time::sleep;
use trie_rs::Trie;
use zk_snarks::verify_proof; // Import zk-SNARK verification function

===================
```rs
pub mod proof_of_cooperation;
pub mod validation;
pub mod round_management;
pub mod timeout_handling;
pub mod federation;
pub mod sharding; // Add sharding module
pub mod pbft; // Add PBFT module

use async_trait::async_trait;
use std::collections::{HashMap, VecDeque};
use std::time::Duration;
use tokio::time::sleep;
use tokio::task;
use icn_common::{ReputationManager, ConsensusEngine, Vote, VoteStatus, GovernanceError};
use icn_types::{Block, Transaction}; // Import Transaction
use std::sync::Arc;
use bit_set::BitSet;
use trie_rs::Trie;
use thiserror::Error;
use federation::{Federation, FederationError};
use serde::{Serialize, Deserialize};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Error, Debug)]
pub enum ConsensusError {
    #[error("Failed to reach consensus: {0}")]
    ConsensusFailure(String),
    #[error("Block validation failed: {0}")]
    ValidationFailure(String),
    #[error("Timeout occurred: {0}")]
    TimeoutError(String),
    #[error("BFT error: {0}")]
    BftError(String),
}

pub struct ProofOfCooperation {
    current_round: u64,
    participants: VecDeque<String>,
    proposed_block: Option<Block>,
    votes: BitSet,
    vote_trie: Trie,
    timeout: Duration,
    timeout_handling: timeout_handling::TimeoutHandling,
    reputation_manager: Arc<dyn ReputationManager>,
    federation_operations: HashMap<String, FederationOperation>,
    federations: HashMap<String, Federation>,
    round_start_time: std::time::Instant,
    shard_manager: sharding::ShardManager, // Add shard manager field
    pbft_consensus: Option<pbft::PbftConsensus>, // Add PBFT consensus field
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: Arc<dyn ReputationManager>) -> Self {
        let shard_config = sharding::ShardConfig {
            shard_count: 4,  // Start with 4 shards
            shard_capacity: 1000, // Each shard can hold 1000 transactions
            rebalance_threshold: 0.3, // Rebalance when load differs by 30%
        };
        
        ProofOfCooperation {
            current_round: 0,
            participants: VecDeque::new(),
            proposed_block: None,
            votes: BitSet::new(),
            vote_trie: Trie::new(),
            timeout: Duration::from_secs(60),
            timeout_handling: timeout_handling::TimeoutHandling::new(Duration::from_secs(60)),
            reputation_manager,
            federation_operations: HashMap::new(),
            federations: HashMap::new(),
            round_start_time: std::time::Instant::now(),
            shard_manager: sharding::ShardManager::new(shard_config),
            pbft_consensus: None,
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.vote_trie = Trie::new();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            let index = self.participants.iter().position(|p| p == &participant).unwrap_or_else(|| {
                self.participants.push_back(participant.clone());
                self.participants.len() - 1
            });
            if vote {
                self.votes.insert(index);
            }
            self.vote_trie.insert(&participant);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Get validator list for this round
        let validators = self.select_validators(50).await
            .map_err(|e| ConsensusError::ConsensusFailure(e.to_string()))?;
            
        // Ensure we have enough validators for BFT
        let f = validators.len() / 4; // Maximum allowed Byzantine nodes
        let min_validators = 3 * f + 1; // Minimum required for BFT
        
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }
        
        if self.pbft_consensus.is_none() {
            self.pbft_consensus = Some(pbft::PbftConsensus::new(validators.clone()));
        }
        
        let pbft = self.pbft_consensus.as_mut().unwrap();
        
        if let Some(block) = &self.proposed_block {
            // Primary validator broadcasts pre-prepare message
            if pbft.is_primary(&self.identity_did) {
                let pre_prepare = pbft::ConsensusMessage {
                    message_type: pbft::MessageType::PrePrepare,
                    view_number: pbft.view_number,
                    sequence_number: pbft.sequence_number,
                    block_hash: block.hash.clone(),
                    sender: self.identity_did.clone(),
                    signature: "signature".to_string(), // This should be a proper signature
                };
                
                // Distribute to all validators
                self.broadcast_consensus_message(pre_prepare).await?;
            }
            
            // Wait for consensus to be reached
            let timeout = Duration::from_secs(30);
            let start = std::time::Instant::now();
            
            while start.elapsed() < timeout {
                if pbft.is_committed(&block.hash) {
                    // Consensus reached, update block metadata
                    let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                    let mut final_block = block.clone();
                    final_block.metadata.consensus_duration_ms = consensus_duration;
                    
                    // Clear round state
                    self.start_round();
                    
                    return Ok(Some(final_block));
                }
                
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
            
            // Timeout occurred
            Err(ConsensusError::TimeoutError("PBFT consensus timed out".into()))
        } else {
            Err(ConsensusError::ConsensusFailure("No proposed block".into()))
        }
    }

    pub async fn handle_timeout(&self) {
        if let Err(e) = self.timeout_handling.handle_timeout().await {
            eprintln!("Error handling timeout: {}", e);
        }
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus")
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), Box<dyn std::error::Error>> {
        let chunks: Vec<_> = self.participants.chunks(self.participants.len() / 4).collect();
        let mut handles = vec![];

        for chunk in chunks {
            let chunk = chunk.to_vec();
            let reputation_manager = self.reputation_manager.clone();
            let votes = self.votes.clone();
            let handle = task::spawn(async move {
                let mut total_reputation = 0i64;
                let mut approval_reputation = 0i64;
                
                for (i, p) in chunk.iter().enumerate() {
                    let rep = reputation_manager.get_reputation(p, "consensus");
                    total_reputation += rep;
                    if votes.contains(i) {
                        approval_reputation += rep;
                    }
                }
                
                Ok((total_reputation, approval_reputation))
            });
            handles.push(handle);
        }

        let mut total_reputation = 0;
        let mut approval_reputation = 0;

        for handle in handles {
            let (chunk_total, chunk_approval) = handle.await??;
            total_reputation += chunk_total;
            approval_reputation += chunk_approval;
        }

        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, ConsensusError> {
        let mut validators = Vec::new();
        let participants: Vec<_> = self.participants.iter().cloned().collect();

        for participant in participants {
            if self.reputation_manager.is_eligible(&participant, min_reputation, "consensus") {
                validators.push(participant);
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.max_faulty_nodes() * 3) + 1;
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }

        Ok(validators)
    }

    fn max_faulty_nodes(&self) -> usize {
        self.participants.len() / 3
    }

    pub async fn handle_consensus_round(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Start timeout handler
        let timeout_handler = self.timeout_handling.start_timeout();
        
        tokio::select! {
            result = self.finalize_block() => {
                result
            }
            _ = timeout_handler => {
                self.handle_timeout().await;
                Err(ConsensusError::TimeoutError("Consensus round timed out".into()))
            }
        }
    }

    pub fn handle_federation_operation(&mut self, operation: FederationOperation) {
        match operation {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                self.create_federation(partner_id, federation_type, terms).unwrap();
            }
            FederationOperation::JoinFederation { federation_id, commitment } => {
                // Handle joining federation logic
            }
            FederationOperation::LeaveFederation { federation_id, reason } => {
                // Handle leaving federation logic
            }
            FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
                // Handle proposing action logic
            }
            FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
                // Handle voting on proposal logic
            }
            FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
                // Handle sharing resources logic
            }
            FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
                // Handle updating federation terms logic
            }
        }
    }

    pub fn create_federation(
        &mut self,
        creator_id: String,
        federation_type: FederationType,
        terms: FederationTerms,
    ) -> Result<String, ConsensusError> {
        // Verify creator's reputation
        let creator_reputation = self.reputation_manager.get_reputation(&creator_id, "consensus");
        if creator_reputation < terms.minimum_reputation {
            return Err(ConsensusError::ConsensusFailure(
                "Insufficient reputation to create federation".into(),
            ));
        }

        // Generate unique federation ID
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());

        // Create new federation
        let federation = Federation::new(
            federation_id.clone(),
            federation_type,
            terms,
            creator_id,
        );

        // Store federation
        self.federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn adjust_validator_set(&mut self) -> Result<(), ConsensusError> {
        // Get current validator counts for BFT calculation
        let current_size = self.participants.len();
        let min_validators = (current_size / 3) * 3 + 1; // 3f + 1 where f is max faulty

        // Remove validators that fell below minimum reputation
        let mut to_remove = Vec::new();
        for participant in self.participants.iter() {
            if !self.reputation_manager.is_eligible(participant, 50, "consensus") {
                to_remove.push(participant.clone());
            }
        }

        // Remove disqualified validators if we maintain BFT requirements
        if (current_size - to_remove.len()) >= min_validators {
            for participant in to_remove {
                if let Some(pos) = self.participants.iter().position(|x| x == &participant) {
                    self.participants.remove(pos);
                }
            }
        }

        // Add new validators that meet higher reputation threshold
        let new_validators = self.select_validators(80).await?;
        
        // Add new validators while maintaining max size limit
        let max_validators = 100; // Example maximum validator set size
        for validator in new_validators {
            if self.participants.len() >= max_validators {
                break;
            }
            if !self.participants.contains(&validator) {
                self.participants.push_back(validator);
            }
        }

        Ok(())
    }

    pub async fn start_validator_rotation(&mut self) {
        tokio::spawn(async move {
            let rotation_interval = Duration::from_secs(3600); // 1 hour
            loop {
                sleep(rotation_interval).await;
                if let Err(e) = self.adjust_validator_set().await {
                    error!("Failed to adjust validator set: {}", e);
                }
            }
        });
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub fn apply_anti_monopoly_reputation_decay(&self, reputation: i64, dominance: f64, total: f64, alpha: f64) -> i64 {
        (reputation as f64 * (1.0 - dominance / total).powf(alpha)) as i64
    }

    pub fn quadratic_vote_weight(&self, reputation_points: i64) -> f64 {
        (reputation_points as f64).sqrt()
    }

    pub fn randomized_delegation(&self, participants: Vec<String>, num_delegates: usize) -> Vec<String> {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        let mut delegates = participants.clone();
        delegates.shuffle(&mut rng);
        delegates.truncate(num_delegates);
        delegates
    }

    pub fn dynamic_contribution_valuation(&self, value: i64, repeated: i64, lambda: f64) -> i64 {
        (value as f64 * (-lambda * repeated as f64).exp()) as i64
    }

    pub async fn add_signature(&self, did: &str, signature: &str, message: &str) -> Result<(), ConsensusError> {
        // Retrieve public key from IdentityService
        if let Some(public_key) = self.identity_service.get_public_key(did).await {
            let key_pair = KeyPair {
                public_key,
                private_key: vec![], // Not needed for verification
                algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
            };
            if key_pair.verify(message.as_bytes(), signature.as_bytes()) {
                Ok(())
            } else {
                Err(ConsensusError::ValidationFailure("Invalid signature".to_string()))
            }
        } else {
            Err(ConsensusError::ValidationFailure("Public key not found".to_string()))
        }
    }

    // Add a method to handle transaction sharding
    pub fn add_transaction(&mut self, transaction: Transaction) -> Result<u32, ConsensusError> {
        let shard_id = self.shard_manager.assign_transaction(transaction);
        
        // Check if shard is ready for finalization
        let shard = &self.shard_manager.shards[&shard_id];
        if shard.len() >= self.shard_manager.config.shard_capacity as usize {
            if let Some(block) = self.shard_manager.finalize_shard(shard_id) {
                self.propose_block(block);
            }
        }
        
        Ok(shard_id)
    }

    async fn broadcast_consensus_message(&self, message: pbft::ConsensusMessage) -> Result<(), ConsensusError> {
        // Implementation to broadcast message to all validators
        // This would use your networking layer to distribute the message
        // ...
        Ok(())
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) {
        // Start the consensus process
    }

    async fn stop(&self) {
        // Stop the consensus process
    }

    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(&vote.proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
        
        if !self.is_eligible_voter(&vote.voter_did) {
            return Err(GovernanceError::NotEligibleToVote);
        }

        proposal.votes.insert(vote);
        self.check_proposal_status(&proposal.proposal_id)
    }

    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError> {
        let proposal = self.active_proposals.remove(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;

        match proposal.proposal_type {
            ProposalType::AddValidator(info) => self.add_validator(info),
            ProposalType::RemoveValidator(did) => self.remove_validator(&did),
            ProposalType::UpdateRules(rules) => {
                self.rules = rules;
                Ok(())
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: std::collections::HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

#[derive(Serialize, Deserialize)]
struct FederationTerms {
    minimum_reputation: i64,
    resource_sharing_policies: String,
    governance_rules: String,
    duration: String,
}

#[derive(Serialize, Deserialize)]
enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}
```

===================
File: ./crates/icn-dsl/src/lib.rs
Size: 5568 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000
Dependencies:
use nom::{

===================
```rs
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, multispace0, multispace1},
    combinator::{map, opt},
    multi::{many0, many1},
    sequence::{delimited, preceded, terminated, tuple},
    IResult,
};

#[derive(Debug, Clone)]
pub struct CoopLangAST {
    pub governance: Option<GovernanceNode>,
    pub reputation: Option<ReputationNode>,
    pub marketplace: Option<MarketplaceNode>,
    pub federation: Option<FederationNode>,
    pub validation: Option<ValidationNode>,
    pub logging: Option<LoggingNode>,
}

#[derive(Debug, Clone)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
    pub resource_checks: Option<ResourceChecks>,
    pub custom_merge: Option<CustomMerge>,
}

#[derive(Debug, Clone)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

#[derive(Debug, Clone)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transition: Option<String>,
}

#[derive(Debug, Clone)]
pub struct CustomMerge {
    pub strategy: String,
    pub handlers: Vec<ConflictHandler>,
}

#[derive(Debug, Clone)]
pub struct ConflictHandler {
    pub field_path: String,
    pub resolution_type: String,
}

// Parser implementation
impl CoopLangAST {
    pub fn parse(input: &str) -> IResult<&str, Self> {
        let (input, _) = multispace0(input)?;
        let (input, governance) = opt(Self::parse_governance_section)(input)?;
        let (input, reputation) = opt(Self::parse_reputation_section)(input)?;
        let (input, marketplace) = opt(Self::parse_marketplace_section)(input)?;
        let (input, federation) = opt(Self::parse_federation_section)(input)?;
        let (input, validation) = opt(Self::parse_validation_section)(input)?;
        let (input, logging) = opt(Self::parse_logging_section)(input)?;
        
        Ok((input, CoopLangAST {
            governance,
            reputation,
            marketplace,
            federation,
            validation,
            logging,
        }))
    }

    fn parse_validation_section(input: &str) -> IResult<&str, ValidationNode> {
        let (input, _) = tag("validation:")(input)?;
        let (input, _) = multispace1(input)?;
        
        let (input, pre_checks) = Self::parse_checks("pre_checks:")(input)?;
        let (input, post_checks) = Self::parse_checks("post_checks:")(input)?;
        let (input, state_validation) = opt(Self::parse_state_validation)(input)?;
        let (input, resource_checks) = opt(Self::parse_resource_checks)(input)?;
        let (input, custom_merge) = opt(Self::parse_custom_merge)(input)?;

        Ok((input, ValidationNode {
            pre_checks,
            post_checks,
            state_validation,
            resource_checks,
            custom_merge,
        }))
    }

    fn parse_checks(label: &'static str) -> impl Fn(&str) -> IResult<&str, Vec<Check>> {
        move |input: &str| {
            let (input, _) = tag(label)(input)?;
            let (input, _) = multispace1(input)?;
            many0(Self::parse_check)(input)
        }
    }

    fn parse_check(input: &str) -> IResult<&str, Check> {
        let (input, _) = char('-')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, condition) = take_while1(|c| c != ':')(input)?;
        let (input, _) = char(':')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, action) = take_while1(|c| c != '\n')(input)?;
        let (input, _) = multispace0(input)?;

        Ok((input, Check {
            condition: condition.trim().to_string(),
            action: action.trim().to_string(),
        }))
    }

    // Add other section parsers similarly...
}

// Bytecode generation
pub fn compile_to_icvm(ast: &CoopLangAST) -> Vec<u8> {
    let mut bytecode = Vec::new();

    // Header
    bytecode.extend_from_slice(&[0x49, 0x43, 0x56, 0x4D]); // "ICVM" magic bytes
    bytecode.push(0x01); // Version

    // Compile validation rules
    if let Some(validation) = &ast.validation {
        bytecode.push(0x01); // Validation section marker
        
        // Pre-checks
        bytecode.push(validation.pre_checks.len() as u8);
        for check in &validation.pre_checks {
            compile_check(&mut bytecode, check);
        }

        // Post-checks
        bytecode.push(validation.post_checks.len() as u8);
        for check in &validation.post_checks {
            compile_check(&mut bytecode, check);
        }

        // State validation
        if let Some(state_validation) = &validation.state_validation {
            bytecode.push(0x01);
            compile_state_validation(&mut bytecode, state_validation);
        } else {
            bytecode.push(0x00);
        }
    }

    // Compile other sections similarly...

    bytecode
}

fn compile_check(bytecode: &mut Vec<u8>, check: &Check) {
    // Convert check condition to bytecode operations
    bytecode.extend_from_slice(check.condition.as_bytes());
    bytecode.push(0x00); // Null terminator
    bytecode.extend_from_slice(check.action.as_bytes());
    bytecode.push(0x00); // Null terminator
}

fn compile_state_validation(bytecode: &mut Vec<u8>, validation: &StateValidation) {
    if let Some(current) = &validation.current {
        bytecode.push(0x01);
        bytecode.extend_from_slice(current.as_bytes());
        bytecode.push(0x00);
    } else {
        bytecode.push(0x00);
    }
    // Similarly for expected and transition...
}
```

===================
File: ./crates/icn-core/src/lib.rs
Size: 609 bytes
Modified: 2025-03-07 20:20:28.965849379 +0000
Dependencies:

===================
```rs
// Module declarations
pub mod blockchain;
pub mod core;
pub mod db;
pub mod identity;
pub mod reputation;
pub mod storage;
pub mod vm;
pub mod networking;
pub mod models;
pub mod telemetry;
pub mod verifiable_credentials;
pub mod zk_snarks;

// Re-export main interfaces
pub use self::{
    storage::StorageInterface,
    networking::NetworkInterface,
    identity::IdentityInterface,
    reputation::ReputationInterface,
    telemetry::TelemetryManager,
    models::{ResourceAllocationSystem, FederationManager},
    vm::runtime::RuntimeManager,
};
pub use icn_types::RuntimeInterface;

pub mod governance;
```

===================
File: ./crates/icn-identity/src/lib.rs
Size: 1952 bytes
Modified: 2025-03-07 09:33:03.302936920 +0000
Dependencies:

===================
```rs
pub mod ledger {
    use crate::VerifiableCredential;
    
    /// Create an identity in the ledger
    pub async fn create_identity_in_ledger(identity: &str, _credential: &VerifiableCredential) -> Result<(), String> {
        println!("Creating identity in ledger: {}", identity);
        Ok(())
    }
    
    /// Get identity from the ledger
    pub async fn get_identity_from_ledger(identity: &str) -> Result<String, String> {
        println!("Getting identity from ledger: {}", identity);
        Ok(identity.to_string())
    }
    
    /// Rotate a key in the ledger
    pub async fn rotate_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Rotating key in ledger: {}", identity);
        Ok(())
    }
    
    /// Revoke a key in the ledger
    pub async fn revoke_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Revoking key in ledger: {}", identity);
        Ok(())
    }
    
    /// Apply reputation decay in the ledger
    pub async fn apply_reputation_decay_in_ledger(did: &str, decay_rate: f64) -> Result<(), String> {
        println!("Applying reputation decay to {}: {}", did, decay_rate);
        Ok(())
    }
    
    /// Handle sybil resistance in the ledger
    pub async fn handle_sybil_resistance_in_ledger(did: &str, reputation_score: i64) -> Result<(), String> {
        println!("Handling sybil resistance for {}: {}", did, reputation_score);
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct VerifiableCredential {
    pub credential_type: String,
    pub issuer_did: String,
    pub subject_did: String,
    pub issuance_date: String,
    pub expiration_date: Option<String>,
    pub credential_status: Option<String>,
    pub credential_schema: Option<String>,
    pub proof: Proof,
}

#[derive(Debug, Clone)]
pub struct Proof {
    pub type_: String,
    pub created: String,
    pub proof_purpose: String,
    pub verification_method: String,
    pub jws: String,
}```

===================
File: ./crates/icn-mutual-credit/src/lib.rs
Size: 2294 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000
Dependencies:
use chrono::Utc;
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

===================
```rs
use std::collections::HashMap;
use chrono::Utc;
use serde::{Serialize, Deserialize};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64,
    pub signature: String,
    pub timestamp: i64,
}

pub struct MutualCreditLedger {
    // Maps member DID to current credit balance.
    pub balances: HashMap<String, i64>,
    // Ordered list of all mutual credit transactions.
    pub history: Vec<MutualCreditTransaction>,
}

impl MutualCreditLedger {
    pub fn new() -> Self {
        Self {
            balances: HashMap::new(),
            history: Vec::new(),
        }
    }

    // Process a new mutual credit transaction.
    pub fn process_transaction(&mut self, tx: MutualCreditTransaction) -> Result<(), String> {
        // Verify sender signature
        if !Self::verify_signature(&tx.sender_did, &tx.signature, tx.amount) {
            return Err("Invalid signature".into());
        }
        // Update sender and receiver balances
        *self.balances.entry(tx.sender_did.clone()).or_insert(0) -= tx.amount;
        *self.balances.entry(tx.receiver_did.clone()).or_insert(0) += tx.amount;
        // Append to history
        self.history.push(tx);
        Ok(())
    }

    // Verify signature using icn-crypto
    fn verify_signature(did: &str, signature: &str, amount: i64) -> bool {
        // Retrieve public key from IdentityService (placeholder)
        let public_key = vec![]; // Replace with actual public key retrieval logic
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        key_pair.verify(amount.to_string().as_bytes(), signature.as_bytes())
    }

    // Get balance summary for a member
    pub fn get_balance(&self, did: &str) -> i64 {
        *self.balances.get(did).unwrap_or(&0)
    }

    // Print simple ledger summary (for logging)
    pub fn print_summary(&self) {
        for (did, balance) in &self.balances {
            println!("Member {}: Balance {}", did, balance);
        }
    }
}
```

===================
File: ./crates/icn-resource/src/lib.rs
Size: 6916 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000
Dependencies:
use async_trait::async_trait;
use icn_federation::ResourceManager;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_federation::ResourceManager;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub resource_type: String,
    pub owner: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub price_per_unit: f64,
    pub constraints: ResourceConstraints,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceConstraints {
    pub min_reputation: i64,
    pub max_allocation: u64,
    pub time_limit: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationResourcePool {
    pub federation_id: String,
    pub resources: HashMap<String, Resource>,
    pub access_control: FederationAccessControl,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationAccessControl {
    pub allowed_federations: Vec<String>,
    pub min_reputation: i64,
    pub max_allocation_per_federation: u64,
}

pub struct ResourceAllocationSystem {
    resources: Arc<RwLock<HashMap<String, Resource>>>,
    allocations: Arc<RwLock<HashMap<String, Vec<ResourceAllocation>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub allocation_id: String,
    pub resource_id: String,
    pub recipient: String,
    pub amount: u64,
    pub allocated_at: u64,
    pub expires_at: Option<u64>,
}

impl ResourceAllocationSystem {
    pub fn new() -> Self {
        Self {
            resources: Arc::new(RwLock::new(HashMap::new())),
            allocations: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn register_resource(
        &self,
        owner: String,
        resource_type: String,
        amount: u64,
        price: f64,
        constraints: ResourceConstraints,
    ) -> Result<String, ResourceError> {
        let resource_id = format!("res_{}", uuid::Uuid::new_v4());
        let resource = Resource {
            id: resource_id.clone(),
            resource_type,
            owner,
            total_amount: amount,
            available_amount: amount,
            price_per_unit: price,
            constraints,
        };

        let mut resources = self.resources.write().await;
        resources.insert(resource_id.clone(), resource);

        Ok(resource_id)
    }

    pub async fn allocate(
        &self,
        resource_id: &str,
        recipient: String,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        let resource = resources.get_mut(resource_id)
            .ok_or(ResourceError::ResourceNotFound)?;

        if resource.available_amount < amount {
            return Err(ResourceError::InsufficientResources);
        }

        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        let allocation = ResourceAllocation {
            allocation_id: allocation_id.clone(),
            resource_id: resource_id.to_string(),
            recipient,
            amount,
            allocated_at: chrono::Utc::now().timestamp() as u64,
            expires_at: None,
        };

        resource.available_amount -= amount;

        let mut allocations = self.allocations.write().await;
        allocations.entry(resource_id.to_string())
            .or_insert_with(Vec::new)
            .push(allocation);

        Ok(allocation_id)
    }

    pub async fn release(
        &self,
        allocation_id: &str,
    ) -> Result<(), ResourceError> {
        let mut allocations = self.allocations.write().await;
        for (resource_id, resource_allocations) in allocations.iter_mut() {
            if let Some(index) = resource_allocations.iter().position(|alloc| alloc.allocation_id == allocation_id) {
                let allocation = resource_allocations.remove(index);
                let mut resources = self.resources.write().await;
                if let Some(resource) = resources.get_mut(&allocation.resource_id) {
                    resource.available_amount += allocation.amount;
                }
                return Ok(());
            }
        }
        Err(ResourceError::InvalidAllocation)
    }

    pub async fn adjust_price(
        &self,
        resource_id: &str,
        new_price: f64,
    ) -> Result<(), ResourceError> {
        let mut resources = self.resources.write().await;
        if let Some(resource) = resources.get_mut(resource_id) {
            resource.price_per_unit = new_price;
            Ok(())
        } else {
            Err(ResourceError::ResourceNotFound)
        }
    }

    pub async fn create_federation_pool(
        &self,
        federation_id: String,
        access_control: FederationAccessControl,
    ) -> Result<(), ResourceError> {
        let pool = FederationResourcePool {
            federation_id: federation_id.clone(),
            resources: HashMap::new(),
            access_control,
        };
        
        let mut resources = self.resources.write().await;
        resources.insert(federation_id, pool);
        Ok(())
    }

    pub async fn share_with_federation(
        &self,
        source_federation: &str,
        target_federation: &str, 
        resource_id: &str,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        
        // Verify federation access permissions
        let source_pool = resources.get(source_federation)
            .ok_or(ResourceError::ResourceNotFound)?;
            
        if !source_pool.access_control.allowed_federations.contains(&target_federation.to_string()) {
            return Err(ResourceError::UnauthorizedAction);
        }

        // Create allocation record
        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        
        // Allocate resources to target federation
        self.allocate(resource_id, target_federation.to_string(), amount).await?;

        Ok(allocation_id)
    }
}

#[async_trait]
impl ResourceManager for ResourceAllocationSystem {
    async fn allocate_resources(&self, allocation: icn_federation::ResourceAllocation) -> Result<(), String> {
        self.allocate(&allocation.resource_type, allocation.recipient, allocation.amount)
            .await
            .map_err(|e| e.to_string())
    }

    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String> {
        // Implementation for releasing resources back to the pool
        Ok(())
    }
}

#[derive(Debug)]
pub enum ResourceError {
    ResourceNotFound,
    InsufficientResources,
    InvalidAllocation,
    UnauthorizedAction,
}
```

===================
File: ./crates/icn-federation/src/lib.rs
Size: 39751 bytes
Modified: 2025-03-07 19:04:35.270649052 +0000
Dependencies:
use async_trait::async_trait;
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_networking::p2p::{P2PManager, FederationEvent}; // Import P2PManager and FederationEvent
use icn_p2p::sdp::{SDPManager, SDPPacket, SDPHeader, PublicKey};
use icn_types::{Block, Transaction};
use icn_zkp::RollupBatch;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{SystemTime, Duration};
use thiserror::Error;
use tokio::sync::RwLock;
use zk_snarks::verify_proof; // Import zk-SNARK verification function

===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_types::{Block, Transaction};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_zkp::RollupBatch;
use thiserror::Error;
use icn_networking::p2p::{P2PManager, FederationEvent}; // Import P2PManager and FederationEvent
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::time::{SystemTime, Duration};

// Add SDP support
use icn_p2p::sdp::{SDPManager, SDPPacket, SDPHeader, PublicKey};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub federation_type: FederationType,
    pub members: HashMap<String, MemberStatus>, // DID -> status
    pub member_roles: HashMap<String, MemberRole>, // DID -> role
    pub terms: FederationTerms,
    pub resources: HashMap<String, ResourcePool>,
    pub proposals: Vec<FederationProposal>, // Add proposals field
    pub created_at: u64,
    pub status: FederationStatus,
    pub disputes: HashMap<String, FederationDispute>, // Add disputes field
    pub cross_federation_disputes: HashMap<String, Vec<FederationDispute>>,
    pub audit_log: Vec<AuditEntry>,
    pub p2p_manager: Arc<tokio::sync::Mutex<P2PManager>>, // Changed to tokio::sync::Mutex
    // Add secure communication fields
    pub sdp_peers: HashMap<String, Vec<String>>, // federation_id -> [peer_addresses]
    pub federation_public_keys: HashMap<String, String>, // federation_id -> public_key (base58 encoded)
}

// Add an SDPConfig struct to handle SDP configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SDPConfig {
    pub bind_address: String,
    pub enable_multipath: bool,
    pub enable_onion_routing: bool,
    pub message_priority: HashMap<String, u8>, // message_type -> priority
}

impl Default for SDPConfig {
    fn default() -> Self {
        let mut message_priority = HashMap::new();
        message_priority.insert("governance_vote".to_string(), 8);
        message_priority.insert("dispute_resolution".to_string(), 9);
        message_priority.insert("resource_allocation".to_string(), 6);
        message_priority.insert("member_update".to_string(), 5);
        
        Self {
            bind_address: "0.0.0.0:0".to_string(), // Random port by default
            enable_multipath: true,
            enable_onion_routing: false, // Optional advanced feature
            message_priority,
        }
    }
}

// Add a struct for federation manager with SDP support
pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
    // Add SDP manager
    sdp_manager: Option<Arc<RwLock<SDPManager>>>,
    sdp_config: SDPConfig,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
            sdp_manager: None,
            sdp_config: SDPConfig::default(),
        }
    }

    // Initialize SDP for secure federation communications
    pub async fn init_sdp(&mut self, config: SDPConfig) -> Result<(), FederationError> {
        match SDPManager::new(&config.bind_address) {
            Ok(manager) => {
                self.sdp_manager = Some(Arc::new(RwLock::new(manager)));
                self.sdp_config = config;
                
                // Start receiver for handling incoming messages
                self.start_sdp_receiver().await?;
                
                Ok(())
            },
            Err(e) => Err(FederationError::CommunicationError(format!("Failed to initialize SDP: {}", e))),
        }
    }

    // Start SDP receiver to handle incoming messages
    async fn start_sdp_receiver(&self) -> Result<(), FederationError> {
        if let Some(sdp) = &self.sdp_manager {
            let sdp_clone = sdp.clone();
            let federations_clone = self.federations.clone();
            
            let handler = move |data: Vec<u8>, src| {
                let federations = federations_clone.clone();
                
                tokio::spawn(async move {
                    // Handle incoming SDP messages
                    if let Ok(message) = serde_json::from_slice::<FederationMessage>(&data) {
                        // Process message based on type
                        match message.message_type {
                            FederationMessageType::ProposalSubmission => {
                                if let Ok(proposal) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        // Add signature verification here
                                        let _ = federation.submit_proposal(proposal);
                                    }
                                }
                            },
                            FederationMessageType::Vote => {
                                if let Ok(vote) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.vote(vote);
                                    }
                                }
                            },
                            FederationMessageType::DisputeInitiation => {
                                if let Ok(dispute) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.submit_dissolution_dispute(dispute);
                                    }
                                }
                            },
                            FederationMessageType::ResourceAllocation => {
                                // Handle resource allocation messages
                            },
                            FederationMessageType::MembershipUpdate => {
                                // Handle membership updates
                            },
                        }
                    }
                });
            };
            
            sdp_clone.lock().await.start_receiver(handler).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to start SDP receiver: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    // Send a federation message via SDP
    pub async fn send_federation_message(
        &self,
        source_federation: &str,
        target_federation: &str,
        message_type: FederationMessageType,
        payload: serde_json::Value,
        signature: &str,
    ) -> Result<(), FederationError> {
        let federations = self.federations.read().await;
        
        let source_fed = federations.get(source_federation)
            .ok_or(FederationError::FederationNotFound(source_federation.to_string()))?;
            
        let target_fed = federations.get(target_federation)
            .ok_or(FederationError::FederationNotFound(target_federation.to_string()))?;
            
        // Check if we have SDP peer info for the target
        if !source_fed.sdp_peers.contains_key(target_federation) {
            return Err(FederationError::CommunicationError(
                format!("No SDP routing information for federation {}", target_federation)
            ));
        }
        
        // Create federation message
        let message = FederationMessage {
            source_federation: source_federation.to_string(),
            target_federation: target_federation.to_string(),
            message_type,
            payload,
            timestamp: SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            signature: signature.to_string(),
        };
        
        // Serialize message
        let serialized = serde_json::to_vec(&message)
            .map_err(|e| FederationError::CommunicationError(format!("Serialization error: {}", e)))?;
            
        // Get message priority
        let priority = self.sdp_config.message_priority
            .get(message.message_type.to_string().as_str())
            .cloned()
            .unwrap_or(5); // Default priority
            
        if let Some(sdp_manager) = &self.sdp_manager {
            let manager = sdp_manager.lock().await;
            manager.send_message(target_federation, &serialized, priority).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to send SDP message: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
            // Initialize SDP communication fields
            sdp_peers: HashMap::new(),
            federation_public_keys: HashMap::new(),
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }

        // Add SDP peer information if available
        if let Some(sdp) = &self.sdp_manager {
            let manager = sdp.lock().await;
            let public_key = manager.keypair.1;
            
            // Update the federation with this node's SDP information
            let mut federations = self.federations.write().await;
            if let Some(federation) = federations.get_mut(federation_id) {
                // Add public key in base58 encoding for interoperability
                federation.federation_public_keys.insert(
                    member_did.to_string(),
                    bs58::encode(public_key.as_bytes()).into_string()
                );
            }
        }
        
        Ok(())
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

// Add FederationMessage struct for secure communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMessage {
    pub source_federation: String,
    pub target_federation: String,
    pub message_type: FederationMessageType,
    pub payload: serde_json::Value,
    pub timestamp: u64,
    pub signature: String,
}

// Define message types for federation communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationMessageType {
    ProposalSubmission,
    Vote,
    DisputeInitiation,
    ResourceAllocation,
    MembershipUpdate,
}

impl ToString for FederationMessageType {
    fn to_string(&self) -> String {
        match self {
            FederationMessageType::ProposalSubmission => "governance_proposal".to_string(),
            FederationMessageType::Vote => "governance_vote".to_string(),
            FederationMessageType::DisputeInitiation => "dispute_resolution".to_string(),
            FederationMessageType::ResourceAllocation => "resource_allocation".to_string(),
            FederationMessageType::MembershipUpdate => "member_update".to_string(),
        }
    }
}

impl Federation {
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), FederationError> {
        if self.members.contains_key(&did) {
            return Err(FederationError::AlreadyMember(did));
        }

        // Verify member meets minimum reputation requirements
        if !self.verify_member_eligibility(&did) {
            return Err(FederationError::InsufficientReputation(
                "Member does not meet minimum reputation requirements".to_string(),
            ));
        }

        self.members.insert(did, MemberStatus::Active);
        Ok(())
    }

    pub fn remove_member(&mut self, did: &str) -> Result<(), FederationError> {
        if !self.members.contains_key(did) {
            return Err(FederationError::MemberNotFound(did.to_string()));
        }

        self.members.remove(did);
        Ok(())
    }

    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.members.get(did)
    }

    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), FederationError> {
        if let Some(member_status) = self.members.get_mut(did) {
            *member_status = status;
            Ok(())
        } else {
            Err(FederationError::MemberNotFound(did.to_string()))
        }
    }

    pub fn get_active_members(&self) -> Vec<String> {
        self.members
            .iter()
            .filter(|(_, status)| matches!(status, MemberStatus::Active))
            .map(|(did, _)| did.clone())
            .collect()
    }

    pub fn verify_member_eligibility(&self, did: &str) -> bool {
        // This would integrate with the reputation system in practice
        true // Simplified for example
    }

    pub fn submit_proposal(&mut self, proposal: FederationProposal) -> Result<(), FederationError> {
        // Validate proposal
        self.validate_proposal(&proposal)?;

        // Set proposal voting period
        let mut proposal = proposal;
        proposal.voting_ends_at = chrono::Utc::now().timestamp() as u64 + 
            (self.terms.governance_rules.max_voting_period_hours * 3600);

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote(&mut self, vote: Vote) -> Result<(), FederationError> {
        // Validate vote
        self.validate_vote(&vote)?;

        // Get proposal
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Record vote
        proposal.votes.insert(vote.voter, vote.approve);

        // Check if voting period ended and finalize if needed
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            proposal.status = self.finalize_proposal(&proposal.id)?;
        }

        Ok(())
    }

    pub fn validate_proposal(&self, proposal: &FederationProposal) -> Result<(), FederationError> {
        // Check if proposal type is allowed
        if !self.terms.governance_rules.allowed_proposal_types.contains(&proposal.proposal_type.to_string()) {
            return Err(FederationError::InvalidProposalType(proposal.proposal_type.to_string()));
        }

        // Validate proposer has sufficient reputation
        if !self.verify_member_eligibility(&proposal.proposer) {
            return Err(FederationError::InsufficientReputation(
                "Proposer does not meet minimum reputation requirements".to_string()
            ));
        }

        Ok(())
    }

    pub fn validate_vote(&self, vote: &Vote) -> Result<(), FederationError> {
        // Check if voter is a member
        if !self.members.contains_key(&vote.voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote".to_string(), did: vote.voter.clone() });
        }

        // Check if proposal exists
        let proposal = self.proposals.iter()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Check if voting period is still open
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            return Err(FederationError::VotingPeriodEnded(vote.proposal_id.clone()));
        }

        // Check for veto rights
        if let Some(member_role) = self.member_roles.get(&vote.voter) {
            if let Some(veto_actions) = self.terms.governance_rules.veto_rights.get(&member_role.to_string()) {
                if veto_actions.contains(&proposal.proposal_type.to_string()) && !vote.approve {
                    // Record veto
                    return Ok(());
                }
            }
        }

        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<ProposalStatus, FederationError> {
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == proposal_id)
            .ok_or(FederationError::ProposalNotFound(proposal_id.to_string()))?;

        // Create vote batch for on-chain processing
        let batch = RollupBatch {
            proposal_id: proposal_id.to_string(),
            votes: proposal.votes.iter()
                .map(|(voter, approve)| Vote { voter: voter.clone(), approve: *approve, signature: String::new() }) // Added signature field
                .collect(),
            rollup_root: [0u8; 32], // Computed by ZK prover
            proof: Vec::new(), // Generated by ZK prover
        };

        // Submit batch to chain
        self.contract.submit_vote_batch(batch)?;

        // Execute proposal on-chain
        let approved = self.contract.execute_proposal(proposal_id)?;
        
        proposal.status = if approved {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }

    pub fn calculate_asset_distribution(&self) -> HashMap<String, AssetAllocation> {
        let mut distributions = HashMap::new();
        // Implement fair asset distribution calculation
        distributions
    }

    pub fn settle_outstanding_debts(&self) -> Vec<DebtSettlement> {
        let mut settlements = Vec::new();
        // Implement debt settlement calculation
        settlements
    }

    pub fn reassign_members(&self) -> Vec<MemberReassignment> {
        let mut reassignments = Vec::new();
        // Implement member reassignment logic
        reassignments
    }

    pub fn calculate_vote_weight(&self, cooperative_id: &str, proposal: &FederationProposal) -> f64 {
        let voting_model = match proposal.proposal_type {
            ProposalType::GovernanceChange(_) | ProposalType::PolicyUpdate(_) => 
                &self.terms.governance_rules.governance_voting_model,
            ProposalType::ResourceAllocation(_) =>
                &self.terms.governance_rules.resource_voting_model,
            _ => &self.terms.governance_rules.default_voting_model,
        };

        voting_model.calculate_voting_power(self, cooperative_id)
    }

    pub fn get_cooperative_weight(&self, cooperative_id: &str) -> f64 {
        let total_members: u32 = self.members.values().map(|m| m.member_count).sum();
        let coop_members = self.members.get(cooperative_id)
            .map(|m| m.member_count)
            .unwrap_or(0);
        
        coop_members as f64 / total_members as f64
    }

    pub fn initiate_dissolution(&mut self, initiator: String, reason: String) -> Result<DissolutionProtocol, FederationError> {
        let protocol = DissolutionProtocol {
            federation_id: self.id.clone(),
            initiated_by: initiator,
            reason: DissolutionReason::Voluntary,
            status: DissolutionStatus::Initiated,
            asset_distribution: HashMap::new(),
            debt_settlements: Vec::new(),
            member_reassignments: Vec::new(),
            dispute_period_ends: SystemTime::now() + Duration::from_secs(7 * 24 * 60 * 60), // 7 days
        };

        self.status = FederationStatus::DisputePeriod;
        Ok(protocol)
    }

    pub fn submit_dissolution_dispute(&mut self, dispute: FederationDispute) -> Result<(), FederationError> {
        if self.status != FederationStatus::DisputePeriod {
            return Err(FederationError::InvalidStatusTransition { from: "DisputePeriod".to_string(), to: self.status.to_string() });
        }

        if !self.members.contains_key(&dispute.initiator) {
            return Err(FederationError::UnauthorizedAction { action: "submit_dissolution_dispute".to_string(), did: dispute.initiator.clone() });
        }

        self.disputes.insert(dispute.id.clone(), dispute);
        self.status = FederationStatus::DisputeResolution;
        Ok(())
    }

    pub fn vote_on_dispute(&mut self, dispute_id: &str, voter: String, support: bool) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        if !self.members.contains_key(&voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote_on_dispute".to_string(), did: voter.clone() });
        }

        dispute.supporting_votes.insert(voter, support);

        // Check if we have enough votes to resolve the dispute
        let total_votes = dispute.supporting_votes.len();
        let supporting_votes = dispute.supporting_votes.values().filter(|&&v| v).count();
        let required_votes = (self.members.len() * 2) / 3; // 2/3 majority

        if total_votes >= required_votes {
            if supporting_votes > total_votes / 2 {
                dispute.status = DisputeStatus::Resolved;
                self.status = FederationStatus::Active;
            } else {
                dispute.status = DisputeStatus::Rejected;
                self.status = FederationStatus::Dissolved;
            }
        }

        Ok(())
    }

    pub fn resolve_dispute(&mut self, dispute_id: &str, resolution: DisputeResolution) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        dispute.resolution = Some(resolution);
        dispute.status = DisputeStatus::Resolved;

        // If all disputes are resolved, proceed with dissolution
        if self.disputes.values().all(|d| d.status == DisputeStatus::Resolved || d.status == DisputeStatus::Rejected) {
            let any_upheld = self.disputes.values().any(|d| d.status == DisputeStatus::Resolved);
            self.status = if any_upheld {
                FederationStatus::Active
            } else {
                FederationStatus::Dissolved;
            };
        }

        Ok(())
    }

    pub async fn initiate_cross_federation_dispute(
        &mut self,
        target_federation: &str,
        dispute: FederationDispute
    ) -> Result<(), FederationError> {
        // Verify both federations exist and have sufficient reputation
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        let disputes = self.cross_federation_disputes
            .entry(target_federation.to_string())
            .or_insert_with(Vec::new);
        
        disputes.push(dispute);
        
        // Log dispute for audit
        self.audit_log.push(AuditEntry {
            action: "cross_federation_dispute".into(),
            target_federation: Some(target_federation.to_string()),
            timestamp: chrono::Utc::now(),
        });

        Ok(())
    }

    pub async fn submit_cross_federation_proposal(
        &mut self,
        target_federation: &str,
        proposal: CrossFederationProposal
    ) -> Result<(), FederationError> {
        // Verify both federations meet minimum reputation requirements
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        // Create batch for cross-federation proposals
        let mut batch = ProposalBatch::new();
        batch.add_proposal(proposal.clone());
        
        // Submit to cross-federation coordinator
        self.coordinator.submit_batch(batch).await?;
        
        // Record proposal for local tracking
        self.cross_federation_proposals.insert(proposal.id.clone(), proposal);
        
        Ok(())
    }

    pub fn batch_process_proposals(&mut self, proposals: Vec<FederationProposal>) -> Result<(), FederationError> {
        let mut batch = ProposalBatch::new();
        
        for proposal in proposals {
            self.validate_proposal(&proposal)?;
            batch.add_proposal(proposal);
        }
        
        // Process batch through ZK rollup
        let rollup = self.create_proposal_rollup(batch);
        self.contract.submit_rollup(rollup)?;
        
        Ok(())
    }

    pub async fn publish_event(&self, event: FederationEvent) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.publish(event).await.map_err(|e| FederationError::EventPublishError(e.to_string()))
    }

    pub async fn subscribe_to_events(&self) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.subscribe().await.map_err(|e| FederationError::EventSubscribeError(e.to_string()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourcePool {
    pub resource_type: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub contributors: HashMap<String, u64>, // DID -> amount contributed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationProposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub description: String,
    pub votes: HashMap<String, bool>, // DID -> vote
    pub status: ProposalStatus,
    pub created_at: u64,
    pub voting_ends_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    AddMember(String),
    RemoveMember(String),
    UpdateTerms(FederationTerms),
    AllocateResources(ResourceAllocation),
    UpdatePolicy(String),
}

impl std::fmt::Display for ProposalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProposalType::AddMember(_) => write!(f, "AddMember"),
            ProposalType::RemoveMember(_) => write!(f, "RemoveMember"),
            ProposalType::UpdateTerms(_) => write!(f, "UpdateTerms"),
            ProposalType::AllocateResources(_) => write!(f, "AllocateResources"),
            ProposalType::UpdatePolicy(_) => write!(f, "UpdatePolicy"),
        }
    }
}

pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

#[async_trait]
pub trait ResourceManager: Send + Sync {
    async fn allocate_resources(&self, allocation: ResourceAllocation) -> Result<(), String>;
    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String>;
}

pub trait FederationDissolution {
    fn initiate_dissolution(&mut self, initiator: &str, reason: DissolutionReason) -> Result<DissolutionProtocol, Error>;
    fn process_dissolution(&mut self, protocol: &DissolutionProtocol) -> Result<DissolutionStatus, Error>;
    fn cancel_dissolution(&mut self, protocol_id: &str) -> Result<(), Error>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: GovernanceRules,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceRules {
    pub min_votes_required: u32,
    pub approval_threshold_percent: u32,
    pub min_voting_period_hours: u32,
    pub max_voting_period_hours: u32,
    pub allowed_proposal_types: Vec<String>,
    pub veto_rights: HashMap<String, Vec<String>>, // role -> action types that can be vetoed
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FederationStatus {
    Active,
    Suspended,
    Dissolved,
    DisputePeriod,
    DisputeResolution,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Expired,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

impl std::fmt::Display for MemberRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MemberRole::Admin => write!(f, "Admin"),
            MemberRole::Member => write!(f, "Member"),
            MemberRole::Observer => write!(f, "Observer"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemberStatus {
    Active,
    Inactive,
    Suspended,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String, // Added required field
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationDispute {
    pub id: String,
    pub federation_id: String,
    pub initiator: String,
    pub reason: String,
    pub evidence: Option<String>,
    pub supporting_votes: HashMap<String, bool>,
    pub created_at: u64,
    pub status: DisputeStatus,
    pub resolution: Option<DisputeResolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub decision: String,
    pub rationale: String,
    pub resolved_at: u64,
    pub resolver: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DisputeStatus {
    Pending,
    Resolved,
    Rejected,
}

impl std::fmt::Display for DisputeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisputeStatus::Pending => write!(f, "Pending"),
            DisputeStatus::Resolved => write!(f, "Resolved"),
            DisputeStatus::Rejected => write!(f, "Rejected"),
        }
    }
}

#[derive(Error, Debug)]
pub enum FederationError {
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Already a member: {0}")]
    AlreadyMember(String),
    
    #[error("Invalid commitment: {0}")]
    InvalidCommitment(String),
    
    #[error("Insufficient resources: {resource_type}")]
    InsufficientResources { resource_type: String },
    
    #[error("Unauthorized action: {action} by {did}")]
    UnauthorizedAction { action: String, did: String },
    
    #[error("Member not found: {0}")]
    MemberNotFound(String),
    
    #[error("Invalid status transition from {from} to {to}")]
    InvalidStatusTransition { from: String, to: String },
    
    #[error("Insufficient permissions: {0}")]
    InsufficientPermissions(String),
    
    #[error("Invalid proposal type: {0}")] 
    InvalidProposalType(String),
    
    #[error("Voting period ended for proposal {0}")]
    VotingPeriodEnded(String),
    
    #[error("Proposal not found: {0}")]
    ProposalNotFound(String),
    
    #[error("Insufficient reputation: {0}")]
    InsufficientReputation(String),
    
    #[error("Dispute not found: {0}")]
    DisputeNotFound(String),
    
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    
    #[error("Consensus error: {0}")]
    ConsensusError(#[from] ConsensusError),
    
    #[error("Event publish error: {0}")]
    EventPublishError(String),
    
    #[error("Event subscribe error: {0}")]
    EventSubscribeError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEntry {
    pub action: String,
    pub target_federation: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossFederationProposal {
    pub id: String,
    pub source_federation: String,
    pub target_federation: String,
    pub proposal_type: CrossFederationProposalType,
    pub terms: CrossFederationTerms,
    pub votes: HashMap<String, bool>,
    pub status: ProposalStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CrossFederationProposalType {
    Merge,
    Alliance,
    ResourceSharing,
    DisputeResolution,
}

#[derive(Debug)]
pub struct BatchProcessor {
    pub coordinator: Arc<tokio::sync::Mutex<ProposalCoordinator>>,
}

#[derive(Debug)]
pub struct ProposalCoordinator {
    // Add fields as needed
}

impl ProposalCoordinator {
    pub async fn submit_batch(&self, batch: ProposalBatch) -> Result<(), FederationError> {
        // Implementation here
        Ok(())
    }
}

#[derive(Debug)]
pub struct ProposalBatch {
    proposals: Vec<FederationProposal>,
}

impl ProposalBatch {
    pub fn new() -> Self {
        Self {
            proposals: Vec::new(),
        }
    }

    pub fn add_proposal(&mut self, proposal: FederationProposal) {
        self.proposals.push(proposal);
    }
}

// Add missing types
#[derive(Debug)]
pub struct StorageError;

#[derive(Debug)]
pub struct ConsensusError;

#[derive(Debug, Clone)]
pub struct AssetAllocation {
    pub asset_type: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct DebtSettlement {
    pub debtor: String,
    pub creditor: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct MemberReassignment {
    pub member_id: String,
    pub new_federation: String,
}

#[derive(Debug, Clone)]
pub struct CrossFederationTerms {
    pub resource_sharing_terms: String,
    pub governance_terms: String,
}
```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 5761 bytes
Modified: 2025-03-07 09:09:46.448773684 +0000
Dependencies:
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;
use icn_types::Algorithm;
use kyber::decapsulate as kyber_decapsulate;
use kyber::encapsulate as kyber_encapsulate;
use kyber::keypair as kyber_keypair;
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};

===================
```rs
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn_types::Algorithm;
use kyber::keypair as kyber_keypair;
use kyber::encapsulate as kyber_encapsulate;
use kyber::decapsulate as kyber_decapsulate;
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;

pub enum Algorithm {
    Secp256k1,
    RSA,
    ECDSA,
    Kyber,
    Dilithium,
    Falcon,
}

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
}

impl KeyPair {
    pub fn generate(algorithm: Algorithm) -> Self {
        match algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let (private_key, public_key) = secp.generate_keypair(&mut rand::thread_rng());
                KeyPair {
                    public_key: public_key.serialize().to_vec(),
                    private_key: private_key[..].to_vec(),
                    algorithm,
                }
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::new(&mut rand::thread_rng(), 2048).expect("failed to generate a key");
                let public_key = RSAPublicKey::from(&private_key);
                KeyPair {
                    public_key: public_key.to_pkcs1().expect("failed to encode public key"),
                    private_key: private_key.to_pkcs1().expect("failed to encode private key"),
                    algorithm,
                }
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::random(&mut rand::thread_rng());
                let verifying_key = VerifyingKey::from(&signing_key);
                KeyPair {
                    public_key: verifying_key.to_bytes().to_vec(),
                    private_key: signing_key.to_bytes().to_vec(),
                    algorithm,
                }
            },
            Algorithm::Kyber => {
                let (public_key, private_key) = kyber_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Dilithium => {
                let (public_key, private_key) = dilithium_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Falcon => {
                let (public_key, private_key) = falcon_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
        }
    }

    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let private_key = SecretKey::from_slice(&self.private_key).expect("32 bytes");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                secp.sign(&message, &private_key).serialize_compact().to_vec()
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::from_pkcs1(&self.private_key).expect("failed to decode private key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                private_key.sign(padding, &Sha256::digest(message)).expect("failed to sign message")
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::from_bytes(&self.private_key).expect("failed to decode private key");
                signing_key.sign(message).to_bytes().to_vec()
            },
            Algorithm::Dilithium => {
                dilithium_sign(&self.private_key, message)
            },
            Algorithm::Falcon => {
                falcon_sign(&self.private_key, message)
            },
            _ => vec![],
        }
    }

    pub fn verify(&self, message: &[u8], signature: &[u8]) -> bool {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let public_key = PublicKey::from_slice(&self.public_key).expect("invalid public key");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                let signature = Signature::from_compact(signature).expect("invalid signature");
                secp.verify(&message, &signature, &public_key).is_ok()
            },
            Algorithm::RSA => {
                let public_key = RSAPublicKey::from_pkcs1(&self.public_key).expect("failed to decode public key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                public_key.verify(padding, &Sha256::digest(message), signature).is_ok()
            },
            Algorithm::ECDSA => {
                let verifying_key = VerifyingKey::from_bytes(&self.public_key).expect("failed to decode public key");
                verifying_key.verify(message, signature).is_ok()
            },
            Algorithm::Dilithium => {
                dilithium_verify(&self.public_key, message, signature)
            },
            Algorithm::Falcon => {
                falcon_verify(&self.public_key, message, signature)
            },
            _ => false,
        }
    }
}

pub fn hash(data: &[u8]) -> Vec<u8> {
    Sha256::digest(data).to_vec()
}
```

