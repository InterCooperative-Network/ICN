Project Code Dump - Generated Sat Dec 21 18:12:05 UTC 2024
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

File Organization:
- /backend/src/: Core Rust implementation
- /frontend/src/: React frontend application
- /contracts/: Smart contract implementations
- /docker/: Deployment configurations

======================

Project Tree:
=============
.
├── Cargo.lock
├── Cargo.toml
├── ICN.code-workspace
├── README.md
├── backend
│   └── Cargo.toml
├── contracts
│   ├── cooperative
│   │   └── src
│   └── governance
├── crates
│   ├── icn-consensus
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-core
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-crypto
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-p2p
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-runtime
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-storage
│   │   ├── Cargo.toml
│   │   └── src
│   └── icn-types
│       ├── Cargo.toml
│       └── src
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── identity
│   ├── did.rs
│   ├── identity_system.rs
│   └── mod.rs
├── improved-setup.sh
├── inventory_nodes.sh
├── old_src_backup
│   ├── config
│   ├── consensus
│   ├── network
│   ├── storage
│   └── vm
├── project_code_dump.txt
├── project_docs_dump.txt
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── src
│   └── block.rs
├── start_docs_server.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── docmanager.py
    │   ├── docsctl
    │   ├── specgen.py
    │   └── venv
    ├── install_docsctl.sh
    └── requirements.txt

===================
File: ./backend/Cargo.toml
Size: 617 bytes
Modified: 2024-12-17 00:38:49.193177112 +0000

===================
```toml
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[dependencies]
icn-types = { path = "../crates/icn-types" }
icn-core = { path = "../crates/icn-core" }
icn-consensus = { path = "../crates/icn-consensus" }
icn-crypto = { path = "../crates/icn-crypto" }
icn-p2p = { path = "../crates/icn-p2p" }
icn-runtime = { path = "../crates/icn-runtime" }
icn-storage = { path = "../crates/icn-storage" }
serde = "1.0"
secp256k1 = "0.21"
chrono = "0.4"
sha2 = "0.9"
tokio-tungstenite = "0.15"
warp = "0.3"
futures-util = "0.3"
hashbrown = "0.11"
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
```

===================
File: ./frontend/package.json
Size: 546 bytes
Modified: 2024-12-16 14:21:48.053095673 +0000

===================
```json
{
  "name": "icn-frontend",
  "version": "1.0.0",
  "description": "Frontend for the Inter-Cooperative Network",
  "main": "index.js",
  "scripts": {
    "start": "next start",
    "build": "next build",
    "dev": "next dev",
    "lint": "eslint .",
    "format": "prettier --write ."
  },
  "dependencies": {
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
  "devDependencies": {
    "eslint": "^7.32.0",
    "prettier": "^2.3.2",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^3.4.0"
  }
}
```

===================
File: ./docker/docker-compose.yml
Size: 829 bytes
Modified: 2024-12-17 00:38:49.194177112 +0000

===================

===================
File: ./.devcontainer/docker-compose.yml
Size: 829 bytes
Modified: 2024-12-16 14:21:48.047095702 +0000

===================

===================
File: ./crates/icn-storage/src/lib.rs
Size: 3686 bytes
Modified: 2024-12-16 14:21:48.049095692 +0000
Dependencies:
mod tests {
use icn-types::Block;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use thiserror::Error;
use tokio::sync::Mutex;

===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use thiserror::Error;
use icn-types::Block;

/// Errors that can occur in storage operations
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
}

/// Represents the result of storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Core storage interface for the system
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    
    /// Retrieve a value by key
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Manages persistent storage for the system
pub struct StorageManager {
    backend: Arc<Mutex<Box<dyn StorageBackend>>>,
}

impl StorageManager {
    /// Create a new storage manager with the given backend
    pub fn new(backend: Box<dyn StorageBackend>) -> Self {
        Self {
            backend: Arc::new(Mutex::new(backend)),
        }
    }
    
    /// Store a serializable value
    pub async fn store<T: Serialize>(&self, key: &str, value: &T) -> StorageResult<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| StorageError::SerializationError(e.to_string()))?;
            
        let backend = self.backend.lock().await;
        backend.set(key, &serialized).await
    }
    
    /// Retrieve and deserialize a value
    pub async fn retrieve<T: for<'de> Deserialize<'de>>(&self, key: &str) -> StorageResult<T> {
        let backend = self.backend.lock().await;
        let data = backend.get(key).await?;
        
        serde_json::from_slice(&data)
            .map_err(|e| StorageError::SerializationError(e.to_string()))
    }
    
    /// Delete a stored value
    pub async fn remove(&self, key: &str) -> StorageResult<()> {
        let backend = self.backend.lock().await;
        backend.delete(key).await
    }
    
    /// Check if a key exists in storage
    pub async fn has_key(&self, key: &str) -> StorageResult<bool> {
        let backend = self.backend.lock().await;
        backend.exists(key).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Mock storage backend for testing
    struct MockStorage {
        data: HashMap<String, Vec<u8>>,
    }
    
    #[async_trait::async_trait]
    impl StorageBackend for MockStorage {
        async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
            self.data.insert(key.to_string(), value.to_vec());
            Ok(())
        }
        
        async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
            self.data.get(key)
                .cloned()
                .ok_or_else(|| StorageError::NotFound(key.to_string()))
        }
        
        async fn delete(&self, key: &str) -> StorageResult<()> {
            self.data.remove(key);
            Ok(())
        }
        
        async fn exists(&self, key: &str) -> StorageResult<bool> {
            Ok(self.data.contains_key(key))
        }
    }
    
    #[tokio::test]
    async fn test_basic_storage_operations() {
        // Test implementation here
        // Will add comprehensive tests as we develop
    }
}
```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 4168 bytes
Modified: 2024-12-16 14:21:48.049095692 +0000
Dependencies:
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn-types::Algorithm;
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};

===================
```rs
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn-types::Algorithm;

pub enum Algorithm {
    Secp256k1,
    RSA,
    ECDSA,
}

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
}

impl KeyPair {
    pub fn generate(algorithm: Algorithm) -> Self {
        match algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let (private_key, public_key) = secp.generate_keypair(&mut rand::thread_rng());
                KeyPair {
                    public_key: public_key.serialize().to_vec(),
                    private_key: private_key[..].to_vec(),
                    algorithm,
                }
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::new(&mut rand::thread_rng(), 2048).expect("failed to generate a key");
                let public_key = RSAPublicKey::from(&private_key);
                KeyPair {
                    public_key: public_key.to_pkcs1().expect("failed to encode public key"),
                    private_key: private_key.to_pkcs1().expect("failed to encode private key"),
                    algorithm,
                }
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::random(&mut rand::thread_rng());
                let verifying_key = VerifyingKey::from(&signing_key);
                KeyPair {
                    public_key: verifying_key.to_bytes().to_vec(),
                    private_key: signing_key.to_bytes().to_vec(),
                    algorithm,
                }
            },
        }
    }

    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let private_key = SecretKey::from_slice(&self.private_key).expect("32 bytes");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                secp.sign(&message, &private_key).serialize_compact().to_vec()
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::from_pkcs1(&self.private_key).expect("failed to decode private key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                private_key.sign(padding, &Sha256::digest(message)).expect("failed to sign message")
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::from_bytes(&self.private_key).expect("failed to decode private key");
                signing_key.sign(message).to_bytes().to_vec()
            },
        }
    }

    pub fn verify(&self, message: &[u8], signature: &[u8]) -> bool {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let public_key = PublicKey::from_slice(&self.public_key).expect("invalid public key");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                let signature = Signature::from_compact(signature).expect("invalid signature");
                secp.verify(&message, &signature, &public_key).is_ok()
            },
            Algorithm::RSA => {
                let public_key = RSAPublicKey::from_pkcs1(&self.public_key).expect("failed to decode public key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                public_key.verify(padding, &Sha256::digest(message), signature).is_ok()
            },
            Algorithm::ECDSA => {
                let verifying_key = VerifyingKey::from_bytes(&self.public_key).expect("failed to decode public key");
                verifying_key.verify(message, signature).is_ok()
            },
        }
    }
}

pub fn hash(data: &[u8]) -> Vec<u8> {
    Sha256::digest(data).to_vec()
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 19644 bytes
Modified: 2024-12-16 01:24:43.503945460 +0000
Dependencies:
use chrono::{DateTime, Utc};
use lazy_static::lazy_static;
use rayon::prelude::*;
use serde::{Serialize, Deserialize};
use serde_derive::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;
use std::sync::Mutex;
use std::time::SystemTime;
use thiserror::Error;
use tokio::task;

===================
```rs
use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use serde_derive::{Serialize, Deserialize};
use tokio::task;
use rayon::prelude::*;
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum BlockError {
    #[error("Invalid block hash")]
    InvalidHash,
    #[error("Previous hash mismatch")]
    PreviousHashMismatch,
    #[error("Invalid block index")]
    InvalidIndex,
    #[error("Invalid timestamp")]
    InvalidTimestamp,
    #[error("Invalid transaction: {0}")]
    InvalidTransaction(String),
    #[error("Resource usage mismatch")]
    ResourceMismatch,
    #[error("Relationship metadata mismatch")]
    MetadataMismatch,
}

#[derive(Debug)]
pub struct ResourceDebt {
    pub cpu_debt: u64,
    pub memory_debt: u64,
    pub bandwidth_debt: u64,
}

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    /// Sequential index of this block in the chain
    pub index: u64,
    
    /// Hash of the previous block
    pub previous_hash: String,
    
    /// Unix timestamp in milliseconds when block was created
    pub timestamp: u64,
    
    /// List of transactions included in this block
    pub transactions: Vec<Transaction>,
    
    /// Hash of this block's contents
    pub hash: String,
    
    /// The DID of the validator that proposed this block
    pub proposer: String,
    
    /// Collection of validator signatures approving this block
    pub signatures: Vec<BlockSignature>,
    
    /// Metadata about the block creation
    pub metadata: BlockMetadata,
}

/// Signature from a validator approving a block
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    /// DID of the signing validator
    pub validator_did: String,
    
    /// The signature itself
    pub signature: String,
    
    /// Timestamp when signature was created
    pub timestamp: DateTime<Utc>,
    
    /// Voting power of the validator at time of signing
    pub voting_power: f64,
}

/// Additional metadata about block creation and validation
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    /// Time taken to reach consensus (milliseconds)
    pub consensus_duration_ms: u64,
    
    /// Number of validators that participated
    pub validator_count: u32,
    
    /// Total voting power that approved the block
    pub total_voting_power: f64,
    
    /// Total resources consumed by transactions in the block
    pub resources_used: u64,
    
    /// Size of the block in bytes
    pub size: u64,
    
    /// Summary of relationship transactions
    pub relationship_updates: RelationshipMetadata,
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

lazy_static! {
    static ref TRANSACTION_CACHE: Mutex<HashMap<String, bool>> = Mutex::new(HashMap::new());
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            signatures: Vec::new(),
            metadata,
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        // Add block header fields
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        // Add transaction hashes
        let transaction_hashes: Vec<String> = self.transactions.par_iter()
            .map(|tx| tx.hash.clone())
            .collect();
        for tx_hash in transaction_hashes {
            hasher.update(tx_hash);
        }
        
        // Add proposer
        hasher.update(&self.proposer);
        
        // Convert hash to hex string
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub async fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        let signature_task = task::spawn(async move {
            BlockSignature {
                validator_did,
                signature,
                timestamp: Utc::now(),
                voting_power,
            }
        });

        let new_signature = signature_task.await.unwrap();
        self.signatures.push(new_signature);

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub async fn verify(&self, previous_block: Option<&Block>) -> Result<(), BlockError> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err(BlockError::InvalidHash);
        }

        // Verify previous block linkage
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err(BlockError::PreviousHashMismatch);
            }
            if self.index != prev.index + 1 {
                return Err(BlockError::InvalidIndex);
            }
            if self.timestamp <= prev.timestamp {
                return Err(BlockError::InvalidTimestamp);
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err(BlockError::InvalidTimestamp);
        }

        // Group transactions by type
        let mut grouped_transactions: HashMap<&str, Vec<&Transaction>> = HashMap::new();
        for tx in &self.transactions {
            let tx_type = match &tx.transaction_type {
                TransactionType::Transfer { .. } => "Transfer",
                TransactionType::ContractExecution { .. } => "ContractExecution",
                TransactionType::RecordContribution { .. } => "RecordContribution",
                TransactionType::RecordMutualAid { .. } => "RecordMutualAid",
                TransactionType::UpdateRelationship { .. } => "UpdateRelationship",
                TransactionType::AddEndorsement { .. } => "AddEndorsement",
            };
            grouped_transactions.entry(tx_type).or_default().push(tx);
        }

        // Validate transactions in parallel
        let validation_tasks: Vec<_> = grouped_transactions.iter()
            .flat_map(|(_, txs)| txs.iter().map(|tx| {
                let tx_hash = tx.hash.clone();
                task::spawn(async move {
                    let mut cache = TRANSACTION_CACHE.lock().unwrap();
                    if let Some(&is_valid) = cache.get(&tx_hash) {
                        is_valid
                    } else {
                        let is_valid = tx.validate();
                        cache.insert(tx_hash, is_valid);
                        is_valid
                    }
                })
            }))
            .collect();

        for task in validation_tasks {
            if !task.await.unwrap() {
                return Err(BlockError::InvalidTransaction("One or more invalid transactions".into()));
            }
        }

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err(BlockError::ResourceMismatch);
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err(BlockError::MetadataMismatch);
        }

        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> RelationshipMetadata {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        metadata
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }

    /// Finalizes the block and ensures all validations pass
    pub async fn finalize(&mut self) -> Result<(), BlockError> {
        self.verify(None).await?;
        
        let resource_usage = self.transactions.par_iter()
            .map(|tx| tx.resource_cost)
            .sum();
            
        self.metadata.resources_used = resource_usage;
        
        self.metadata.size = bincode::serialize(&self)
            .map_err(|_| BlockError::InvalidHash)?
            .len() as u64;
            
        self.hash = self.calculate_hash();
        
        Ok(())
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: std::collections::HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,
    pub transaction_type: TransactionType,
    pub timestamp: u128,
    pub hash: String,
    pub resource_cost: u64,      // Resource points required for this transaction
    pub resource_priority: u8,    // Priority level for resource allocation (1-10)
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);
        
        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
            resource_cost,
            resource_priority: 5, // Default priority level
        }
    }

    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                // Base cost plus percentage of transfer amount
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                // Base cost plus data size cost
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                // Cost based on content size and complexity
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                // Base cost plus content size
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                // Base cost plus story length
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                // Base cost plus content and skills
                60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        // Ensure sender is not empty
        if self.sender.is_empty() {
            return false;
        }

        // Validate based on transaction type
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && 
                !impact_story.is_empty() && 
                !context.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && 
                !description.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && 
                !relationship_type.is_empty() && 
                !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && 
                !content.is_empty() && 
                !context.is_empty() && 
                !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend(self.sender.as_bytes());
        bytes.extend(self.hash.as_bytes());
        bytes.extend(&self.timestamp.to_be_bytes());
        bytes
    }
}
```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 86 bytes
Modified: 2024-12-16 14:21:48.049095692 +0000
Dependencies:
use icn-types::Transaction;

===================
```rs
pub mod websocket;
pub mod protocol;
pub mod networking;

use icn-types::Transaction;
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 518 bytes
Modified: 2024-12-16 14:21:48.049095692 +0000
Dependencies:
use async_trait::async_trait;
use icn_types::{Block, Transaction};

===================
```rs
use async_trait::async_trait;
use icn_types::{Block, Transaction};

pub struct RuntimeManager {
    // Fields for the RuntimeManager struct
}

impl RuntimeManager {
    // Methods for the RuntimeManager struct
}

#[async_trait]
pub trait VM {
    async fn execute_transaction(&self, transaction: Transaction);
    async fn execute_block(&self, block: Block);
}

pub struct ContractExecution {
    // Fields for the ContractExecution struct
}

impl ContractExecution {
    // Methods for the ContractExecution struct
}
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 2357 bytes
Modified: 2024-12-16 14:21:48.049095692 +0000
Dependencies:
use async_trait::async_trait;
use icn_core::ReputationManager;
use icn_types::Block;
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::sleep;

===================
```rs
pub mod proof_of_cooperation;
pub mod validation;
pub mod round_management;
pub mod timeout_handling;

use async_trait::async_trait;
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::sleep;
use icn_core::ReputationManager;
use icn_types::Block;

pub struct ProofOfCooperation {
    current_round: u64,
    participants: Vec<String>,
    proposed_block: Option<Block>,
    votes: HashMap<String, bool>,
    timeout: Duration,
    timeout_handling: timeout_handling::TimeoutHandling,
    reputation_manager: Arc<dyn ReputationManager>,
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: Arc<dyn ReputationManager>) -> Self {
        ProofOfCooperation {
            current_round: 0,
            participants: Vec::new(),
            proposed_block: None,
            votes: HashMap::new(),
            timeout: Duration::from_secs(60),
            timeout_handling: timeout_handling::TimeoutHandling::new(Duration::from_secs(60)),
            reputation_manager,
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
    }

    pub fn propose_block(&mut self, block: Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            self.votes.insert(participant, vote);
        }
    }

    pub fn finalize_block(&self) -> Option<Block> {
        let total_reputation: i64 = self.votes.keys().map(|p| self.reputation_manager.get_reputation(p, "consensus")).sum();
        let approval_reputation: i64 = self.votes.iter().filter(|&(_, &v)| v).map(|(p, _)| self.reputation_manager.get_reputation(p, "consensus")).sum();

        if approval_reputation > total_reputation / 2 {
            self.proposed_block.clone()
        } else {
            None
        }
    }

    pub async fn handle_timeout(&self) {
        self.timeout_handling.handle_timeout().await;
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus")
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) {
        // Start the consensus process
    }

    async fn stop(&self) {
        // Stop the consensus process
    }
}
```

===================
File: ./crates/icn-core/src/lib.rs
Size: 4097 bytes
Modified: 2024-12-16 01:18:30.662003017 +0000
Dependencies:
use async_trait::async_trait;
use icn_consensus::ProofOfCooperation;
use icn_types::{Block, Transaction};
use std::sync::Arc;

===================
```rs
use std::sync::Arc;
use async_trait::async_trait;
use icn_types::{Block, Transaction};
use icn_consensus::ProofOfCooperation;

pub struct Core {
    consensus: Arc<dyn ConsensusEngine>,
    storage: Arc<dyn StorageManager>,
    network: Arc<dyn NetworkManager>,
    runtime: Arc<dyn RuntimeManager>,
    telemetry: Arc<TelemetryManager>,
    identity: Arc<dyn IdentityManager>,
    reputation: Arc<dyn ReputationManager>,
}

impl Core {
    pub fn new(
        storage: Arc<dyn StorageManager>,
        network: Arc<dyn NetworkManager>,
        runtime: Arc<dyn RuntimeManager>,
        telemetry: Arc<TelemetryManager>,
        identity: Arc<dyn IdentityManager>,
        reputation: Arc<dyn ReputationManager>,
    ) -> Self {
        let consensus = Arc::new(ProofOfCooperation::new(reputation.clone()));
        Core {
            consensus,
            storage,
            network,
            runtime,
            telemetry,
            identity,
            reputation,
        }
    }

    pub async fn start(&self) {
        self.telemetry.log("Starting Core...");
        self.consensus.start().await;
        self.network.start().await;
        self.runtime.start().await;
        self.identity.start().await;
        self.reputation.start().await;
        self.telemetry.log("Core started.");
    }

    pub async fn stop(&self) {
        self.telemetry.log("Stopping Core...");
        self.runtime.stop().await;
        self.network.stop().await;
        self.consensus.stop().await;
        self.identity.stop().await;
        self.reputation.stop().await;
        self.telemetry.log("Core stopped.");
    }

    pub async fn process_transaction(&self, transaction: Transaction) {
        self.telemetry.log("Processing transaction...");
        self.runtime.execute_transaction(transaction).await;
        self.telemetry.log("Transaction processed.");
    }

    pub async fn add_block(&self, block: Block) {
        self.telemetry.log("Adding block...");
        self.storage.store_block(block).await;
        self.telemetry.log("Block added.");
    }
}

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self);
    async fn stop(&self);
}

#[async_trait]
pub trait StorageManager {
    async fn store_block(&self, block: Block);
}

#[async_trait]
pub trait NetworkManager {
    async fn start(&self);
    async fn stop(&self);
}

#[async_trait]
pub trait RuntimeManager {
    async fn start(&self);
    async fn stop(&self);
    async fn execute_transaction(&self, transaction: Transaction);
}

#[async_trait]
pub trait IdentityManager {
    async fn start(&self);
    async fn stop(&self);
    async fn register_did(&self, did: String, public_key: String, algorithm: Algorithm);
    async fn verify_did(&self, did: String, signature: String, algorithm: Algorithm) -> bool;
}

#[async_trait]
pub trait ReputationManager {
    async fn start(&self);
    async fn stop(&self);
    async fn adjust_reputation(&self, did: String, change: i64, category: String);
    async fn get_reputation(&self, did: String, category: String) -> i64;
    async fn is_eligible(&self, did: String, min_reputation: i64, category: String) -> bool;
}
pub struct TelemetryManager {
    metrics: PrometheusMetrics,
    logger: Logger,
    traces: TracingSystem,
}

impl TelemetryManager {
    pub fn new(metrics: PrometheusMetrics, logger: Logger, traces: TracingSystem) -> Self {
        TelemetryManager {
            metrics,
            logger,
            traces,
        }
    }

    pub fn log(&self, message: &str) {
        self.logger.log(message);
        self.traces.trace(message);
    }

    pub fn record_metric(&self, name: &str, value: f64) {
        self.metrics.record(name, value);
    }
}

pub struct PrometheusMetrics;

impl PrometheusMetrics {
    pub fn record(&self, name: &str, value: f64) {
        // Record the metric
    }
}

pub struct Logger;

impl Logger {
    pub fn log(&self, message: &str) {
        // Log the message
    }
}

pub struct TracingSystem;

impl TracingSystem {
    pub fn trace(&self, message: &str) {
        // Trace the message
    }
}
```

