Project Code Dump - Generated Sat 22 Feb 2025 02:30:02 AM UTC
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

File Organization:
- /backend/src/: Core Rust implementation
- /frontend/src/: React frontend application
- /contracts/: Smart contract implementations
- /docker/: Deployment configurations

======================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── migrations
│   │   └── 20240218000000_initial.sql
│   └── src
│       ├── api
│       ├── blockchain.rs
│       ├── core
│       ├── core.rs
│       ├── database
│       ├── db.rs
│       ├── governance.rs
│       ├── identity.rs
│       ├── lib.rs
│       ├── main.rs
│       ├── middleware
│       ├── models.rs
│       ├── networking
│       ├── networking.rs
│       ├── reputation.rs
│       ├── services
│       ├── storage.rs
│       └── vm.rs
├── Cargo.lock
├── Cargo.toml
├── config
│   └── feature-flags.json
├── contracts
│   ├── Cargo.toml
│   └── cooperative
│       └── src
├── crates
│   ├── consensus
│   │   └── Cargo.toml
│   ├── core
│   │   └── Cargo.toml
│   ├── finance
│   │   └── src
│   ├── icn-consensus
│   │   ├── Cargo.toml
│   │   ├── README.md
│   │   └── src
│   ├── icn-core
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-crypto
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-dsl
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-federation
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-governance
│   │   └── src
│   ├── icn-mutual-credit
│   │   └── src
│   ├── icn-p2p
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-resource
│   │   └── src
│   ├── icn-runtime
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-storage
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-types
│   │   ├── Cargo.toml
│   │   └── src
│   ├── identity
│   ├── networking
│   │   └── Cargo.toml
│   ├── resources
│   │   └── Cargo.toml
│   ├── runtime
│   │   └── Cargo.toml
│   └── storage
│       └── Cargo.toml
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── DSL_ICN.txt
├── frontend
│   ├── Cargo.toml
│   ├── package.json
│   ├── postcss.config.js
│   ├── src
│   │   ├── components
│   │   └── styles
│   ├── tailwind.config.js
│   └── tsconfig.json
├── fsprovider-sample
│   ├── CHANGELOG.md
│   ├── eslint.config.mjs
│   ├── package.json
│   ├── package-lock.json
│   ├── README.md
│   ├── sample.png
│   ├── src
│   │   ├── extension.ts
│   │   └── fileSystemProvider.ts
│   └── tsconfig.json
├── generate_code_dump.sh
├── grammar
│   ├── coop_lang.pest
│   └── did_grammar.peg
├── ICN.code-workspace
├── icn-consensus
│   └── src
│       └── lib.rs
├── icn-core
│   └── src
│       ├── storage.rs
│       └── transaction.rs
├── identity
│   ├── did.rs
│   ├── identity_system.rs
│   ├── key_manager.rs
│   └── mod.rs
├── improved-setup.sh
├── inventory_nodes.sh
├── messaging
│   └── server.rs
├── project_code_dump.txt
├── project_docs_dump.txt
├── README.md
├── reputation
│   ├── errors.rs
│   └── reputation_manager.rs
├── scripts
│   ├── backend
│   │   ├── Cargo.toml
│   │   └── src
│   ├── contracts
│   ├── crates
│   ├── frontend
│   │   ├── package-lock.json
│   │   └── src
│   └── setup.sh
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── src
│   ├── api
│   │   └── types.ts
│   ├── attestation
│   ├── block.rs
│   ├── cache.js
│   ├── dsl
│   │   ├── governance.rs
│   │   ├── grammar.pest
│   │   ├── mod.rs
│   │   ├── parser.rs
│   │   └── vm.rs
│   ├── errors.js
│   ├── feature-flags
│   ├── governance
│   │   ├── mod.rs
│   │   └── rollback.rs
│   ├── logger.js
│   ├── parser.rs
│   └── security.js
├── start_docs_server.sh
├── Technical_Architecture.md
└── tools
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── docmanager.py
    │   ├── docsctl
    │   ├── __init__.py
    │   └── specgen.py
    ├── install_docsctl.sh
    ├── README.md
    └── requirements.txt

===================
File: ./backend/Cargo.toml
Size: 478 bytes
Modified: 2025-02-22 01:12:53.285021400 +0000

===================
```toml
[package]
name = "backend"
version = "0.1.0"
edition = "2018"

[dependencies]
tokio = { version = "1.30", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
sqlx = { version = "0.7", features = ["postgres", "runtime-tokio"] }
icn-federation = { path = "../crates/icn-federation" }
tower = { version = "0.4", features = ["limit"] }
tower-http = { version = "0.4", features = ["limit"] }
bls-signatures = "0.8"
didcomm-rs = "0.1"
```

===================
File: ./scripts/backend/Cargo.toml
Size: 78 bytes
Modified: 2025-02-18 07:59:01.136149500 +0000

===================
```toml
[package]
name = "backend"
version = "0.1.0"
edition = "2021"

[dependencies]
```

===================
File: ./backend/src/lib.rs
Size: 97 bytes
Modified: 2025-02-21 00:12:17.835165200 +0000
Dependencies:

===================
```rs
pub mod api;
pub mod services;
pub mod database;
pub mod networking;
pub mod core;
pub mod main;
```

===================
File: ./backend/src/main.rs
Size: 11224 bytes
Modified: 2025-02-21 01:12:45.445193600 +0000
Dependencies:
mod config;
mod core;
mod db;
mod federation;
mod middleware;
mod notification;
mod reputation;
mod websocket;
use async_trait::async_trait;
use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::create_pool;
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use dashmap::DashMap;
use env_logger;
use futures_util::StreamExt;
use log::{info, error};
use middleware::rate_limit::with_rate_limit;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::sync::Arc;
use thiserror::Error;
use tokio;
use tokio::signal;
use warp::cors::Cors;
use warp::{Filter, ws::{WebSocket, Message}};
use warp::http::Method;

===================
```rs
mod config;
mod core;
mod db;
mod federation;
mod notification;
mod reputation;
mod websocket;
mod middleware;

use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use tokio;
use log::{info, error};
use env_logger;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use futures_util::StreamExt;
use warp::{Filter, ws::{WebSocket, Message}};
use dashmap::DashMap;
use sqlx::PgPool;
use thiserror::Error;
use reqwest::Client;
use tokio::signal;
use async_trait::async_trait;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use warp::http::Method;
use warp::cors::Cors;
use crate::db::create_pool;
use middleware::rate_limit::with_rate_limit;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    #[error("Validation error: {0}")]
    ValidationError(String),
}

#[derive(Serialize, Deserialize)]
struct Proposal {
    id: String,
    title: String,
    description: String,
    status: String,
    votes_for: i64,
    votes_against: i64,
    created_by: String,
    ends_at: String,
}

#[derive(Serialize, Deserialize)]
struct Vote {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Serialize, Deserialize)]
struct TokenizedResource {
    resource_id: String,
    owner: String,
    quantity: u64,
    price_per_unit: f64,
}

#[tokio::main]
async fn main() -> Result<(), AppError> {
    // Initialize logging with env_logger
    env_logger::init();

    // Load and validate configuration
    let config: Config = config::load_config().map_err(|e| AppError::ConfigError(e.to_string()))?;
    config.validate()?;
    
    // Create a single database pool
    let db_pool = create_pool()
        .await
        .map_err(AppError::DatabaseError)?;
    let db_pool = Arc::new(db_pool);
    
    // Share the pool with all services
    let storage_backend = DatabaseStorageBackend::new(db_pool.clone());
    let storage_manager = StorageManager::new(Box::new(storage_backend));
    let governance_service = Arc::new(Mutex::new(GovernanceService::new(db_pool.clone())));
    
    // Initialize other components with shared pool
    let websocket_clients: WebSocketClients = Arc::new(DashMap::new());
    let network_manager = NetworkManager::new();
    let runtime_manager = RuntimeManager::new();
    let telemetry_manager = TelemetryManager::new(PrometheusMetrics, Logger, TracingSystem);
    let identity_manager = IdentityManager::new();
    let reputation_cache = ReputationCache::new(config.reputation_cache_max_size);
    let reputation_manager = ReputationManager::new(
        config.governance_decay_rate,
        config.resource_sharing_decay_rate,
        config.technical_contributions_decay_rate,
        config.decay_exemptions.clone(),
        reputation_cache,
    );

    let notification_manager = NotificationManager::new(config.notification_email.clone(), config.notification_sms.clone());

    // Create core system
    let core = Core::new(
        Arc::new(storage_manager),
        Arc::new(network_manager),
        Arc::new(runtime_manager),
        Arc::new(telemetry_manager),
        Arc::new(identity_manager),
        Arc::new(reputation_manager),
    );

    // Start core system
    if let Err(e) = core.start().await {
        error!("Failed to start core system: {}", e);
        return Err(AppError::ConfigError(e));
    }

    // Set up WebSocket server
    let websocket_route = warp::path("ws")
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let websocket_clients = websocket_clients.clone();
            ws.on_upgrade(move |socket| handle_websocket(socket, websocket_clients))
        });
    
    // Apply rate limits to routes
    let create_proposal = with_rate_limit(
        warp::path!("api" / "v1" / "governance" / "proposals")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |proposal: Proposal| {
                let ns = notification_manager.clone();
                let wc = websocket_clients.clone();
                let gs = governance_service.clone();
                async move {
                    let mut service = gs.lock().await;
                    service.handle_create_proposal(proposal, ns, wc).await
                }
            }),
        10 // 10 requests per second
    );

    let vote_on_proposal = with_rate_limit(
        warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |proposal_id: String, vote: Vote| {
                let ns = notification_manager.clone();
                let wc = websocket_clients.clone();
                let gs = governance_service.clone();
                async move {
                    // Set the proposal_id in vote if not matching
                    let vote = Vote { proposal_id, ..vote };
                    let mut service = gs.lock().await;
                    service.handle_vote_on_proposal(vote, ns, wc).await
                }
            }),
        20 // 20 requests per second
    );

    let federation_routes = with_rate_limit(
        warp::path("api/v1/federation")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |operation: FederationOperation| {
                let notification_manager = notification_manager.clone();
                async move {
                    handle_federation_operation(operation, notification_manager).await
                }
            }),
        5 // 5 requests per second
    );

    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and_then(move || {
            async move {
                handle_query_shared_resources().await
            }
        });

    let cors = warp::cors()
        .allow_any_origin()
        .allow_methods(&[Method::GET, Method::POST, Method::PUT, Method::DELETE])
        .allow_headers(vec!["content-type"]);

    let routes = create_proposal
        .or(vote_on_proposal)
        .or(federation_routes)
        .or(query_shared_resources)
        .or(websocket_route)
        .with(cors);

    let server = warp::serve(routes).run(([0, 0, 0, 0], 8081));

    // Handle graceful shutdown
    let shutdown_signal = async {
        signal::ctrl_c().await.expect("Failed to install CTRL+C signal handler");
    };

    info!("Warp server started.");
    let (_, server_result) = tokio::join!(shutdown_signal, server);

    if let Err(e) = server_result {
        error!("Warp server encountered an error: {}", e);
    }

    // Stop core system
    if let Err(e) = core.stop().await {
        error!("Failed to stop core system: {}", e);
    }

    info!("Backend application stopped.");
    Ok(())
}

async fn handle_federation_operation(operation: FederationOperation, notification_manager: NotificationManager) -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle federation operations
    let subject = match &operation {
        FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
            format!("Federation Initiated: {:?}", federation_type)
        }
        FederationOperation::JoinFederation { federation_id, commitment } => {
            format!("Joined Federation: {}", federation_id)
        }
        FederationOperation::LeaveFederation { federation_id, reason } => {
            format!("Left Federation: {}", federation_id)
        }
        FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
            format!("Action Proposed in Federation: {}", federation_id)
        }
        FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
            format!("Vote on Federation Proposal: {}", proposal_id)
        }
        FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
            format!("Resources Shared in Federation: {}", federation_id)
        }
        FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
            format!("Federation Terms Updated: {}", federation_id)
        }
    };

    let body = format!("Federation operation executed: {:?}", operation);
    notification_manager.send_notification(&subject, &body).await;
    Ok(warp::reply::json(&operation))
}

async fn handle_query_shared_resources() -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle querying shared resources
    let resources = vec![
        TokenizedResource {
            resource_id: "resource1".to_string(),
            owner: "did:icn:owner1".to_string(),
            quantity: 100,
            price_per_unit: 10.0,
        },
        TokenizedResource {
            resource_id: "resource2".to_string(),
            owner: "did:icn:owner2".to_string(),
            quantity: 200,
            price_per_unit: 20.0,
        },
    ];
    Ok(warp::reply::json(&resources))
}

struct DatabaseStorageBackend {
    pool: PgPool,
}

impl DatabaseStorageBackend {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.exists.unwrap_or(false))
    }
}
```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
Modified: 2025-02-18 07:59:01.140151200 +0000
Dependencies:

===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./frontend/package.json
Size: 499 bytes
Modified: 2025-02-19 06:23:14.811145100 +0000

===================
```json
{
  "name": "icn-frontend",
  "version": "1.0.0",
  "description": "Frontend for the Inter-Cooperative Network",
  "main": "index.js",
  "scripts": {
    "start": "next start",
    "build": "next build",
    "dev": "next dev",
    "lint": "eslint .",
    "format": "prettier --write ."
  },
  "dependencies": {
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
  "devDependencies": {
main
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

===================
File: ./.devcontainer/docker-compose.yml
Size: 973 bytes
Modified: 2025-02-19 00:47:20.891182900 +0000

===================

===================
File: ./docker/docker-compose.yml
Size: 1347 bytes
Modified: 2025-02-19 00:47:20.971282200 +0000

===================

===================
File: ./backend/src/api/federation.rs
Size: 5968 bytes
Modified: 2025-02-22 01:34:39.158092200 +0000
Dependencies:
use icn_federation::{FederationService, FederationOperation};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_federation::{FederationService, FederationOperation};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};

#[derive(Debug, Deserialize, Serialize)]
struct InitiateFederationRequest {
    federation_type: String,
    partner_id: String,
    terms: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct JoinFederationRequest {
    federation_id: String,
    commitment: String,
}

pub fn federation_routes(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let initiate_federation = warp::path!("api" / "v1" / "federation" / "initiate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and_then(initiate_federation_handler);

    let join_federation = warp::path!("api" / "v1" / "federation" / "join")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and_then(join_federation_handler);

    let initiate_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolve")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and_then(initiate_federation_dissolution_handler);

    let get_dissolution_status = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "status")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and_then(get_dissolution_status_handler);

    let cancel_federation_dissolution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "cancel")
        .and(warp::post())
        .and(with_federation_service(federation_service.clone()))
        .and_then(cancel_federation_dissolution_handler);

    let get_asset_distribution = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "assets")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and_then(get_asset_distribution_handler);

    let get_debt_settlements = warp::path!("api" / "v1" / "federation" / String / "dissolution" / "debts")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and_then(get_debt_settlements_handler);

    initiate_federation
        .or(join_federation)
        .or(initiate_federation_dissolution)
        .or(get_dissolution_status)
        .or(cancel_federation_dissolution)
        .or(get_asset_distribution)
        .or(get_debt_settlements)
}

fn with_federation_service(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = (Arc<Mutex<FederationService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || federation_service.clone())
}

async fn initiate_federation_handler(
    request: InitiateFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::InitiateFederation {
        federation_type: request.federation_type,
        partner_id: request.partner_id,
        terms: request.terms,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => Ok(warp::reply::json(&"Federation initiated")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn join_federation_handler(
    request: JoinFederationRequest,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = FederationOperation::JoinFederation {
        federation_id: request.federation_id,
        commitment: request.commitment,
    };

    let mut service = federation_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => Ok(warp::reply::json(&"Joined federation")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn initiate_federation_dissolution_handler(
    federation_id: String,
    request: DissolutionRequest,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    let protocol = service.initiate_dissolution(&federation_id, &request.initiator_id, request.reason.clone()).await?;
    Ok(warp::reply::json(&protocol))
}

async fn get_dissolution_status_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let status = service.get_federation_dissolution_status(&federation_id).await?;
    Ok(warp::reply::json(&status))
}

async fn cancel_federation_dissolution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = federation_service.lock().await;
    service.cancel_dissolution(&federation_id).await?;
    Ok(warp::reply::json(&"Dissolution cancelled"))
}

async fn get_asset_distribution_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let distribution = service.calculate_asset_distribution(&federation_id).await?;
    Ok(warp::reply::json(&distribution))
}

async fn get_debt_settlements_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    let settlements = service.settle_outstanding_debts(&federation_id).await?;
    Ok(warp::reply::json(&settlements))
}
```

===================
File: ./backend/src/api/governance.rs
Size: 4076 bytes
Modified: 2025-02-22 01:46:06.133659300 +0000
Dependencies:
use crate::services::governance_service::{GovernanceService, Proposal, Vote};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::governance_service::{GovernanceService, Proposal, Vote};

#[derive(Debug, Deserialize, Serialize)]
struct CreateProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize)]
struct RecallVoteRequest {
    target_member: String,
    voter: String,
    approve: bool,
}

pub fn governance_routes(
    governance_service: Arc<Mutex<GovernanceService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_proposal = warp::path!("api" / "v1" / "governance" / "proposals")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and_then(create_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and_then(vote_on_proposal_handler);

    let recall_vote = warp::path!("api" / "v1" / "governance" / "recall")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and_then(recall_vote_handler);

    let check_expiring = warp::path!("api" / "v1" / "governance" / "proposals" / String / "expiring")
        .and(warp::get())
        .and(with_governance_service(governance_service.clone()))
        .and_then(check_proposal_expiring_handler);

    create_proposal
        .or(vote_on_proposal)
        .or(recall_vote)
        .or(check_expiring)
}

fn with_governance_service(
    governance_service: Arc<Mutex<GovernanceService>>,
) -> impl Filter<Extract = (Arc<Mutex<GovernanceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || governance_service.clone())
}

async fn create_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => Ok(warp::reply::json(&proposal_id)),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => Ok(warp::reply::json(&"Vote recorded")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn recall_vote_handler(
    request: RecallVoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.process_recall_vote(&request.voter, &request.target_member, request.approve).await {
        Ok(_) => Ok(warp::reply::json(&"Recall vote recorded")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn check_proposal_expiring_handler(
    proposal_id: String,
    governance_service: Arc<Mutex<GovernanceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = governance_service.lock().await;
    match service.check_proposal_expiration(&proposal_id).await {
        Ok(is_expiring) => Ok(warp::reply::json(&is_expiring)),
        Err(e) => Err(warp::reject::custom(e)),
    }
}
```

===================
File: ./backend/src/api/identity.rs
Size: 2920 bytes
Modified: 2025-02-22 01:12:53.304105000 +0000
Dependencies:
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use std::sync::Arc;
use warp::Filter;

===================
```rs
use warp::Filter;
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use std::sync::Arc;

pub fn identity_routes(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_identity = warp::path!("api" / "v1" / "identity" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_create_identity);

    let get_identity = warp::path!("api" / "v1" / "identity" / "get" / String)
        .and(warp::get())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_get_identity);

    let rotate_key = warp::path!("api" / "v1" / "identity" / "rotate_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_rotate_key);

    let revoke_key = warp::path!("api" / "v1" / "identity" / "revoke_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_revoke_key);

    create_identity.or(get_identity).or(rotate_key).or(revoke_key)
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn handle_create_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.create_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Identity created", warp::http::StatusCode::CREATED))
}

async fn handle_get_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let data = identity_service.get_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::json(&data))
}

async fn handle_rotate_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.rotate_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key rotated", warp::http::StatusCode::OK))
}

async fn handle_revoke_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.revoke_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key revoked", warp::http::StatusCode::OK))
}
```

===================
File: ./backend/src/api/reputation.rs
Size: 1235 bytes
Modified: 2025-02-22 01:12:53.322526200 +0000
Dependencies:
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution};
use warp::Filter;

===================
```rs
use warp::Filter;
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution};

pub fn reputation_routes() -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path("api")
        .and(
            warp::path("v1")
                .and(
                    warp::path("reputation")
                        .and(
                            warp::path("get")
                                .and(warp::get())
                                .and(warp::query::<String>())
                                .and_then(get_reputation)
                        )
                        .or(
                            warp::path("adjust")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(adjust_reputation)
                        )
                        .or(
                            warp::path("verify")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(verify_contribution)
                        )
                )
        )
}
```

===================
File: ./backend/src/api/resources.rs
Size: 2100 bytes
Modified: 2025-02-21 00:12:21.812455800 +0000
Dependencies:
use crate::services::resource_service::{ResourceService, ResourceQuery};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::resource_service::{ResourceService, ResourceQuery};

#[derive(Debug, Deserialize, Serialize)]
struct QuerySharedResourcesRequest {
    resource_type: String,
    owner: Option<String>,
}

pub fn resource_routes(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(query_shared_resources_handler);

    query_shared_resources
}

fn with_resource_service(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = (Arc<Mutex<ResourceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || resource_service.clone())
}

async fn query_shared_resources_handler(
    request: QuerySharedResourcesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let query = ResourceQuery {
        resource_type: request.resource_type,
        owner: request.owner,
    };

    let mut service = resource_service.lock().await;
    match service.query_shared_resources(query).await {
        Ok(resources) => {
            // Use EXPLAIN ANALYZE to verify index usage
            let explain_query = format!(
                "EXPLAIN ANALYZE SELECT * FROM resources WHERE resource_type = '{}' AND owner = '{}'",
                request.resource_type,
                request.owner.clone().unwrap_or_default()
            );
            let explain_result = sqlx::query(&explain_query)
                .fetch_all(&service.pool)
                .await
                .map_err(|e| warp::reject::custom(e))?;
            println!("EXPLAIN ANALYZE result: {:?}", explain_result);

            Ok(warp::reply::json(&resources))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}
```

===================
File: ./backend/src/lib.rs
Size: 97 bytes
Modified: 2025-02-21 00:12:17.835165200 +0000
Dependencies:

===================
```rs
pub mod api;
pub mod services;
pub mod database;
pub mod networking;
pub mod core;
pub mod main;
```

===================
File: ./backend/src/main.rs
Size: 11224 bytes
Modified: 2025-02-21 01:12:45.445193600 +0000
Dependencies:
mod config;
mod core;
mod db;
mod federation;
mod middleware;
mod notification;
mod reputation;
mod websocket;
use async_trait::async_trait;
use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::create_pool;
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use dashmap::DashMap;
use env_logger;
use futures_util::StreamExt;
use log::{info, error};
use middleware::rate_limit::with_rate_limit;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::sync::Arc;
use thiserror::Error;
use tokio;
use tokio::signal;
use warp::cors::Cors;
use warp::{Filter, ws::{WebSocket, Message}};
use warp::http::Method;

===================
```rs
mod config;
mod core;
mod db;
mod federation;
mod notification;
mod reputation;
mod websocket;
mod middleware;

use crate::config::Config;
use crate::core::{Core, TelemetryManager, PrometheusMetrics, Logger, TracingSystem, RuntimeManager};
use crate::db::Database;
use crate::federation::{FederationOperation, FederationTerms, FederationType};
use crate::notification::NotificationManager;
use crate::reputation::ReputationManager;
use crate::websocket::{WebSocketClients, handle_websocket, broadcast_message};
use tokio;
use log::{info, error};
use env_logger;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use futures_util::StreamExt;
use warp::{Filter, ws::{WebSocket, Message}};
use dashmap::DashMap;
use sqlx::PgPool;
use thiserror::Error;
use reqwest::Client;
use tokio::signal;
use async_trait::async_trait;
use crate::storage::{StorageManager, StorageBackend, StorageResult, StorageError};
use warp::http::Method;
use warp::cors::Cors;
use crate::db::create_pool;
use middleware::rate_limit::with_rate_limit;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    #[error("Validation error: {0}")]
    ValidationError(String),
}

#[derive(Serialize, Deserialize)]
struct Proposal {
    id: String,
    title: String,
    description: String,
    status: String,
    votes_for: i64,
    votes_against: i64,
    created_by: String,
    ends_at: String,
}

#[derive(Serialize, Deserialize)]
struct Vote {
    proposal_id: String,
    voter: String,
    approve: bool,
}

#[derive(Serialize, Deserialize)]
struct TokenizedResource {
    resource_id: String,
    owner: String,
    quantity: u64,
    price_per_unit: f64,
}

#[tokio::main]
async fn main() -> Result<(), AppError> {
    // Initialize logging with env_logger
    env_logger::init();

    // Load and validate configuration
    let config: Config = config::load_config().map_err(|e| AppError::ConfigError(e.to_string()))?;
    config.validate()?;
    
    // Create a single database pool
    let db_pool = create_pool()
        .await
        .map_err(AppError::DatabaseError)?;
    let db_pool = Arc::new(db_pool);
    
    // Share the pool with all services
    let storage_backend = DatabaseStorageBackend::new(db_pool.clone());
    let storage_manager = StorageManager::new(Box::new(storage_backend));
    let governance_service = Arc::new(Mutex::new(GovernanceService::new(db_pool.clone())));
    
    // Initialize other components with shared pool
    let websocket_clients: WebSocketClients = Arc::new(DashMap::new());
    let network_manager = NetworkManager::new();
    let runtime_manager = RuntimeManager::new();
    let telemetry_manager = TelemetryManager::new(PrometheusMetrics, Logger, TracingSystem);
    let identity_manager = IdentityManager::new();
    let reputation_cache = ReputationCache::new(config.reputation_cache_max_size);
    let reputation_manager = ReputationManager::new(
        config.governance_decay_rate,
        config.resource_sharing_decay_rate,
        config.technical_contributions_decay_rate,
        config.decay_exemptions.clone(),
        reputation_cache,
    );

    let notification_manager = NotificationManager::new(config.notification_email.clone(), config.notification_sms.clone());

    // Create core system
    let core = Core::new(
        Arc::new(storage_manager),
        Arc::new(network_manager),
        Arc::new(runtime_manager),
        Arc::new(telemetry_manager),
        Arc::new(identity_manager),
        Arc::new(reputation_manager),
    );

    // Start core system
    if let Err(e) = core.start().await {
        error!("Failed to start core system: {}", e);
        return Err(AppError::ConfigError(e));
    }

    // Set up WebSocket server
    let websocket_route = warp::path("ws")
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let websocket_clients = websocket_clients.clone();
            ws.on_upgrade(move |socket| handle_websocket(socket, websocket_clients))
        });
    
    // Apply rate limits to routes
    let create_proposal = with_rate_limit(
        warp::path!("api" / "v1" / "governance" / "proposals")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |proposal: Proposal| {
                let ns = notification_manager.clone();
                let wc = websocket_clients.clone();
                let gs = governance_service.clone();
                async move {
                    let mut service = gs.lock().await;
                    service.handle_create_proposal(proposal, ns, wc).await
                }
            }),
        10 // 10 requests per second
    );

    let vote_on_proposal = with_rate_limit(
        warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |proposal_id: String, vote: Vote| {
                let ns = notification_manager.clone();
                let wc = websocket_clients.clone();
                let gs = governance_service.clone();
                async move {
                    // Set the proposal_id in vote if not matching
                    let vote = Vote { proposal_id, ..vote };
                    let mut service = gs.lock().await;
                    service.handle_vote_on_proposal(vote, ns, wc).await
                }
            }),
        20 // 20 requests per second
    );

    let federation_routes = with_rate_limit(
        warp::path("api/v1/federation")
            .and(warp::post())
            .and(warp::body::json())
            .and_then(move |operation: FederationOperation| {
                let notification_manager = notification_manager.clone();
                async move {
                    handle_federation_operation(operation, notification_manager).await
                }
            }),
        5 // 5 requests per second
    );

    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and_then(move || {
            async move {
                handle_query_shared_resources().await
            }
        });

    let cors = warp::cors()
        .allow_any_origin()
        .allow_methods(&[Method::GET, Method::POST, Method::PUT, Method::DELETE])
        .allow_headers(vec!["content-type"]);

    let routes = create_proposal
        .or(vote_on_proposal)
        .or(federation_routes)
        .or(query_shared_resources)
        .or(websocket_route)
        .with(cors);

    let server = warp::serve(routes).run(([0, 0, 0, 0], 8081));

    // Handle graceful shutdown
    let shutdown_signal = async {
        signal::ctrl_c().await.expect("Failed to install CTRL+C signal handler");
    };

    info!("Warp server started.");
    let (_, server_result) = tokio::join!(shutdown_signal, server);

    if let Err(e) = server_result {
        error!("Warp server encountered an error: {}", e);
    }

    // Stop core system
    if let Err(e) = core.stop().await {
        error!("Failed to stop core system: {}", e);
    }

    info!("Backend application stopped.");
    Ok(())
}

async fn handle_federation_operation(operation: FederationOperation, notification_manager: NotificationManager) -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle federation operations
    let subject = match &operation {
        FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
            format!("Federation Initiated: {:?}", federation_type)
        }
        FederationOperation::JoinFederation { federation_id, commitment } => {
            format!("Joined Federation: {}", federation_id)
        }
        FederationOperation::LeaveFederation { federation_id, reason } => {
            format!("Left Federation: {}", federation_id)
        }
        FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
            format!("Action Proposed in Federation: {}", federation_id)
        }
        FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
            format!("Vote on Federation Proposal: {}", proposal_id)
        }
        FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
            format!("Resources Shared in Federation: {}", federation_id)
        }
        FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
            format!("Federation Terms Updated: {}", federation_id)
        }
    };

    let body = format!("Federation operation executed: {:?}", operation);
    notification_manager.send_notification(&subject, &body).await;
    Ok(warp::reply::json(&operation))
}

async fn handle_query_shared_resources() -> Result<impl warp::Reply, warp::Rejection> {
    // Logic to handle querying shared resources
    let resources = vec![
        TokenizedResource {
            resource_id: "resource1".to_string(),
            owner: "did:icn:owner1".to_string(),
            quantity: 100,
            price_per_unit: 10.0,
        },
        TokenizedResource {
            resource_id: "resource2".to_string(),
            owner: "did:icn:owner2".to_string(),
            quantity: 200,
            price_per_unit: 20.0,
        },
    ];
    Ok(warp::reply::json(&resources))
}

struct DatabaseStorageBackend {
    pool: PgPool,
}

impl DatabaseStorageBackend {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        Ok(result.exists.unwrap_or(false))
    }
}
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 13857 bytes
Modified: 2025-02-21 01:05:05.411981900 +0000
Dependencies:
use async_trait::async_trait;
use bit_set::BitSet;
use federation::{Federation, FederationError};
use icn_core::ReputationManager;
use icn_types::Block;
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use std::time::Duration;
use thiserror::Error;
use tokio::task;
use tokio::time::sleep;
use trie_rs::Trie;

===================
```rs
pub mod proof_of_cooperation;
pub mod validation;
pub mod round_management;
pub mod timeout_handling;
pub mod federation;

use async_trait::async_trait;
use std::collections::{HashMap, VecDeque};
use std::time::Duration;
use tokio::time::sleep;
use tokio::task;
use icn_core::ReputationManager;
use icn_types::Block;
use std::sync::Arc;
use bit_set::BitSet;
use trie_rs::Trie;
use thiserror::Error;
use federation::{Federation, FederationError};

#[derive(Error, Debug)]
pub enum ConsensusError {
    #[error("Failed to reach consensus: {0}")]
    ConsensusFailure(String),
    #[error("Block validation failed: {0}")]
    ValidationFailure(String),
    #[error("Timeout occurred: {0}")]
    TimeoutError(String),
    #[error("BFT error: {0}")]
    BftError(String),
}

pub struct ProofOfCooperation {
    current_round: u64,
    participants: VecDeque<String>,
    proposed_block: Option<Block>,
    votes: BitSet,
    vote_trie: Trie,
    timeout: Duration,
    timeout_handling: timeout_handling::TimeoutHandling,
    reputation_manager: Arc<dyn ReputationManager>,
    federation_operations: HashMap<String, FederationOperation>,
    federations: HashMap<String, Federation>,
    round_start_time: std::time::Instant,
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: Arc<dyn ReputationManager>) -> Self {
        ProofOfCooperation {
            current_round: 0,
            participants: VecDeque::new(),
            proposed_block: None,
            votes: BitSet::new(),
            vote_trie: Trie::new(),
            timeout: Duration::from_secs(60),
            timeout_handling: timeout_handling::TimeoutHandling::new(Duration::from_secs(60)),
            reputation_manager,
            federation_operations: HashMap::new(),
            federations: HashMap::new(),
            round_start_time: std::time::Instant::now(),
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.vote_trie = Trie::new();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            let index = self.participants.iter().position(|p| p == &participant).unwrap_or_else(|| {
                self.participants.push_back(participant.clone());
                self.participants.len() - 1
            });
            if vote {
                self.votes.insert(index);
            }
            self.vote_trie.insert(&participant);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<Block>, ConsensusError> {
        let (total_reputation, approval_reputation) = self.parallel_vote_counting().await
            .map_err(|e| ConsensusError::ConsensusFailure(e.to_string()))?;

        // BFT requirement: Need more than 2/3 of total reputation for finalization
        let bft_threshold = (total_reputation as f64 * 2.0 / 3.0) as i64;
        
        if approval_reputation > bft_threshold {
            if let Some(block) = &self.proposed_block {
                // Update block metadata before finalization
                let mut final_block = block.clone();
                let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                final_block.metadata.consensus_duration_ms = consensus_duration;
                
                // Clear round state
                self.start_round();
                
                Ok(Some(final_block))
            } else {
                Err(ConsensusError::ConsensusFailure("No proposed block".into()))
            }
        } else {
            Ok(None)
        }
    }

    pub async fn handle_timeout(&self) {
        if let Err(e) = self.timeout_handling.handle_timeout().await {
            eprintln!("Error handling timeout: {}", e);
        }
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus")
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), Box<dyn std::error::Error>> {
        let chunks: Vec<_> = self.participants.chunks(self.participants.len() / 4).collect();
        let mut handles = vec![];

        for chunk in chunks {
            let chunk = chunk.to_vec();
            let reputation_manager = self.reputation_manager.clone();
            let votes = self.votes.clone();
            let handle = task::spawn(async move {
                let total_reputation: i64 = chunk.iter().map(|p| reputation_manager.get_reputation(p, "consensus")).sum();
                let approval_reputation: i64 = chunk.iter().enumerate().filter(|(i, _)| votes.contains(*i)).map(|(_, p)| reputation_manager.get_reputation(p, "consensus")).sum();
                Ok((total_reputation, approval_reputation))
            });
            handles.push(handle);
        }

        let mut total_reputation = 0;
        let mut approval_reputation = 0;

        for handle in handles {
            let (chunk_total, chunk_approval) = handle.await??;
            total_reputation += chunk_total;
            approval_reputation += chunk_approval;
        }

        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, ConsensusError> {
        let mut validators = Vec::new();
        let participants: Vec<_> = self.participants.iter().cloned().collect();

        for participant in participants {
            if self.reputation_manager.is_eligible(&participant, min_reputation, "consensus") {
                validators.push(participant);
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.max_faulty_nodes() * 3) + 1;
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }

        Ok(validators)
    }

    fn max_faulty_nodes(&self) -> usize {
        self.participants.len() / 3
    }

    pub async fn handle_consensus_round(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Start timeout handler
        let timeout_handler = self.timeout_handling.start_timeout();
        
        tokio::select! {
            result = self.finalize_block() => {
                result
            }
            _ = timeout_handler => {
                self.handle_timeout().await;
                Err(ConsensusError::TimeoutError("Consensus round timed out".into()))
            }
        }
    }

    pub fn handle_federation_operation(&mut self, operation: FederationOperation) {
        match operation {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                self.create_federation(partner_id, federation_type, terms).unwrap();
            }
            FederationOperation::JoinFederation { federation_id, commitment } => {
                // Handle joining federation logic
            }
            FederationOperation::LeaveFederation { federation_id, reason } => {
                // Handle leaving federation logic
            }
            FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
                // Handle proposing action logic
            }
            FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
                // Handle voting on proposal logic
            }
            FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
                // Handle sharing resources logic
            }
            FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
                // Handle updating federation terms logic
            }
        }
    }

    pub fn create_federation(
        &mut self,
        creator_id: String,
        federation_type: FederationType,
        terms: FederationTerms,
    ) -> Result<String, ConsensusError> {
        // Verify creator's reputation
        let creator_reputation = self.reputation_manager.get_reputation(&creator_id, "consensus");
        if creator_reputation < terms.minimum_reputation {
            return Err(ConsensusError::ConsensusFailure(
                "Insufficient reputation to create federation".into(),
            ));
        }

        // Generate unique federation ID
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());

        // Create new federation
        let federation = Federation::new(
            federation_id.clone(),
            federation_type,
            terms,
            creator_id,
        );

        // Store federation
        self.federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn adjust_validator_set(&mut self) -> Result<(), ConsensusError> {
        // Get current validator counts for BFT calculation
        let current_size = self.participants.len();
        let min_validators = (current_size / 3) * 3 + 1; // 3f + 1 where f is max faulty

        // Remove validators that fell below minimum reputation
        let mut to_remove = Vec::new();
        for participant in self.participants.iter() {
            if !self.reputation_manager.is_eligible(participant, 50, "consensus") {
                to_remove.push(participant.clone());
            }
        }

        // Remove disqualified validators if we maintain BFT requirements
        if (current_size - to_remove.len()) >= min_validators {
            for participant in to_remove {
                if let Some(pos) = self.participants.iter().position(|x| x == &participant) {
                    self.participants.remove(pos);
                }
            }
        }

        // Add new validators that meet higher reputation threshold
        let new_validators = self.select_validators(80).await?;
        
        // Add new validators while maintaining max size limit
        let max_validators = 100; // Example maximum validator set size
        for validator in new_validators {
            if self.participants.len() >= max_validators {
                break;
            }
            if !self.participants.contains(&validator) {
                self.participants.push_back(validator);
            }
        }

        Ok(())
    }

    pub async fn start_validator_rotation(&mut self) {
        tokio::spawn(async move {
            let rotation_interval = Duration::from_secs(3600); // 1 hour
            loop {
                sleep(rotation_interval).await;
                if let Err(e) = self.adjust_validator_set().await {
                    error!("Failed to adjust validator set: {}", e);
                }
            }
        });
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) {
        // Start the consensus process
    }

    async fn stop(&self) {
        // Stop the consensus process
    }

    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(&vote.proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
        
        if !self.is_eligible_voter(&vote.voter_did) {
            return Err(GovernanceError::NotEligibleToVote);
        }

        proposal.votes.insert(vote);
        self.check_proposal_status(&proposal.proposal_id)
    }

    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError> {
        let proposal = self.active_proposals.remove(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;

        match proposal.proposal_type {
            ProposalType::AddValidator(info) => self.add_validator(info),
            ProposalType::RemoveValidator(did) => self.remove_validator(&did),
            ProposalType::UpdateRules(rules) => {
                self.rules = rules;
                Ok(())
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: std::collections::HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

#[derive(Serialize, Deserialize)]
struct FederationTerms {
    minimum_reputation: i64,
    resource_sharing_policies: String,
    governance_rules: String,
    duration: String,
}

#[derive(Serialize, Deserialize)]
enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}
```

===================
File: ./crates/icn-core/src/lib.rs
Size: 8914 bytes
Modified: 2025-02-19 21:25:52.327008500 +0000
Dependencies:
use async_trait::async_trait;
use icn_consensus::ProofOfCooperation;
use icn_types::{Block, Transaction, FederationType, FederationTerms, FederationOperation};
use log::{info, error};
use std::sync::Arc;
use tokio::time::{sleep, Duration};

===================
```rs
use std::sync::Arc;
use async_trait::async_trait;
use icn_types::{Block, Transaction, FederationType, FederationTerms, FederationOperation};
use icn_consensus::ProofOfCooperation;
use tokio::time::{sleep, Duration};
use log::{info, error};

pub struct Core {
    consensus: Arc<dyn ConsensusEngine>,
    storage: Arc<dyn StorageManager>,
    network: Arc<dyn NetworkManager>,
    runtime: Arc<dyn RuntimeManager>,
    telemetry: Arc<TelemetryManager>,
    identity: Arc<dyn IdentityManager>,
    reputation: Arc<dyn ReputationManager>,
    federation_manager: Arc<FederationManager>,
    resource_system: Arc<ResourceAllocationSystem>,
}

impl Core {
    pub fn new(
        storage: Arc<dyn StorageManager>,
        network: Arc<dyn NetworkManager>,
        runtime: Arc<dyn RuntimeManager>,
        telemetry: Arc<TelemetryManager>,
        identity: Arc<dyn IdentityManager>,
        reputation: Arc<dyn ReputationManager>,
    ) -> Self {
        let resource_system = Arc::new(ResourceAllocationSystem::new());
        let federation_manager = Arc::new(FederationManager::new(resource_system.clone()));
        let consensus = Arc::new(ProofOfCooperation::new(reputation.clone()));

        Core {
            consensus,
            storage,
            network,
            runtime,
            telemetry,
            identity,
            reputation,
            federation_manager,
            resource_system,
        }
    }

    pub async fn start(&self) -> Result<(), String> {
        self.telemetry.log("Starting Core...");
        if let Err(e) = self.consensus.start().await {
            return Err(format!("Failed to start consensus: {}", e));
        }
        if let Err(e) = self.network.start().await {
            return Err(format!("Failed to start network: {}", e));
        }
        if let Err(e) = self.runtime.start().await {
            return Err(format!("Failed to start runtime: {}", e));
        }
        if let Err(e) = self.identity.start().await {
            return Err(format!("Failed to start identity: {}", e));
        }
        if let Err(e) = self.reputation.start().await {
            return Err(format!("Failed to start reputation: {}", e));
        }

        // Start real-time reputation recalibration
        let reputation_system = self.reputation.clone();
        tokio::spawn(async move {
            loop {
                reputation_system.dynamic_adjustment("did:icn:test", 10).await;
                reputation_system.apply_decay("did:icn:test", 0.1).await;
                sleep(Duration::from_secs(10)).await;
            }
        });

        self.telemetry.log("Core started.");
        Ok(())
    }

    pub async fn stop(&self) -> Result<(), String> {
        self.telemetry.log("Stopping Core...");
        if let Err(e) = self.runtime.stop().await {
            return Err(format!("Failed to stop runtime: {}", e));
        }
        if let Err(e) = self.network.stop().await {
            return Err(format!("Failed to stop network: {}", e));
        }
        if let Err(e) = self.consensus.stop().await {
            return Err(format!("Failed to stop consensus: {}", e));
        }
        if let Err(e) = self.identity.stop().await {
            return Err(format!("Failed to stop identity: {}", e));
        }
        if let Err(e) = self.reputation.stop().await {
            return Err(format!("Failed to stop reputation: {}", e));
        }
        self.telemetry.log("Core stopped.");
        Ok(())
    }

    pub async fn process_transaction(&self, transaction: Transaction) -> Result<(), String> {
        self.telemetry.log("Processing transaction...");
        self.runtime.execute_transaction(transaction).await;
        self.telemetry.log("Transaction processed.");
        Ok(())
    }

    pub async fn add_block(&self, block: Block) -> Result<(), String> {
        self.telemetry.log("Adding block...");
        self.storage.store_block(block).await;
        self.telemetry.log("Block added.");
        Ok(())
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<(), Box<dyn std::error::Error>> {
        self.telemetry.log("Creating proposal...");
        // Logic to handle proposal creation
        self.telemetry.log("Proposal created.");
        Ok(())
    }

    pub async fn vote_on_proposal(&self, vote: Vote) -> Result<(), Box<dyn std::error::Error>> {
        self.telemetry.log("Voting on proposal...");
        // Logic to handle voting on a proposal
        self.telemetry.log("Vote cast.");
        Ok(())
    }

    pub async fn handle_federation_operation(&self, operation: FederationOperation) -> Result<(), Box<dyn std::error::Error>> {
        self.telemetry.log("Handling federation operation...");
        
        match operation {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                self.federation_manager.create_federation(
                    format!("Federation with {}", partner_id),
                    federation_type,
                    terms,
                    partner_id,
                ).await?;
            }
            FederationOperation::JoinFederation { federation_id, commitment } => {
                // Get the requesting member's DID from context
                let member_did = "did:icn:requesting_member"; // This should come from auth context
                self.federation_manager.join_federation(&federation_id, member_did, commitment).await?;
            }
            // ... handle other federation operations ...
        }

        self.telemetry.log("Federation operation handled.");
        Ok(())
    }

    pub async fn allocate_resource(&self, request: ResourceAllocation) -> Result<String, Box<dyn std::error::Error>> {
        self.telemetry.log("Allocating resources...");
        let allocation_id = self.resource_system.allocate(
            &request.resource_type,
            request.recipient,
            request.amount,
        ).await?;
        self.telemetry.log("Resources allocated.");
        Ok(allocation_id)
    }

    pub async fn load_cooperative_rules(&self, dsl_code: &str) -> Result<(), Box<dyn std::error::Error>> {
        // Parse DSL code
        let ast = icn_dsl::CoopLangAST::parse(dsl_code)
            .map_err(|e| format!("Failed to parse DSL: {}", e))?;
        
        // Compile to ICVM bytecode
        let bytecode = icn_dsl::compile_to_icvm(&ast);
        
        // Load into VM
        self.runtime.load_bytecode(&bytecode).await?;
        
        Ok(())
    }
}

#[async_trait]
pub trait ConsensusEngine {
    async fn get_reputation(&self, did: String, category: String) -> Result<i64, Box<dyn std::error::Error>>;
    async fn is_eligible(&self, did: String, min_reputation: i64, category: String) -> Result<bool, Box<dyn std::error::Error>>;
    async fn dynamic_adjustment(&self, did: String, contribution: i64) -> Result<(), Box<dyn std::error::Error>>;
    async fn apply_decay(&self, did: String, decay_rate: f64) -> Result<(), Box<dyn std::error::Error>>;
    async fn reputation_based_access(&self, did: String, min_reputation: i64) -> Result<bool, Box<dyn std::error::Error>>;
}

pub struct TelemetryManager {
    metrics: PrometheusMetrics,
    logger: Logger,
    traces: TracingSystem,
}

impl TelemetryManager {
    pub fn new(metrics: PrometheusMetrics, logger: Logger, traces: TracingSystem) -> Self {
        TelemetryManager {
            metrics,
            logger,
            traces,
        }
    }

    pub fn log(&self, message: &str) {
        self.logger.log(message);
        self.traces.trace(message);
    }

    pub fn record_metric(&self, name: &str, value: f64) {
        self.metrics.record(name, value);
    }
}

pub struct PrometheusMetrics;

impl PrometheusMetrics {
    pub fn record(&self, name: &str, value: f64) {
        // Record the metric
    }
}

pub struct Logger;

impl Logger {
    pub fn log(&self, message: &str) {
        // Log the message
    }
}

pub struct TracingSystem;

impl TracingSystem {
    pub fn trace(&self, message: &str) {
        // Trace the message
    }
}

#[derive(Serialize, Deserialize)]
pub struct Proposal {
    id: String,
    title: String,
    description: String,
    status: String,
    votes_for: i64,
    votes_against: i64,
    created_by: String,
    ends_at: String,
}

#[derive(Serialize, Deserialize)]
pub struct Vote {
    proposal_id: String,
    voter: String,
    approve: bool,
}

pub mod blockchain;
pub mod core;
pub mod db;
pub mod identity;
pub mod reputation;
pub mod governance;   // <-- new module export
pub mod vm;
pub mod networking;
pub mod storage;
pub mod models;
```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 5761 bytes
Modified: 2025-01-16 22:02:57.844616100 +0000
Dependencies:
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;
use icn_types::Algorithm;
use kyber::decapsulate as kyber_decapsulate;
use kyber::encapsulate as kyber_encapsulate;
use kyber::keypair as kyber_keypair;
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};

===================
```rs
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn_types::Algorithm;
use kyber::keypair as kyber_keypair;
use kyber::encapsulate as kyber_encapsulate;
use kyber::decapsulate as kyber_decapsulate;
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;

pub enum Algorithm {
    Secp256k1,
    RSA,
    ECDSA,
    Kyber,
    Dilithium,
    Falcon,
}

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
}

impl KeyPair {
    pub fn generate(algorithm: Algorithm) -> Self {
        match algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let (private_key, public_key) = secp.generate_keypair(&mut rand::thread_rng());
                KeyPair {
                    public_key: public_key.serialize().to_vec(),
                    private_key: private_key[..].to_vec(),
                    algorithm,
                }
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::new(&mut rand::thread_rng(), 2048).expect("failed to generate a key");
                let public_key = RSAPublicKey::from(&private_key);
                KeyPair {
                    public_key: public_key.to_pkcs1().expect("failed to encode public key"),
                    private_key: private_key.to_pkcs1().expect("failed to encode private key"),
                    algorithm,
                }
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::random(&mut rand::thread_rng());
                let verifying_key = VerifyingKey::from(&signing_key);
                KeyPair {
                    public_key: verifying_key.to_bytes().to_vec(),
                    private_key: signing_key.to_bytes().to_vec(),
                    algorithm,
                }
            },
            Algorithm::Kyber => {
                let (public_key, private_key) = kyber_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Dilithium => {
                let (public_key, private_key) = dilithium_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Falcon => {
                let (public_key, private_key) = falcon_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
        }
    }

    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let private_key = SecretKey::from_slice(&self.private_key).expect("32 bytes");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                secp.sign(&message, &private_key).serialize_compact().to_vec()
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::from_pkcs1(&self.private_key).expect("failed to decode private key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                private_key.sign(padding, &Sha256::digest(message)).expect("failed to sign message")
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::from_bytes(&self.private_key).expect("failed to decode private key");
                signing_key.sign(message).to_bytes().to_vec()
            },
            Algorithm::Dilithium => {
                dilithium_sign(&self.private_key, message)
            },
            Algorithm::Falcon => {
                falcon_sign(&self.private_key, message)
            },
            _ => vec![],
        }
    }

    pub fn verify(&self, message: &[u8], signature: &[u8]) -> bool {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let public_key = PublicKey::from_slice(&self.public_key).expect("invalid public key");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                let signature = Signature::from_compact(signature).expect("invalid signature");
                secp.verify(&message, &signature, &public_key).is_ok()
            },
            Algorithm::RSA => {
                let public_key = RSAPublicKey::from_pkcs1(&self.public_key).expect("failed to decode public key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                public_key.verify(padding, &Sha256::digest(message), signature).is_ok()
            },
            Algorithm::ECDSA => {
                let verifying_key = VerifyingKey::from_bytes(&self.public_key).expect("failed to decode public key");
                verifying_key.verify(message, signature).is_ok()
            },
            Algorithm::Dilithium => {
                dilithium_verify(&self.public_key, message, signature)
            },
            Algorithm::Falcon => {
                falcon_verify(&self.public_key, message, signature)
            },
            _ => false,
        }
    }
}

pub fn hash(data: &[u8]) -> Vec<u8> {
    Sha256::digest(data).to_vec()
}
```

===================
File: ./crates/icn-dsl/src/lib.rs
Size: 5568 bytes
Modified: 2025-02-18 06:50:47.143649200 +0000
Dependencies:
use nom::{

===================
```rs
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, multispace0, multispace1},
    combinator::{map, opt},
    multi::{many0, many1},
    sequence::{delimited, preceded, terminated, tuple},
    IResult,
};

#[derive(Debug, Clone)]
pub struct CoopLangAST {
    pub governance: Option<GovernanceNode>,
    pub reputation: Option<ReputationNode>,
    pub marketplace: Option<MarketplaceNode>,
    pub federation: Option<FederationNode>,
    pub validation: Option<ValidationNode>,
    pub logging: Option<LoggingNode>,
}

#[derive(Debug, Clone)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
    pub resource_checks: Option<ResourceChecks>,
    pub custom_merge: Option<CustomMerge>,
}

#[derive(Debug, Clone)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

#[derive(Debug, Clone)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transition: Option<String>,
}

#[derive(Debug, Clone)]
pub struct CustomMerge {
    pub strategy: String,
    pub handlers: Vec<ConflictHandler>,
}

#[derive(Debug, Clone)]
pub struct ConflictHandler {
    pub field_path: String,
    pub resolution_type: String,
}

// Parser implementation
impl CoopLangAST {
    pub fn parse(input: &str) -> IResult<&str, Self> {
        let (input, _) = multispace0(input)?;
        let (input, governance) = opt(Self::parse_governance_section)(input)?;
        let (input, reputation) = opt(Self::parse_reputation_section)(input)?;
        let (input, marketplace) = opt(Self::parse_marketplace_section)(input)?;
        let (input, federation) = opt(Self::parse_federation_section)(input)?;
        let (input, validation) = opt(Self::parse_validation_section)(input)?;
        let (input, logging) = opt(Self::parse_logging_section)(input)?;
        
        Ok((input, CoopLangAST {
            governance,
            reputation,
            marketplace,
            federation,
            validation,
            logging,
        }))
    }

    fn parse_validation_section(input: &str) -> IResult<&str, ValidationNode> {
        let (input, _) = tag("validation:")(input)?;
        let (input, _) = multispace1(input)?;
        
        let (input, pre_checks) = Self::parse_checks("pre_checks:")(input)?;
        let (input, post_checks) = Self::parse_checks("post_checks:")(input)?;
        let (input, state_validation) = opt(Self::parse_state_validation)(input)?;
        let (input, resource_checks) = opt(Self::parse_resource_checks)(input)?;
        let (input, custom_merge) = opt(Self::parse_custom_merge)(input)?;

        Ok((input, ValidationNode {
            pre_checks,
            post_checks,
            state_validation,
            resource_checks,
            custom_merge,
        }))
    }

    fn parse_checks(label: &'static str) -> impl Fn(&str) -> IResult<&str, Vec<Check>> {
        move |input: &str| {
            let (input, _) = tag(label)(input)?;
            let (input, _) = multispace1(input)?;
            many0(Self::parse_check)(input)
        }
    }

    fn parse_check(input: &str) -> IResult<&str, Check> {
        let (input, _) = char('-')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, condition) = take_while1(|c| c != ':')(input)?;
        let (input, _) = char(':')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, action) = take_while1(|c| c != '\n')(input)?;
        let (input, _) = multispace0(input)?;

        Ok((input, Check {
            condition: condition.trim().to_string(),
            action: action.trim().to_string(),
        }))
    }

    // Add other section parsers similarly...
}

// Bytecode generation
pub fn compile_to_icvm(ast: &CoopLangAST) -> Vec<u8> {
    let mut bytecode = Vec::new();

    // Header
    bytecode.extend_from_slice(&[0x49, 0x43, 0x56, 0x4D]); // "ICVM" magic bytes
    bytecode.push(0x01); // Version

    // Compile validation rules
    if let Some(validation) = &ast.validation {
        bytecode.push(0x01); // Validation section marker
        
        // Pre-checks
        bytecode.push(validation.pre_checks.len() as u8);
        for check in &validation.pre_checks {
            compile_check(&mut bytecode, check);
        }

        // Post-checks
        bytecode.push(validation.post_checks.len() as u8);
        for check in &validation.post_checks {
            compile_check(&mut bytecode, check);
        }

        // State validation
        if let Some(state_validation) = &validation.state_validation {
            bytecode.push(0x01);
            compile_state_validation(&mut bytecode, state_validation);
        } else {
            bytecode.push(0x00);
        }
    }

    // Compile other sections similarly...

    bytecode
}

fn compile_check(bytecode: &mut Vec<u8>, check: &Check) {
    // Convert check condition to bytecode operations
    bytecode.extend_from_slice(check.condition.as_bytes());
    bytecode.push(0x00); // Null terminator
    bytecode.extend_from_slice(check.action.as_bytes());
    bytecode.push(0x00); // Null terminator
}

fn compile_state_validation(bytecode: &mut Vec<u8>, validation: &StateValidation) {
    if let Some(current) = &validation.current {
        bytecode.push(0x01);
        bytecode.extend_from_slice(current.as_bytes());
        bytecode.push(0x00);
    } else {
        bytecode.push(0x00);
    }
    // Similarly for expected and transition...
}
```

===================
File: ./crates/icn-federation/src/lib.rs
Size: 13348 bytes
Modified: 2025-02-22 02:20:02.175883200 +0000
Dependencies:
use async_trait::async_trait;
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_types::{Block, Transaction};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_types::{Block, Transaction};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub federation_type: FederationType,
    pub members: HashMap<String, MemberStatus>, // DID -> status
    pub member_roles: HashMap<String, MemberRole>, // DID -> role
    pub terms: FederationTerms,
    pub resources: HashMap<String, ResourcePool>,
    pub proposals: Vec<FederationProposal>, // Add proposals field
    pub created_at: u64,
    pub status: FederationStatus,
}

impl Federation {
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), FederationError> {
        if self.members.contains_key(&did) {
            return Err(FederationError::AlreadyMember);
        }

        // Verify member meets minimum reputation requirements
        if !self.verify_member_eligibility(&did) {
            return Err(FederationError::InsufficientReputation(
                "Member does not meet minimum reputation requirements".to_string(),
            ));
        }

        self.members.insert(did, MemberStatus::Active);
        Ok(())
    }

    pub fn remove_member(&mut self, did: &str) -> Result<(), FederationError> {
        if !self.members.contains_key(did) {
            return Err(FederationError::MemberNotFound);
        }

        self.members.remove(did);
        Ok(())
    }

    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.members.get(did)
    }

    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), FederationError> {
        if let Some(member_status) = self.members.get_mut(did) {
            *member_status = status;
            Ok(())
        } else {
            Err(FederationError::MemberNotFound)
        }
    }

    pub fn get_active_members(&self) -> Vec<String> {
        self.members
            .iter()
            .filter(|(_, status)| matches!(status, MemberStatus::Active))
            .map(|(did, _)| did.clone())
            .collect()
    }

    pub fn verify_member_eligibility(&self, did: &str) -> bool {
        // This would integrate with the reputation system in practice
        true // Simplified for example
    }

    pub fn submit_proposal(&mut self, proposal: FederationProposal) -> Result<(), FederationError> {
        // Validate proposal
        self.validate_proposal(&proposal)?;

        // Set proposal voting period
        let mut proposal = proposal;
        proposal.voting_ends_at = chrono::Utc::now().timestamp() as u64 + 
            (self.terms.governance_rules.max_voting_period_hours * 3600);

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote(&mut self, vote: Vote) -> Result<(), FederationError> {
        // Validate vote
        self.validate_vote(&vote)?;

        // Get proposal
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound)?;

        // Record vote
        proposal.votes.insert(vote.voter, vote.approve);

        // Check if voting period ended and finalize if needed
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            proposal.status = self.finalize_proposal(&proposal.id)?;
        }

        Ok(())
    }

    pub fn validate_proposal(&self, proposal: &FederationProposal) -> Result<(), FederationError> {
        // Check if proposal type is allowed
        if !self.terms.governance_rules.allowed_proposal_types.contains(&proposal.proposal_type.to_string()) {
            return Err(FederationError::InvalidProposalType);
        }

        // Validate proposer has sufficient reputation
        if !self.verify_member_eligibility(&proposal.proposer) {
            return Err(FederationError::InsufficientReputation(
                "Proposer does not meet minimum reputation requirements".to_string()
            ));
        }

        Ok(())
    }

    pub fn validate_vote(&self, vote: &Vote) -> Result<(), FederationError> {
        // Check if voter is a member
        if !self.members.contains_key(&vote.voter) {
            return Err(FederationError::UnauthorizedAction);
        }

        // Check if proposal exists
        let proposal = self.proposals.iter()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound)?;

        // Check if voting period is still open
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            return Err(FederationError::VotingPeriodEnded);
        }

        // Check for veto rights
        if let Some(member_role) = self.member_roles.get(&vote.voter) {
            if let Some(veto_actions) = self.terms.governance_rules.veto_rights.get(&member_role.to_string()) {
                if veto_actions.contains(&proposal.proposal_type.to_string()) && !vote.approve {
                    // Record veto
                    return Ok(());
                }
            }
        }

        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<ProposalStatus, FederationError> {
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == proposal_id)
            .ok_or(FederationError::ProposalNotFound)?;

        let total_votes = proposal.votes.len() as u32;
        if total_votes < self.terms.governance_rules.min_votes_required {
            return Ok(ProposalStatus::Rejected);
        }

        let approval_votes = proposal.votes.values().filter(|&v| *v).count() as u32;
        let approval_percentage = (approval_votes * 100) / total_votes;

        if approval_percentage >= self.terms.governance_rules.approval_threshold_percent {
            proposal.status = ProposalStatus::Approved;
        } else {
            proposal.status = ProposalStatus::Rejected;
        }

        Ok(proposal.status.clone())
    }

    pub fn calculate_asset_distribution(&self) -> HashMap<String, AssetAllocation> {
        let mut distributions = HashMap::new();
        // Implement fair asset distribution calculation
        distributions
    }

    pub fn settle_outstanding_debts(&self) -> Vec<DebtSettlement> {
        let mut settlements = Vec::new();
        // Implement debt settlement calculation
        settlements
    }

    pub fn reassign_members(&self) -> Vec<MemberReassignment> {
        let mut reassignments = Vec::new();
        // Implement member reassignment logic
        reassignments
    }

    pub fn calculate_vote_weight(&self, cooperative_id: &str, proposal: &FederationProposal) -> f64 {
        let voting_model = match proposal.proposal_type {
            ProposalType::GovernanceChange(_) | ProposalType::PolicyUpdate(_) => 
                &self.terms.governance_rules.governance_voting_model,
            ProposalType::ResourceAllocation(_) =>
                &self.terms.governance_rules.resource_voting_model,
            _ => &self.terms.governance_rules.default_voting_model,
        };

        voting_model.calculate_voting_power(self, cooperative_id)
    }

    pub fn get_cooperative_weight(&self, cooperative_id: &str) -> f64 {
        let total_members: u32 = self.members.values().map(|m| m.member_count).sum();
        let coop_members = self.members.get(cooperative_id)
            .map(|m| m.member_count)
            .unwrap_or(0);
        
        coop_members as f64 / total_members as f64
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourcePool {
    pub resource_type: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub contributors: HashMap<String, u64>, // DID -> amount contributed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationProposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub description: String,
    pub votes: HashMap<String, bool>, // DID -> vote
    pub status: ProposalStatus,
    pub created_at: u64,
    pub voting_ends_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalType {
    AddMember(String),
    RemoveMember(String),
    UpdateTerms(FederationTerms),
    AllocateResources(ResourceAllocation),
    UpdatePolicy(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub resource_type: String,
    pub amount: u64,
    pub recipient: String,
    pub duration: Option<u64>,
}

pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember);
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment);
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound)
        }
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }
}

#[async_trait]
pub trait ResourceManager: Send + Sync {
    async fn allocate_resources(&self, allocation: ResourceAllocation) -> Result<(), String>;
    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String>;
}

pub trait FederationDissolution {
    fn initiate_dissolution(&mut self, initiator: &str, reason: DissolutionReason) -> Result<DissolutionProtocol, Error>;
    fn process_dissolution(&mut self, protocol: &DissolutionProtocol) -> Result<DissolutionStatus, Error>;
    fn cancel_dissolution(&mut self, protocol_id: &str) -> Result<(), Error>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: GovernanceRules,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceRules {
    pub min_votes_required: u32,
    pub approval_threshold_percent: u32,
    pub min_voting_period_hours: u32,
    pub max_voting_period_hours: u32,
    pub allowed_proposal_types: Vec<String>,
    pub veto_rights: HashMap<String, Vec<String>>, // role -> action types that can be vetoed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationStatus {
    Active,
    Suspended,
    Dissolved,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Expired,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemberStatus {
    Active,
    Inactive,
    Suspended,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub approve: bool,
}

#[derive(Debug)]
pub enum FederationError {
    FederationNotFound,
    AlreadyMember,
    InvalidCommitment,
    InsufficientResources,
    UnauthorizedAction,
    MemberNotFound,
    InvalidStatusTransition,
    InsufficientPermissions,
    InvalidProposalType,
    VotingPeriodEnded,
    ProposalNotFound,
    InsufficientReputation(String),
}
```

===================
File: ./crates/icn-governance/src/lib.rs
Size: 4414 bytes
Modified: 2025-02-22 02:20:02.175883200 +0000
Dependencies:
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use thiserror::Error;

===================
```rs
use thiserror::Error;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Invalid rollback - proposal is not in pending state")]
    InvalidRollback,
    #[error("Dispute already exists")]
    DisputeExists,
    #[error("Insufficient reputation to dispute")]
    InsufficientReputation,
    #[error("Invalid dispute resolution")]
    InvalidResolution,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub status: ProposalStatus,
    pub created_at: DateTime<Utc>,
    pub votes: HashMap<String, Vote>,
    pub disputes: Vec<Dispute>,
    pub execution_history: Vec<ExecutionEvent>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Active,
    Approved,
    Rejected,
    Disputed,
    RolledBack,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
    pub reputation: i64,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dispute {
    pub id: String,
    pub proposal_id: String,
    pub disputer: String,
    pub reason: String,
    pub evidence: String,
}

#[derive(Debug)]
pub struct DissolutionProtocol {
    federation_id: String,
    initiated_by: String,
    reason: DissolutionReason,
    status: DissolutionStatus,
    asset_distribution: HashMap<String, AssetAllocation>,
    debt_settlements: Vec<DebtSettlement>,
    member_reassignments: Vec<MemberReassignment>,
}

#[derive(Debug)]
pub enum DissolutionReason {
    Voluntary,
    InactivityThreshold,
    GovernanceViolation,
    EconomicNonviability,
}

#[derive(Debug)]
pub enum DissolutionStatus {
    Initiated,
    InProgress,
    Completed,
    Cancelled,
}

#[derive(Debug)]
pub struct AssetAllocation {
    asset_id: String,
    recipient_id: String,
    allocation_share: f64,
}

#[derive(Debug)]
pub struct DebtSettlement {
    creditor_id: String,
    debtor_id: String,
    amount: f64,
    due_date: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct MemberReassignment {
    member_id: String,
    new_federation_id: Option<String>,
    transition_period: chrono::Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionThresholds {
    pub resource_allocation_threshold: u64,
    pub technical_effort_threshold: u32, // in days
    pub financial_impact_threshold: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationControls {
    pub max_gap_multiplier: f64,
    pub decay_threshold_multiplier: f64,
    pub monthly_decay_rate: f64,
    pub equity_bonus_groups: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VotingModel {
    Equal,
    Proportional { cap_percentage: u8 },
    Hybrid {
        governance_model: Box<VotingModel>,
        resource_model: Box<VotingModel>,
    },
}

impl VotingModel {
    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match self {
            VotingModel::Equal => 1.0,
            VotingModel::Proportional { cap_percentage } => {
                let power = federation.get_cooperative_weight(cooperative_id);
                power.min(*cap_percentage as f64 / 100.0)
            },
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Use different models based on proposal type
                // ...existing code...
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationManager {
    pub controls: ReputationControls,
    reputation_scores: HashMap<String, f64>,
    last_decay_check: DateTime<Utc>,
}

impl ReputationManager {
    pub fn apply_anti_oppression_mechanisms(&mut self) {
        let avg_reputation = self.calculate_average_reputation();
        
        for score in self.reputation_scores.values_mut() {
            if *score > avg_reputation * self.controls.decay_threshold_multiplier {
                *score *= 1.0 - self.controls.monthly_decay_rate;
            }
        }
    }
    
    // ...existing code...
}```

===================
File: ./crates/icn-mutual-credit/src/lib.rs
Size: 2371 bytes
Modified: 2025-02-22 01:50:09.718197800 +0000
Dependencies:
use chrono::Utc;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

===================
```rs
use std::collections::HashMap;
use chrono::Utc;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64,
    pub signature: String,
    pub timestamp: i64,
}

pub struct MutualCreditLedger {
    // Maps member DID to current credit balance.
    pub balances: HashMap<String, i64>,
    // Ordered list of all mutual credit transactions.
    pub history: Vec<MutualCreditTransaction>,
}

impl MutualCreditLedger {
    pub fn new() -> Self {
        Self {
            balances: HashMap::new(),
            history: Vec::new(),
        }
    }

    // Process a new mutual credit transaction.
    pub fn process_transaction(&mut self, tx: MutualCreditTransaction) -> Result<(), String> {
        // Verify sender signature (placeholder)
        if !Self::verify_signature(&tx.sender_did, &tx.signature, tx.amount) {
            return Err("Invalid signature".into());
        }
        // Update sender and receiver balances
        *self.balances.entry(tx.sender_did.clone()).or_insert(0) -= tx.amount;
        *self.balances.entry(tx.receiver_did.clone()).or_insert(0) += tx.amount;
        // Append to history
        self.history.push(tx);
        Ok(())
    }

    // Dummy signature verifier (to be replaced with actual verification logic)
    fn verify_signature(_did: &str, _signature: &str, _amount: i64) -> bool {
        true // In practice, verify using the sender's DID key.
    }

    // Get balance summary for a member
    pub fn get_balance(&self, did: &str) -> i64 {
        *self.balances.get(did).unwrap_or(&0)
    }

    // Print simple ledger summary (for logging)
    pub fn print_summary(&self) {
        for (did, balance) in &self.balances {
            println!("Member {}: Balance {}", did, balance);
        }
    }
}

// Example usage (to be removed or used in unit tests)
// fn main() {
//     let mut ledger = MutualCreditLedger::new();
//     let tx = MutualCreditTransaction {
//         sender_did: "did:icn:member1".into(),
//         receiver_did: "did:icn:member2".into(),
//         amount: 50,
//         signature: "signature_placeholder".into(),
//         timestamp: Utc::now().timestamp(),
//     };
//     ledger.process_transaction(tx).unwrap();
//     ledger.print_summary();
// }
```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 93 bytes
Modified: 2025-02-19 06:23:14.798626400 +0000
Dependencies:
use icn_types::Transaction;

===================
```rs
pub mod websocket;
pub mod protocol;
pub mod networking;

use icn_types::Transaction;

```

===================
File: ./crates/icn-resource/src/lib.rs
Size: 6916 bytes
Modified: 2025-02-19 06:23:14.798626400 +0000
Dependencies:
use async_trait::async_trait;
use icn_federation::ResourceManager;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_federation::ResourceManager;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub resource_type: String,
    pub owner: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub price_per_unit: f64,
    pub constraints: ResourceConstraints,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceConstraints {
    pub min_reputation: i64,
    pub max_allocation: u64,
    pub time_limit: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationResourcePool {
    pub federation_id: String,
    pub resources: HashMap<String, Resource>,
    pub access_control: FederationAccessControl,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationAccessControl {
    pub allowed_federations: Vec<String>,
    pub min_reputation: i64,
    pub max_allocation_per_federation: u64,
}

pub struct ResourceAllocationSystem {
    resources: Arc<RwLock<HashMap<String, Resource>>>,
    allocations: Arc<RwLock<HashMap<String, Vec<ResourceAllocation>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub allocation_id: String,
    pub resource_id: String,
    pub recipient: String,
    pub amount: u64,
    pub allocated_at: u64,
    pub expires_at: Option<u64>,
}

impl ResourceAllocationSystem {
    pub fn new() -> Self {
        Self {
            resources: Arc::new(RwLock::new(HashMap::new())),
            allocations: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn register_resource(
        &self,
        owner: String,
        resource_type: String,
        amount: u64,
        price: f64,
        constraints: ResourceConstraints,
    ) -> Result<String, ResourceError> {
        let resource_id = format!("res_{}", uuid::Uuid::new_v4());
        let resource = Resource {
            id: resource_id.clone(),
            resource_type,
            owner,
            total_amount: amount,
            available_amount: amount,
            price_per_unit: price,
            constraints,
        };

        let mut resources = self.resources.write().await;
        resources.insert(resource_id.clone(), resource);

        Ok(resource_id)
    }

    pub async fn allocate(
        &self,
        resource_id: &str,
        recipient: String,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        let resource = resources.get_mut(resource_id)
            .ok_or(ResourceError::ResourceNotFound)?;

        if resource.available_amount < amount {
            return Err(ResourceError::InsufficientResources);
        }

        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        let allocation = ResourceAllocation {
            allocation_id: allocation_id.clone(),
            resource_id: resource_id.to_string(),
            recipient,
            amount,
            allocated_at: chrono::Utc::now().timestamp() as u64,
            expires_at: None,
        };

        resource.available_amount -= amount;

        let mut allocations = self.allocations.write().await;
        allocations.entry(resource_id.to_string())
            .or_insert_with(Vec::new)
            .push(allocation);

        Ok(allocation_id)
    }

    pub async fn release(
        &self,
        allocation_id: &str,
    ) -> Result<(), ResourceError> {
        let mut allocations = self.allocations.write().await;
        for (resource_id, resource_allocations) in allocations.iter_mut() {
            if let Some(index) = resource_allocations.iter().position(|alloc| alloc.allocation_id == allocation_id) {
                let allocation = resource_allocations.remove(index);
                let mut resources = self.resources.write().await;
                if let Some(resource) = resources.get_mut(&allocation.resource_id) {
                    resource.available_amount += allocation.amount;
                }
                return Ok(());
            }
        }
        Err(ResourceError::InvalidAllocation)
    }

    pub async fn adjust_price(
        &self,
        resource_id: &str,
        new_price: f64,
    ) -> Result<(), ResourceError> {
        let mut resources = self.resources.write().await;
        if let Some(resource) = resources.get_mut(resource_id) {
            resource.price_per_unit = new_price;
            Ok(())
        } else {
            Err(ResourceError::ResourceNotFound)
        }
    }

    pub async fn create_federation_pool(
        &self,
        federation_id: String,
        access_control: FederationAccessControl,
    ) -> Result<(), ResourceError> {
        let pool = FederationResourcePool {
            federation_id: federation_id.clone(),
            resources: HashMap::new(),
            access_control,
        };
        
        let mut resources = self.resources.write().await;
        resources.insert(federation_id, pool);
        Ok(())
    }

    pub async fn share_with_federation(
        &self,
        source_federation: &str,
        target_federation: &str, 
        resource_id: &str,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        
        // Verify federation access permissions
        let source_pool = resources.get(source_federation)
            .ok_or(ResourceError::ResourceNotFound)?;
            
        if !source_pool.access_control.allowed_federations.contains(&target_federation.to_string()) {
            return Err(ResourceError::UnauthorizedAction);
        }

        // Create allocation record
        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        
        // Allocate resources to target federation
        self.allocate(resource_id, target_federation.to_string(), amount).await?;

        Ok(allocation_id)
    }
}

#[async_trait]
impl ResourceManager for ResourceAllocationSystem {
    async fn allocate_resources(&self, allocation: icn_federation::ResourceAllocation) -> Result<(), String> {
        self.allocate(&allocation.resource_type, allocation.recipient, allocation.amount)
            .await
            .map_err(|e| e.to_string())
    }

    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String> {
        // Implementation for releasing resources back to the pool
        Ok(())
    }
}

#[derive(Debug)]
pub enum ResourceError {
    ResourceNotFound,
    InsufficientResources,
    InvalidAllocation,
    UnauthorizedAction,
}
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 4266 bytes
Modified: 2025-02-19 03:17:24.483393900 +0000
Dependencies:
use async_trait::async_trait;
use icn_dsl::CoopLangAST;
use icn_types::{Block, Transaction};

===================
```rs
use async_trait::async_trait;
use icn_types::{Block, Transaction};
use icn_dsl::CoopLangAST;

pub struct RuntimeManager {
    // Fields for the RuntimeManager struct
    dsl_context: Option<CoopLangAST>,
}

impl RuntimeManager {
    // Methods for the RuntimeManager struct

    pub async fn load_bytecode(&mut self, bytecode: &[u8]) -> Result<(), RuntimeError> {
        // Implementation to load and validate DSL bytecode
        self.dsl_context = Some(CoopLangAST::parse(bytecode)?);
        Ok(())
    }

    pub async fn execute_cooperative_rules(&self, context: &ExecutionContext) -> Result<(), RuntimeError> {
        if let Some(ast) = &self.dsl_context {
            // Execute validation rules
            if let Some(validation) = &ast.validation {
                self.execute_validation_rules(validation, context).await?;
            }

            // Execute governance rules
            if let Some(governance) = &ast.governance {
                self.execute_governance_rules(governance, context).await?;
            }

            // Execute marketplace rules
            if let Some(marketplace) = &ast.marketplace {
                self.execute_marketplace_rules(marketplace, context).await?;
            }
        }
        Ok(())
    }

    async fn execute_governance_rules(&self, governance: &GovernanceNode, context: &ExecutionContext) -> Result<(), RuntimeError> {
        // Implementation for executing governance rules
        Ok(())
    }

    async fn execute_marketplace_rules(&self, marketplace: &MarketplaceNode, context: &ExecutionContext) -> Result<(), RuntimeError> {
        // Implementation for executing marketplace rules
        Ok(())
    }

    async fn evaluate_condition(&self, condition: &str, context: &ExecutionContext) -> Result<bool, RuntimeError> {
        // Parse and evaluate condition expression
        // This could use a simple expression evaluator or more complex logic
        Ok(true) // Placeholder
    }
}

#[async_trait]
pub trait ValidationExecutor {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> Result<(), RuntimeError>;
    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> Result<(), RuntimeError>;
    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> Result<(), RuntimeError>;
}

#[async_trait]
impl ValidationExecutor for RuntimeManager {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> Result<(), RuntimeError> {
        // Execute pre-checks
        for check in &validation.pre_checks {
            self.execute_check(check, context).await?;
        }

        // Validate state if specified
        if let Some(state_validation) = &validation.state_validation {
            self.validate_state(state_validation, context).await?;
        }

        // Execute post-checks
        for check in &validation.post_checks {
            self.execute_check(check, context).await?;
        }

        Ok(())
    }

    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> Result<(), RuntimeError> {
        let condition_result = self.evaluate_condition(&check.condition, context).await?;
        if !condition_result {
            return Err(RuntimeError::ValidationFailed(check.action.clone()));
        }
        Ok(())
    }

    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> Result<(), RuntimeError> {
        if let Some(current) = &validation.current {
            let state = self.get_current_state(context).await?;
            if state != *current {
                return Err(RuntimeError::InvalidState);
            }
        }
        // Similarly check expected state and transitions...
        Ok(())
    }
}

#[async_trait]
pub trait VM {
    async fn execute_transaction(&self, transaction: Transaction);
    async fn execute_block(&self, block: Block);
}

pub struct ContractExecution {
    // Fields for the ContractExecution struct
}

impl ContractExecution {
    // Methods for the ContractExecution struct
}
```

===================
File: ./crates/icn-storage/src/lib.rs
Size: 4340 bytes
Modified: 2025-02-21 01:05:58.895528700 +0000
Dependencies:
mod tests {
use icn_types::Block;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use std::time::Duration;
use thiserror::Error;
use tokio::sync::Mutex;

===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use thiserror::Error;
use icn_types::Block;
use std::time::Duration;

/// Errors that can occur in storage operations
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
}

/// Represents the result of storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Core storage interface for the system
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    
    /// Retrieve a value by key
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Manages persistent storage for the system
pub struct StorageManager {
    backend: Arc<Mutex<Box<dyn StorageBackend>>>,
    cache: Arc<StorageCache>,
}

impl StorageManager {
    /// Create a new storage manager with the given backend
    pub fn new(backend: Box<dyn StorageBackend>, cache_size: usize, cache_ttl: Duration) -> Self {
        Self {
            backend: Arc::new(Mutex::new(backend)),
            cache: Arc::new(StorageCache::new(cache_size, cache_ttl)),
        }
    }
    
    /// Store a serializable value
    pub async fn store<T: Serialize>(&self, key: &str, value: &T) -> StorageResult<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| StorageError::SerializationError(e.to_string()))?;
            
        // Update backend
        let backend = self.backend.lock().await;
        backend.set(key, &serialized).await?;
        
        // Update cache
        self.cache.set(key.to_string(), serialized);
        
        Ok(())
    }
    
    /// Retrieve and deserialize a value
    pub async fn retrieve<T: for<'de> Deserialize<'de>>(&self, key: &str) -> StorageResult<T> {
        // Try cache first
        if let Some(cached_data) = self.cache.get(key) {
            return serde_json::from_slice(&cached_data)
                .map_err(|e| StorageError::SerializationError(e.to_string()));
        }

        // Fall back to backend
        let backend = self.backend.lock().await;
        let data = backend.get(key).await?;
        
        // Update cache
        self.cache.set(key.to_string(), data.clone());
        
        serde_json::from_slice(&data)
            .map_err(|e| StorageError::SerializationError(e.to_string()))
    }
    
    /// Delete a stored value
    pub async fn remove(&self, key: &str) -> StorageResult<()> {
        let backend = self.backend.lock().await;
        backend.delete(key).await
    }
    
    /// Check if a key exists in storage
    pub async fn has_key(&self, key: &str) -> StorageResult<bool> {
        let backend = self.backend.lock().await;
        backend.exists(key).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Mock storage backend for testing
    struct MockStorage {
        data: HashMap<String, Vec<u8>>,
    }
    
    #[async_trait::async_trait]
    impl StorageBackend for MockStorage {
        async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
            self.data.insert(key.to_string(), value.to_vec());
            Ok(())
        }
        
        async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
            self.data.get(key)
                .cloned()
                .ok_or_else(|| StorageError::NotFound(key.to_string()))
        }
        
        async fn delete(&self, key: &str) -> StorageResult<()> {
            self.data.remove(key);
            Ok(())
        }
        
        async fn exists(&self, key: &str) -> StorageResult<bool> {
            Ok(self.data.contains_key(key))
        }
    }
    
    #[tokio::test]
    async fn test_basic_storage_operations() {
        // Test implementation here
        // Will add comprehensive tests as we develop
    }
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 23544 bytes
Modified: 2025-02-21 01:05:05.402617800 +0000
Dependencies:
use chrono::{DateTime, Utc};
use lazy_static::lazy_static;
use rayon::prelude::*;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use std::collections::HashMap;
use std::sync::Mutex; // Remove Arc since it's unused
use std::time::SystemTime;
use thiserror::Error;
use tokio::task;

===================
```rs
use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use tokio::task;
use rayon::prelude::*;
use std::collections::HashMap;

use std::sync::Mutex; // Remove Arc since it's unused
use lazy_static::lazy_static;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum BlockError {
    #[error("Invalid block hash")]
    InvalidHash,
    #[error("Previous hash mismatch")]
    PreviousHashMismatch,
    #[error("Invalid block index")]
    InvalidIndex,
    #[error("Invalid timestamp")]
    InvalidTimestamp,
    #[error("Invalid transaction: {0}")]
    InvalidTransaction(String),
    #[error("Resource usage mismatch")]
    ResourceMismatch,
    #[error("Relationship metadata mismatch")]
    MetadataMismatch,
}

#[derive(Debug)]
pub struct ResourceDebt {
    pub cpu_debt: u64,
    pub memory_debt: u64,
    pub bandwidth_debt: u64,
}

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    /// Sequential index of this block in the chain
    pub index: u64,
    
    /// Hash of the previous block
    pub previous_hash: String,
    
    /// Unix timestamp in milliseconds when block was created
    pub timestamp: u64,
    
    /// List of transactions included in this block
    pub transactions: Vec<Transaction>,
    
    /// Hash of this block's contents
    pub hash: String,
    
    /// The DID of the validator that proposed this block
    pub proposer: String,
    
    /// Collection of validator signatures approving this block
    pub signatures: Vec<BlockSignature>,
    
    /// Metadata about the block creation
    pub metadata: BlockMetadata,
}

/// Signature from a validator approving a block
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    /// DID of the signing validator
    pub validator_did: String,
    
    /// The signature itself
    pub signature: String,
    
    /// Timestamp when signature was created
    pub timestamp: DateTime<Utc>,
    
    /// Voting power of the validator at time of signing
    pub voting_power: f64,
}

/// Additional metadata about block creation and validation
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub consensus_duration_ms: u64,
    pub validator_count: u32,
    pub total_voting_power: f64,
    pub resources_used: u64,
    pub size: u64,
    pub relationship_updates: RelationshipMetadata,
    pub fault_tolerance: Option<u32>,
}

impl BlockMetadata {
    pub fn with_bft_info(&mut self, quorum_size: u32, fault_tolerance: u32) {
        self.validator_count = quorum_size;
        self.fault_tolerance = Some(fault_tolerance);
        self.consensus_duration_ms = 0; // Will be set during finalization
    }

    pub fn is_bft_valid(&self) -> bool {
        if let Some(fault_tolerance) = self.fault_tolerance {
            // Check if we have enough validators (3f + 1)
            self.validator_count >= (fault_tolerance * 3) + 1
        } else {
            false
        }
    }
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

lazy_static! {
    static ref TRANSACTION_CACHE: Mutex<HashMap<String, bool>> = Mutex::new(HashMap::new());
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
            fault_tolerance: None,
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            signatures: Vec::new(),
            metadata,
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        // Add block header fields
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        // Add entire transaction data
        for tx in &self.transactions {
            hasher.update(serde_json::to_string(tx).unwrap());
        }
        
        // Add proposer
        hasher.update(&self.proposer);
        
        // Convert hash to hex string
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub async fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        let signature_task = task::spawn(async move {
            BlockSignature {
                validator_did,
                signature,
                timestamp: Utc::now(),
                voting_power,
            }
        });

        let new_signature = signature_task.await.unwrap();
        self.signatures.push(new_signature);

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub async fn verify(&self, previous_block: Option<&Block>) -> Result<(), BlockError> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err(BlockError::InvalidHash);
        }

        // Verify previous block linkage
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err(BlockError::PreviousHashMismatch);
            }
            if self.index != prev.index + 1 {
                return Err(BlockError::InvalidIndex);
            }
            if self.timestamp <= prev.timestamp {
                return Err(BlockError::InvalidTimestamp);
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err(BlockError::InvalidTimestamp);
        }

        // Validate transactions
        self.validate_transactions().await?;

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err(BlockError::ResourceMismatch);
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err(BlockError::MetadataMismatch);
        }

        Ok(())
    }

    /// Validates the transactions in the block
    async fn validate_transactions(&self) -> Result<(), BlockError> {
        let validation_tasks: Vec<_> = self.transactions.iter()
            .map(|tx| {
                let tx = tx.clone();
                task::spawn(async move {
                    let tx_hash = tx.hash.clone();
                    let mut cache = TRANSACTION_CACHE.lock().unwrap();
                    if let Some(&is_valid) = cache.get(&tx_hash) {
                        is_valid
                    } else {
                        let is_valid = tx.validate();
                        cache.insert(tx_hash, is_valid);
                        is_valid
                    }
                })
            })
            .collect();

        for task in validation_tasks {
            if !task.await.unwrap() {
                return Err(BlockError::InvalidTransaction("One or more invalid transactions".into()));
            }
        }

        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> RelationshipMetadata {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        metadata
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }

    /// Finalizes the block and ensures all validations pass
    pub async fn finalize(&mut self) -> Result<(), BlockError> {
        self.verify(None).await?;
        
        let resource_usage = self.transactions.par_iter()
            .map(|tx| tx.resource_cost)
            .sum();
            
        self.metadata.resources_used = resource_usage;
        
        self.metadata.size = bincode::serialize(&self)
            .map_err(|_| BlockError::InvalidHash)?
            .len() as u64;
            
        self.hash = self.calculate_hash();
        
        Ok(())
    }

    /// Initiates a consensus round among the validators
    pub async fn start_consensus_round(&mut self) -> Result<(), BlockError> {
        // Simulate consensus round
        let consensus_duration = 1000; // Simulated duration in milliseconds
        tokio::time::sleep(tokio::time::Duration::from_millis(consensus_duration)).await;

        // Simulate validator signatures
        let validators = vec!["validator1", "validator2", "validator3"];
        for validator in validators {
            let signature = format!("signature_of_{}", validator);
            self.add_signature(validator.to_string(), signature, 1.0).await?;
        }

        // Update metadata after consensus
        self.update_metadata(consensus_duration, bincode::serialize(&self).unwrap().len() as u64);

        Ok(())
    }

    /// Records a validator's vote on the block
    pub async fn vote_on_block(&mut self, validator_did: String, vote: bool) -> Result<(), BlockError> {
        let signature = if vote {
            format!("signature_of_{}", validator_did)
        } else {
            return Err(BlockError::InvalidTransaction("Validator voted against the block".into()));
        };

        self.add_signature(validator_did, signature, 1.0).await?;
        Ok(())
    }

    pub fn update_validator_metadata(&mut self, validator: String, reputation: i64) {
        let validator_meta = BlockSignature {
            validator_did: validator,
            signature: String::new(),
            timestamp: Utc::now(),
            voting_power: reputation as f64,
        };
        self.signatures.push(validator_meta);
        
        // Update validator count and total voting power
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: std::collections::HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

impl TransactionType {
    pub fn as_str(&self) -> &str {
        match self {
            TransactionType::Transfer { .. } => "Transfer",
            TransactionType::ContractExecution { .. } => "ContractExecution",
            TransactionType::RecordContribution { .. } => "RecordContribution",
            TransactionType::RecordMutualAid { .. } => "RecordMutualAid",
            TransactionType::UpdateRelationship { .. } => "UpdateRelationship",
            TransactionType::AddEndorsement { .. } => "AddEndorsement",
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub hash: String,
    pub transaction_type: TransactionType,
    pub timestamp: u128,
    pub resource_cost: u64,      // Resource points required for this transaction
    pub resource_priority: u8,    // Priority level for resource allocation (1-10)
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);
        
        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
            resource_cost,
            resource_priority: 5, // Default priority level
        }
    }

    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                // Base cost plus percentage of transfer amount
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                // Base cost plus data size cost
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                // Cost based on content size and complexity
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                // Base cost plus content size
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                // Base cost plus story length
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                // Base cost plus content and skills
                60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        // Ensure sender is not empty
        if self.sender.is_empty() {
            return false;
        }

        // Validate based on transaction type
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0 && self.sender != *receiver
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && 
                !impact_story.is_empty() && 
                !context.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && 
                !description.is_empty() && 
                !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && 
                !relationship_type.is_empty() && 
                !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && 
                !content.is_empty() && 
                !context.is_empty() && 
                !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap_or_default()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community, 
    Hybrid
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}
```

===================
File: ./icn-consensus/src/lib.rs
Size: 1234 bytes
Modified: 2025-02-18 05:59:31.559796600 +0000
Dependencies:

===================
```rs
// ...existing code...

// Define the structure for cooperative governance rules
struct GovernanceRules {
    max_validators: usize,
    min_stake: u64,
    election_period: u64,
    // ...other rules...
}

// Define the structure for a validator
struct Validator {
    id: String,
    stake: u64,
    // ...other properties...
}

// Define the structure for the genesis block
struct GenesisBlock {
    initial_validators: Vec<Validator>,
    // ...other properties...
}

// Function to enforce cooperative governance rules
fn enforce_governance_rules(validators: &mut Vec<Validator>, rules: &GovernanceRules) {
    // Implement rules to prevent centralized control
    // ...code to enforce rules...
}

// Function to finalize the genesis block format
fn finalize_genesis_block(validators: Vec<Validator>) -> GenesisBlock {
    GenesisBlock {
        initial_validators: validators,
        // ...initialize other properties...
    }
}

// Function to develop a validator election mechanism
fn elect_validators(current_validators: &Vec<Validator>, candidates: &Vec<Validator>, rules: &GovernanceRules) -> Vec<Validator> {
    // Implement democratic election mechanism
    // ...code to elect validators...
}

// ...existing code...
```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
Modified: 2025-02-18 07:59:01.140151200 +0000
Dependencies:

===================
```rs
fn main() {
    println!("Hello, world!");
}
```

