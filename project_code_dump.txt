Project Code Dump - Generated Mon Mar 10 03:53:51 UTC 2025
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

Note: Documentation files are handled by a separate script and not included here.
Note: Dependencies (node_modules, target, etc.) are excluded from this dump.
======================

Project Structure Summary:
=========================
Main directories:
.
  backend
    benches
    migrations
    src
    tests
  bridges
    cross_chain
  config
  consensus
  contracts
    cooperative
  crates
    consensus
    core
    icn-cli
    icn-common
    icn-consensus
    icn-core
    icn-crypto
    icn-dsl
    icn-federation
    icn-governance
    icn-identity
    icn-mutual-credit
    icn-p2p
    icn-reputation
    icn-resource
    icn-runtime
    icn-storage
    icn-types
    icn-zk
    networking
    storage
    zk_snarks
  data
    bootstrap
    db
    validator1
    validator2
  docker
    backend
    frontend
    init-db
  docs
    api
    architecture
    deployment
    development
    guides
    specifications
    templates
    user
  examples
  federation
  frontend
    build
    public
    src
  fsprovider-sample
    src
  grammar
  helm
    icn-backend
  icn-consensus
    src
  icn-core
    src
  identity
    tests
  k8s
    production
    staging
  logs
  messaging
  prototype
    __tests__
    config
    dashboard
    data
    logs
    scripts
    src
  reputation
  scripts
    backend
    frontend
  src
    api
    attestation
    blockchain
    consensus
    dsl
    federation
    governance
    identity
    network
    services
    storage
  tests
    a11y
    load_tests
  tools
    doctools

===================
File: ./.devcontainer/docker-compose.yml
Size: 973 bytes
===================
```yml
version: '3.8'

services:
  backend:
    build:
      context: ../backend                        
      dockerfile: ../docker/backend.Dockerfile   
    ports:
      - "8081:8081"  
    environment:
      - DATABASE_URL=postgres://icnuser:icnpass@db:5432/icndb
    networks:
      - icn-network

  frontend:
    build:
      context: ../frontend                       
      dockerfile: ../docker/frontend.Dockerfile  
    ports:
      - "3000:3000"
    networks:
      - icn-network

  db:
    image: postgres:13.3
    environment:
      POSTGRES_USER: icnuser
      POSTGRES_PASSWORD: icnpass
      POSTGRES_DB: icndb
    ports:
      - "5432:5432"
    networks:
      - icn-network

  docs:
    image: squidfunk/mkdocs-material:7.1.0
    volumes:
      - ../docs:/docs          
    ports:
      - "8000:8000"
    working_dir: /docs
    command: /bin/sh -c "pip install mkdocs-mermaid2-plugin && mkdocs serve -a 0.0.0.0:8000"

networks:
  icn-network:
    driver: bridge
```

===================
File: ./Cargo.toml
Size: 2244 bytes
===================
```toml
[workspace]
members = [
    "backend",
    "crates/icn-types",
    "crates/icn-common",
    "crates/icn-core",
    "crates/icn-p2p",
    "crates/icn-cli"
]

[workspace.dependencies]
# Internal crates
icn-types = { path = "crates/icn-types" }
icn-common = { path = "crates/icn-common" }
icn-core = { path = "crates/icn-core" }
icn-p2p = { path = "crates/icn-p2p" }
icn-cli = { path = "crates/icn-cli" }

# External dependencies
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
warp = "0.3"
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"] }
thiserror = "1.0"
chrono = { version = "0.4.40", features = ["serde"] }
async-trait = "0.1"
futures = "0.3.31"
tracing = "0.1.41"
log = "0.4"
env_logger = "0.11.6"
sha2 = "0.10.8"
rayon = "1.10.0"
lazy_static = "1.5.0"
x25519-dalek = "2.0.1"
libsqlite3-sys = "0.30.1"

[package]
name = "icn"
version = "0.1.0"
description = "Inter-Cooperative Network - A platform for cooperative resource sharing and governance"
edition = "2021"

[features]
default = ["basic", "federation"]
basic = []
federation = ["dep:tokio", "dep:async-trait"]
advanced-governance = ["dep:parity-scale-codec"]
monitoring = ["dep:prometheus"]

[dependencies]
icn-types = { workspace = true }
tokio = { workspace = true, optional = true }
warp = { workspace = true }
async-trait = { workspace = true, optional = true }
parity-scale-codec = { version = "3.7.4", optional = true }
prometheus = { version = "0.13.4", optional = true }
serde = { workspace = true }
icn-core = { workspace = true }
log = { workspace = true }
env_logger = { workspace = true }
pest = "2.7.15"
pest_derive = "2.7.15"
serde_json = { workspace = true }
chrono = { workspace = true }
futures = { workspace = true }
tokio-tungstenite = "0.26.2"
icn-p2p = { path = "crates/icn-p2p" }

[[bin]]
name = "icn_cli"
path = "crates/icn-cli/src/main.rs"

[lib]
name = "icn_lib"
path = "src/lib.rs"

[[bin]]
name = "icn_bin"
path = "src/main.rs"

[[example]]
name = "sdp_federation_example"
path = "examples/sdp_federation_example.rs"

[dev-dependencies]
reqwest = { version = "0.11", features = ["json"] }
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
```

===================
File: ./README.md
Size: 4383 bytes
===================
```md
# Internet of Cooperative Networks (ICN)

A federated blockchain platform for cooperative resource sharing and governance.

## Table of Contents
- [Core Components](#core-components)
- [Architecture](#architecture)
- [Quick Start](#quick-start)
- [Project Structure](#project-structure)
- [Key Features](#key-features)
- [Usage](#usage)
- [Contributing](#contributing)
- [Testing](#testing)
- [Documentation](#documentation)
- [License](#license)

## Core Components

- **Consensus Engine**: Proof of Cooperation based consensus with democratic validator selection
- **Federated Ledger**: Distributed transaction processing with cooperative governance
- **DID Authentication**: Identity management using decentralized identifiers
- **Hybrid Storage**: Combined on-chain/off-chain storage model

## Architecture

```mermaid
graph TD
    A[Consensus Layer] --> B[Governance Engine]
    B --> C[Transaction Processing]
    C --> D[Storage Manager]
    D --> E[IPFS/Filecoin]
    D --> F[On-Chain Storage]
```

## Quick Start

```bash
# Build the project
cargo build

# Run tests
cargo test

# Start a local testnet
cargo run --bin icn-node -- --testnet
```

## Project Structure
The ICN project is organized into several directories, each serving a specific purpose:

- **backend**: Contains the Rust code for the backend services.
- **frontend**: Contains the JavaScript code for the frontend application.
- **contracts**: Contains the smart contracts for governance and cooperative operations.
- **crates**:
  - **core**: Contains core libraries (icn-core, icn-crypto, icn-dsl, icn-types).
  - **consensus**: Contains the consensus mechanism (icn-consensus).
  - **networking**: Contains networking libraries (icn-p2p, icn-federation).
  - **storage**: Contains persistence and storage management (icn-storage).
  - **runtime**: Contains runtime support (icn-runtime).
  - **resources**: Contains resource management (icn-resource).
  - **finance**: Contains the mutual credit system (icn-mutual-credit).
- **docker**: Contains Dockerfiles and Docker Compose configurations for containerizing the services.
- **docs**: Contains the project documentation, including setup guides, contribution guides, and API documentation.
- **scripts**: Contains various scripts for setup, deployment, and management of the project.
- **config**: Contains configuration files for different environments and services.

## Key Features
- **Decentralized Identity Management**: Secure and verifiable identities using DIDs.
- **Reputation System**: Track and manage reputation across cooperatives.
- **Governance**: Democratic decision-making through proposals and voting.
- **Resource Sharing**: Efficient allocation and management of resources.
- **Consensus Mechanism**: Proof of Cooperation (PoC) for transaction validation.
- **Telemetry and Logging**: Integrated metrics and logging for monitoring and debugging.

## Usage
To run the ICN project locally, follow the instructions in the [Getting Started](#getting-started) section. For detailed usage instructions, refer to the [User Guides](docs/user/guides/index.md).

### Starting the Backend
```bash
# Navigate to the backend directory
cd backend

# Run the backend services
cargo run --bin icn-backend
```

### Starting the Frontend
```bash
# Navigate to the frontend directory
cd frontend

# Install dependencies
npm install

# Run the frontend application
npm start
```

## Contributing
We welcome contributions from the community! To get started, please read the [ICN Contribution Guide](docs/development/guides/contributing.md) for guidelines on how to contribute to the project.

## Testing
The ICN project uses a comprehensive testing strategy to ensure the quality and reliability of the codebase. For detailed information on the testing strategy and how to run tests, refer to the [ICN Testing Strategy Guide](docs/development/guides/test-strategy.md).

## Documentation
For detailed documentation, including the Development Setup Guide, ICN Contribution Guide, and other relevant documents, refer to the [Documentation Index](docs/INDEX.md).

- [Consensus Engine](./crates/icn-consensus/README.md)
- [Core Architecture](./crates/icn-core/README.md)
- [API Reference](./docs/api.md)
- [Governance Model](./docs/governance.md)

## License
This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for more details.
```

===================
File: ./backend/Cargo.toml
Size: 639 bytes
===================
```toml
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { workspace = true, features = ["full"] }
warp = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
log = { workspace = true }
env_logger = { workspace = true }
sqlx = { workspace = true, features = ["runtime-tokio-rustls", "postgres"] }
thiserror = { workspace = true }
futures = { workspace = true }
async-trait = { workspace = true }
chrono = { workspace = true }

# Internal crates
icn-types = { workspace = true }
icn-common = { workspace = true }
icn-core = { workspace = true }
icn-p2p = { workspace = true }
```

===================
File: ./contracts/Cargo.toml
Size: 277 bytes
===================
```toml
[package]
name = "contracts"
version = "0.1.0"
edition = "2018"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tendermint = "0.23"
tokio = { version = "1", features = ["full"] }

[lib]
name = "contracts"
path = "src/lib.rs"
```

===================
File: ./crates/consensus/Cargo.toml
Size: 207 bytes
===================
```toml
[package]
name = "consensus"
version = "0.1.0"
edition = "2018"

[dependencies]
tendermint = "0.23.0"
tokio = { version = "1", features = ["full"] }

[lib]
name = "consensus"
path = "src/lib.rs"
```

===================
File: ./crates/core/Cargo.toml
Size: 195 bytes
===================
```toml
[package]
name = "core"
version = "0.1.0"
edition = "2018"

[dependencies]
tendermint = "0.23"
tokio = { version = "1", features = ["full"] }

[lib]
name = "core"
path = "src/lib.rs"
```

===================
File: ./crates/icn-cli/Cargo.toml
Size: 333 bytes
===================
```toml
[package]
name = "icn-cli"
version = "0.1.0"
edition = "2021"

[dependencies]
clap = "2.33"
tokio = { version = "1.0", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
icn-types = { path = "../icn-types" }
thiserror = "1.0"
anyhow = "1.0"```

===================
File: ./crates/icn-common/Cargo.toml
Size: 242 bytes
===================
```toml
[package]
name = "icn-common"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { workspace = true }
thiserror = { workspace = true }
async-trait = { workspace = true }
futures = { workspace = true }
icn-types = { workspace = true }
```

===================
File: ./crates/icn-consensus/Cargo.toml
Size: 416 bytes
===================
```toml
[package]
name = "icn-consensus"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
log = "0.4"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"
uuid = { version = "1.0", features = ["v4"] }
bit-set = "0.5"
trie-rs = "0.1"
rand = "0.8"
icn-types = { path = "../icn-types" }
icn-common = { path = "../icn-common" }
```

===================
File: ./crates/icn-consensus/README.md
Size: 790 bytes
===================
```md
# ICN Consensus Engine

Implements the Proof of Cooperation consensus mechanism with democratic validator governance.

## Validator Selection

Validators are selected through a democratic process:
- Each cooperative can propose validators
- Proposals require majority approval
- Maximum validators per cooperative is enforced
- Minimum stake requirements apply

## Governance Rules

```rust
ValidatorRules {
    max_validators_per_coop: 2,
    min_stake_requirement: 100_000,
    election_period_blocks: 40320, // ~7 days
}
```

## Usage Example

```rust
let rules = ValidatorRules::default();
let engine = GovernanceEngine::new(rules);

// Submit validator proposal
let proposal = VoteProposal::new(
    ProposalType::AddValidator(validator_info)
);
engine.submit_proposal(proposal)?;
```
```

===================
File: ./crates/icn-core/Cargo.toml
Size: 394 bytes
===================
```toml
[package]
name = "icn-core"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { workspace = true }
serde = { workspace = true }
thiserror = { workspace = true }
async-trait = { workspace = true }
futures = { workspace = true }
log = { workspace = true }
icn-types = { workspace = true }
icn-common = { workspace = true }
chrono = { version = "0.4", features = ["serde"] }
rand = "0.8"
```

===================
File: ./crates/icn-crypto/Cargo.toml
Size: 65 bytes
===================
```toml
[package]
name = "icn-crypto"
version = "0.1.0"
edition = "2021"
```

===================
File: ./crates/icn-dsl/Cargo.toml
Size: 534 bytes
===================
```toml
[package]
name = "icn-dsl"
version = "0.1.0"
edition = "2021"
description = "Domain-specific language implementation for the Inter-Cooperative Network (ICN) system"
license = "MIT"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
nom = "7.1"
log = { workspace = true }
thiserror = { workspace = true }
futures = { workspace = true }
async-trait = { workspace = true }
bincode = "1.3"

[dev-dependencies]
tokio = { workspace = true, features = ["full", "test-util"] }

[features]
default = []
testing = []```

===================
File: ./crates/icn-federation/Cargo.toml
Size: 576 bytes
===================
```toml
[package]
name = "icn-federation"
version = "0.1.0"
edition = "2018"

[dependencies]
tokio = { version = "1.30", features = ["full"] }
tendermint = "0.23"
serde = { version = "1.0", features = ["derive"] }
thiserror = "1.0"
async-trait = "0.1"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
icn-types = { workspace = true }
icn-governance = { path = "../icn-governance" }
icn-zk = { path = "../icn-zk" }
icn-networking = { path = "../networking" }
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"] }
```

===================
File: ./crates/icn-governance/Cargo.toml
Size: 487 bytes
===================
```toml
[package]
name = "icn-governance"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
log = "0.4"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"
uuid = { version = "1.0", features = ["v4"] }
bit-set = "0.5"
trie-rs = "0.1"
rand = "0.8"
icn-types = { path = "../icn-types" }
icn-zk = { path = "../icn-zk" }
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"] }
```

===================
File: ./crates/icn-identity/Cargo.toml
Size: 699 bytes
===================
```toml
[package]
name = "icn-identity"
version = "0.1.0"
edition = "2021"
description = "Identity management for the Inter-Cooperative Network (ICN) system"
license = "MIT"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
chrono = { workspace = true }
async-trait = { workspace = true }
icn-types = { workspace = true }
sha2 = { workspace = true }
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"], optional = true }

[dev-dependencies]
tokio = { workspace = true, features = ["full", "test-util"] }

[features]
default = []
testing = []
database = ["dep:sqlx"]```

===================
File: ./crates/icn-mutual-credit/Cargo.toml
Size: 420 bytes
===================
```toml
[package]
name = "icn-mutual-credit"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
log = "0.4"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
chrono = "0.4"
uuid = { version = "1.0", features = ["v4"] }
bit-set = "0.5"
trie-rs = "0.1"
rand = "0.8"
icn-types = { path = "../icn-types" }
icn-common = { path = "../icn-common" }
```

===================
File: ./crates/icn-p2p/Cargo.toml
Size: 487 bytes
===================
```toml
[package]
name = "icn-p2p"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
async-trait = { workspace = true }
futures = { workspace = true }
log = { workspace = true }
icn-types = { workspace = true }
icn-common = { workspace = true }
tokio-tungstenite = { version = "0.21.0", features = ["native-tls"] }
x25519-dalek = "2.0.0"
rand = "0.8"
```

===================
File: ./crates/icn-reputation/Cargo.toml
Size: 337 bytes
===================
```toml
[package]
name = "icn-reputation"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
async-trait = "0.1"
icn-zkp = { path = "../icn-zk" }
icn-types = { path = "../icn-types" }
icn-storage = { path = "../icn-storage" }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }```

===================
File: ./crates/icn-resource/Cargo.toml
Size: 702 bytes
===================
```toml
[package]
name = "icn-resource"
version = "0.1.0"
edition = "2021"
description = "Resource management for the Inter-Cooperative Network (ICN) system"
license = "MIT"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
chrono = { workspace = true }
async-trait = { workspace = true }
icn-types = { workspace = true }
futures = { workspace = true }
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"], optional = true }

[dev-dependencies]
tokio = { workspace = true, features = ["full", "test-util"] }

[features]
default = []
testing = []
database = ["dep:sqlx"]```

===================
File: ./crates/icn-runtime/Cargo.toml
Size: 482 bytes
===================
```toml
[package]
name = "icn-runtime"
version = "0.1.0"
edition = "2021"
description = "Runtime implementation for the Inter-Cooperative Network"

[dependencies]
icn-types = { workspace = true }
tokio = { workspace = true }
serde = { workspace = true }
thiserror = { workspace = true }
async-trait = { workspace = true }
futures = { workspace = true }
tracing = { workspace = true }

[dev-dependencies]
tokio = { workspace = true, features = ["test-util", "macros"] }
tracing-test = "0.2"
```

===================
File: ./crates/icn-storage/Cargo.toml
Size: 503 bytes
===================
```toml
[package]
name = "icn-storage"
version = "0.1.0"
edition = "2021"
description = "Storage implementation for the Inter-Cooperative Network"

[dependencies]
icn-types = { workspace = true }
tokio = { workspace = true }
serde = { workspace = true }
thiserror = { workspace = true }
chrono = { workspace = true }
async-trait = "0.1"
ipfs-api-backend-actix = "0.6"
futures = "0.3"
serde_json = "1.0"
bincode = "1.3"

[dev-dependencies]
tokio = { workspace = true, features = ["test-util"] }
tempfile = "3.8"
```

===================
File: ./crates/icn-types/Cargo.toml
Size: 641 bytes
===================
```toml
[package]
name = "icn-types"
version = "0.1.0"
edition = "2021"
description = "Core types for the Inter-Cooperative Network (ICN) system"
license = "MIT"

[dependencies]
serde = { workspace = true }
thiserror = { workspace = true }
async-trait = { workspace = true }
sqlx = { workspace = true, optional = true }
sha2 = "0.10.7"
chrono = { version = "0.4", features = ["serde"] }
tokio = { workspace = true, features = ["full"] }
lazy_static = "1.4"
log = "0.4"
bincode = "1.3"
serde_json = "1.0"

[dev-dependencies]
tokio = { workspace = true, features = ["full", "test-util"] }

[features]
default = []
testing = []
database = ["dep:sqlx"]
```

===================
File: ./crates/icn-zk/Cargo.toml
Size: 314 bytes
===================
```toml
[package]
name = "icn-zk"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
bellman = "0.9"
rand = "0.8"
ff = "0.9"
group = "0.9"
pairing = "0.20"
sqlx = { version = "0.8.3", features = ["runtime-tokio-rustls", "postgres"] }
```

===================
File: ./crates/networking/Cargo.toml
Size: 215 bytes
===================
```toml
[package]
name = "icn-networking"
version = "0.1.0"
edition = "2018"

[dependencies]
tokio = { version = "1", features = ["full"] }
tendermint = "0.23"

[lib]
name = "icn_networking"
path = "src/lib.rs"
```

===================
File: ./crates/storage/Cargo.toml
Size: 232 bytes
===================
```toml
[package]
name = "storage"
version = "0.1.0"
edition = "2018"

[dependencies]
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }

[lib]
name = "storage"
path = "src/lib.rs"
```

===================
File: ./crates/zk_snarks/Cargo.toml
Size: 543 bytes
===================
```toml
[package]
name = "zk_snarks"
version = "0.1.0"
edition = "2021"
description = "Zero-knowledge proofs implementation for the Inter-Cooperative Network (ICN) system"
license = "MIT"

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
log = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
bellman = "0.17.0"
ff = "0.13.0" 
rand = "0.8"
sha2 = { workspace = true }

[dev-dependencies]
tokio = { workspace = true, features = ["full", "test-util"] }

[features]
default = []
testing = []```

===================
File: ./docker/backend/Cargo.toml
Size: 78 bytes
===================
```toml
[package]
name = "backend"
version = "0.1.0"
edition = "2024"

[dependencies]
```

===================
File: ./docker/docker-compose.yml
Size: 4778 bytes
===================
```yml
version: "3.8"

services:
  # PostgreSQL database service
  db:
    image: postgres:14-alpine
    restart: unless-stopped
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./init-db:/docker-entrypoint-initdb.d:ro
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-icnuser}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-icnpass}
      POSTGRES_DB: ${POSTGRES_DB:-icndb}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U icnuser -d icndb"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    ports:
      - "5432:5432"
    networks:
      - icn-network

  # Backend service - Rust application
  backend:
    build:
      context: ..
      dockerfile: docker/backend.Dockerfile
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "8081:8081"
    volumes:
      - backend_data:/data
      - backend_logs:/logs
      - backend_config:/config
    environment:
      - DATABASE_URL=postgres://${POSTGRES_USER:-icnuser}:${POSTGRES_PASSWORD:-icnpass}@db:5432/${POSTGRES_DB:-icndb}?options=-c%20search_path%3Dicn
      - RUST_LOG=${RUST_LOG:-info}
      - RUST_BACKTRACE=${RUST_BACKTRACE:-0}
    healthcheck:
      test: ["CMD", "curl", "-X", "GET", "http://localhost:8081/api/v1/health", "||", "exit", "1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - icn-network

  # Frontend service - React application
  frontend:
    build:
      context: ..
      dockerfile: docker/frontend.Dockerfile
      args:
        - REACT_APP_API_URL=/api
    restart: unless-stopped
    depends_on:
      - backend  # Changed from condition: service_healthy to just the service name
    ports:
      - "80:80"
    environment:
      - API_URL=http://backend:8081/api
      - NODE_ENV=production
    healthcheck:
      test: ["CMD", "wget", "-q", "-O-", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      - icn-network

  # ICN Bootstrap Node
  bootstrap:
    build:
      context: ..
      dockerfile: docker/backend.Dockerfile
    container_name: icn-bootstrap
    environment:
      - NODE_TYPE=bootstrap
      - NODE_PORT=9000
      - API_PORT=8082
      - BOOTSTRAP_NODES=[]
      - COOPERATIVE_ID=${COOPERATIVE_ID:-icn-primary}
      - COOPERATIVE_TIER=provider
      - LOG_LEVEL=${RUST_LOG:-info}
      - DATABASE_URL=postgres://${POSTGRES_USER:-icnuser}:${POSTGRES_PASSWORD:-icnpass}@db:5432/${POSTGRES_DB:-icndb}
    ports:
      - "9000:9000"
      - "8082:8082"
    volumes:
      - bootstrap_data:/data
      - bootstrap_logs:/logs
    depends_on:
      - db
    networks:
      - icn-network
    restart: unless-stopped

  # ICN Validator Node 1
  validator1:
    build:
      context: ..
      dockerfile: docker/backend.Dockerfile
    container_name: icn-validator1
    environment:
      - NODE_TYPE=validator
      - NODE_PORT=9001
      - API_PORT=8083
      - BOOTSTRAP_NODES=["ws://bootstrap:9000"]
      - COOPERATIVE_ID=${COOPERATIVE_ID:-icn-primary}
      - COOPERATIVE_TIER=validator
      - LOG_LEVEL=${RUST_LOG:-info}
      - DATABASE_URL=postgres://${POSTGRES_USER:-icnuser}:${POSTGRES_PASSWORD:-icnpass}@db:5432/${POSTGRES_DB:-icndb}
    ports:
      - "9001:9001"
      - "8083:8083"
    volumes:
      - validator1_data:/data
      - validator1_logs:/logs
    depends_on:
      - bootstrap
      - db
    networks:
      - icn-network
    restart: unless-stopped

  # ICN Validator Node 2
  validator2:
    build:
      context: ..
      dockerfile: docker/backend.Dockerfile
    container_name: icn-validator2
    environment:
      - NODE_TYPE=validator
      - NODE_PORT=9002
      - API_PORT=8084
      - BOOTSTRAP_NODES=["ws://bootstrap:9000"]
      - COOPERATIVE_ID=${COOPERATIVE_ID:-icn-primary}
      - COOPERATIVE_TIER=validator
      - LOG_LEVEL=${RUST_LOG:-info}
      - DATABASE_URL=postgres://${POSTGRES_USER:-icnuser}:${POSTGRES_PASSWORD:-icnpass}@db:5432/${POSTGRES_DB:-icndb}
    ports:
      - "9002:9002"
      - "8084:8084"
    volumes:
      - validator2_data:/data
      - validator2_logs:/logs
    depends_on:
      - bootstrap
      - db
    networks:
      - icn-network
    restart: unless-stopped

volumes:
  db_data:
    name: icn_db_data
  backend_data:
    name: icn_backend_data
  backend_logs:
    name: icn_backend_logs
  backend_config:
    name: icn_backend_config
  bootstrap_data:
    name: icn_bootstrap_data
  bootstrap_logs:
    name: icn_bootstrap_logs
  validator1_data:
    name: icn_validator1_data
  validator1_logs:
    name: icn_validator1_logs
  validator2_data:
    name: icn_validator2_data
  validator2_logs:
    name: icn_validator2_logs

networks:
  icn-network:
    driver: bridge
```

===================
File: ./docker/frontend/frontend/frontend/package.json
Size: 648 bytes
===================
```json
{
  "name": "frontend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^4.9.5"
  },
  "description": "",
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/preset-react": "^7.26.3",
    "@babel/preset-typescript": "^7.26.0",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.5.3",
    "react-scripts": "^5.0.1",
    "tailwindcss": "^4.0.12"
  }
}
```

===================
File: ./docker/frontend/package.json
Size: 425 bytes
===================
```json
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  }
}
```

===================
File: ./frontend/Cargo.toml
Size: 318 bytes
===================
```toml
[package]
name = "frontend"
version = "0.1.0"
edition = "2018"

[dependencies]
tokio = { version = "1.30", features = ["full"] }
tendermint = "0.23"
serde = { version = "1.0", features = ["derive"] }

[lib]
name = "frontend_lib"
path = "src/lib.rs"

[[bin]]
name = "frontend_bin"
path = "src/main.rs"
```

===================
File: ./frontend/package.json
Size: 1445 bytes
===================
```json
{
  "name": "icn-frontend",
  "version": "0.1.0",
  "private": true,
  "description": "Frontend for the Inter-Cooperative Network",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "dev": "next dev",
    "lint": "eslint .",
    "format": "prettier --write .",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "@types/d3": "^7.4.3",
    "@types/node": "^16.18.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-window": "^1.8.8",
    "autoprefixer": "^10.4.0",
    "clsx": "^2.1.1",
    "d3": "^7.9.0",
    "lucide-react": "^0.290.0",
    "next": "latest",
    "postcss": "^8.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-grid-heatmap": "^1.3.0",
    "react-router-dom": "^6.21.0",
    "react-scripts": "^5.0.1",
    "react-window": "^1.8.11",
    "recharts": "^2.15.1",
    "tailwind-merge": "^2.2.0",
    "tailwindcss": "^3.3.0",
    "typescript": "^4.9.5"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

===================
File: ./frontend/tsconfig.json
Size: 630 bytes
===================
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "NodeNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["./*"]
    },
    "noImplicitAny": false,
    "strictNullChecks": false
  },
  "include": ["src"]
}
```

===================
File: ./fsprovider-sample/README.md
Size: 1206 bytes
===================
```md
# MemFS

This extension implements an in-memory file system to show-case the [filesystem provider api](https://github.com/Microsoft/vscode/blob/51a880315fd0ec2cafb511a17de48ec31802ba6d/src/vs/vscode.d.ts#L4968). It serves two purposes:

* Be a sample/reference for extension authors that want to implement a filesystem provider
* Be a test for other extensions that *falsely* assume text document always live on disk.

To *get started* you need this:

* install this extension
* when *not* having a workspace opened, select 'F1 > [MemFS] Setup Workspace' (optionally save the workspace now)
* select 'F1 > [MemFs] Create Files' and notice how the explorer is now populated
* ... try things out, e.g. IntelliSense in memfs-files, create new files, save them, etc
* open `file.txt` and make changes
* 'F1 > [MemFS] Delete "file.txt', observe that the editor is now indicating that the file is deleted
* 'F1 > [MemFS] Add "file.txt', observe that the editor content is reset and the '(delete)' annotation disappeared
* select 'F1 > [MemFs] Delete Files' or reload to restart

![sample screenshot](https://github.com/Microsoft/vscode-extension-samples/raw/main/fsprovider-sample/sample.png)
```

===================
File: ./fsprovider-sample/package.json
Size: 2043 bytes
===================
```json
{
	"name": "vscode-memfs",
	"displayName": "MemFS - a file system provider sample",
	"description": "Showcase for the file system provider API, also useful for testing again document that are not on disk.",
	"version": "0.0.3",
	"publisher": "vscode-samples",
	"private": true,
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "https://github.com/Microsoft/vscode-extension-samples"
	},
	"engines": {
		"vscode": "^1.74.0"
	},
	"categories": [
		"Other"
	],
	"activationEvents": [
		"onFileSystem:memfs"
	],
	"main": "./out/src/extension",
	"contributes": {
		"commands": [
			{
				"command": "memfs.workspaceInit",
				"title": "Setup Workspace",
				"category": "MemFS"
			},
			{
				"command": "memfs.init",
				"title": "Create Files",
				"category": "MemFS"
			},
			{
				"command": "memfs.reset",
				"title": "Delete Files",
				"category": "MemFS"
			},
			{
				"command": "memfs.deleteFile",
				"title": "Delete \"file.txt\"",
				"category": "MemFS"
			},
			{
				"command": "memfs.addFile",
				"title": "Add \"file.txt\"",
				"category": "MemFS"
			}
		],
		"menus": {
			"commandPalette": [
				{
					"command": "memfs.init",
					"when": "workbenchState == workspace"
				},
				{
					"command": "memfs.reset",
					"when": "workbenchState == workspace"
				},
				{
					"command": "memfs.deleteFile",
					"when": "workbenchState == workspace"
				},
				{
					"command": "memfs.addFile",
					"when": "workbenchState == workspace"
				},
				{
					"command": "memfs.workspaceInit",
					"when": "workbenchState != workspace"
				}
			]
		}
	},
	"scripts": {
		"vscode:prepublish": "npm run compile",
		"compile": "tsc -p ./",
		"lint": "eslint",
		"watch": "tsc -watch -p ./"
	},
	"devDependencies": {
		"@eslint/js": "^9.13.0",
		"@stylistic/eslint-plugin": "^2.9.0",
		"@types/node": "^20",
		"@types/vscode": "^1.73.0",
		"eslint": "^9.13.0",
		"typescript": "^5.7.2",
		"typescript-eslint": "^8.16.0"
	}
}
```

===================
File: ./fsprovider-sample/tsconfig.json
Size: 258 bytes
===================
```json
{
	"compilerOptions": {
		"strictNullChecks": true,
		"module": "commonjs",
		"target": "es2020",
		"lib": ["es2020"],
		"outDir": "out",
		"sourceMap": true,
		"strict": true,
		"rootDir": "."
	},
	"exclude": ["node_modules", ".vscode-test"]
}
```

===================
File: ./package.json
Size: 544 bytes
===================
```json
{
  "dependencies": {
    "@reach/dialog": "^0.18.0",
    "lucide-react": "^0.479.0",
    "react-window": "^1.8.11",
    "recharts": "^2.15.1"
  },
  "devDependencies": {
    "@axe-core/playwright": "^4.8.1",
    "@percy/cli": "^1.27.4",
    "@playwright/test": "^1.40.0",
    "@types/node": "^20.10.0",
    "playwright": "^1.40.0",
    "typescript": "^5.3.0"
  },
  "scripts": {
    "test:a11y": "playwright test tests/a11y/",
    "test:visual": "percy snapshot frontend/build",
    "test:ci": "npm run test:a11y && npm run test:visual"
  }
}
```

===================
File: ./prototype/docker-compose.yml
Size: 2027 bytes
===================
```yml
version: '3.8'

services:
  bootstrap:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: icn-bootstrap
    environment:
      - NODE_TYPE=bootstrap
      - NODE_PORT=9000
      - API_PORT=3000
      - BOOTSTRAP_NODES=[]
      - COOPERATIVE_ID=icn-prototype
      - COOPERATIVE_TIER=provider
      - LOG_LEVEL=info
    ports:
      - "9000:9000"
      - "3000:3000"
    volumes:
      - bootstrap-data:/app/data
      - bootstrap-logs:/app/logs
    networks:
      - icn-network
    restart: unless-stopped

  node1:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: icn-node1
    environment:
      - NODE_TYPE=regular
      - NODE_PORT=9001
      - API_PORT=3001
      - BOOTSTRAP_NODES=["ws://bootstrap:9000"]
      - COOPERATIVE_ID=icn-prototype
      - COOPERATIVE_TIER=contributor
      - LOG_LEVEL=info
    ports:
      - "9001:9001"
      - "3001:3001"
    volumes:
      - node1-data:/app/data
      - node1-logs:/app/logs
    networks:
      - icn-network
    depends_on:
      - bootstrap
    restart: unless-stopped

  node2:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: icn-node2
    environment:
      - NODE_TYPE=regular
      - NODE_PORT=9002
      - API_PORT=3002
      - BOOTSTRAP_NODES=["ws://bootstrap:9000"]
      - COOPERATIVE_ID=icn-prototype
      - COOPERATIVE_TIER=contributor
      - LOG_LEVEL=info
    ports:
      - "9002:9002"
      - "3002:3002"
    volumes:
      - node2-data:/app/data
      - node2-logs:/app/logs
    networks:
      - icn-network
    depends_on:
      - bootstrap
    restart: unless-stopped

  dashboard:
    image: nginx:alpine
    container_name: icn-dashboard
    volumes:
      - ./dashboard:/usr/share/nginx/html
    ports:
      - "8080:80"
    networks:
      - icn-network
    depends_on:
      - bootstrap
      - node1
      - node2

volumes:
  bootstrap-data:
  bootstrap-logs:
  node1-data:
  node1-logs:
  node2-data:
  node2-logs:

networks:
  icn-network:
    driver: bridge```

===================
File: ./prototype/package.json
Size: 907 bytes
===================
```json
{
  "name": "icn-prototype",
  "version": "0.1.0",
  "description": "ICN (Internet of Cooperative Networks) Prototype Implementation",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "express": "^4.17.1",
    "cors": "^2.8.5",
    "body-parser": "^1.19.0",
    "ws": "^8.2.3",
    "node-fetch": "^2.6.12",
    "uuid": "^8.3.2",
    "better-sqlite3": "^8.5.0",
    "winston": "^3.3.3",
    "dockerode": "^3.3.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^27.0.6",
    "supertest": "^6.1.6"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "license": "MIT",
  "jest": {
    "testEnvironment": "node",
    "coverageDirectory": "./coverage",
    "collectCoverageFrom": [
      "src/**/*.js"
    ]
  }
}```

===================
File: ./rust-toolchain.toml
Size: 31 bytes
===================
```toml
[toolchain]
channel = "1.85.0"
```

===================
File: ./scripts/frontend/package.json
Size: 239 bytes
===================
```json
{
  "dependencies": {
    "@reach/dialog": "^0.18.0",
    "lucide-react": "^0.479.0",
    "react-grid-heatmap": "^1.3.0",
    "react-window": "^1.8.11",
    "recharts": "^2.15.1"
  },
  "devDependencies": {
    "shadcn-ui": "^0.9.5"
  }
}
```

===================
File: ./scripts/frontend/tsconfig.json
Size: 541 bytes
===================
```json
{
  "extends": "./tsconfig.paths.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "noEmit": true
  },
  "include": ["src"]
}
```

===================
File: ./tools/README.md
Size: 561 bytes
===================
```md
# ICN Documentation Tools

This directory contains tools for managing ICN project documentation.

## Setup

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Add tools to your PATH:
   ```bash
   export PATH=$PATH:$(pwd)/tools/doctools
   ```

## Usage

Generate a new specification:
```bash
specgen.py --title "Component Name" --type "specification" --component "core-component"
```

List all documents:
```bash
docmanager.py list
```

Create documentation index:
```bash
docmanager.py index
```
```

===================
File: ./backend/src/api/mod.rs
Size: 1433 bytes
===================
```rs
pub mod health;
pub mod identity;
pub mod governance;
pub mod resource;
pub mod federation;
pub mod federation_resource_sharing;
pub mod reputation;

use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;
use crate::services::{
    IdentityService,
    GovernanceService,
    ResourceService,
    FederationService,
    ReputationService,
    p2p::P2PManager
};
use crate::middleware::auth::with_auth;

pub fn routes(
    identity_service: Arc<Mutex<IdentityService>>,
    governance_service: Arc<Mutex<GovernanceService>>,
    resource_service: Arc<Mutex<ResourceService>>,
    federation_service: Arc<Mutex<FederationService>>,
    reputation_service: Arc<Mutex<ReputationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    // Routes that require auth
    let auth_routes = identity::identity_routes(identity_service.clone())
        .or(governance::governance_routes(governance_service, p2p_manager.clone(), identity_service.clone()))
        .or(resource::resource_routes(resource_service))
        .or(federation::federation_routes(federation_service.clone(), p2p_manager.clone()))
        .or(federation_resource_sharing::federation_resource_sharing_routes(federation_service, p2p_manager.clone()))
        .or(reputation::reputation_routes(p2p_manager));

    // Apply auth middleware
    auth_routes.and(with_auth(identity_service))
}```

===================
File: ./backend/src/lib.rs
Size: 327 bytes
===================
```rs
pub mod api;
pub mod core;
pub mod db;
pub mod middleware;

use thiserror::Error;

#[derive(Debug, Error)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    ConfigError(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
}

pub type Result<T> = std::result::Result<T, AppError>;
```

===================
File: ./backend/src/main.rs
Size: 2918 bytes
===================
```rs
use std::net::SocketAddr;
use warp::{Filter, Reply};
use log::{info, error};
use warp::ws::WebSocket;
use futures::{StreamExt, SinkExt};  // Combined StreamExt and added SinkExt

#[tokio::main]
async fn main() {
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("info"));
    info!("Starting ICN backend server...");

    // WebSocket handler
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .map(|ws: warp::ws::Ws| {
            ws.on_upgrade(handle_websocket_connection)
        });

    // Health check route
    let health_route = warp::path("api")
        .and(warp::path("v1"))
        .and(warp::path("health"))
        .and(warp::get())
        .map(|| {
            info!("Health check requested");
            warp::reply::json(&serde_json::json!({
                "status": "ok",
                "version": env!("CARGO_PKG_VERSION")
            }))
        });

    // Combine routes and add CORS
    let routes = health_route
        .or(ws_route)
        .with(warp::cors()
            .allow_any_origin()
            .allow_headers(vec!["content-type"])
            .allow_methods(vec!["GET", "POST", "PUT", "DELETE"])
        )
        .with(warp::log("icn_backend"));

    // Configure server address and start
    let addr = SocketAddr::from(([0, 0, 0, 0], 8081));
    info!("Server starting on http://{}", addr);
    
    warp::serve(routes)
        .run(addr)
        .await;
}

async fn handle_websocket_connection(ws: WebSocket) {
    let (mut ws_tx, mut ws_rx) = ws.split();
    
    // Handle incoming messages
    while let Some(result) = ws_rx.next().await {
        match result {
            Ok(msg) => {
                info!("Received message: {:?}", msg);
                // Echo the message back
                if let Err(e) = ws_tx.send(msg).await {
                    error!("Error sending ws message: {}", e);
                    break;
                }
            }
            Err(e) => {
                error!("Error receiving ws message: {}", e);
                break;
            }
        }
    }
}

fn with_db(pool: sqlx::PgPool) -> impl Filter<Extract = (sqlx::PgPool,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || pool.clone())
}

async fn health_handler(pool: sqlx::PgPool) -> Result<impl Reply, warp::Rejection> {
    // Test database connectivity
    let db_healthy = sqlx::query("SELECT 1")
        .fetch_one(&pool)
        .await
        .is_ok();

    let status = if db_healthy {
        warp::http::StatusCode::OK
    } else {
        warp::http::StatusCode::SERVICE_UNAVAILABLE
    };

    Ok(warp::reply::with_status(
        warp::reply::json(&serde_json::json!({
            "status": if db_healthy { "healthy" } else { "unhealthy" },
            "version": env!("CARGO_PKG_VERSION"),
            "database": db_healthy
        })),
        status
    ))
}
```

===================
File: ./backend/src/middleware/mod.rs
Size: 260 bytes
===================
```rs
use warp::Filter;

pub fn cors() -> warp::cors::Builder {
    warp::cors()
        .allow_any_origin()
        .allow_methods(vec!["GET", "POST", "PUT", "DELETE"])
        .allow_headers(vec!["content-type"])
}

pub mod auth;
pub mod cors;

pub use cors::cors;```

===================
File: ./backend/src/websocket/mod.rs
Size: 1654 bytes
===================
```rs
use redis::{Client as RedisClient, Commands};
use tokio::sync::broadcast;

pub struct DistributedWebSocketManager {
    redis: RedisClient,
    event_tx: broadcast::Sender<WebSocketEvent>,
}

impl DistributedWebSocketManager {
    pub fn new(redis_url: &str) -> Self {
        let (tx, _) = broadcast::channel(1000);
        Self {
            redis: RedisClient::open(redis_url).unwrap(),
            event_tx: tx,
        }
    }

    pub async fn broadcast_message(&self, message: WebSocketEvent) {
        // Local broadcast
        let _ = self.event_tx.send(message.clone());
        
        // Redis pub/sub broadcast
        let _ = self.redis.publish("ws_events", serde_json::to_string(&message).unwrap());
    }
}

pub struct WebSocketEvent {
    pub event_type: String,
    pub payload: String,
}

impl WebSocketEvent {
    pub fn new(event_type: &str, payload: &str) -> Self {
        Self {
            event_type: event_type.to_string(),
            payload: payload.to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::broadcast;

    #[tokio::test]
    async fn test_broadcast_message() {
        let manager = DistributedWebSocketManager::new("redis://127.0.0.1/");
        let (tx, mut rx) = broadcast::channel(1000);

        let event = WebSocketEvent::new("test_event", "test_payload");
        manager.broadcast_message(event.clone()).await;

        let received_event = rx.recv().await.unwrap();
        assert_eq!(received_event.event_type, event.event_type);
        assert_eq!(received_event.payload, event.payload);
    }
}
```

===================
File: ./contracts/cooperative/src/lib.rs
Size: 1284 bytes
===================
```rs
mod proposals;

use proposals::{ProposalContract, Proposal};
use icn_zkp::{RollupBatch, VerificationKey};
use ethers::prelude::*;

pub struct CooperativeContract {
    proposal_contract: ProposalContract,
    contract_address: Address,
    // ...existing code...
}

impl CooperativeContract {
    pub fn new(contract_address: Address, verification_key: VerificationKey) -> Self {
        Self {
            proposal_contract: ProposalContract::new(
                3,
                verification_key,
                contract_address
            ),
            contract_address,
            // ...existing code...
        }
    }

    pub async fn submit_vote_batch(&mut self, batch: RollupBatch) -> Result<(), String> {
        self.proposal_contract.submit_vote_batch(batch).await
    }

    pub async fn execute_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        self.proposal_contract.execute_proposal(proposal_id).await
    }

    pub async fn submit_zk_snark_proof(&self, proof: Vec<u8>) -> Result<(), String> {
        // Implement zk-SNARK proof submission logic
        Ok(())
    }

    pub async fn verify_zk_snark_proof(&self, proof: Vec<u8>) -> Result<bool, String> {
        // Implement zk-SNARK proof verification logic
        Ok(true)
    }
}
```

===================
File: ./crates/icn-cli/src/main.rs
Size: 9564 bytes
===================
```rs
mod client;

use clap::{App, Arg, SubCommand};
use std::error::Error;
use client::IcnClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let app = App::new("icn-cli")
        .version("0.1.0")
        .author("ICN Team")
        .about("Command Line Interface for the Inter-Cooperative Network")
        .arg(
            Arg::with_name("api-url")
                .long("api-url")
                .help("ICN API URL")
                .default_value("http://localhost:8081")
                .takes_value(true)
        )
        .subcommand(
            SubCommand::with_name("health")
                .about("Check the health of the ICN API")
        )
        .subcommand(
            SubCommand::with_name("identity")
                .about("Identity management commands")
                .subcommand(
                    SubCommand::with_name("create")
                        .about("Create a new DID identity")
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List existing DIDs")
                )
        )
        .subcommand(
            SubCommand::with_name("cooperative")
                .about("Cooperative management commands")
                .subcommand(
                    SubCommand::with_name("join")
                        .about("Join a cooperative")
                        .arg(
                            Arg::with_name("coop-id")
                                .help("ID of the cooperative to join")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List available cooperatives")
                )
        )
        .subcommand(
            SubCommand::with_name("resource")
                .about("Resource management commands")
                .subcommand(
                    SubCommand::with_name("register")
                        .about("Register a new resource")
                        .arg(
                            Arg::with_name("type")
                                .help("Type of resource (compute/storage/network)")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("capacity")
                                .help("Resource capacity")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("list")
                        .about("List available resources")
                )
        )
        .subcommand(
            SubCommand::with_name("governance")
                .about("Governance commands")
                .subcommand(
                    SubCommand::with_name("propose")
                        .about("Create a new proposal")
                        .arg(
                            Arg::with_name("title")
                                .help("Proposal title")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("description")
                                .help("Proposal description")
                                .required(true)
                        )
                )
                .subcommand(
                    SubCommand::with_name("vote")
                        .about("Vote on a proposal")
                        .arg(
                            Arg::with_name("proposal-id")
                                .help("ID of the proposal")
                                .required(true)
                        )
                        .arg(
                            Arg::with_name("vote")
                                .help("Vote (yes/no)")
                                .required(true)
                        )
                )
        );

    let matches = app.get_matches();
    let api_url = matches.value_of("api-url").unwrap().to_string();
    let client = IcnClient::new(api_url);

    match matches.subcommand() {
        ("health", Some(_)) => {
            match client.check_health().await {
                Ok(health) => {
                    println!("✅ ICN API is healthy");
                    println!("Status: {}", health.status);
                    println!("Version: {}", health.version);
                    println!("Uptime: {} seconds", health.uptime);
                }
                Err(e) => {
                    eprintln!("❌ ICN API health check failed: {}", e);
                    return Err(e);
                }
            }
        }
        ("identity", Some(identity_matches)) => {
            match identity_matches.subcommand() {
                ("create", Some(_)) => {
                    match client.create_identity().await {
                        Ok(identity) => println!("Created new DID: {}", identity.did),
                        Err(e) => eprintln!("Error creating identity: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_identities().await {
                        Ok(identities) => {
                            println!("Existing DIDs:");
                            for identity in identities {
                                println!("- {} (public key: {})", identity.did, identity.public_key);
                            }
                        }
                        Err(e) => eprintln!("Error listing identities: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("cooperative", Some(coop_matches)) => {
            match coop_matches.subcommand() {
                ("join", Some(join_matches)) => {
                    let coop_id = join_matches.value_of("coop-id").unwrap();
                    match client.join_cooperative(coop_id).await {
                        Ok(_) => println!("Successfully joined cooperative {}", coop_id),
                        Err(e) => eprintln!("Error joining cooperative: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_cooperatives().await {
                        Ok(cooperatives) => {
                            println!("Available cooperatives:");
                            for coop in cooperatives {
                                println!("- {} ({} members)", coop.name, coop.member_count);
                            }
                        }
                        Err(e) => eprintln!("Error listing cooperatives: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("resource", Some(resource_matches)) => {
            match resource_matches.subcommand() {
                ("register", Some(register_matches)) => {
                    let resource_type = register_matches.value_of("type").unwrap();
                    let capacity = register_matches.value_of("capacity").unwrap();
                    match client.register_resource(resource_type, capacity).await {
                        Ok(resource) => println!("Registered resource: {} (ID: {})", resource.resource_type, resource.id),
                        Err(e) => eprintln!("Error registering resource: {}", e),
                    }
                }
                ("list", Some(_)) => {
                    match client.list_resources().await {
                        Ok(resources) => {
                            println!("Available resources:");
                            for resource in resources {
                                println!("- {} ({} capacity, owned by {})", 
                                    resource.resource_type, 
                                    resource.capacity,
                                    resource.owner);
                            }
                        }
                        Err(e) => eprintln!("Error listing resources: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        ("governance", Some(governance_matches)) => {
            match governance_matches.subcommand() {
                ("propose", Some(propose_matches)) => {
                    let title = propose_matches.value_of("title").unwrap();
                    let description = propose_matches.value_of("description").unwrap();
                    match client.create_proposal(title, description).await {
                        Ok(proposal) => println!("Created proposal: {} (ID: {})", proposal.title, proposal.id),
                        Err(e) => eprintln!("Error creating proposal: {}", e),
                    }
                }
                ("vote", Some(vote_matches)) => {
                    let proposal_id = vote_matches.value_of("proposal-id").unwrap();
                    let vote = vote_matches.value_of("vote").unwrap().to_lowercase() == "yes";
                    match client.vote_proposal(proposal_id, vote).await {
                        Ok(_) => println!("Successfully voted on proposal {}", proposal_id),
                        Err(e) => eprintln!("Error voting on proposal: {}", e),
                    }
                }
                _ => unreachable!(),
            }
        }
        _ => {
            println!("No command specified. Use --help to see available commands.");
        }
    }

    Ok(())
}```

===================
File: ./crates/icn-common/src/lib.rs
Size: 1095 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Serialize, Deserialize};
use thiserror::Error;

#[async_trait]
pub trait ReputationManager: Send + Sync {
    fn get_reputation(&self, participant: &str, context: &str) -> i64;
    fn is_eligible(&self, participant: &str, threshold: i64, context: &str) -> bool;
    async fn update_reputation(&self, participant: &str, change: i64, context: &str);
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self);
    async fn stop(&self);
    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError>;
    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError>;
}
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 25246 bytes
===================
```rs
pub mod proof_of_cooperation;
pub mod validation;
pub mod round_management;
pub mod timeout_handling;
pub mod federation;
pub mod sharding; // Add sharding module
pub mod pbft; // Add PBFT module

use async_trait::async_trait;
use std::collections::{HashMap, VecDeque, HashSet}; // Added HashSet import
use std::time::Duration;
use tokio::time::sleep;
use tokio::task;
use icn_common::{ReputationManager, ConsensusEngine, Vote, VoteStatus, GovernanceError};
use icn_types::{Block, Transaction}; // Import Transaction
use std::sync::Arc;
use bit_set::BitSet;
use trie_rs::Trie;
use thiserror::Error;
use federation::{Federation, FederationError};
use serde::{Serialize, Deserialize};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use log::error;

// Interface for identity services
#[async_trait]
pub trait IdentityService: Send + Sync {
    async fn get_public_key(&self, did: &str) -> Option<Vec<u8>>;
    async fn verify_identity(&self, did: &str, proof: &str) -> bool;
}

#[derive(Error, Debug)]
pub enum ConsensusError {
    #[error("Failed to reach consensus: {0}")]
    ConsensusFailure(String),
    #[error("Block validation failed: {0}")]
    ValidationFailure(String),
    #[error("Timeout occurred: {0}")]
    TimeoutError(String),
    #[error("BFT error: {0}")]
    BftError(String),
}

pub struct ProofOfCooperation {
    current_round: u64,
    participants: VecDeque<String>,
    proposed_block: Option<Block>,
    votes: BitSet,
    vote_trie: Trie,
    timeout: Duration,
    timeout_handling: timeout_handling::TimeoutHandling,
    reputation_manager: Arc<dyn ReputationManager>,
    federation_operations: HashMap<String, FederationOperation>,
    federations: HashMap<String, Federation>,
    round_start_time: std::time::Instant,
    shard_manager: sharding::ShardManager, // Add shard manager field
    pbft_consensus: Option<pbft::PbftConsensus>, // Add PBFT consensus field
    identity_did: String, // Add the identity DID of the current node
    identity_service: Arc<dyn IdentityService>, // Add identity service
    active_proposals: HashMap<String, Proposal>, // Add active proposals
    rules: ConsensusRules,
}

// Define proposal structure
#[derive(Clone, Debug)]
pub struct Proposal {
    pub proposal_id: String,
    pub proposal_type: ProposalType,
    pub votes: HashSet<Vote>,
    pub status: ProposalStatus,
    pub created_at: std::time::SystemTime,
}

// Define proposal types
#[derive(Clone, Debug)]
pub enum ProposalType {
    AddValidator(ValidatorInfo),
    RemoveValidator(String), // DID
    UpdateRules(ConsensusRules),
}

// Define validator info
#[derive(Clone, Debug)]
pub struct ValidatorInfo {
    pub did: String,
    pub reputation: i64,
    pub voting_power: u32,
}

// Define consensus rules
#[derive(Clone, Debug)]
pub struct ConsensusRules {
    pub min_reputation: i64,
    pub quorum_percentage: u8,
    pub block_time: Duration,
}

// Define proposal status
#[derive(Clone, Debug, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Approved,
    Rejected,
    Expired,
}

impl ProofOfCooperation {
    pub fn new(
        reputation_manager: Arc<dyn ReputationManager>,
        identity_service: Arc<dyn IdentityService>,
        identity_did: String
    ) -> Self {
        let shard_config = sharding::ShardConfig {
            shard_count: 4,  // Start with 4 shards
            shard_capacity: 1000, // Each shard can hold 1000 transactions
            rebalance_threshold: 0.3, // Rebalance when load differs by 30%
        };
        
        ProofOfCooperation {
            current_round: 0,
            participants: VecDeque::new(),
            proposed_block: None,
            votes: BitSet::new(),
            vote_trie: Trie::new(),
            timeout: Duration::from_secs(60),
            timeout_handling: timeout_handling::TimeoutHandling::new(Duration::from_secs(60)),
            reputation_manager,
            federation_operations: HashMap::new(),
            federations: HashMap::new(),
            round_start_time: std::time::Instant::now(),
            shard_manager: sharding::ShardManager::new(shard_config),
            pbft_consensus: None,
            identity_did,
            identity_service,
            active_proposals: HashMap::new(),
            rules: ConsensusRules {
                min_reputation: 50,
                quorum_percentage: 67, // 2/3 majority
                block_time: Duration::from_secs(30),
            },
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.vote_trie = Trie::new();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            let index = self.participants.iter().position(|p| p == &participant).unwrap_or_else(|| {
                self.participants.push_back(participant.clone());
                self.participants.len() - 1
            });
            if vote {
                self.votes.insert(index);
            }
            self.vote_trie.insert(&participant);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Get validator list for this round
        let validators = self.select_validators(50).await
            .map_err(|e| ConsensusError::ConsensusFailure(e.to_string()))?;
            
        // Ensure we have enough validators for BFT
        let f = validators.len() / 4; // Maximum allowed Byzantine nodes
        let min_validators = 3 * f + 1; // Minimum required for BFT
        
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }
        
        if self.pbft_consensus.is_none() {
            self.pbft_consensus = Some(pbft::PbftConsensus::new(validators.clone()));
        }
        
        let pbft = self.pbft_consensus.as_mut().unwrap();
        
        if let Some(block) = &self.proposed_block {
            // Primary validator broadcasts pre-prepare message
            if pbft.is_primary(&self.identity_did) {
                let pre_prepare = pbft::ConsensusMessage {
                    message_type: pbft::MessageType::PrePrepare,
                    view_number: pbft.view_number,
                    sequence_number: pbft.sequence_number,
                    block_hash: block.hash.clone(),
                    sender: self.identity_did.clone(),
                    signature: "signature".to_string(), // This should be a proper signature
                };
                
                // Distribute to all validators
                self.broadcast_consensus_message(pre_prepare).await?;
            }
            
            // Wait for consensus to be reached
            let timeout = Duration::from_secs(30);
            let start = std::time::Instant::now();
            
            while start.elapsed() < timeout {
                if pbft.is_committed(&block.hash) {
                    // Consensus reached, update block metadata
                    let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                    let mut final_block = block.clone();
                    final_block.metadata.consensus_duration_ms = consensus_duration;
                    
                    // Clear round state
                    self.start_round();
                    
                    return Ok(Some(final_block));
                }
                
                tokio::time::sleep(Duration::from_millis(100)).await;
            }
            
            // Timeout occurred
            Err(ConsensusError::TimeoutError("PBFT consensus timed out".into()))
        } else {
            Err(ConsensusError::ConsensusFailure("No proposed block".into()))
        }
    }

    pub async fn handle_timeout(&self) {
        if let Err(e) = self.timeout_handling.handle_timeout().await {
            eprintln!("Error handling timeout: {}", e);
        }
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus")
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), Box<dyn std::error::Error>> {
        let chunks: Vec<_> = self.participants.chunks(self.participants.len() / 4).collect();
        let mut handles = vec![];

        for chunk in chunks {
            let chunk = chunk.to_vec();
            let reputation_manager = self.reputation_manager.clone();
            let votes = self.votes.clone();
            let handle = task::spawn(async move {
                let mut total_reputation = 0i64;
                let mut approval_reputation = 0i64;
                
                for (i, p) in chunk.iter().enumerate() {
                    let rep = reputation_manager.get_reputation(p, "consensus");
                    total_reputation += rep;
                    if votes.contains(i) {
                        approval_reputation += rep;
                    }
                }
                
                Ok((total_reputation, approval_reputation))
            });
            handles.push(handle);
        }

        let mut total_reputation = 0;
        let mut approval_reputation = 0;

        for handle in handles {
            let (chunk_total, chunk_approval) = handle.await??;
            total_reputation += chunk_total;
            approval_reputation += chunk_approval;
        }

        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, ConsensusError> {
        let mut validators = Vec::new();
        let participants: Vec<_> = self.participants.iter().cloned().collect();

        for participant in participants {
            if self.reputation_manager.is_eligible(&participant, min_reputation, "consensus") {
                validators.push(participant);
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.max_faulty_nodes() * 3) + 1;
        if validators.len() < min_validators {
            return Err(ConsensusError::BftError(
                format!("Insufficient validators: {} (need {})", validators.len(), min_validators)
            ));
        }

        Ok(validators)
    }

    fn max_faulty_nodes(&self) -> usize {
        self.participants.len() / 3
    }

    pub async fn handle_consensus_round(&mut self) -> Result<Option<Block>, ConsensusError> {
        // Start timeout handler
        let timeout_handler = self.timeout_handling.start_timeout();
        
        tokio::select! {
            result = self.finalize_block() => {
                result
            }
            _ = timeout_handler => {
                self.handle_timeout().await;
                Err(ConsensusError::TimeoutError("Consensus round timed out".into()))
            }
        }
    }

    pub fn handle_federation_operation(&mut self, operation: FederationOperation) {
        match operation {
            FederationOperation::InitiateFederation { federation_type, partner_id, terms } => {
                self.create_federation(partner_id, federation_type, terms).unwrap();
            }
            FederationOperation::JoinFederation { federation_id, commitment } => {
                // Handle joining federation logic
            }
            FederationOperation::LeaveFederation { federation_id, reason } => {
                // Handle leaving federation logic
            }
            FederationOperation::ProposeAction { federation_id, action_type, description, resources } => {
                // Handle proposing action logic
            }
            FederationOperation::VoteOnProposal { federation_id, proposal_id, approve, notes } => {
                // Handle voting on proposal logic
            }
            FederationOperation::ShareResources { federation_id, resource_type, amount, recipient_id } => {
                // Handle sharing resources logic
            }
            FederationOperation::UpdateFederationTerms { federation_id, new_terms } => {
                // Handle updating federation terms logic
            }
        }
    }

    pub fn create_federation(
        &mut self,
        creator_id: String,
        federation_type: FederationType,
        terms: FederationTerms,
    ) -> Result<String, ConsensusError> {
        // Verify creator's reputation
        let creator_reputation = self.reputation_manager.get_reputation(&creator_id, "consensus");
        if creator_reputation < terms.minimum_reputation {
            return Err(ConsensusError::ConsensusFailure(
                "Insufficient reputation to create federation".into(),
            ));
        }

        // Generate unique federation ID
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());

        // Create new federation
        let federation = Federation::new(
            federation_id.clone(),
            federation_type,
            terms,
            creator_id,
        );

        // Store federation
        self.federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn adjust_validator_set(&mut self) -> Result<(), ConsensusError> {
        // Get current validator counts for BFT calculation
        let current_size = self.participants.len();
        let min_validators = (current_size / 3) * 3 + 1; // 3f + 1 where f is max faulty

        // Remove validators that fell below minimum reputation
        let mut to_remove = Vec::new();
        for participant in self.participants.iter() {
            if !self.reputation_manager.is_eligible(participant, 50, "consensus") {
                to_remove.push(participant.clone());
            }
        }

        // Remove disqualified validators if we maintain BFT requirements
        if (current_size - to_remove.len()) >= min_validators {
            for participant in to_remove {
                if let Some(pos) = self.participants.iter().position(|x| x == &participant) {
                    self.participants.remove(pos);
                }
            }
        }

        // Add new validators that meet higher reputation threshold
        let new_validators = self.select_validators(80).await?;
        
        // Add new validators while maintaining max size limit
        let max_validators = 100; // Example maximum validator set size
        for validator in new_validators {
            if self.participants.len() >= max_validators {
                break;
            }
            if !self.participants.contains(&validator) {
                self.participants.push_back(validator);
            }
        }

        Ok(())
    }

    pub async fn start_validator_rotation(&mut self) {
        tokio::spawn(async move {
            let rotation_interval = Duration::from_secs(3600); // 1 hour
            loop {
                sleep(rotation_interval).await;
                if let Err(e) = self.adjust_validator_set().await {
                    error!("Failed to adjust validator set: {}", e);
                }
            }
        });
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub fn apply_anti_monopoly_reputation_decay(&self, reputation: i64, dominance: f64, total: f64, alpha: f64) -> i64 {
        (reputation as f64 * (1.0 - dominance / total).powf(alpha)) as i64
    }

    pub fn quadratic_vote_weight(&self, reputation_points: i64) -> f64 {
        (reputation_points as f64).sqrt()
    }

    pub fn randomized_delegation(&self, participants: Vec<String>, num_delegates: usize) -> Vec<String> {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        let mut delegates = participants.clone();
        delegates.shuffle(&mut rng);
        delegates.truncate(num_delegates);
        delegates
    }

    pub fn dynamic_contribution_valuation(&self, value: i64, repeated: i64, lambda: f64) -> i64 {
        (value as f64 * (-lambda * repeated as f64).exp()) as i64
    }

    pub async fn add_signature(&self, did: &str, signature: &str, message: &str) -> Result<(), ConsensusError> {
        // Retrieve public key from IdentityService
        if let Some(public_key) = self.identity_service.get_public_key(did).await {
            let key_pair = KeyPair {
                public_key,
                private_key: vec![], // Not needed for verification
                algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
            };
            if key_pair.verify(message.as_bytes(), signature.as_bytes()) {
                Ok(())
            } else {
                Err(ConsensusError::ValidationFailure("Invalid signature".to_string()))
            }
        } else {
            Err(ConsensusError::ValidationFailure("Public key not found".to_string()))
        }
    }

    // Add a method to handle transaction sharding
    pub fn add_transaction(&mut self, transaction: Transaction) -> Result<u32, ConsensusError> {
        // Assign transaction to a shard
        let shard_id = self.shard_manager.assign_transaction(transaction);
        
        // Check if shard is ready for finalization
        let shard = self.shard_manager.shards.get(&shard_id).unwrap();
        if shard.len() >= self.shard_manager.config.shard_capacity as usize {
            if let Some(block) = self.shard_manager.finalize_shard(shard_id) {
                self.propose_block(block);
            }
        }
        
        // Periodically rebalance shards
        if self.current_round % 10 == 0 {  // Every 10 rounds
            self.shard_manager.rebalance();
        }
        
        Ok(shard_id)
    }

    async fn broadcast_consensus_message(&self, message: pbft::ConsensusMessage) -> Result<(), ConsensusError> {
        // Implementation to broadcast message to all validators
        // This would use your networking layer to distribute the message
        // ...
        Ok(())
    }

    // Check if a participant is eligible to vote
    pub fn is_eligible_voter(&self, voter_did: &str) -> bool {
        // Check if they have enough reputation
        let reputation = self.reputation_manager.get_reputation(voter_did, "governance");
        if reputation < self.rules.min_reputation {
            return false;
        }
        
        // Check if they're a validator
        self.participants.iter().any(|p| p == voter_did)
    }
    
    // Add a validator to the consensus system
    pub fn add_validator(&mut self, info: ValidatorInfo) -> Result<(), GovernanceError> {
        // Verify validator meets minimum reputation requirements
        if info.reputation < self.rules.min_reputation {
            return Err(GovernanceError::NotEligibleToVote);
        }
        
        // Add to participant list if not already present
        if !self.participants.contains(&info.did) {
            self.participants.push_back(info.did);
        }
        
        Ok(())
    }
    
    // Remove a validator from the consensus system
    pub fn remove_validator(&mut self, did: &str) -> Result<(), GovernanceError> {
        // Find and remove from participant list
        if let Some(index) = self.participants.iter().position(|p| p == did) {
            self.participants.remove(index);
            Ok(())
        } else {
            Err(GovernanceError::ProposalNotFound)
        }
    }
    
    // Check proposal status and update if necessary
    pub fn check_proposal_status(&mut self, proposal_id: &str) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
            
        // Count votes
        let mut approve_votes = 0;
        let mut reject_votes = 0;
        
        for vote in &proposal.votes {
            if vote.approve {
                approve_votes += 1;
            } else {
                reject_votes += 1;
            }
        }
        
        // Check if we have enough votes for a decision
        let total_participants = self.participants.len();
        let quorum_threshold = (total_participants * self.rules.quorum_percentage as usize) / 100;
        
        if approve_votes + reject_votes < quorum_threshold {
            // Not enough votes yet
            proposal.status = ProposalStatus::Pending;
            return Ok(VoteStatus::Pending);
        }
        
        // We have enough votes to make a decision
        if approve_votes > reject_votes {
            proposal.status = ProposalStatus::Approved;
            Ok(VoteStatus::Accepted)
        } else {
            proposal.status = ProposalStatus::Rejected;
            Ok(VoteStatus::Rejected)
        }
    }
    
    // Submit a new proposal
    pub fn submit_proposal(&mut self, proposal_type: ProposalType, submitter: String) -> Result<String, GovernanceError> {
        // Check if submitter is eligible
        if !self.is_eligible_voter(&submitter) {
            return Err(GovernanceError::NotEligibleToVote);
        }
        
        // Generate proposal ID
        let proposal_id = format!("prop_{}", uuid::Uuid::new_v4());
        
        // Create new proposal
        let proposal = Proposal {
            proposal_id: proposal_id.clone(),
            proposal_type,
            votes: HashSet::new(),
            status: ProposalStatus::Pending,
            created_at: std::time::SystemTime::now(),
        };
        
        // Store proposal
        self.active_proposals.insert(proposal_id.clone(), proposal);
        
        Ok(proposal_id)
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) {
        // Start the consensus process
        // In a real implementation, this would initiate validator rounds
        // and transaction processing
        log::info!("Starting Proof of Cooperation consensus engine");
    }

    async fn stop(&self) {
        // Stop the consensus process
        log::info!("Stopping Proof of Cooperation consensus engine");
    }

    async fn submit_vote(&mut self, vote: Vote) -> Result<VoteStatus, GovernanceError> {
        let proposal = self.active_proposals.get_mut(&vote.proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;
        
        if !self.is_eligible_voter(&vote.voter) {
            return Err(GovernanceError::NotEligibleToVote);
        }

        proposal.votes.insert(vote);
        self.check_proposal_status(&proposal.proposal_id)
    }

    async fn process_approved_proposal(&mut self, proposal_id: &str) -> Result<(), GovernanceError> {
        let proposal = self.active_proposals.remove(proposal_id)
            .ok_or(GovernanceError::ProposalNotFound)?;

        match proposal.proposal_type {
            ProposalType::AddValidator(info) => self.add_validator(info),
            ProposalType::RemoveValidator(did) => self.remove_validator(&did),
            ProposalType::UpdateRules(rules) => {
                self.rules = rules;
                Ok(())
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: std::collections::HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

#[derive(Serialize, Deserialize)]
struct FederationTerms {
    minimum_reputation: i64,
    resource_sharing_policies: String,
    governance_rules: String,
    duration: String,
}

#[derive(Serialize, Deserialize)]
enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: String,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum VoteStatus {
    Accepted,
    Rejected,
    Pending,
}

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Not eligible to vote")]
    NotEligibleToVote,
}
```

===================
File: ./crates/icn-core/src/blockchain/mod.rs
Size: 2537 bytes
===================
```rs
use crate::zk_snarks::ZkProof;
use icn_types::{Block, Transaction, BlockError, RuntimeInterface};
use crate::StorageInterface;
use tokio::sync::RwLock;
use std::sync::Arc;

pub struct Blockchain {
    storage: Box<dyn StorageInterface>,
    runtime: Box<dyn RuntimeInterface>,
    chain: Arc<RwLock<Vec<Block>>>,
    pending_transactions: Arc<RwLock<Vec<Transaction>>>,
}

impl Blockchain {
    pub fn new(storage: Box<dyn StorageInterface>, runtime: Box<dyn RuntimeInterface>) -> Self {
        Self {
            storage,
            runtime,
            chain: Arc::new(RwLock::new(Vec::new())),
            pending_transactions: Arc::new(RwLock::new(Vec::new())),
        }
    }

    pub async fn add_block(&self, block: Block) -> Result<(), BlockError> {
        let mut chain = self.chain.write().await;
        if let Some(previous_block) = chain.last() {
            block.verify(Some(previous_block)).await?;
        }
        chain.push(block);
        Ok(())
    }

    pub async fn add_transaction(&self, transaction: Transaction) -> Result<(), String> {
        if let Some(proof) = &transaction.zk_snark_proof {
            let inputs = transaction.get_zk_snark_inputs();
            let public_inputs = vec![inputs]; // Wrap in Vec<Vec<u8>> as required
            
            // Convert String to Vec<u8> for proof_data
            let proof_data = proof.as_bytes().to_vec();
            
            let zk_proof = ZkProof {
                proof_data,
                public_inputs: public_inputs.clone(), // Clone to avoid moving
            };
            
            // Handle the error conversion explicitly
            match crate::zk_snarks::verify_proof(&zk_proof, &public_inputs) {
                Ok(valid) => {
                    if !valid {
                        return Err("Invalid zk-SNARK proof".to_string());
                    }
                },
                Err(e) => {
                    return Err(format!("ZK proof verification error: {}", e));
                }
            }
        }
        
        let mut pending = self.pending_transactions.write().await;
        pending.push(transaction);
        Ok(())
    }

    pub async fn get_pending_transactions(&self) -> Vec<Transaction> {
        self.pending_transactions.read().await.clone()
    }

    pub async fn clear_pending_transactions(&self) {
        self.pending_transactions.write().await.clear();
    }

    pub async fn get_latest_block(&self) -> Option<Block> {
        self.chain.read().await.last().cloned()
    }
}
```

===================
File: ./crates/icn-core/src/core/mod.rs
Size: 2110 bytes
===================
```rs
use std::sync::Arc;
use log::info;
use crate::{
    storage::StorageInterface,
    identity::IdentityInterface,
    networking::NetworkInterface,
    reputation::ReputationInterface,
    telemetry::TelemetryManager,
    models::{ResourceAllocationSystem, FederationManager}
};
use icn_types::{Transaction, RuntimeInterface};
use crate::telemetry::{PrometheusMetrics, Logger, TracingSystem};

pub struct Core {
    storage: Arc<dyn StorageInterface>,
    network: Arc<dyn NetworkInterface>,
    identity: Arc<dyn IdentityInterface>,
    reputation: Arc<dyn ReputationInterface>,
    runtime: Arc<dyn RuntimeInterface>,
    telemetry: Arc<TelemetryManager>,
    federation_manager: Arc<FederationManager>,
    resource_system: Arc<ResourceAllocationSystem>,
}

impl Core {
    pub fn new(
        storage: Arc<dyn StorageInterface>,
        network: Arc<dyn NetworkInterface>,
        identity: Arc<dyn IdentityInterface>,
        reputation: Arc<dyn ReputationInterface>,
        runtime: Arc<dyn RuntimeInterface>,
    ) -> Self {
        let resource_system = Arc::new(ResourceAllocationSystem::new());
        let federation_manager = Arc::new(FederationManager::new(resource_system.clone()));
        let telemetry = Arc::new(TelemetryManager::new(
            PrometheusMetrics::new(),
            Logger::new(),
            TracingSystem::new()
        ));

        Core {
            storage,
            network,
            identity,
            reputation,
            runtime,
            telemetry,
            federation_manager,
            resource_system,
        }
    }

    pub async fn start(&self) -> Result<(), String> {
        info!("Starting Core system...");
        Ok(())
    }

    pub async fn stop(&self) -> Result<(), String> {
        info!("Stopping Core system...");
        Ok(())
    }

    pub async fn process_transaction(&self, transaction: Transaction) -> Result<(), String> {
        info!("Processing transaction...");
        Ok(())
    }

    pub async fn start_consensus(&self) -> Result<(), String> {
        info!("Starting consensus...");
        Ok(())
    }
}
```

===================
File: ./crates/icn-core/src/db/mod.rs
Size: 1637 bytes
===================
```rs
use async_trait::async_trait;
use icn_types::{StorageError, StorageResult};
use std::collections::HashMap;
use tokio::sync::RwLock;

pub struct Database {
    data: RwLock<HashMap<String, Vec<u8>>>,
}

impl Database {
    pub fn new() -> Self {
        Self {
            data: RwLock::new(HashMap::new()),
        }
    }

    pub async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        self.data.read().await
            .get(key)
            .cloned()
            .ok_or_else(|| StorageError::NotFound(key.to_string()))
    }

    pub async fn put(&self, key: String, value: Vec<u8>) -> StorageResult<()> {
        self.data.write().await.insert(key, value);
        Ok(())
    }

    pub async fn delete(&self, key: &str) -> StorageResult<()> {
        self.data.write().await.remove(key);
        Ok(())
    }
}

#[async_trait]
pub trait DatabaseBackend: Send + Sync {
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    async fn put(&self, key: String, value: Vec<u8>) -> StorageResult<()>;
    async fn delete(&self, key: &str) -> StorageResult<()>;
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

#[async_trait]
impl DatabaseBackend for Database {
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        self.get(key).await
    }

    async fn put(&self, key: String, value: Vec<u8>) -> StorageResult<()> {
        self.put(key, value).await
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        self.delete(key).await
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        Ok(self.data.read().await.contains_key(key))
    }
}
```

===================
File: ./crates/icn-core/src/identity/mod.rs
Size: 1438 bytes
===================
```rs
use std::collections::HashMap;
use tokio::sync::RwLock;
use icn_types::{MemberId, CooperativeId};
use async_trait::async_trait;

pub struct IdentityManager {
    members: RwLock<HashMap<String, MemberId>>,
    cooperatives: RwLock<HashMap<String, CooperativeId>>,
}

#[async_trait]
pub trait IdentityInterface: Send + Sync {
    async fn register_member(&self, did: String, cooperative_id: CooperativeId) -> Result<MemberId, String>;
    async fn verify_member(&self, did: &str) -> bool;
    async fn start(&self) -> Result<(), String>;
    async fn stop(&self) -> Result<(), String>;
}

#[async_trait]
impl IdentityInterface for IdentityManager {
    async fn register_member(&self, did: String, cooperative_id: CooperativeId) -> Result<MemberId, String> {
        let member_id = MemberId {
            did: did.clone(),
            cooperative_id: cooperative_id.clone(),
        };
        
        self.members.write().await.insert(did, member_id.clone());
        Ok(member_id)
    }

    async fn verify_member(&self, did: &str) -> bool {
        self.members.read().await.contains_key(did)
    }

    async fn start(&self) -> Result<(), String> {
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        Ok(())
    }
}

impl IdentityManager {
    pub fn new() -> Self {
        Self {
            members: RwLock::new(HashMap::new()),
            cooperatives: RwLock::new(HashMap::new()),
        }
    }
}
```

===================
File: ./crates/icn-core/src/lib.rs
Size: 609 bytes
===================
```rs
// Module declarations
pub mod blockchain;
pub mod core;
pub mod db;
pub mod identity;
pub mod reputation;
pub mod storage;
pub mod vm;
pub mod networking;
pub mod models;
pub mod telemetry;
pub mod verifiable_credentials;
pub mod zk_snarks;

// Re-export main interfaces
pub use self::{
    storage::StorageInterface,
    networking::NetworkInterface,
    identity::IdentityInterface,
    reputation::ReputationInterface,
    telemetry::TelemetryManager,
    models::{ResourceAllocationSystem, FederationManager},
    vm::runtime::RuntimeManager,
};
pub use icn_types::RuntimeInterface;

pub mod governance;
```

===================
File: ./crates/icn-core/src/models/mod.rs
Size: 1828 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub resource_type: String,
    pub amount: u64,
    pub recipient: String,
    pub priority: u8,
    pub constraints: HashMap<String, String>,
}

#[derive(Debug)]
pub struct ResourceAllocationSystem {
    allocations: HashMap<String, ResourceAllocation>,
}

impl ResourceAllocationSystem {
    pub fn new() -> Self {
        Self {
            allocations: HashMap::new(),
        }
    }

    pub async fn allocate(&self, resource_type: &str, recipient: String, amount: u64) 
        -> Result<String, Box<dyn std::error::Error>> 
    {
        let allocation_id = format!("alloc_{}_{}", recipient, resource_type);
        // Implementation details...
        Ok(allocation_id)
    }
}

#[derive(Debug)]
pub struct FederationManager {
    resource_system: std::sync::Arc<ResourceAllocationSystem>,
}

impl FederationManager {
    pub fn new(resource_system: std::sync::Arc<ResourceAllocationSystem>) -> Self {
        Self {
            resource_system,
        }
    }

    pub async fn start(&self) -> Result<(), String> {
        Ok(())
    }

    pub async fn stop(&self) -> Result<(), String> {
        Ok(())
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: icn_types::FederationType,
        terms: icn_types::FederationTerms,
        partner_id: String,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Implementation details...
        Ok(())
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // Implementation details...
        Ok(())
    }
}
```

===================
File: ./crates/icn-core/src/networking/mod.rs
Size: 1427 bytes
===================
```rs
use tokio::sync::broadcast;
use icn_types::{Block, Transaction};
use async_trait::async_trait;

#[async_trait]
pub trait NetworkInterface: Send + Sync {
    async fn start(&self) -> Result<(), String>;
    async fn stop(&self) -> Result<(), String>;
    async fn broadcast_block(&self, block: Block) -> Result<(), String>;
    async fn broadcast_transaction(&self, transaction: Transaction) -> Result<(), String>;
}

pub struct NetworkManager {
    block_tx: broadcast::Sender<Block>,
    transaction_tx: broadcast::Sender<Transaction>,
}

impl NetworkManager {
    pub fn new() -> Self {
        let (block_tx, _) = broadcast::channel(100);
        let (transaction_tx, _) = broadcast::channel(100);
        Self {
            block_tx,
            transaction_tx,
        }
    }
}

#[async_trait]
impl NetworkInterface for NetworkManager {
    async fn start(&self) -> Result<(), String> {
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        Ok(())
    }

    async fn broadcast_block(&self, block: Block) -> Result<(), String> {
        self.block_tx.send(block)
            .map_err(|e| format!("Failed to broadcast block: {}", e))?;
        Ok(())
    }

    async fn broadcast_transaction(&self, transaction: Transaction) -> Result<(), String> {
        self.transaction_tx.send(transaction)
            .map_err(|e| format!("Failed to broadcast transaction: {}", e))?;
        Ok(())
    }
}
```

===================
File: ./crates/icn-core/src/reputation/mod.rs
Size: 3193 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::RwLock;
use icn_types::{MemberId, ReputationScore};
use chrono::{Utc};
use async_trait::async_trait;

// Define a local error type to avoid conflicts with icn_types
#[derive(Debug, Clone)]
pub enum LocalReputationError {
    NotFound(String),
    InvalidUpdate(String),
    LockError,
}

impl std::fmt::Display for LocalReputationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LocalReputationError::NotFound(msg) => write!(f, "Not found: {}", msg),
            LocalReputationError::InvalidUpdate(msg) => write!(f, "Invalid update: {}", msg),
            LocalReputationError::LockError => write!(f, "Lock error"),
        }
    }
}

impl std::error::Error for LocalReputationError {}

// Create extension methods through a new struct
pub struct ReputationScoreExt;

impl ReputationScoreExt {
    pub fn default_score(member_id: MemberId) -> ReputationScore {
        ReputationScore {
            member_id,
            score: 0.0,
            last_updated: Utc::now(),
        }
    }
}

#[async_trait]
pub trait ReputationInterface: Send + Sync {
    async fn get_reputation(&self, did: MemberId) -> Result<ReputationScore, LocalReputationError>;
    async fn add_contribution(&self, did: MemberId, contribution: ReputationScore) -> Result<(), LocalReputationError>;
    async fn apply_decay(&self, decay_rate: f64) -> Result<(), LocalReputationError>;
}

pub struct ReputationSystem {
    scores: RwLock<HashMap<MemberId, ReputationScore>>,
}

impl ReputationSystem {
    pub fn new() -> Self {
        Self {
            scores: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl ReputationInterface for ReputationSystem {
    async fn get_reputation(&self, did: MemberId) -> Result<ReputationScore, LocalReputationError> {
        let scores = self.scores.read().map_err(|_| LocalReputationError::LockError)?;
        Ok(scores.get(&did).cloned().unwrap_or_else(|| 
            ReputationScoreExt::default_score(did)
        ))
    }

    async fn add_contribution(&self, did: MemberId, contribution: ReputationScore) -> Result<(), LocalReputationError> {
        let mut scores = self.scores.write().map_err(|_| LocalReputationError::LockError)?;
        let score = scores.entry(did.clone()).or_insert_with(|| 
            ReputationScoreExt::default_score(did)
        );
        
        let member_id = score.member_id.clone(); // Clone before the update
        *score = ReputationScore {
            member_id,
            score: score.score + contribution.score,
            last_updated: Utc::now(),
        };
        Ok(())
    }

    async fn apply_decay(&self, decay_rate: f64) -> Result<(), LocalReputationError> {
        let mut scores = self.scores.write().map_err(|_| LocalReputationError::LockError)?;
        for score in scores.values_mut() {
            let member_id = score.member_id.clone(); // Clone before the update
            *score = ReputationScore {
                member_id,
                score: score.score * (1.0 - decay_rate),
                last_updated: Utc::now(),
            };
        }
        Ok(())
    }
}
```

===================
File: ./crates/icn-core/src/storage/mod.rs
Size: 2953 bytes
===================
```rs
use async_trait::async_trait;
use icn_types::{Block, Transaction, StorageError};
use std::collections::HashMap;
use std::sync::RwLock;

#[async_trait]
pub trait StorageInterface: Send + Sync {
    async fn store_block(&self, block: &Block) -> Result<(), StorageError>;
    async fn get_block(&self, block_id: &str) -> Result<Block, StorageError>;
    async fn store_transaction(&self, transaction: &Transaction) -> Result<(), StorageError>;
    async fn get_transaction(&self, transaction_id: &str) -> Result<Transaction, StorageError>;
}

// Helper function instead of implementing on StorageError directly
fn create_db_error(msg: impl Into<String>) -> StorageError {
    StorageError::DatabaseError(msg.into())
}

pub struct MemoryStorage {
    blocks: RwLock<HashMap<String, Block>>,
    transactions: RwLock<HashMap<String, Transaction>>,
}

impl MemoryStorage {
    pub fn new() -> Self {
        Self {
            blocks: RwLock::new(HashMap::new()),
            transactions: RwLock::new(HashMap::new()),
        }
    }
}

#[async_trait]
impl StorageInterface for MemoryStorage {
    async fn store_block(&self, block: &Block) -> Result<(), StorageError> {
        let mut blocks = self.blocks.write().map_err(|_| create_db_error("Lock error"))?;
        blocks.insert(block.hash.clone(), block.clone());
        Ok(())
    }

    async fn get_block(&self, block_id: &str) -> Result<Block, StorageError> {
        let blocks = self.blocks.read().map_err(|_| create_db_error("Lock error"))?;
        blocks.get(block_id)
            .cloned()
            .ok_or_else(|| StorageError::NotFound("Block not found".into()))
    }

    async fn store_transaction(&self, transaction: &Transaction) -> Result<(), StorageError> {
        let mut transactions = self.transactions.write().map_err(|_| create_db_error("Lock error"))?;
        transactions.insert(transaction.id.clone(), transaction.clone());
        Ok(())
    }

    async fn get_transaction(&self, transaction_id: &str) -> Result<Transaction, StorageError> {
        let transactions = self.transactions.read().map_err(|_| create_db_error("Lock error"))?;
        transactions.get(transaction_id)
            .cloned()
            .ok_or_else(|| StorageError::NotFound("Transaction not found".into()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_memory_storage() {
        let storage = MemoryStorage::new();
        
        let block = Block::default(); // Assuming Block has Default implementation
        storage.store_block(&block).await.unwrap();
        let retrieved = storage.get_block(&block.hash).await.unwrap();
        assert_eq!(block.hash, retrieved.hash);

        let tx = Transaction::default(); // Assuming Transaction has Default implementation
        storage.store_transaction(&tx).await.unwrap();
        let retrieved = storage.get_transaction(&tx.id).await.unwrap();
        assert_eq!(tx.id, retrieved.id);
    }
}
```

===================
File: ./crates/icn-core/src/telemetry/mod.rs
Size: 1100 bytes
===================
```rs
pub struct TelemetryManager {
    metrics: PrometheusMetrics,
    logger: Logger,
    traces: TracingSystem,
}

impl TelemetryManager {
    pub fn new(metrics: PrometheusMetrics, logger: Logger, traces: TracingSystem) -> Self {
        Self {
            metrics,
            logger,
            traces,
        }
    }

    pub fn log(&self, message: &str) {
        self.logger.log(message);
        self.traces.trace(message);
    }

    pub fn record_metric(&self, name: &str, value: f64) {
        self.metrics.record(name, value);
    }
}

pub struct PrometheusMetrics;

impl PrometheusMetrics {
    pub fn new() -> Self {
        Self
    }

    pub fn record(&self, _name: &str, _value: f64) {
        // TODO: Implement metric recording
    }
}

pub struct Logger;

impl Logger {
    pub fn new() -> Self {
        Self
    }

    pub fn log(&self, _message: &str) {
        // TODO: Implement logging
    }
}

pub struct TracingSystem;

impl TracingSystem {
    pub fn new() -> Self {
        Self
    }

    pub fn trace(&self, _message: &str) {
        // TODO: Implement tracing
    }
}
```

===================
File: ./crates/icn-core/src/vm/mod.rs
Size: 92 bytes
===================
```rs
pub mod runtime;
pub mod vm;
pub mod contract;
pub mod opcode;
pub mod cooperative_metadata;```

===================
File: ./crates/icn-core/src/zk_snarks/mod.rs
Size: 709 bytes
===================
```rs
use std::error::Error;

pub struct ZkProof {
    pub proof_data: Vec<u8>,
    pub public_inputs: Vec<Vec<u8>>,
}

pub fn verify_proof(proof: &ZkProof, inputs: &[Vec<u8>]) -> Result<bool, Box<dyn Error>> {
    // TODO: Implement actual zk-SNARK verification
    // For now return true if proof exists and inputs match
    Ok(!proof.proof_data.is_empty() && proof.public_inputs == inputs)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verify_proof() {
        let proof = ZkProof {
            proof_data: vec![1, 2, 3],
            public_inputs: vec![vec![4, 5, 6]],
        };
        let inputs = vec![vec![4, 5, 6]];
        assert!(verify_proof(&proof, &inputs).unwrap());
    }
}```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 5761 bytes
===================
```rs
use secp256k1::{Secp256k1, SecretKey, PublicKey, Message, Signature};
use sha2::{Sha256, Digest};
use rsa::{RSAPrivateKey, RSAPublicKey, PaddingScheme};
use ecdsa::{SigningKey, VerifyingKey, signature::Signer, signature::Verifier};
use icn_types::Algorithm;
use kyber::keypair as kyber_keypair;
use kyber::encapsulate as kyber_encapsulate;
use kyber::decapsulate as kyber_decapsulate;
use dilithium::keypair as dilithium_keypair;
use dilithium::sign as dilithium_sign;
use dilithium::verify as dilithium_verify;
use falcon::keypair as falcon_keypair;
use falcon::sign as falcon_sign;
use falcon::verify as falcon_verify;

pub enum Algorithm {
    Secp256k1,
    RSA,
    ECDSA,
    Kyber,
    Dilithium,
    Falcon,
}

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub algorithm: Algorithm,
}

impl KeyPair {
    pub fn generate(algorithm: Algorithm) -> Self {
        match algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let (private_key, public_key) = secp.generate_keypair(&mut rand::thread_rng());
                KeyPair {
                    public_key: public_key.serialize().to_vec(),
                    private_key: private_key[..].to_vec(),
                    algorithm,
                }
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::new(&mut rand::thread_rng(), 2048).expect("failed to generate a key");
                let public_key = RSAPublicKey::from(&private_key);
                KeyPair {
                    public_key: public_key.to_pkcs1().expect("failed to encode public key"),
                    private_key: private_key.to_pkcs1().expect("failed to encode private key"),
                    algorithm,
                }
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::random(&mut rand::thread_rng());
                let verifying_key = VerifyingKey::from(&signing_key);
                KeyPair {
                    public_key: verifying_key.to_bytes().to_vec(),
                    private_key: signing_key.to_bytes().to_vec(),
                    algorithm,
                }
            },
            Algorithm::Kyber => {
                let (public_key, private_key) = kyber_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Dilithium => {
                let (public_key, private_key) = dilithium_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
            Algorithm::Falcon => {
                let (public_key, private_key) = falcon_keypair();
                KeyPair {
                    public_key,
                    private_key,
                    algorithm,
                }
            },
        }
    }

    pub fn sign(&self, message: &[u8]) -> Vec<u8> {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let private_key = SecretKey::from_slice(&self.private_key).expect("32 bytes");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                secp.sign(&message, &private_key).serialize_compact().to_vec()
            },
            Algorithm::RSA => {
                let private_key = RSAPrivateKey::from_pkcs1(&self.private_key).expect("failed to decode private key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                private_key.sign(padding, &Sha256::digest(message)).expect("failed to sign message")
            },
            Algorithm::ECDSA => {
                let signing_key = SigningKey::from_bytes(&self.private_key).expect("failed to decode private key");
                signing_key.sign(message).to_bytes().to_vec()
            },
            Algorithm::Dilithium => {
                dilithium_sign(&self.private_key, message)
            },
            Algorithm::Falcon => {
                falcon_sign(&self.private_key, message)
            },
            _ => vec![],
        }
    }

    pub fn verify(&self, message: &[u8], signature: &[u8]) -> bool {
        match self.algorithm {
            Algorithm::Secp256k1 => {
                let secp = Secp256k1::new();
                let public_key = PublicKey::from_slice(&self.public_key).expect("invalid public key");
                let message = Message::from_slice(&Sha256::digest(message)).expect("32 bytes");
                let signature = Signature::from_compact(signature).expect("invalid signature");
                secp.verify(&message, &signature, &public_key).is_ok()
            },
            Algorithm::RSA => {
                let public_key = RSAPublicKey::from_pkcs1(&self.public_key).expect("failed to decode public key");
                let padding = PaddingScheme::new_pkcs1v15_sign(None);
                public_key.verify(padding, &Sha256::digest(message), signature).is_ok()
            },
            Algorithm::ECDSA => {
                let verifying_key = VerifyingKey::from_bytes(&self.public_key).expect("failed to decode public key");
                verifying_key.verify(message, signature).is_ok()
            },
            Algorithm::Dilithium => {
                dilithium_verify(&self.public_key, message, signature)
            },
            Algorithm::Falcon => {
                falcon_verify(&self.public_key, message, signature)
            },
            _ => false,
        }
    }
}

pub fn hash(data: &[u8]) -> Vec<u8> {
    Sha256::digest(data).to_vec()
}
```

===================
File: ./crates/icn-dsl/src/lib.rs
Size: 5568 bytes
===================
```rs
use nom::{
    branch::alt,
    bytes::complete::{tag, take_while1},
    character::complete::{char, multispace0, multispace1},
    combinator::{map, opt},
    multi::{many0, many1},
    sequence::{delimited, preceded, terminated, tuple},
    IResult,
};

#[derive(Debug, Clone)]
pub struct CoopLangAST {
    pub governance: Option<GovernanceNode>,
    pub reputation: Option<ReputationNode>,
    pub marketplace: Option<MarketplaceNode>,
    pub federation: Option<FederationNode>,
    pub validation: Option<ValidationNode>,
    pub logging: Option<LoggingNode>,
}

#[derive(Debug, Clone)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
    pub resource_checks: Option<ResourceChecks>,
    pub custom_merge: Option<CustomMerge>,
}

#[derive(Debug, Clone)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

#[derive(Debug, Clone)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transition: Option<String>,
}

#[derive(Debug, Clone)]
pub struct CustomMerge {
    pub strategy: String,
    pub handlers: Vec<ConflictHandler>,
}

#[derive(Debug, Clone)]
pub struct ConflictHandler {
    pub field_path: String,
    pub resolution_type: String,
}

// Parser implementation
impl CoopLangAST {
    pub fn parse(input: &str) -> IResult<&str, Self> {
        let (input, _) = multispace0(input)?;
        let (input, governance) = opt(Self::parse_governance_section)(input)?;
        let (input, reputation) = opt(Self::parse_reputation_section)(input)?;
        let (input, marketplace) = opt(Self::parse_marketplace_section)(input)?;
        let (input, federation) = opt(Self::parse_federation_section)(input)?;
        let (input, validation) = opt(Self::parse_validation_section)(input)?;
        let (input, logging) = opt(Self::parse_logging_section)(input)?;
        
        Ok((input, CoopLangAST {
            governance,
            reputation,
            marketplace,
            federation,
            validation,
            logging,
        }))
    }

    fn parse_validation_section(input: &str) -> IResult<&str, ValidationNode> {
        let (input, _) = tag("validation:")(input)?;
        let (input, _) = multispace1(input)?;
        
        let (input, pre_checks) = Self::parse_checks("pre_checks:")(input)?;
        let (input, post_checks) = Self::parse_checks("post_checks:")(input)?;
        let (input, state_validation) = opt(Self::parse_state_validation)(input)?;
        let (input, resource_checks) = opt(Self::parse_resource_checks)(input)?;
        let (input, custom_merge) = opt(Self::parse_custom_merge)(input)?;

        Ok((input, ValidationNode {
            pre_checks,
            post_checks,
            state_validation,
            resource_checks,
            custom_merge,
        }))
    }

    fn parse_checks(label: &'static str) -> impl Fn(&str) -> IResult<&str, Vec<Check>> {
        move |input: &str| {
            let (input, _) = tag(label)(input)?;
            let (input, _) = multispace1(input)?;
            many0(Self::parse_check)(input)
        }
    }

    fn parse_check(input: &str) -> IResult<&str, Check> {
        let (input, _) = char('-')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, condition) = take_while1(|c| c != ':')(input)?;
        let (input, _) = char(':')(input)?;
        let (input, _) = multispace0(input)?;
        let (input, action) = take_while1(|c| c != '\n')(input)?;
        let (input, _) = multispace0(input)?;

        Ok((input, Check {
            condition: condition.trim().to_string(),
            action: action.trim().to_string(),
        }))
    }

    // Add other section parsers similarly...
}

// Bytecode generation
pub fn compile_to_icvm(ast: &CoopLangAST) -> Vec<u8> {
    let mut bytecode = Vec::new();

    // Header
    bytecode.extend_from_slice(&[0x49, 0x43, 0x56, 0x4D]); // "ICVM" magic bytes
    bytecode.push(0x01); // Version

    // Compile validation rules
    if let Some(validation) = &ast.validation {
        bytecode.push(0x01); // Validation section marker
        
        // Pre-checks
        bytecode.push(validation.pre_checks.len() as u8);
        for check in &validation.pre_checks {
            compile_check(&mut bytecode, check);
        }

        // Post-checks
        bytecode.push(validation.post_checks.len() as u8);
        for check in &validation.post_checks {
            compile_check(&mut bytecode, check);
        }

        // State validation
        if let Some(state_validation) = &validation.state_validation {
            bytecode.push(0x01);
            compile_state_validation(&mut bytecode, state_validation);
        } else {
            bytecode.push(0x00);
        }
    }

    // Compile other sections similarly...

    bytecode
}

fn compile_check(bytecode: &mut Vec<u8>, check: &Check) {
    // Convert check condition to bytecode operations
    bytecode.extend_from_slice(check.condition.as_bytes());
    bytecode.push(0x00); // Null terminator
    bytecode.extend_from_slice(check.action.as_bytes());
    bytecode.push(0x00); // Null terminator
}

fn compile_state_validation(bytecode: &mut Vec<u8>, validation: &StateValidation) {
    if let Some(current) = &validation.current {
        bytecode.push(0x01);
        bytecode.extend_from_slice(current.as_bytes());
        bytecode.push(0x00);
    } else {
        bytecode.push(0x00);
    }
    // Similarly for expected and transition...
}
```

===================
File: ./crates/icn-federation/src/lib.rs
Size: 43020 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_types::{Block, Transaction};
use icn_governance::{DissolutionProtocol, DissolutionReason, DissolutionStatus};
use icn_zkp::RollupBatch;
use thiserror::Error;
use icn_networking::p2p::{P2PManager, FederationEvent}; // Import P2PManager and FederationEvent
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::time::{SystemTime, Duration};

// Add SDP support
use icn_p2p::sdp::{SDPManager, SDPPacket, SDPHeader, PublicKey};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub federation_type: FederationType,
    pub members: HashMap<String, MemberStatus>, // DID -> status
    pub member_roles: HashMap<String, MemberRole>, // DID -> role
    pub terms: FederationTerms,
    pub resources: HashMap<String, ResourcePool>,
    pub proposals: Vec<FederationProposal>, // Add proposals field
    pub created_at: u64,
    pub status: FederationStatus,
    pub disputes: HashMap<String, FederationDispute>, // Add disputes field
    pub cross_federation_disputes: HashMap<String, Vec<FederationDispute>>,
    pub audit_log: Vec<AuditEntry>,
    pub p2p_manager: Arc<tokio::sync::Mutex<P2PManager>>, // Changed to tokio::sync::Mutex
    // Add secure communication fields
    pub sdp_peers: HashMap<String, Vec<String>>, // federation_id -> [peer_addresses]
    pub federation_public_keys: HashMap<String, String>, // federation_id -> public_key (base58 encoded)
}

// Add an SDPConfig struct to handle SDP configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SDPConfig {
    pub bind_address: String,
    pub enable_multipath: bool,
    pub enable_onion_routing: bool,
    pub message_priority: HashMap<String, u8>, // message_type -> priority
}

impl Default for SDPConfig {
    fn default() -> Self {
        let mut message_priority = HashMap::new();
        message_priority.insert("governance_vote".to_string(), 8);
        message_priority.insert("dispute_resolution".to_string(), 9);
        message_priority.insert("resource_allocation".to_string(), 6);
        message_priority.insert("member_update".to_string(), 5);
        
        Self {
            bind_address: "0.0.0.0:0".to_string(), // Random port by default
            enable_multipath: true,
            enable_onion_routing: false, // Optional advanced feature
            message_priority,
        }
    }
}

// Add a struct for federation manager with SDP support
pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
    // Add SDP manager
    sdp_manager: Option<Arc<RwLock<SDPManager>>>,
    sdp_config: SDPConfig,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
            sdp_manager: None,
            sdp_config: SDPConfig::default(),
        }
    }

    // Initialize SDP for secure federation communications
    pub async fn init_sdp(&mut self, config: SDPConfig) -> Result<(), FederationError> {
        match SDPManager::new(&config.bind_address) {
            Ok(manager) => {
                self.sdp_manager = Some(Arc::new(RwLock::new(manager)));
                self.sdp_config = config;
                
                // Start receiver for handling incoming messages
                self.start_sdp_receiver().await?;
                
                Ok(())
            },
            Err(e) => Err(FederationError::CommunicationError(format!("Failed to initialize SDP: {}", e))),
        }
    }

    // Start SDP receiver to handle incoming messages
    async fn start_sdp_receiver(&self) -> Result<(), FederationError> {
        if let Some(sdp) = &self.sdp_manager {
            let sdp_clone = sdp.clone();
            let federations_clone = self.federations.clone();
            
            let handler = move |data: Vec<u8>, src| {
                let federations = federations_clone.clone();
                
                tokio::spawn(async move {
                    // Handle incoming SDP messages
                    if let Ok(message) = serde_json::from_slice::<FederationMessage>(&data) {
                        // Process message based on type
                        match message.message_type {
                            FederationMessageType::ProposalSubmission => {
                                if let Ok(proposal) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        // Add signature verification here
                                        let _ = federation.submit_proposal(proposal);
                                    }
                                }
                            },
                            FederationMessageType::Vote => {
                                if let Ok(vote) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.vote(vote);
                                    }
                                }
                            },
                            FederationMessageType::DisputeInitiation => {
                                if let Ok(dispute) = serde_json::from_value(message.payload) {
                                    let mut federations_lock = federations.write().await;
                                    if let Some(federation) = federations_lock.get_mut(&message.target_federation) {
                                        let _ = federation.submit_dissolution_dispute(dispute);
                                    }
                                }
                            },
                            FederationMessageType::ResourceAllocation => {
                                // Handle resource allocation messages
                            },
                            FederationMessageType::MembershipUpdate => {
                                // Handle membership updates
                            },
                        }
                    }
                });
            };
            
            sdp_clone.lock().await.start_receiver(handler).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to start SDP receiver: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    // Send a federation message via SDP
    pub async fn send_federation_message(
        &self,
        source_federation: &str,
        target_federation: &str,
        message_type: FederationMessageType,
        payload: serde_json::Value,
        signature: &str,
    ) -> Result<(), FederationError> {
        let federations = self.federations.read().await;
        
        let source_fed = federations.get(source_federation)
            .ok_or(FederationError::FederationNotFound(source_federation.to_string()))?;
            
        let target_fed = federations.get(target_federation)
            .ok_or(FederationError::FederationNotFound(target_federation.to_string()))?;
            
        // Check if we have SDP peer info for the target
        if !source_fed.sdp_peers.contains_key(target_federation) {
            return Err(FederationError::CommunicationError(
                format!("No SDP routing information for federation {}", target_federation)
            ));
        }
        
        // Create federation message
        let message = FederationMessage {
            source_federation: source_federation.to_string(),
            target_federation: target_federation.to_string(),
            message_type,
            payload,
            timestamp: SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            signature: signature.to_string(),
        };
        
        // Serialize message
        let serialized = serde_json::to_vec(&message)
            .map_err(|e| FederationError::CommunicationError(format!("Serialization error: {}", e)))?;
            
        // Get message priority
        let priority = self.sdp_config.message_priority
            .get(message.message_type.to_string().as_str())
            .cloned()
            .unwrap_or(5); // Default priority
            
        if let Some(sdp_manager) = &self.sdp_manager {
            let manager = sdp_manager.lock().await;
            manager.send_message(target_federation, &serialized, priority).await
                .map_err(|e| FederationError::CommunicationError(format!("Failed to send SDP message: {}", e)))
        } else {
            Err(FederationError::CommunicationError("SDP manager not initialized".to_string()))
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
            // Initialize SDP communication fields
            sdp_peers: HashMap::new(),
            federation_public_keys: HashMap::new(),
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }

        // Add SDP peer information if available
        if let Some(sdp) = &self.sdp_manager {
            let manager = sdp.lock().await;
            let public_key = manager.keypair.1;
            
            // Update the federation with this node's SDP information
            let mut federations = self.federations.write().await;
            if let Some(federation) = federations.get_mut(federation_id) {
                // Add public key in base58 encoding for interoperability
                federation.federation_public_keys.insert(
                    member_did.to_string(),
                    bs58::encode(public_key.as_bytes()).into_string()
                );
            }
        }
        
        Ok(())
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

// Add FederationMessage struct for secure communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMessage {
    pub source_federation: String,
    pub target_federation: String,
    pub message_type: FederationMessageType,
    pub payload: serde_json::Value,
    pub timestamp: u64,
    pub signature: String,
}

// Define message types for federation communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationMessageType {
    ProposalSubmission,
    Vote,
    DisputeInitiation,
    ResourceAllocation,
    MembershipUpdate,
}

impl ToString for FederationMessageType {
    fn to_string(&self) -> String {
        match self {
            FederationMessageType::ProposalSubmission => "governance_proposal".to_string(),
            FederationMessageType::Vote => "governance_vote".to_string(),
            FederationMessageType::DisputeInitiation => "dispute_resolution".to_string(),
            FederationMessageType::ResourceAllocation => "resource_allocation".to_string(),
            FederationMessageType::MembershipUpdate => "member_update".to_string(),
        }
    }
}

impl Federation {
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), FederationError> {
        if self.members.contains_key(&did) {
            return Err(FederationError::AlreadyMember(did));
        }

        // Verify member meets minimum reputation requirements
        if !self.verify_member_eligibility(&did) {
            return Err(FederationError::InsufficientReputation(
                "Member does not meet minimum reputation requirements".to_string(),
            ));
        }

        self.members.insert(did, MemberStatus::Active);
        Ok(())
    }

    pub fn remove_member(&mut self, did: &str) -> Result<(), FederationError> {
        if !self.members.contains_key(did) {
            return Err(FederationError::MemberNotFound(did.to_string()));
        }

        self.members.remove(did);
        Ok(())
    }

    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.members.get(did)
    }

    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), FederationError> {
        if let Some(member_status) = self.members.get_mut(did) {
            *member_status = status;
            Ok(())
        } else {
            Err(FederationError::MemberNotFound(did.to_string()))
        }
    }

    pub fn get_active_members(&self) -> Vec<String> {
        self.members
            .iter()
            .filter(|(_, status)| matches!(status, MemberStatus::Active))
            .map(|(did, _)| did.clone())
            .collect()
    }

    pub fn verify_member_eligibility(&self, did: &str) -> bool {
        // This would integrate with the reputation system in practice
        true // Simplified for example
    }

    pub fn submit_proposal(&mut self, proposal: FederationProposal) -> Result<(), FederationError> {
        // Validate proposal
        self.validate_proposal(&proposal)?;

        // Set proposal voting period
        let mut proposal = proposal;
        proposal.voting_ends_at = chrono::Utc::now().timestamp() as u64 + 
            (self.terms.governance_rules.max_voting_period_hours * 3600);

        self.proposals.push(proposal);
        Ok(())
    }

    pub fn vote(&mut self, vote: Vote) -> Result<(), FederationError> {
        // Validate vote
        self.validate_vote(&vote)?;

        // Get proposal
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Record vote
        proposal.votes.insert(vote.voter, vote.approve);

        // Check if voting period ended and finalize if needed
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            proposal.status = self.finalize_proposal(&proposal.id)?;
        }

        Ok(())
    }

    pub fn validate_proposal(&self, proposal: &FederationProposal) -> Result<(), FederationError> {
        // Check if proposal type is allowed
        if !self.terms.governance_rules.allowed_proposal_types.contains(&proposal.proposal_type.to_string()) {
            return Err(FederationError::InvalidProposalType(proposal.proposal_type.to_string()));
        }

        // Validate proposer has sufficient reputation
        if !self.verify_member_eligibility(&proposal.proposer) {
            return Err(FederationError::InsufficientReputation(
                "Proposer does not meet minimum reputation requirements".to_string()
            ));
        }

        Ok(())
    }

    pub fn validate_vote(&self, vote: &Vote) -> Result<(), FederationError> {
        // Check if voter is a member
        if !self.members.contains_key(&vote.voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote".to_string(), did: vote.voter.clone() });
        }

        // Check if proposal exists
        let proposal = self.proposals.iter()
            .find(|p| p.id == vote.proposal_id)
            .ok_or(FederationError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Check if voting period is still open
        let now = chrono::Utc::now().timestamp() as u64;
        if now > proposal.voting_ends_at {
            return Err(FederationError::VotingPeriodEnded(vote.proposal_id.clone()));
        }

        // Check for veto rights
        if let Some(member_role) = self.member_roles.get(&vote.voter) {
            if let Some(veto_actions) = self.terms.governance_rules.veto_rights.get(&member_role.to_string()) {
                if veto_actions.contains(&proposal.proposal_type.to_string()) && !vote.approve {
                    // Record veto
                    return Ok(());
                }
            }
        }

        Ok(())
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<ProposalStatus, FederationError> {
        let proposal = self.proposals.iter_mut()
            .find(|p| p.id == proposal_id)
            .ok_or(FederationError::ProposalNotFound(proposal_id.to_string()))?;

        // Create vote batch for on-chain processing
        let batch = RollupBatch {
            proposal_id: proposal_id.to_string(),
            votes: proposal.votes.iter()
                .map(|(voter, approve)| Vote { voter: voter.clone(), approve: *approve, signature: String::new() }) // Added signature field
                .collect(),
            rollup_root: [0u8; 32], // Computed by ZK prover
            proof: Vec::new(), // Generated by ZK prover
        };

        // Submit batch to chain
        self.contract.submit_vote_batch(batch)?;

        // Execute proposal on-chain
        let approved = self.contract.execute_proposal(proposal_id)?;
        
        proposal.status = if approved {
            ProposalStatus::Approved
        } else {
            ProposalStatus::Rejected
        };

        Ok(proposal.status.clone())
    }

    pub fn calculate_asset_distribution(&self) -> HashMap<String, AssetAllocation> {
        let mut distributions = HashMap::new();
        // Implement fair asset distribution calculation
        distributions
    }

    pub fn settle_outstanding_debts(&self) -> Vec<DebtSettlement> {
        let mut settlements = Vec::new();
        // Implement debt settlement calculation
        settlements
    }

    pub fn reassign_members(&self) -> Vec<MemberReassignment> {
        let mut reassignments = Vec::new();
        // Implement member reassignment logic
        reassignments
    }

    pub fn calculate_vote_weight(&self, cooperative_id: &str, proposal: &FederationProposal) -> f64 {
        let voting_model = match proposal.proposal_type {
            ProposalType::GovernanceChange(_) | ProposalType::PolicyUpdate(_) => 
                &self.terms.governance_rules.governance_voting_model,
            ProposalType::ResourceAllocation(_) =>
                &self.terms.governance_rules.resource_voting_model,
            _ => &self.terms.governance_rules.default_voting_model,
        };

        voting_model.calculate_voting_power(self, cooperative_id)
    }

    pub fn get_cooperative_weight(&self, cooperative_id: &str) -> f64 {
        let total_members: u32 = self.members.values().map(|m| m.member_count).sum();
        let coop_members = self.members.get(cooperative_id)
            .map(|m| m.member_count)
            .unwrap_or(0);
        
        coop_members as f64 / total_members as f64
    }

    pub fn initiate_dissolution(&mut self, initiator: String, reason: String) -> Result<DissolutionProtocol, FederationError> {
        let protocol = DissolutionProtocol {
            federation_id: self.id.clone(),
            initiated_by: initiator,
            reason: DissolutionReason::Voluntary,
            status: DissolutionStatus::Initiated,
            asset_distribution: HashMap::new(),
            debt_settlements: Vec::new(),
            member_reassignments: Vec::new(),
            dispute_period_ends: SystemTime::now() + Duration::from_secs(7 * 24 * 60 * 60), // 7 days
        };

        self.status = FederationStatus::DisputePeriod;
        Ok(protocol)
    }

    pub fn submit_dissolution_dispute(&mut self, dispute: FederationDispute) -> Result<(), FederationError> {
        if self.status != FederationStatus::DisputePeriod {
            return Err(FederationError::InvalidStatusTransition { from: "DisputePeriod".to_string(), to: self.status.to_string() });
        }

        if !self.members.contains_key(&dispute.initiator) {
            return Err(FederationError::UnauthorizedAction { action: "submit_dissolution_dispute".to_string(), did: dispute.initiator.clone() });
        }

        self.disputes.insert(dispute.id.clone(), dispute);
        self.status = FederationStatus::DisputeResolution;
        Ok(())
    }

    pub fn vote_on_dispute(&mut self, dispute_id: &str, voter: String, support: bool) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        if !self.members.contains_key(&voter) {
            return Err(FederationError::UnauthorizedAction { action: "vote_on_dispute".to_string(), did: voter.clone() });
        }

        dispute.supporting_votes.insert(voter, support);

        // Check if we have enough votes to resolve the dispute
        let total_votes = dispute.supporting_votes.len();
        let supporting_votes = dispute.supporting_votes.values().filter(|&&v| v).count();
        let required_votes = (self.members.len() * 2) / 3; // 2/3 majority

        if total_votes >= required_votes {
            if supporting_votes > total_votes / 2 {
                dispute.status = DisputeStatus::Resolved;
                self.status = FederationStatus::Active;
            } else {
                dispute.status = DisputeStatus::Rejected;
                self.status = FederationStatus::Dissolved;
            }
        }

        Ok(())
    }

    pub fn resolve_dispute(&mut self, dispute_id: &str, resolution: DisputeResolution) -> Result<(), FederationError> {
        let dispute = self.disputes.get_mut(dispute_id)
            .ok_or(FederationError::DisputeNotFound(dispute_id.to_string()))?;

        dispute.resolution = Some(resolution);
        dispute.status = DisputeStatus::Resolved;

        // If all disputes are resolved, proceed with dissolution
        if self.disputes.values().all(|d| d.status == DisputeStatus::Resolved || d.status == DisputeStatus::Rejected) {
            let any_upheld = self.disputes.values().any(|d| d.status == DisputeStatus::Resolved);
            self.status = if any_upheld {
                FederationStatus::Active
            } else {
                FederationStatus::Dissolved;
            };
        }

        Ok(())
    }

    pub async fn initiate_cross_federation_dispute(
        &mut self,
        target_federation: &str,
        dispute: FederationDispute
    ) -> Result<(), FederationError> {
        // Verify both federations exist and have sufficient reputation
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        let disputes = self.cross_federation_disputes
            .entry(target_federation.to_string())
            .or_insert_with(Vec::new);
        
        disputes.push(dispute);
        
        // Log dispute for audit
        self.audit_log.push(AuditEntry {
            action: "cross_federation_dispute".into(),
            target_federation: Some(target_federation.to_string()),
            timestamp: chrono::Utc::now(),
        });

        Ok(())
    }

    pub async fn submit_cross_federation_proposal(
        &mut self,
        target_federation: &str,
        proposal: CrossFederationProposal
    ) -> Result<(), FederationError> {
        // Verify both federations meet minimum reputation requirements
        self.verify_cross_federation_eligibility(target_federation).await?;
        
        // Create batch for cross-federation proposals
        let mut batch = ProposalBatch::new();
        batch.add_proposal(proposal.clone());
        
        // Submit to cross-federation coordinator
        self.coordinator.submit_batch(batch).await?;
        
        // Record proposal for local tracking
        self.cross_federation_proposals.insert(proposal.id.clone(), proposal);
        
        Ok(())
    }

    pub fn batch_process_proposals(&mut self, proposals: Vec<FederationProposal>) -> Result<(), FederationError> {
        let mut batch = ProposalBatch::new();
        
        for proposal in proposals {
            self.validate_proposal(&proposal)?;
            batch.add_proposal(proposal);
        }
        
        // Process batch through ZK rollup
        let rollup = self.create_proposal_rollup(batch);
        self.contract.submit_rollup(rollup)?;
        
        Ok(())
    }

    pub async fn publish_event(&self, event: FederationEvent) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.publish(event).await.map_err(|e| FederationError::EventPublishError(e.to_string()))
    }

    pub async fn subscribe_to_events(&self) -> Result<(), FederationError> {
        let mut p2p = self.p2p_manager.lock().await;
        p2p.subscribe().await.map_err(|e| FederationError::EventSubscribeError(e.to_string()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourcePool {
    pub resource_type: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub contributors: HashMap<String, u64>, // DID -> amount contributed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationProposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub description: String,
    pub votes: HashMap<String, bool>, // DID -> vote
    pub status: ProposalStatus,
    pub created_at: u64,
    pub voting_ends_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalType {
    AddMember(String),
    RemoveMember(String),
    UpdateTerms(FederationTerms),
    AllocateResources(ResourceAllocation),
    UpdatePolicy(String),
}

impl std::fmt::Display for ProposalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProposalType::AddMember(_) => write!(f, "AddMember"),
            ProposalType::RemoveMember(_) => write!(f, "RemoveMember"),
            ProposalType::UpdateTerms(_) => write!(f, "UpdateTerms"),
            ProposalType::AllocateResources(_) => write!(f, "AllocateResources"),
            ProposalType::UpdatePolicy(_) => write!(f, "UpdatePolicy"),
        }
    }
}

pub struct FederationManager {
    federations: Arc<RwLock<HashMap<String, Federation>>>,
    resource_manager: Arc<dyn ResourceManager>,
}

impl FederationManager {
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            federations: Arc::new(RwLock::new(HashMap::new())),
            resource_manager,
        }
    }

    pub async fn create_federation(
        &self,
        name: String,
        federation_type: FederationType,
        initial_terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationError> {
        let federation_id = format!("fed_{}", uuid::Uuid::new_v4());
        let federation = Federation {
            id: federation_id.clone(),
            name,
            federation_type,
            members: vec![founding_member].into_iter().map(|m| (m, MemberStatus::Active)).collect(),
            member_roles: HashMap::new(),
            terms: initial_terms,
            resources: HashMap::new(),
            proposals: Vec::new(),
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Active,
            disputes: HashMap::new(),
            cross_federation_disputes: HashMap::new(),
            audit_log: Vec::new(),
            p2p_manager: Arc::new(tokio::sync::Mutex::new(P2PManager::new())), // Initialize p2p_manager
        };

        let mut federations = self.federations.write().await;
        federations.insert(federation_id.clone(), federation);

        Ok(federation_id)
    }

    pub async fn join_federation(
        &self,
        federation_id: &str,
        member_did: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;
        
        if let Some(federation) = federations.get_mut(federation_id) {
            if federation.members.contains_key(member_did) {
                return Err(FederationError::AlreadyMember(member_did.to_string()));
            }

            // Verify commitments against federation terms
            if !self.verify_commitments(&federation.terms, &commitment).await {
                return Err(FederationError::InvalidCommitment(member_did.to_string()));
            }

            federation.members.insert(member_did.to_string(), MemberStatus::Active);
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    async fn verify_commitments(&self, terms: &FederationTerms, commitment: &[String]) -> bool {
        // Add commitment verification logic here
        true // Placeholder
    }

    pub async fn submit_proposal(
        &self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.submit_proposal(proposal)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }

    pub async fn vote(
        &self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationError> {
        let mut federations = self.federations.write().await;

        if let Some(federation) = federations.get_mut(federation_id) {
            federation.vote(vote)?;
            Ok(())
        } else {
            Err(FederationError::FederationNotFound(federation_id.to_string()))
        }
    }
}

#[async_trait]
pub trait ResourceManager: Send + Sync {
    async fn allocate_resources(&self, allocation: ResourceAllocation) -> Result<(), String>;
    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String>;
}

pub trait FederationDissolution {
    fn initiate_dissolution(&mut self, initiator: &str, reason: DissolutionReason) -> Result<DissolutionProtocol, Error>;
    fn process_dissolution(&mut self, protocol: &DissolutionProtocol) -> Result<DissolutionStatus, Error>;
    fn cancel_dissolution(&mut self, protocol_id: &str) -> Result<(), Error>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: GovernanceRules,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceRules {
    pub min_votes_required: u32,
    pub approval_threshold_percent: u32,
    pub min_voting_period_hours: u32,
    pub max_voting_period_hours: u32,
    pub allowed_proposal_types: Vec<String>,
    pub veto_rights: HashMap<String, Vec<String>>, // role -> action types that can be vetoed
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FederationStatus {
    Active,
    Suspended,
    Dissolved,
    DisputePeriod,
    DisputeResolution,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Expired,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

impl std::fmt::Display for MemberRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MemberRole::Admin => write!(f, "Admin"),
            MemberRole::Member => write!(f, "Member"),
            MemberRole::Observer => write!(f, "Observer"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemberStatus {
    Active,
    Inactive,
    Suspended,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String, // Added required field
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationDispute {
    pub id: String,
    pub federation_id: String,
    pub initiator: String,
    pub reason: String,
    pub evidence: Option<String>,
    pub supporting_votes: HashMap<String, bool>,
    pub created_at: u64,
    pub status: DisputeStatus,
    pub resolution: Option<DisputeResolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub decision: String,
    pub rationale: String,
    pub resolved_at: u64,
    pub resolver: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DisputeStatus {
    Pending,
    Resolved,
    Rejected,
}

impl std::fmt::Display for DisputeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisputeStatus::Pending => write!(f, "Pending"),
            DisputeStatus::Resolved => write!(f, "Resolved"),
            DisputeStatus::Rejected => write!(f, "Rejected"),
        }
    }
}

#[derive(Error, Debug)]
pub enum FederationError {
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Already a member: {0}")]
    AlreadyMember(String),
    
    #[error("Invalid commitment: {0}")]
    InvalidCommitment(String),
    
    #[error("Insufficient resources: {resource_type}")]
    InsufficientResources { resource_type: String },
    
    #[error("Unauthorized action: {action} by {did}")]
    UnauthorizedAction { action: String, did: String },
    
    #[error("Member not found: {0}")]
    MemberNotFound(String),
    
    #[error("Invalid status transition from {from} to {to}")]
    InvalidStatusTransition { from: String, to: String },
    
    #[error("Insufficient permissions: {0}")]
    InsufficientPermissions(String),
    
    #[error("Invalid proposal type: {0}")] 
    InvalidProposalType(String),
    
    #[error("Voting period ended for proposal {0}")]
    VotingPeriodEnded(String),
    
    #[error("Proposal not found: {0}")]
    ProposalNotFound(String),
    
    #[error("Insufficient reputation: {0}")]
    InsufficientReputation(String),
    
    #[error("Dispute not found: {0}")]
    DisputeNotFound(String),
    
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    
    #[error("Consensus error: {0}")]
    ConsensusError(#[from] ConsensusError),
    
    #[error("Event publish error: {0}")]
    EventPublishError(String),
    
    #[error("Event subscribe error: {0}")]
    EventSubscribeError(String),

    #[error("Communication error: {0}")]
    CommunicationError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEntry {
    pub action: String,
    pub target_federation: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossFederationProposal {
    pub id: String,
    pub source_federation: String,
    pub target_federation: String,
    pub proposal_type: CrossFederationProposalType,
    pub terms: CrossFederationTerms,
    pub votes: HashMap<String, bool>,
    pub status: ProposalStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CrossFederationProposalType {
    Merge,
    Alliance,
    ResourceSharing,
    DisputeResolution,
}

#[derive(Debug)]
pub struct BatchProcessor {
    pub coordinator: Arc<tokio::sync::Mutex<ProposalCoordinator>>,
}

#[derive(Debug)]
pub struct ProposalCoordinator {
    // Add fields as needed
}

impl ProposalCoordinator {
    pub async fn submit_batch(&self, batch: ProposalBatch) -> Result<(), FederationError> {
        // Implementation here
        Ok(())
    }
}

#[derive(Debug)]
pub struct ProposalBatch {
    proposals: Vec<FederationProposal>,
}

impl ProposalBatch {
    pub fn new() -> Self {
        Self {
            proposals: Vec::new(),
        }
    }

    pub fn add_proposal(&mut self, proposal: FederationProposal) {
        self.proposals.push(proposal);
    }
}

// Add missing types
#[derive(Debug)]
pub struct StorageError;

#[derive(Debug)]
pub struct ConsensusError;

#[derive(Debug, Clone)]
pub struct AssetAllocation {
    pub asset_type: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct DebtSettlement {
    pub debtor: String,
    pub creditor: String,
    pub amount: u64,
}

#[derive(Debug, Clone)]
pub struct MemberReassignment {
    pub member_id: String,
    pub new_federation: String,
}

#[derive(Debug, Clone)]
pub struct CrossFederationTerms {
    pub resource_sharing_terms: String,
    pub governance_terms: String,
}

// Federation system for resource sharing and governance across cooperatives
mod federation;
mod resource_sharing;
mod resource_manager;

pub use federation::{
    Federation, 
    FederationError, 
    FederationType, 
    FederationTerms, 
    FederationManager,
    FederationProposal,
    FederationRole,
    FederationMember,
    Vote
};

pub use resource_sharing::{
    ResourceSharingAgreement,
    ResourceAllocation,
    ResourceUsageMetrics,
    SharingAgreementStatus
};

pub use resource_manager::{
    FederationResourceManager,
    ResourceProvider,
    ResourceError
};

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};

/// Federation resource pool that can be shared with other federations
#[derive(Clone, Debug)]
pub struct FederationResourcePool {
    /// ID of the federation that owns this resource pool
    pub federation_id: String,
    
    /// Available resources in this pool
    pub resources: HashMap<String, Resource>,
    
    /// Access control for this resource pool
    pub access_control: FederationAccessControl,
}

/// Access control settings for federation resource pools
#[derive(Clone, Debug)]
pub struct FederationAccessControl {
    /// List of federation IDs allowed to access this pool
    pub allowed_federations: Vec<String>,
    
    /// Minimum reputation required to access resources
    pub min_reputation: i64,
    
    /// Maximum allocation per federation
    pub max_allocation_per_federation: u64,
}

/// A generic resource that can be shared between federations
#[derive(Clone, Debug)]
pub struct Resource {
    /// Unique identifier for this resource
    pub id: String,
    
    /// Type of resource (e.g., "compute", "storage", "bandwidth")
    pub resource_type: String,
    
    /// Total amount of this resource
    pub total_amount: u64,
    
    /// Currently available (unallocated) amount
    pub available_amount: u64,
    
    /// ID of the federation that owns this resource
    pub owner_federation_id: String,
    
    /// Metadata about this resource
    pub metadata: HashMap<String, String>,
}

/// Creates a new resource sharing agreement between federations
/// 
/// # Arguments
/// * `source_federation_id` - ID of the federation providing resources
/// * `target_federation_id` - ID of the federation receiving resources
/// * `resource_type` - Type of resource being shared
/// * `amount` - Amount of resource to share
/// * `duration_seconds` - Optional duration for the agreement
/// * `terms` - Terms of the sharing agreement
/// * `min_reputation_score` - Minimum reputation score required for the target
/// 
/// # Returns
/// Agreement ID if successful, error otherwise
pub async fn create_resource_sharing_agreement(
    federation_resource_manager: &FederationResourceManager,
    source_federation_id: String,
    target_federation_id: String,
    resource_type: String,
    amount: u64,
    duration_seconds: Option<u64>,
    terms: String,
    min_reputation_score: i64,
) -> Result<String, ResourceError> {
    federation_resource_manager.propose_agreement(
        source_federation_id,
        target_federation_id,
        resource_type,
        amount,
        duration_seconds,
        terms,
        min_reputation_score,
    ).await
}
```

===================
File: ./crates/icn-governance/src/lib.rs
Size: 10971 bytes
===================
```rs
use thiserror::Error;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use icn_types::{DecisionType, Federation, ExecutionEvent, EvidenceItem};
use icn_zk::verify_proof; // Import zk-SNARK verification function

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found")]
    ProposalNotFound,
    #[error("Invalid rollback - proposal is not in pending state")]
    InvalidRollback,
    #[error("Dispute already exists")]
    DisputeExists,
    #[error("Insufficient reputation to dispute")]
    InsufficientReputation,
    #[error("Invalid dispute resolution")]
    InvalidResolution,
    #[error("Database error: {0}")]
    DatabaseError(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: String,
    pub status: ProposalStatus,
    pub created_at: DateTime<Utc>,
    pub votes: HashMap<String, Vote>,
    pub disputes: Vec<Dispute>,
    pub execution_history: Vec<ExecutionEvent>,
    pub phase: ProposalPhase,
    pub required_signers: Vec<String>,
    pub collected_signatures: Vec<String>,
    pub state: ProposalState,
    pub dispute_resolution: Option<DisputeResolution>,
    pub timeout_timestamp: u64,
    pub zk_snark_proof: Option<String>, // Added zk-SNARK proof field
    pub voting_model: VotingModel,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalStatus {
    Pending,
    Active,
    Approved,
    Rejected,
    Disputed,
    RolledBack,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ProposalPhase {
    Submission,
    Deliberation { ends_at: DateTime<Utc> },
    Voting { ends_at: DateTime<Utc> },
    Execution,
    Reconsideration { reason: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
    pub reputation: i64,
    pub timestamp: DateTime<Utc>,
    pub voter_id: String,
    pub proposal_id: String,
    pub decision: DecisionType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dispute {
    pub id: String,
    pub proposal_id: String,
    pub disputer: String,
    pub reason: String,
    pub evidence: String,
    pub arbitrator_did: Option<String>,
    pub resolution: Option<Resolution>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resolution {
    pub decision: DecisionType,
    pub rationale: String,
    pub signatures: Vec<String>, // Requires 75% of arbitrators
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DissolutionProtocol {
    pub federation_id: String,
    pub initiated_by: String,
    pub reason: DissolutionReason,
    pub status: DissolutionStatus,
    pub asset_distribution: HashMap<String, u64>,
    pub debt_settlements: Vec<String>,
    pub member_reassignments: Vec<String>,
    pub dispute_period_ends: std::time::SystemTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionReason {
    Voluntary,
    InactivityThreshold,
    GovernanceFailure,
    ResourceDepletion,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DissolutionStatus {
    Initiated,
    UnderReview,
    Approved,
    Rejected,
    Completed,
}

#[derive(Debug)]
pub struct AssetAllocation {
    asset_id: String,
    recipient_id: String,
    allocation_share: f64,
}

#[derive(Debug)]
pub struct DebtSettlement {
    creditor_id: String,
    debtor_id: String,
    amount: f64,
    due_date: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct MemberReassignment {
    member_id: String,
    new_federation_id: Option<String>,
    transition_period: chrono::Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecisionThresholds {
    pub resource_allocation_threshold: u64,
    pub technical_effort_threshold: u32, // in days
    pub financial_impact_threshold: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationControls {
    pub max_gap_multiplier: f64,
    pub decay_threshold_multiplier: f64,
    pub monthly_decay_rate: f64,
    pub equity_bonus_groups: HashMap<String, f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VotingModel {
    Equal,
    Proportional { cap_percentage: u8 },
    Hybrid {
        governance_model: Box<VotingModel>,
        resource_model: Box<VotingModel>,
    },
    Simple,
    Weighted { weight_factor: f64 },
    Hybrid { governance_model: f64, resource_model: f64 },
}

impl VotingModel {
    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match self {
            VotingModel::Equal => 1.0,
            VotingModel::Proportional { cap_percentage } => {
                let power = federation.get_cooperative_weight(cooperative_id);
                power.min(*cap_percentage as f64 / 100.0)
            },
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Use different models based on proposal type
                // ...existing code...
            }
            VotingModel::Simple => 1.0,
            VotingModel::Weighted { weight_factor } => {
                // Implement weighted voting calculation
                weight_factor * 1.0
            }
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Implement hybrid voting calculation
                governance_model * 0.5 + resource_model * 0.5
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationManager {
    pub controls: ReputationControls,
    reputation_scores: HashMap<String, f64>,
    last_decay_check: DateTime<Utc>,
}

impl ReputationManager {
    pub fn apply_anti_oppression_mechanisms(&mut self) {
        let avg_reputation = self.calculate_average_reputation();
        
        for score in self.reputation_scores.values_mut() {
            if *score > avg_reputation * self.controls.decay_threshold_multiplier {
                *score *= 1.0 - self.controls.monthly_decay_rate;
            }
        }
    }
    
    pub fn calculate_average_reputation(&self) -> f64 {
        // Implement actual calculation
        0.0
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalState {
    Draft,
    UnderReview,
    Voting,
    DisputeResolution,
    Finalized,
    TimedOut,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisputeResolution {
    pub initiator: String,
    pub reason: String, 
    pub mediators: Vec<String>,
    pub resolution: Option<String>,
    pub votes: HashMap<String, bool>,
    pub evidence: Vec<EvidenceItem>,
    pub id: String,
    pub proposal_id: String,
    pub timestamp: i64,
}

impl Proposal {
    pub fn transition_state(&mut self, new_state: ProposalState) -> Result<(), String> {
        let valid = match (&self.state, &new_state) {
            (ProposalState::Draft, ProposalState::UnderReview) => true,
            (ProposalState::UnderReview, ProposalState::Voting) => true,
            (ProposalState::Voting, ProposalState::DisputeResolution) => true,
            (ProposalState::DisputeResolution, ProposalState::Finalized) => true,
            _ => false,
        };

        if valid {
            self.state = new_state;
            Ok(())
        } else {
            Err("Invalid state transition".to_string())
        }
    }
    
    pub fn initiate_dispute(&mut self, initiator: String, reason: String) -> Result<(), String> {
        if self.state != ProposalState::Voting {
            return Err("Can only initiate dispute during voting phase".to_string());
        }
        
        if let Some(proof) = &self.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        
        self.dispute_resolution = Some(DisputeResolution {
            initiator,
            reason,
            mediators: vec![],
            resolution: None,
            votes: HashMap::new(),
            evidence: vec![],
            id: String::new(),
            proposal_id: String::new(),
            timestamp: 0,
        });
        
        self.transition_state(ProposalState::DisputeResolution)
    }

    pub async fn execute_proposal(&self) -> bool {
        if let Some(proof) = &self.zk_snark_proof {
            if verify_proof(proof) {
                execute_approved_action();
                return true;
            }
        }
        false
    }

    pub fn calculate_voting_power(&self, federation: &Federation, cooperative_id: &str) -> f64 {
        match &self.voting_model {
            VotingModel::Simple => 1.0,
            VotingModel::Weighted { weight_factor } => {
                // Implement weighted voting calculation
                weight_factor * 1.0
            }
            VotingModel::Hybrid { governance_model, resource_model } => {
                // Implement hybrid voting calculation
                governance_model * 0.5 + resource_model * 0.5
            }
        }
    }

    pub fn validate_vote(&self, vote: &Vote) -> bool {
        if self.state != ProposalState::Voting {
            return false;
        }
        // Add more validation logic
        true
    }
}

fn verify_proof(proof: &str) -> bool {
    // Implement zk-SNARK proof verification logic
    true
}

fn execute_approved_action() {
    // Implement the action to be executed upon proposal approval
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_reputation_decay() {
        let gov = GovernanceService::new(db_pool).await;
        
        // Test normal decay
        let result = gov.apply_decay("did:icn:test", 0.1).await;
        assert!(result.is_ok());
        
        // Test maximum decay limit
        let result = gov.apply_decay("did:icn:test", 0.9).await;
        assert!(result.is_err());
        
        // Test decay exemption
        let result = gov.apply_decay("did:icn:exempt", 0.1).await;
        assert!(result.is_ok());
        assert_eq!(gov.get_reputation("did:icn:exempt").await.unwrap(), 100);
    }

    #[tokio::test]
    async fn test_voting_edge_cases() {
        let gov = GovernanceService::new(db_pool).await;

        // Test vote after period ends
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 0).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", true).await;
        assert!(matches!(result, Err(GovernanceError::VotingPeriodEnded(_))));

        // Test double voting
        let proposal = gov.create_proposal("Test", "Description", "did:icn:test", 3600).await.unwrap();
        gov.vote(&proposal.id, "did:icn:voter", true).await.unwrap();
        let result = gov.vote(&proposal.id, "did:icn:voter", false).await;
        assert!(matches!(result, Err(GovernanceError::AlreadyVoted(_))));
    }
}
```

===================
File: ./crates/icn-identity/src/lib.rs
Size: 1952 bytes
===================
```rs
pub mod ledger {
    use crate::VerifiableCredential;
    
    /// Create an identity in the ledger
    pub async fn create_identity_in_ledger(identity: &str, _credential: &VerifiableCredential) -> Result<(), String> {
        println!("Creating identity in ledger: {}", identity);
        Ok(())
    }
    
    /// Get identity from the ledger
    pub async fn get_identity_from_ledger(identity: &str) -> Result<String, String> {
        println!("Getting identity from ledger: {}", identity);
        Ok(identity.to_string())
    }
    
    /// Rotate a key in the ledger
    pub async fn rotate_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Rotating key in ledger: {}", identity);
        Ok(())
    }
    
    /// Revoke a key in the ledger
    pub async fn revoke_key_in_ledger(identity: &str) -> Result<(), String> {
        println!("Revoking key in ledger: {}", identity);
        Ok(())
    }
    
    /// Apply reputation decay in the ledger
    pub async fn apply_reputation_decay_in_ledger(did: &str, decay_rate: f64) -> Result<(), String> {
        println!("Applying reputation decay to {}: {}", did, decay_rate);
        Ok(())
    }
    
    /// Handle sybil resistance in the ledger
    pub async fn handle_sybil_resistance_in_ledger(did: &str, reputation_score: i64) -> Result<(), String> {
        println!("Handling sybil resistance for {}: {}", did, reputation_score);
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct VerifiableCredential {
    pub credential_type: String,
    pub issuer_did: String,
    pub subject_did: String,
    pub issuance_date: String,
    pub expiration_date: Option<String>,
    pub credential_status: Option<String>,
    pub credential_schema: Option<String>,
    pub proof: Proof,
}

#[derive(Debug, Clone)]
pub struct Proof {
    pub type_: String,
    pub created: String,
    pub proof_purpose: String,
    pub verification_method: String,
    pub jws: String,
}```

===================
File: ./crates/icn-mutual-credit/src/lib.rs
Size: 2294 bytes
===================
```rs
use std::collections::HashMap;
use chrono::Utc;
use serde::{Serialize, Deserialize};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64,
    pub signature: String,
    pub timestamp: i64,
}

pub struct MutualCreditLedger {
    // Maps member DID to current credit balance.
    pub balances: HashMap<String, i64>,
    // Ordered list of all mutual credit transactions.
    pub history: Vec<MutualCreditTransaction>,
}

impl MutualCreditLedger {
    pub fn new() -> Self {
        Self {
            balances: HashMap::new(),
            history: Vec::new(),
        }
    }

    // Process a new mutual credit transaction.
    pub fn process_transaction(&mut self, tx: MutualCreditTransaction) -> Result<(), String> {
        // Verify sender signature
        if !Self::verify_signature(&tx.sender_did, &tx.signature, tx.amount) {
            return Err("Invalid signature".into());
        }
        // Update sender and receiver balances
        *self.balances.entry(tx.sender_did.clone()).or_insert(0) -= tx.amount;
        *self.balances.entry(tx.receiver_did.clone()).or_insert(0) += tx.amount;
        // Append to history
        self.history.push(tx);
        Ok(())
    }

    // Verify signature using icn-crypto
    fn verify_signature(did: &str, signature: &str, amount: i64) -> bool {
        // Retrieve public key from IdentityService (placeholder)
        let public_key = vec![]; // Replace with actual public key retrieval logic
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        key_pair.verify(amount.to_string().as_bytes(), signature.as_bytes())
    }

    // Get balance summary for a member
    pub fn get_balance(&self, did: &str) -> i64 {
        *self.balances.get(did).unwrap_or(&0)
    }

    // Print simple ledger summary (for logging)
    pub fn print_summary(&self) {
        for (did, balance) in &self.balances {
            println!("Member {}: Balance {}", did, balance);
        }
    }
}
```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 168 bytes
===================
```rs
pub mod websocket;
pub mod protocol;
pub mod networking;
pub mod sdp;

// Re-export necessary types
pub use x25519_dalek::PublicKey;
pub use sdp::SDPManager;

```

===================
File: ./crates/icn-reputation/src/lib.rs
Size: 2471 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use icn_zkp::zk_snark;
use std::sync::Arc;
use async_trait::async_trait;
use icn_types::ReputationError;
use icn_storage::StorageInterface;

#[derive(Debug, Serialize, Deserialize)]
pub struct ReputationScore {
    pub score: i64,
}

impl ReputationScore {
    pub fn generate_proof(&self) -> Vec<u8> {
        // Generate zk-SNARK proof for the reputation score
        zk_snark::generate_proof(self.score)
    }

    pub fn verify_proof(proof: &[u8], expected_score: i64) -> bool {
        // Verify zk-SNARK proof for the reputation score
        zk_snark::verify_proof(proof, expected_score)
    }
}

#[async_trait::async_trait]
pub trait ReputationInterface: Send + Sync {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError>;
    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError>;
    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError>;
}

pub struct ReputationManager {
    store: Arc<dyn StorageInterface>,
}

impl ReputationManager {
    pub fn new(store: Arc<dyn StorageInterface>) -> Self {
        Self { store }
    }
}

#[async_trait::async_trait]
impl ReputationInterface for ReputationManager {
    async fn update_reputation(&self, member_id: &str, delta: i64) -> Result<(), ReputationError> {
        let current = self.get_reputation(member_id).await.unwrap_or(0);
        let new_score = current + delta;
        
        self.store.store(&format!("reputation:{}", member_id), &new_score.to_le_bytes())
            .await
            .map_err(|e| ReputationError { message: e.to_string() })
    }

    async fn get_reputation(&self, member_id: &str) -> Result<i64, ReputationError> {
        match self.store.get(&format!("reputation:{}", member_id)).await {
            Ok(bytes) => {
                let score = i64::from_le_bytes(bytes.try_into().map_err(|_| ReputationError {
                    message: "Invalid reputation data format".to_string()
                })?);
                Ok(score)
            }
            Err(_) => Ok(0) // New members start with 0 reputation
        }
    }

    async fn validate_reputation(&self, member_id: &str, min_required: i64) -> Result<bool, ReputationError> {
        let current = self.get_reputation(member_id).await?;
        Ok(current >= min_required)
    }
}
```

===================
File: ./crates/icn-resource/src/lib.rs
Size: 6916 bytes
===================
```rs
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use icn_federation::ResourceManager;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub resource_type: String,
    pub owner: String,
    pub total_amount: u64,
    pub available_amount: u64,
    pub price_per_unit: f64,
    pub constraints: ResourceConstraints,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceConstraints {
    pub min_reputation: i64,
    pub max_allocation: u64,
    pub time_limit: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationResourcePool {
    pub federation_id: String,
    pub resources: HashMap<String, Resource>,
    pub access_control: FederationAccessControl,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationAccessControl {
    pub allowed_federations: Vec<String>,
    pub min_reputation: i64,
    pub max_allocation_per_federation: u64,
}

pub struct ResourceAllocationSystem {
    resources: Arc<RwLock<HashMap<String, Resource>>>,
    allocations: Arc<RwLock<HashMap<String, Vec<ResourceAllocation>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    pub allocation_id: String,
    pub resource_id: String,
    pub recipient: String,
    pub amount: u64,
    pub allocated_at: u64,
    pub expires_at: Option<u64>,
}

impl ResourceAllocationSystem {
    pub fn new() -> Self {
        Self {
            resources: Arc::new(RwLock::new(HashMap::new())),
            allocations: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn register_resource(
        &self,
        owner: String,
        resource_type: String,
        amount: u64,
        price: f64,
        constraints: ResourceConstraints,
    ) -> Result<String, ResourceError> {
        let resource_id = format!("res_{}", uuid::Uuid::new_v4());
        let resource = Resource {
            id: resource_id.clone(),
            resource_type,
            owner,
            total_amount: amount,
            available_amount: amount,
            price_per_unit: price,
            constraints,
        };

        let mut resources = self.resources.write().await;
        resources.insert(resource_id.clone(), resource);

        Ok(resource_id)
    }

    pub async fn allocate(
        &self,
        resource_id: &str,
        recipient: String,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        let resource = resources.get_mut(resource_id)
            .ok_or(ResourceError::ResourceNotFound)?;

        if resource.available_amount < amount {
            return Err(ResourceError::InsufficientResources);
        }

        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        let allocation = ResourceAllocation {
            allocation_id: allocation_id.clone(),
            resource_id: resource_id.to_string(),
            recipient,
            amount,
            allocated_at: chrono::Utc::now().timestamp() as u64,
            expires_at: None,
        };

        resource.available_amount -= amount;

        let mut allocations = self.allocations.write().await;
        allocations.entry(resource_id.to_string())
            .or_insert_with(Vec::new)
            .push(allocation);

        Ok(allocation_id)
    }

    pub async fn release(
        &self,
        allocation_id: &str,
    ) -> Result<(), ResourceError> {
        let mut allocations = self.allocations.write().await;
        for (resource_id, resource_allocations) in allocations.iter_mut() {
            if let Some(index) = resource_allocations.iter().position(|alloc| alloc.allocation_id == allocation_id) {
                let allocation = resource_allocations.remove(index);
                let mut resources = self.resources.write().await;
                if let Some(resource) = resources.get_mut(&allocation.resource_id) {
                    resource.available_amount += allocation.amount;
                }
                return Ok(());
            }
        }
        Err(ResourceError::InvalidAllocation)
    }

    pub async fn adjust_price(
        &self,
        resource_id: &str,
        new_price: f64,
    ) -> Result<(), ResourceError> {
        let mut resources = self.resources.write().await;
        if let Some(resource) = resources.get_mut(resource_id) {
            resource.price_per_unit = new_price;
            Ok(())
        } else {
            Err(ResourceError::ResourceNotFound)
        }
    }

    pub async fn create_federation_pool(
        &self,
        federation_id: String,
        access_control: FederationAccessControl,
    ) -> Result<(), ResourceError> {
        let pool = FederationResourcePool {
            federation_id: federation_id.clone(),
            resources: HashMap::new(),
            access_control,
        };
        
        let mut resources = self.resources.write().await;
        resources.insert(federation_id, pool);
        Ok(())
    }

    pub async fn share_with_federation(
        &self,
        source_federation: &str,
        target_federation: &str, 
        resource_id: &str,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut resources = self.resources.write().await;
        
        // Verify federation access permissions
        let source_pool = resources.get(source_federation)
            .ok_or(ResourceError::ResourceNotFound)?;
            
        if !source_pool.access_control.allowed_federations.contains(&target_federation.to_string()) {
            return Err(ResourceError::UnauthorizedAction);
        }

        // Create allocation record
        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        
        // Allocate resources to target federation
        self.allocate(resource_id, target_federation.to_string(), amount).await?;

        Ok(allocation_id)
    }
}

#[async_trait]
impl ResourceManager for ResourceAllocationSystem {
    async fn allocate_resources(&self, allocation: icn_federation::ResourceAllocation) -> Result<(), String> {
        self.allocate(&allocation.resource_type, allocation.recipient, allocation.amount)
            .await
            .map_err(|e| e.to_string())
    }

    async fn release_resources(&self, resource_type: &str, amount: u64) -> Result<(), String> {
        // Implementation for releasing resources back to the pool
        Ok(())
    }
}

#[derive(Debug)]
pub enum ResourceError {
    ResourceNotFound,
    InsufficientResources,
    InvalidAllocation,
    UnauthorizedAction,
}
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 7207 bytes
===================
```rs
use async_trait::async_trait;
use icn_types::{
    Block, Transaction, RuntimeError, RuntimeResult, ExecutionContext,
    ValidationNode, GovernanceNode, MarketplaceNode, Check, StateValidation,
    RuntimeConfig
};
use icn_dsl::CoopLangAST;
use tracing::{info, warn, error};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::collections::HashMap;

/// Runtime interface trait for blockchain execution
#[async_trait]
pub trait VM {
    /// Executes a single transaction
    async fn execute_transaction(&self, transaction: Transaction) -> RuntimeResult<()>;
    
    /// Executes all transactions in a block
    async fn execute_block(&self, block: Block) -> RuntimeResult<()>;
}

/// Contract execution handler
pub struct ContractExecution {
    /// Map of contract addresses to their byte code
    contracts: HashMap<String, Vec<u8>>,
    /// Storage for contract state
    state: HashMap<String, Vec<u8>>,
    /// Maximum gas allowed for execution
    max_gas: u64,
}

impl ContractExecution {
    /// Create a new contract execution environment
    pub fn new(max_gas: u64) -> Self {
        Self {
            contracts: HashMap::new(),
            state: HashMap::new(),
            max_gas,
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        if self.contracts.contains_key(&address) {
            return Err("Contract already exists at this address".to_string());
        }
        self.contracts.insert(address, bytecode);
        Ok(())
    }
    
    /// Execute a contract call
    pub async fn execute_contract_call(&mut self, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        if gas > self.max_gas {
            return Err("Gas limit exceeded".to_string());
        }
        
        let contract = self.contracts.get(address).ok_or("Contract not found")?;
        
        // In a real implementation, this would actually execute the bytecode
        // For testing purposes, we just return a dummy result
        Ok(vec![1, 2, 3])
    }
}

/// Runtime manager for handling contract execution
pub struct RuntimeManager {
    /// Execution environment
    execution: ContractExecution,
    /// Map of transaction hashes to execution results
    results: HashMap<String, Vec<u8>>,
}

impl RuntimeManager {
    /// Create a new runtime manager
    pub fn new(max_gas: u64) -> Self {
        Self {
            execution: ContractExecution::new(max_gas),
            results: HashMap::new(),
        }
    }
    
    /// Deploy a new contract
    pub fn deploy_contract(&mut self, address: String, bytecode: Vec<u8>) -> Result<(), String> {
        self.execution.deploy_contract(address, bytecode)
    }
    
    /// Execute a transaction
    pub async fn execute_transaction(&mut self, tx_hash: String, address: &str, input: &[u8], gas: u64) -> Result<Vec<u8>, String> {
        let result = self.execution.execute_contract_call(address, input, gas).await?;
        self.results.insert(tx_hash, result.clone());
        Ok(result)
    }
    
    /// Get transaction result
    pub fn get_transaction_result(&self, tx_hash: &str) -> Option<&Vec<u8>> {
        self.results.get(tx_hash)
    }
}

#[async_trait]
pub trait ValidationExecutor {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()>;
    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()>;
}

#[async_trait]
impl ValidationExecutor for RuntimeManager {
    async fn execute_validation_rules(&self, validation: &ValidationNode, context: &ExecutionContext) -> RuntimeResult<()> {
        // Execute pre-checks
        for check in &validation.pre_checks {
            info!("Executing pre-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        // Validate state if specified
        if let Some(state_validation) = &validation.state_validation {
            info!("Validating state");
            self.validate_state(state_validation, context).await?;
        }

        // Execute post-checks
        for check in &validation.post_checks {
            info!("Executing post-check: {}", check.condition);
            self.execute_check(check, context).await?;
        }

        Ok(())
    }

    async fn execute_check(&self, check: &Check, context: &ExecutionContext) -> RuntimeResult<()> {
        let condition_result = self.evaluate_condition(&check.condition, context).await?;
        if !condition_result {
            error!("Check failed: {}", check.action);
            return Err(RuntimeError::ValidationFailed(check.action.clone()));
        }
        Ok(())
    }

    async fn validate_state(&self, validation: &StateValidation, context: &ExecutionContext) -> RuntimeResult<()> {
        let current_state = self.get_current_state(context).await?;

        // Validate current state if specified
        if let Some(expected_current) = &validation.current {
            if current_state != *expected_current {
                error!("Invalid state. Expected: {}, Found: {}", expected_current, current_state);
                return Err(RuntimeError::InvalidState);
            }
        }

        // Validate expected state transitions
        if let Some(expected) = &validation.expected {
            if !validation.transitions.contains(expected) {
                error!("Invalid state transition to: {}", expected);
                return Err(RuntimeError::InvalidState);
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use icn_types::{Block, Transaction};

    #[tokio::test]
    async fn test_runtime_initialization() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        assert!(runtime.dsl_context.is_none());
    }

    #[tokio::test]
    async fn test_validation_rules() {
        let config = RuntimeConfig {
            vm_type: "test".to_string(),
            max_execution_time: 1000,
            max_memory: 1024 * 1024,
            enable_debugging: true,
            log_level: "debug".to_string(),
        };
        
        let runtime = RuntimeManager::new(config);
        
        let context = ExecutionContext {
            transaction: None,
            block: None,
            state: HashMap::new(),
            metadata: HashMap::new(),
        };

        let validation = ValidationNode {
            pre_checks: vec![
                Check {
                    condition: "true".to_string(),
                    action: "test".to_string(),
                }
            ],
            post_checks: vec![],
            state_validation: None,
        };

        runtime.execute_validation_rules(&validation, &context).await.unwrap();
    }
}
```

===================
File: ./crates/icn-storage/src/lib.rs
Size: 6298 bytes
===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Serialize, Deserialize};
use icn_types::{StorageError, StorageResult, StorageBackend, StorageConfig};
use std::time::Duration;
use ipfs_api_backend_actix::{IpfsClient, TryFromUri};
use futures::TryStreamExt;

mod cache;
use cache::StorageCache;

/// Errors that can occur in storage operations
#[derive(Error, Debug)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
}

/// Represents the result of storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Core storage interface for the system
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    
    /// Retrieve a value by key
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Manages persistent storage for the system
pub struct StorageManager {
    backend: Arc<Mutex<Box<dyn StorageBackend>>>,
    cache: Arc<StorageCache>,
    ipfs_client: IpfsClient,
}

impl StorageManager {
    /// Create a new storage manager with the given backend and configuration
    pub fn new(backend: Box<dyn StorageBackend>, config: StorageConfig) -> Self {
        Self {
            backend: Arc::new(Mutex::new(backend)),
            cache: Arc::new(StorageCache::new(
                config.cache_size,
                Duration::from_secs(config.cache_ttl_seconds)
            )),
            ipfs_client: IpfsClient::from_str(&config.ipfs_url).expect("Invalid IPFS URL"),
        }
    }
    
    /// Store a serializable value
    pub async fn store<T: Serialize>(&self, key: &str, value: &T) -> StorageResult<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| StorageError::SerializationError(e.to_string()))?;
            
        // Update backend
        let backend = self.backend.lock().await;
        backend.set(key, &serialized).await?;
        
        // Update cache
        self.cache.set(key.to_string(), serialized);
        
        Ok(())
    }
    
    /// Retrieve and deserialize a value
    pub async fn retrieve<T: for<'de> Deserialize<'de>>(&self, key: &str) -> StorageResult<T> {
        // Try cache first
        if let Some(cached_data) = self.cache.get(key) {
            return serde_json::from_slice(&cached_data)
                .map_err(|e| StorageError::SerializationError(e.to_string()));
        }

        // Fall back to backend
        let backend = self.backend.lock().await;
        let data = backend.get(key).await?;
        
        // Update cache
        self.cache.set(key.to_string(), data.clone());
        
        serde_json::from_slice(&data)
            .map_err(|e| StorageError::SerializationError(e.to_string()))
    }
    
    /// Delete a stored value
    pub async fn remove(&self, key: &str) -> StorageResult<()> {
        let backend = self.backend.lock().await;
        backend.delete(key).await
    }
    
    /// Check if a key exists in storage
    pub async fn has_key(&self, key: &str) -> StorageResult<bool> {
        let backend = self.backend.lock().await;
        backend.exists(key).await
    }

    /// Store data using IPFS
    pub async fn store_ipfs(&self, data: &[u8]) -> StorageResult<String> {
        let result = self.ipfs_client.add(data).await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(result.hash)
    }

    /// Retrieve data from IPFS
    pub async fn retrieve_ipfs(&self, hash: &str) -> StorageResult<Vec<u8>> {
        let data = self.ipfs_client.cat(hash).map_ok(|chunk| chunk.to_vec()).try_concat().await
            .map_err(|e| StorageError::IpfsError(e.to_string()))?;
        Ok(data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Mock storage backend for testing
    struct MockStorage {
        data: HashMap<String, Vec<u8>>,
    }
    
    #[async_trait::async_trait]
    impl StorageBackend for MockStorage {
        async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
            self.data.insert(key.to_string(), value.to_vec());
            Ok(())
        }
        
        async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
            self.data.get(key)
                .cloned()
                .ok_or_else(|| StorageError::NotFound(key.to_string()))
        }
        
        async fn delete(&self, key: &str) -> StorageResult<()> {
            self.data.remove(key);
            Ok(())
        }
        
        async fn exists(&self, key: &str) -> StorageResult<bool> {
            Ok(self.data.contains_key(key))
        }
    }
    
    #[tokio::test]
    async fn test_basic_storage_operations() {
        let config = StorageConfig {
            backend_type: "mock".to_string(),
            cache_size: 1000,
            cache_ttl_seconds: 300,
            ipfs_url: "http://localhost:5001".to_string(),
            database_url: None,
        };
        
        let storage = StorageManager::new(
            Box::new(MockStorage { data: HashMap::new() }),
            config
        );

        // Test store and retrieve
        let key = "test_key";
        let value = "test_value";
        storage.store(key, &value).await.unwrap();
        
        let retrieved: String = storage.retrieve(key).await.unwrap();
        assert_eq!(retrieved, value);
        
        // Test exists
        assert!(storage.has_key(key).await.unwrap());
        
        // Test delete
        storage.remove(key).await.unwrap();
        assert!(!storage.has_key(key).await.unwrap());
    }
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 33812 bytes
===================
```rs
//! Core types for the ICN (Inter-Cooperative Network) system
//! 
//! This crate provides the fundamental types used across all ICN modules.
//! It serves as a central repository for shared data structures, ensuring
//! consistency across the codebase.

use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use tokio::task;
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;
use thiserror::Error;
use async_trait::async_trait;

mod errors;
pub use errors::{IcnError, IcnResult, log_error};

#[derive(Debug, Error)]
pub enum BlockError {
    #[error("Invalid block index")]
    InvalidIndex,
    #[error("Invalid previous hash")]
    InvalidPreviousHash,
    #[error("Invalid transaction")]
    InvalidTransaction,
    #[error("Invalid proposer")]
    InvalidProposer,
    #[error("Consensus error")]
    ConsensusError,
    #[error("Database error")]
    DatabaseError,
}

#[derive(Debug)]
pub struct ResourceDebt {
    pub cpu_debt: u64,
    pub memory_debt: u64,
    pub bandwidth_debt: u64,
}

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u64,
    pub transactions: Vec<Transaction>,
    pub hash: String,
    pub proposer: String,
    pub metadata: BlockMetadata,
    pub signatures: Vec<BlockSignature>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    pub validator_did: String,
    pub signature: String,
    pub timestamp: DateTime<Utc>,
    pub voting_power: f64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub height: u64,
    pub state_root: String,
    pub transaction_root: String,
    pub consensus_data: HashMap<String, String>,
    pub validator_signatures: Vec<String>,
    pub consensus_duration_ms: u64,
    pub validator_count: u32,
    pub total_voting_power: f64,
    pub size: u64,
    pub resources_used: u64,
    pub relationship_updates: Option<RelationshipMetadata>,
    pub fault_tolerance: Option<u32>,
}

impl Default for BlockMetadata {
    fn default() -> Self {
        Self {
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            size: 0,
            resources_used: 0,
            relationship_updates: None,
            fault_tolerance: None,
        }
    }
}

impl BlockMetadata {
    pub fn with_bft_info(&mut self, quorum_size: u32, fault_tolerance: u32) {
        self.validator_count = quorum_size;
        self.fault_tolerance = Some(fault_tolerance);
        self.consensus_duration_ms = 0; // Will be set during finalization
    }

    pub fn is_bft_valid(&self) -> bool {
        if let Some(fault_tolerance) = self.fault_tolerance {
            // Check if we have enough validators (3f + 1)
            self.validator_count >= (fault_tolerance * 3) + 1
        } else {
            false
        }
    }
}

/// Metadata specific to relationship transactions in the block
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RelationshipMetadata {
    pub contribution_count: u32,
    pub mutual_aid_count: u32,
    pub endorsement_count: u32,
    pub relationship_update_count: u32,
    pub total_participants: u32,
    pub unique_cooperatives: Vec<String>,
}

lazy_static! {
    static ref TRANSACTION_CACHE: Mutex<HashMap<String, bool>> = {
        let m = HashMap::new();
        Mutex::new(m)
    };
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let relationship_metadata = Self::calculate_relationship_metadata(&transactions);
        let resources_used = transactions.iter().map(|tx| tx.resource_cost).sum();

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            resources_used,
            size: 0,
            relationship_updates: relationship_metadata,
            fault_tolerance: None,
            height: 0,
            state_root: String::new(),
            transaction_root: String::new(),
            consensus_data: HashMap::new(),
            validator_signatures: Vec::new(),
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            metadata,
            signatures: Vec::new(),
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        for tx in &self.transactions {
            if let Ok(tx_json) = serde_json::to_string(tx) {
                hasher.update(tx_json);
            }
        }
        
        hasher.update(&self.proposer);
        
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub async fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        let signature_task = task::spawn(async move {
            BlockSignature {
                validator_did,
                signature,
                timestamp: Utc::now(),
                voting_power,
            }
        });

        let new_signature = signature_task.await.unwrap();
        self.signatures.push(new_signature);

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub async fn verify(&self, previous_block: Option<&Block>) -> Result<(), BlockError> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify previous block linkage
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err(BlockError::InvalidPreviousHash);
            }
            if self.index != prev.index + 1 {
                return Err(BlockError::InvalidIndex);
            }
            if self.timestamp <= prev.timestamp {
                return Err(BlockError::InvalidTransaction);
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err(BlockError::InvalidTransaction);
        }

        // Validate transactions
        self.validate_transactions().await?;

        // Verify resource usage
        let calculated_resources: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
        if calculated_resources != self.metadata.resources_used {
            return Err(BlockError::InvalidTransaction);
        }

        // Verify relationship metadata
        let calculated_metadata = Self::calculate_relationship_metadata(&self.transactions);
        if calculated_metadata != self.metadata.relationship_updates {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Validates the transactions in the block
    async fn validate_transactions(&self) -> Result<(), BlockError> {
        for tx in &self.transactions {
            let mut cache = TRANSACTION_CACHE.lock().unwrap();
            
            // Check if transaction is already processed
            if cache.contains_key(&tx.hash) {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Validate the transaction
            if !tx.validate() {
                return Err(BlockError::InvalidTransaction);
            }
            
            // Add to cache
            cache.insert(tx.hash.clone(), true);
        }
        Ok(())
    }

    /// Calculates metadata for relationship transactions in the block
    fn calculate_relationship_metadata(transactions: &[Transaction]) -> Option<RelationshipMetadata> {
        let mut metadata = RelationshipMetadata {
            contribution_count: 0,
            mutual_aid_count: 0,
            endorsement_count: 0,
            relationship_update_count: 0,
            total_participants: 0,
            unique_cooperatives: Vec::new(),
        };

        let mut participants = std::collections::HashSet::new();

        for tx in transactions {
            match &tx.transaction_type {
                TransactionType::RecordContribution { .. } => {
                    metadata.contribution_count += 1;
                    participants.insert(tx.sender.clone());
                }
                TransactionType::RecordMutualAid { receiver, .. } => {
                    metadata.mutual_aid_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(receiver.clone());
                }
                TransactionType::UpdateRelationship { member_two, .. } => {
                    metadata.relationship_update_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(member_two.clone());
                }
                TransactionType::AddEndorsement { to_did, .. } => {
                    metadata.endorsement_count += 1;
                    participants.insert(tx.sender.clone());
                    participants.insert(to_did.clone());
                }
                _ => {}
            }
        }

        metadata.total_participants = participants.len() as u32;

        Some(metadata)
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.resources_used = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
    }

    /// Gets the total resources used by all transactions in the block
    pub fn total_resources_used(&self) -> u64 {
        self.metadata.resources_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }

    /// Finalizes the block and ensures all validations pass
    pub async fn finalize(&mut self) -> Result<(), BlockError> {
        self.verify(None).await?;
        
        let resource_usage: u64 = self.transactions.iter()
            .map(|tx| tx.resource_cost)
            .sum();
            
        self.metadata.resources_used = resource_usage;
        
        self.metadata.size = bincode::serialize(&self)
            .map_err(|_| BlockError::InvalidTransaction)?
            .len() as u64;
            
        self.hash = self.calculate_hash();

        Ok(())
    }

    /// Initiates a consensus round among the validators
    pub async fn start_consensus_round(&mut self) -> Result<(), BlockError> {
        // Simulate consensus process
        let validator = "validator1";
        let signature = format!("signature_of_{}", validator);
        
        if !self.add_signature(validator.to_string(), signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    /// Records a validator's vote on the block
    pub async fn vote_on_block(&mut self, validator_did: String, vote: bool) -> Result<(), BlockError> {
        if !vote {
            return Err(BlockError::InvalidTransaction);
        }

        let signature = "signature".to_string(); // In real implementation, this would be a proper signature
        
        if !self.add_signature(validator_did, signature, 1.0).await {
            return Err(BlockError::InvalidTransaction);
        }

        Ok(())
    }

    pub fn update_validator_metadata(&mut self, validator: String, reputation: i64) {
        let validator_meta = BlockSignature {
            validator_did: validator,
            signature: String::new(),
            timestamp: Utc::now(),
            voting_power: reputation as f64,
        };
        self.signatures.push(validator_meta);
        
        // Update validator count and total voting power
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    // Resource transfer between members
    Transfer {
        receiver: String,
        amount: u64,
    },
    
    // Smart contract execution
    ContractExecution {
        contract_id: String,
        input_data: std::collections::HashMap<String, i64>,
    },
    
    // Relationship management
    RecordContribution {
        description: String,
        impact_story: String,
        context: String,
        tags: Vec<String>,
    },
    
    RecordMutualAid {
        receiver: String,
        description: String,
        impact_story: Option<String>,
        reciprocity_notes: Option<String>,
        tags: Vec<String>,
    },
    
    UpdateRelationship {
        member_two: String,
        relationship_type: String,
        story: String,
        interaction: Option<String>,
    },
    
    AddEndorsement {
        to_did: String,
        content: String,
        context: String,
        skills: Vec<String>,
    },
}

impl TransactionType {
    pub fn as_str(&self) -> &str {
        match self {
            TransactionType::Transfer { .. } => "Transfer",
            TransactionType::ContractExecution { .. } => "ContractExecution",
            TransactionType::RecordContribution { .. } => "RecordContribution",
            TransactionType::RecordMutualAid { .. } => "RecordMutualAid",
            TransactionType::UpdateRelationship { .. } => "UpdateRelationship",
            TransactionType::AddEndorsement { .. } => "AddEndorsement",
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub id: String,
    pub sender: String,
    pub receiver: String,
    pub amount: u64,
    pub transaction_type: TransactionType,
    pub timestamp: i64,
    pub hash: String,
    pub signature: Option<String>,
    pub resource_cost: u64,
    pub resource_priority: u8,
    pub zk_snark_proof: Option<String>,
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos();

        let receiver = match &transaction_type {
            TransactionType::Transfer { receiver, .. } => receiver.clone(),
            TransactionType::RecordMutualAid { receiver, .. } => receiver.clone(),
            TransactionType::UpdateRelationship { member_two, .. } => member_two.clone(),
            TransactionType::AddEndorsement { to_did, .. } => to_did.clone(),
            _ => String::new(),
        };

        let amount = match &transaction_type {
            TransactionType::Transfer { amount, .. } => *amount,
            _ => 0,
        };

        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);
        let resource_cost = Self::calculate_resource_cost(&transaction_type);

        Transaction {
            id: String::new(),
            sender,
            receiver,
            amount,
            transaction_type,
            timestamp: timestamp as i64,
            hash,
            signature: None,
            resource_cost,
            resource_priority: 5, // Default priority
            zk_snark_proof: None,
        }
    }

    pub fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                format!("Contribution:{}:{}:{}:{:?}", description, impact_story, context, tags)
            },
            TransactionType::RecordMutualAid { receiver, description, impact_story, reciprocity_notes, tags } => {
                format!("MutualAid:{}:{}:{:?}:{:?}:{:?}", receiver, description, impact_story, reciprocity_notes, tags)
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, interaction } => {
                format!("Relationship:{}:{}:{}:{:?}", member_two, relationship_type, story, interaction)
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                format!("Endorsement:{}:{}:{}:{:?}", to_did, content, context, skills)
            },
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    pub fn calculate_resource_cost(transaction_type: &TransactionType) -> u64 {
        match transaction_type {
            TransactionType::Transfer { amount, .. } => {
                100 + (amount / 100)
            },
            TransactionType::ContractExecution { input_data, .. } => {
                200 + (input_data.len() as u64 * 10)
            },
            TransactionType::RecordContribution { description, impact_story, tags, .. } => {
                let content_length = (description.len() + impact_story.len()) as u64;
                50 + (content_length / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::RecordMutualAid { description, tags, .. } => {
                75 + (description.len() as u64 / 100) + (tags.len() as u64 * 5)
            },
            TransactionType::UpdateRelationship { story, .. } => {
                100 + (story.len() as u64 / 100)
            },
            TransactionType::AddEndorsement { content, skills, .. } => {
                   60 + (content.len() as u64 / 100) + (skills.len() as u64 * 10)
            },
        }
    }

    pub fn validate(&self) -> bool {
        if self.sender.is_empty() {
            return false;
        }
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0 && self.sender != *receiver
            },
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            },
            TransactionType::RecordContribution { description, impact_story, context, tags } => {
                !description.is_empty() && !impact_story.is_empty() && !context.is_empty() && !tags.is_empty()
            },
            TransactionType::RecordMutualAid { receiver, description, tags, .. } => {
                !receiver.is_empty() && !description.is_empty() && !tags.is_empty()
            },
            TransactionType::UpdateRelationship { member_two, relationship_type, story, .. } => {
                !member_two.is_empty() && !relationship_type.is_empty() && !story.is_empty()
            },
            TransactionType::AddEndorsement { to_did, content, context, skills } => {
                !to_did.is_empty() && !content.is_empty() && !context.is_empty() && !skills.is_empty()
            },
        }
    }

    pub fn set_priority(&mut self, priority: u8) {
        self.resource_priority = priority.min(10);
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp as u128
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap_or_else(|_| Vec::new())
    }
    
    pub fn get_zk_snark_inputs(&self) -> Vec<u8> {
        // A simple implementation that concatenates transaction data
        let mut inputs = Vec::new();
        inputs.extend_from_slice(self.sender.as_bytes());
        inputs.extend_from_slice(self.receiver.as_bytes());
        inputs.extend_from_slice(&self.amount.to_le_bytes());
        inputs.extend_from_slice(self.hash.as_bytes());
        inputs
    }
}

#[derive(Debug, Clone)]
pub struct AuthError(String);

impl std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for AuthError {}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistryTransaction {
    pub registry_data: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AttestMembershipTransaction {
    pub member_did: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64, // positive value; sender's balance decreases and receiver's increases
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceTransaction {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceTransaction {
    pub resource_id: String,
    pub operation: String,
    pub metadata: String,
    pub did_proof: DidProof,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidProof {
    pub did: String,
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ElectionTransaction {
    pub candidate_id: String,
    pub votes: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VoteProposal {
    pub proposal_id: String,
    pub initiator_did: String,
    pub signature: String,
    pub description: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub voter_did: String,
    pub proposal_id: String,
    pub approve: bool,
    pub signature: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistry;

impl DidRegistry {
    pub fn new() -> Self {
        DidRegistry
    }

    pub fn get_did(&self, _did: &str) -> Option<DidDocument> {
        // Placeholder implementation
        Some(DidDocument { is_verified: true })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidDocument {
    pub is_verified: bool,
}

impl Transaction {
    pub fn verify_did_signature(_did: &str, _signature: &str, _message: &str) -> Result<bool, AuthError> {
        Ok(true)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationType {
    Cooperative,
    Community,
    Hybrid
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationTerms {
    pub minimum_reputation: i64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationOperation {
    InitiateFederation {
        federation_type: FederationType,
        partner_id: String,
        terms: FederationTerms,
    },
    JoinFederation {
        federation_id: String,
        commitment: Vec<String>,
    },
    LeaveFederation {
        federation_id: String,
        reason: String,
    },
    ProposeAction {
        federation_id: String,
        action_type: String,
        description: String,
        resources: HashMap<String, u64>,
    },
    VoteOnProposal {
        federation_id: String,
        proposal_id: String,
        approve: bool,
        notes: Option<String>,
    },
    ShareResources {
        federation_id: String,
        resource_type: String,
        amount: u64,
        recipient_id: String,
    },
    UpdateFederationTerms {
        federation_id: String,
        new_terms: FederationTerms,
    },
}

/// Represents a unique identifier for a federation
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct FederationId(pub String);

/// Represents a unique identifier for a cooperative
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct CooperativeId(pub String);

/// Represents a member's identity within the system
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct MemberId {
    pub did: String,
    pub cooperative_id: CooperativeId,
}

/// Represents the status of a federation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationStatus {
    Active,
    Suspended,
    Inactive,
}

/// Represents a governance proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub proposer: MemberId,
    pub created_at: DateTime<Utc>,
    pub status: ProposalStatus,
    pub votes: HashMap<MemberId, VoteChoice>,
}

/// Represents the status of a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Draft,
    Active,
    Passed,
    Rejected,
    Executed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VoteChoice {
    Yes,
    No,
    Abstain,
}

/// Represents a member's reputation score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    pub member_id: MemberId,
    pub score: f64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

/// Represents a resource in the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub owner: CooperativeId,
    pub resource_type: String,
    pub metadata: HashMap<String, String>,
    pub availability: ResourceAvailability,
}

/// Represents the availability status of a resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResourceAvailability {
    Available,
    InUse,
    Maintenance,
    Offline,
}

/// Storage-related error types
#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Item not found: {0}")]
    NotFound(String),
    
    #[error("Invalid data: {0}")]
    InvalidData(String),
    
    #[error("IPFS error: {0}")]
    IpfsError(String),
    
    #[error("Storage reference already exists")]
    ReferenceAlreadyExists,
    
    #[error("Storage reference not found")]
    ReferenceNotFound,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageReference {
    pub id: String,
    pub storage_type: StorageType,
    pub location: String,
    pub status: StorageStatus,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageType {
    Local,
    Distributed,
    Cloud,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageStatus {
    Available,
    Unavailable,
    Syncing,
}

#[async_trait]
pub trait StorageBackend: Send + Sync {
    /// Store a value with the given key
    async fn store(&self, data: &[u8]) -> Result<String, StorageError>;
    
    /// Retrieve a value by key
    async fn retrieve(&self, id: &str) -> Result<Vec<u8>, StorageError>;
    
    /// Delete a value by key
    async fn delete(&self, key: &str) -> StorageResult<()>;
    
    /// Check if a key exists
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

/// Result type for storage operations
pub type StorageResult<T> = Result<T, StorageError>;

/// Storage configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub backend_type: String,
    pub cache_size: usize,
    pub cache_ttl_seconds: u64,
    pub ipfs_url: String,
    pub database_url: Option<String>,
}

/// Runtime-related error types
#[derive(Debug, thiserror::Error)]
pub enum RuntimeError {
    #[error("Validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Invalid state")]
    InvalidState,
    
    #[error("Execution error: {0}")]
    ExecutionError(String),
    
    #[error("DSL error: {0}")]
    DslError(String),
    
    #[error("Contract error: {0}")]
    ContractError(String),
}

impl From<RuntimeError> for IcnError {
    fn from(err: RuntimeError) -> Self {
        IcnError::RuntimeError(err.to_string())
    }
}

pub type RuntimeResult<T> = Result<T, RuntimeError>;

/// Represents the execution context for runtime operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub transaction: Option<Transaction>,
    pub block: Option<Block>,
    pub state: HashMap<String, Vec<u8>>,
    pub metadata: HashMap<String, String>,
}

/// Represents a validation check in the runtime
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Check {
    pub condition: String,
    pub action: String,
}

/// Represents state validation rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateValidation {
    pub current: Option<String>,
    pub expected: Option<String>,
    pub transitions: Vec<String>,
}

/// Represents a validation node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationNode {
    pub pre_checks: Vec<Check>,
    pub post_checks: Vec<Check>,
    pub state_validation: Option<StateValidation>,
}

/// Represents a governance node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceNode {
    pub rules: Vec<String>,
    pub voting_config: HashMap<String, String>,
    pub permissions: HashMap<String, Vec<String>>,
}

/// Represents a marketplace node in the DSL
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplaceNode {
    pub rules: Vec<String>,
    pub pricing_model: String,
    pub constraints: Vec<String>,
}

/// Runtime configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuntimeConfig {
    pub vm_type: String,
    pub max_execution_time: u64,
    pub max_memory: u64,
    pub enable_debugging: bool,
    pub log_level: String,
}

#[derive(Debug, Clone)]
pub struct ReputationError {
    pub message: String,
}

impl std::fmt::Display for ReputationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ReputationError {}

#[derive(Debug, Clone)]
pub struct ExecutionError {
    pub message: String,
}

impl std::fmt::Display for ExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ExecutionError {}

#[derive(Debug, Clone)]
pub struct ContractInput {
    pub contract_id: String,
    pub method: String,
    pub args: Vec<u8>,
}

#[async_trait::async_trait]
pub trait RuntimeInterface: Send + Sync {
    async fn execute_transaction(&self, transaction: &Transaction) -> Result<(), RuntimeError>;
    async fn execute_block(&self, block: &Block) -> Result<(), RuntimeError>;
    async fn execute_contract(&self, input: ContractInput) -> Result<Vec<u8>, ExecutionError>;
    async fn get_contract_state(&self, contract_id: &str) -> Result<Vec<u8>, ExecutionError>;
}
```

===================
File: ./crates/icn-zk/src/lib.rs
Size: 1853 bytes
===================
```rs
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use ff::PrimeField;
use serde::{Deserialize, Serialize};
use std::error::Error;

pub struct ProofOfCooperation<F: PrimeField> {
    pub reputation_score: Option<F>,
    pub cooperation_proof: Option<F>,
}

impl<F: PrimeField> Circuit<F> for ProofOfCooperation<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS
    ) -> Result<(), SynthesisError> {
        // Basic circuit implementation - to be expanded
        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RollupBatch {
    pub proposal_id: String,
    pub votes: Vec<Vote>,
    pub rollup_root: [u8; 32],
    pub proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
}

pub fn verify_proof(proof: &str) -> bool {
    // TODO: Implement actual zk-SNARK verification
    // For now, return true for testing
    true
}

pub fn generate_proof(_cs: &mut impl ConstraintSystem) -> Result<String, Box<dyn Error>> {
    // TODO: Implement actual proof generation
    Ok("dummy_proof".to_string())
}

#[derive(Debug)]
pub struct ProofCircuit {
    // Circuit parameters
    pub public_inputs: Vec<u64>,
    pub private_inputs: Vec<u64>,
}

pub trait ConstraintSystem {
    fn alloc(&mut self, value: Option<u64>) -> Result<Variable, Box<dyn Error>>;
    fn enforce(&mut self, lc0: LinearCombination, lc1: LinearCombination, lc2: LinearCombination);
}

#[derive(Clone, Debug)]
pub struct Variable(u32);

#[derive(Clone, Debug)]
pub struct LinearCombination {
    terms: Vec<(Variable, u64)>,
}

impl LinearCombination {
    pub fn zero() -> Self {
        LinearCombination { terms: Vec::new() }
    }

    pub fn add_assign(&mut self, var: Variable, coeff: u64) {
        self.terms.push((var, coeff));
    }
}
```

===================
File: ./crates/zk_snarks/src/lib.rs
Size: 446 bytes
===================
```rs
//! Mock implementation of ZK-SNARKs for integration testing

/// Verify a ZK-SNARK proof
/// 
/// This is a mock implementation that always returns true
pub fn verify_proof(proof: &str) -> bool {
    // In a real implementation, this would verify the proof
    println!("Verifying ZK-SNARK proof: {}", proof);
    true
}

/// Generate a dummy proof for testing
pub fn generate_test_proof() -> String {
    "dummy_proof_for_testing".to_string()
}```

===================
File: ./docker/backend/src/main.rs
Size: 45 bytes
===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./icn-consensus/src/lib.rs
Size: 1234 bytes
===================
```rs
// ...existing code...

// Define the structure for cooperative governance rules
struct GovernanceRules {
    max_validators: usize,
    min_stake: u64,
    election_period: u64,
    // ...other rules...
}

// Define the structure for a validator
struct Validator {
    id: String,
    stake: u64,
    // ...other properties...
}

// Define the structure for the genesis block
struct GenesisBlock {
    initial_validators: Vec<Validator>,
    // ...other properties...
}

// Function to enforce cooperative governance rules
fn enforce_governance_rules(validators: &mut Vec<Validator>, rules: &GovernanceRules) {
    // Implement rules to prevent centralized control
    // ...code to enforce rules...
}

// Function to finalize the genesis block format
fn finalize_genesis_block(validators: Vec<Validator>) -> GenesisBlock {
    GenesisBlock {
        initial_validators: validators,
        // ...initialize other properties...
    }
}

// Function to develop a validator election mechanism
fn elect_validators(current_validators: &Vec<Validator>, candidates: &Vec<Validator>, rules: &GovernanceRules) -> Vec<Validator> {
    // Implement democratic election mechanism
    // ...code to elect validators...
}

// ...existing code...
```

===================
File: ./identity/mod.rs
Size: 113 bytes
===================
```rs
pub mod did;
pub mod identity_system;

pub use did::creation::DID;
pub use identity_system::IdentitySystem;
```

===================
File: ./prototype/src/index.js
Size: 17929 bytes
===================
```js
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const WebSocket = require('ws');
const os = require('os');
const { spawn } = require('child_process');

// Initialize the logger
const winston = require('winston');
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ 
      filename: process.env.LOG_FILE || 'logs/icn-node.log' 
    })
  ]
});

// Load configuration
let config;
try {
  config = JSON.parse(fs.readFileSync(path.join(__dirname, '../config/node-config.json')));
  logger.info('Configuration loaded successfully');
} catch (error) {
  logger.error('Failed to load configuration:', error);
  process.exit(1);
}

// Load peer ID
let peerId;
try {
  peerId = JSON.parse(fs.readFileSync(path.join(__dirname, '../data/keys/peer-id.json')));
  logger.info(`Using peer ID: ${peerId.id}`);
} catch (error) {
  logger.error('Failed to load peer ID:', error);
  process.exit(1);
}

// Initialize state
const state = {
  nodeId: peerId.id,
  status: 'online',
  startTime: Date.now(),
  connectedPeers: new Map(),
  resources: JSON.parse(fs.readFileSync(path.join(__dirname, '../data/resources.json'))),
  workloads: new Map(),
  pendingMessages: new Map(),
  // Add federation management
  federations: new Map(),
  myFederations: new Set()
};

// Initialize Express app
const app = express();
app.use(cors());
app.use(bodyParser.json());

// API Routes
app.get('/api/status', (req, res) => {
  const uptime = Date.now() - state.startTime;
  res.json({
    id: state.nodeId,
    type: config.nodeType,
    status: state.status,
    uptime,
    connectedPeers: Array.from(state.connectedPeers.keys()),
    resources: {
      cpu: state.resources.cpu,
      memory: {
        total: state.resources.memory.total,
        free: os.freemem()
      }
    }
  });
});

app.get('/api/peers', (req, res) => {
  const peers = Array.from(state.connectedPeers.entries()).map(([id, info]) => ({
    id,
    address: info.address,
    connected: info.connected,
    lastSeen: info.lastSeen,
    nodeType: info.nodeType
  }));
  
  res.json(peers);
});

app.get('/api/workloads', (req, res) => {
  const workloads = Array.from(state.workloads.values());
  res.json(workloads);
});

app.post('/api/workloads', (req, res) => {
  const workload = {
    id: uuidv4(),
    type: req.body.type || 'container',
    command: req.body.command,
    status: 'pending',
    requirements: req.body.requirements || {},
    submittedAt: Date.now(),
    submittedBy: req.body.submittedBy || 'anonymous'
  };
  
  state.workloads.set(workload.id, workload);
  logger.info(`New workload submitted: ${workload.id}`);
  
  // In a real implementation, we'd dispatch this to the workload manager
  // For the prototype, we'll just simulate accepting it
  setTimeout(() => {
    const updatedWorkload = state.workloads.get(workload.id);
    if (updatedWorkload) {
      updatedWorkload.status = 'running';
      updatedWorkload.startedAt = Date.now();
      logger.info(`Workload ${workload.id} started`);
      
      // Simulate completion after some time
      setTimeout(() => {
        const finalWorkload = state.workloads.get(workload.id);
        if (finalWorkload) {
          finalWorkload.status = 'completed';
          finalWorkload.completedAt = Date.now();
          logger.info(`Workload ${workload.id} completed`);
        }
      }, 10000 + Math.random() * 5000);
    }
  }, 2000 + Math.random() * 3000);
  
  res.status(201).json(workload);
});

app.get('/api/resources', (req, res) => {
  res.json({
    cpu: state.resources.cpu,
    memory: {
      total: state.resources.memory.total,
      free: os.freemem()
    },
    platform: state.resources.platform
  });
});

// Federation Management API Routes
app.get('/api/federations', (req, res) => {
  const federationsList = Array.from(state.federations.values());
  res.json(federationsList);
});

app.post('/api/federations', (req, res) => {
  const { name, description, resourcePolicy, governanceRules } = req.body;
  
  if (!name) {
    return res.status(400).json({ error: 'Federation name is required' });
  }
  
  const federationId = uuidv4();
  const federation = {
    id: federationId,
    name,
    description: description || '',
    createdAt: Date.now(),
    createdBy: state.nodeId,
    members: [state.nodeId],
    resourcePolicy: resourcePolicy || {
      cpu: { min: 10, max: 90 }, // Percentage
      memory: { min: 100 * 1024 * 1024, max: 1024 * 1024 * 1024 } // Bytes
    },
    governanceRules: governanceRules || {
      votingThreshold: 0.66, // 66% majority required
      minVotingPeriod: 86400000 // 24 hours in ms
    },
    status: 'active'
  };
  
  state.federations.set(federationId, federation);
  state.myFederations.add(federationId);
  
  logger.info(`Created new federation: ${name} (${federationId})`);
  
  // Announce to all connected peers
  broadcastToPeers({
    type: 'FEDERATION_CREATED',
    nodeId: state.nodeId,
    federation
  });
  
  res.status(201).json(federation);
});

app.post('/api/federations/:id/join', (req, res) => {
  const federationId = req.params.id;
  
  if (!state.federations.has(federationId)) {
    return res.status(404).json({ error: 'Federation not found' });
  }
  
  const federation = state.federations.get(federationId);
  
  if (federation.members.includes(state.nodeId)) {
    return res.status(409).json({ error: 'Already a member of this federation' });
  }
  
  federation.members.push(state.nodeId);
  state.myFederations.add(federationId);
  
  logger.info(`Joined federation: ${federation.name} (${federationId})`);
  
  // Announce to all connected peers
  broadcastToPeers({
    type: 'FEDERATION_JOIN',
    nodeId: state.nodeId,
    federationId
  });
  
  res.json({ success: true, federation });
});

app.post('/api/federations/:id/leave', (req, res) => {
  const federationId = req.params.id;
  
  if (!state.federations.has(federationId)) {
    return res.status(404).json({ error: 'Federation not found' });
  }
  
  const federation = state.federations.get(federationId);
  
  if (!federation.members.includes(state.nodeId)) {
    return res.status(409).json({ error: 'Not a member of this federation' });
  }
  
  federation.members = federation.members.filter(id => id !== state.nodeId);
  state.myFederations.delete(federationId);
  
  logger.info(`Left federation: ${federation.name} (${federationId})`);
  
  // Announce to all connected peers
  broadcastToPeers({
    type: 'FEDERATION_LEAVE',
    nodeId: state.nodeId,
    federationId
  });
  
  res.json({ success: true });
});

app.post('/api/federations/:id/resources', (req, res) => {
  const federationId = req.params.id;
  const { cpu, memory } = req.body;
  
  if (!state.federations.has(federationId)) {
    return res.status(404).json({ error: 'Federation not found' });
  }
  
  const federation = state.federations.get(federationId);
  
  if (!federation.members.includes(state.nodeId)) {
    return res.status(403).json({ error: 'Not a member of this federation' });
  }
  
  // Update resource policy
  if (cpu) {
    federation.resourcePolicy.cpu = { 
      ...federation.resourcePolicy.cpu, 
      ...cpu 
    };
  }
  
  if (memory) {
    federation.resourcePolicy.memory = { 
      ...federation.resourcePolicy.memory, 
      ...memory 
    };
  }
  
  logger.info(`Updated resource policy for federation: ${federation.name}`);
  
  // Announce to all federation members
  broadcastToFederation(federationId, {
    type: 'FEDERATION_RESOURCE_UPDATE',
    nodeId: state.nodeId,
    federationId,
    resourcePolicy: federation.resourcePolicy
  });
  
  res.json({ success: true, resourcePolicy: federation.resourcePolicy });
});

// P2P Networking
const initializeP2PServer = () => {
  const wss = new WebSocket.Server({ port: config.network.listenAddresses[0].split('/').pop() });
  
  wss.on('connection', (ws, req) => {
    const ip = req.socket.remoteAddress;
    logger.info(`New peer connection from ${ip}`);
    
    ws.on('message', (message) => {
      try {
        const msg = JSON.parse(message);
        handlePeerMessage(msg, ws);
      } catch (error) {
        logger.error('Error handling peer message:', error);
      }
    });
    
    ws.on('close', () => {
      // Find and remove the peer
      for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
        if (peerInfo.connection === ws) {
          peerInfo.connected = false;
          logger.info(`Peer ${peerId} disconnected`);
          break;
        }
      }
    });
    
    // Send hello message
    ws.send(JSON.stringify({
      type: 'HELLO',
      nodeId: state.nodeId,
      nodeType: config.nodeType,
      version: '0.1.0'
    }));
  });
  
  logger.info(`P2P server listening on port ${config.network.listenAddresses[0].split('/').pop()}`);
  return wss;
};

const connectToBootstrapNodes = async () => {
  if (!config.network.bootstrapNodes || config.network.bootstrapNodes.length === 0) {
    logger.info('No bootstrap nodes configured');
    return;
  }
  
  for (const node of config.network.bootstrapNodes) {
    try {
      const address = node.startsWith('/ip4/') 
        ? `ws://${node.split('/')[2]}:${node.split('/')[4]}`
        : node;
      
      logger.info(`Connecting to bootstrap node: ${address}`);
      const ws = new WebSocket(address);
      
      ws.on('open', () => {
        logger.info(`Connected to bootstrap node: ${address}`);
        
        // Send hello message
        ws.send(JSON.stringify({
          type: 'HELLO',
          nodeId: state.nodeId,
          nodeType: config.nodeType,
          version: '0.1.0'
        }));
      });
      
      ws.on('message', (message) => {
        try {
          const msg = JSON.parse(message);
          handlePeerMessage(msg, ws);
        } catch (error) {
          logger.error('Error handling bootstrap node message:', error);
        }
      });
      
      ws.on('error', (error) => {
        logger.error(`Error connecting to bootstrap node ${address}:`, error.message);
      });
      
      ws.on('close', () => {
        logger.info(`Disconnected from bootstrap node: ${address}`);
        // Try to reconnect after some time
        setTimeout(() => {
          logger.info(`Attempting to reconnect to ${address}`);
          connectToBootstrapNodes();
        }, 5000 + Math.random() * 5000);
      });
    } catch (error) {
      logger.error(`Failed to connect to bootstrap node: ${error.message}`);
    }
  }
};

const handlePeerMessage = (message, connection) => {
  switch (message.type) {
    case 'HELLO':
      // Store peer information
      state.connectedPeers.set(message.nodeId, {
        id: message.nodeId,
        nodeType: message.nodeType,
        connection,
        connected: true,
        address: connection._socket.remoteAddress,
        lastSeen: Date.now()
      });
      logger.info(`Peer ${message.nodeId} (${message.nodeType}) connected`);
      
      // Send resource information
      connection.send(JSON.stringify({
        type: 'RESOURCES',
        nodeId: state.nodeId,
        resources: {
          cpu: state.resources.cpu,
          memory: {
            total: state.resources.memory.total,
            free: os.freemem()
          }
        }
      }));
      break;
      
    case 'RESOURCES':
      // Update peer resource information
      if (state.connectedPeers.has(message.nodeId)) {
        const peerInfo = state.connectedPeers.get(message.nodeId);
        peerInfo.resources = message.resources;
        peerInfo.lastSeen = Date.now();
      }
      break;
      
    case 'WORKLOAD_REQUEST':
      // In a real implementation, we'd evaluate if we can accept the workload
      // For the prototype, we'll just send back a response
      connection.send(JSON.stringify({
        type: 'WORKLOAD_RESPONSE',
        requestId: message.requestId,
        accepted: Math.random() > 0.2, // 80% chance of accepting
        nodeId: state.nodeId
      }));
      break;
      
    case 'WORKLOAD_RESPONSE':
      // Handle response to our workload request
      if (state.pendingMessages.has(message.requestId)) {
        const { resolve } = state.pendingMessages.get(message.requestId);
        resolve(message);
        state.pendingMessages.delete(message.requestId);
      }
      break;
      
    case 'PING':
      // Respond to ping
      connection.send(JSON.stringify({
        type: 'PONG',
        timestamp: Date.now(),
        nodeId: state.nodeId
      }));
      break;
      
    // Add federation message handling
    case 'FEDERATION_CREATED':
      if (!state.federations.has(message.federation.id)) {
        state.federations.set(message.federation.id, message.federation);
        logger.info(`Received new federation: ${message.federation.name} (${message.federation.id})`);
      }
      break;
      
    case 'FEDERATION_JOIN':
      if (state.federations.has(message.federationId)) {
        const federation = state.federations.get(message.federationId);
        if (!federation.members.includes(message.nodeId)) {
          federation.members.push(message.nodeId);
          logger.info(`Node ${message.nodeId} joined federation ${federation.name}`);
        }
      }
      break;
      
    case 'FEDERATION_LEAVE':
      if (state.federations.has(message.federationId)) {
        const federation = state.federations.get(message.federationId);
        federation.members = federation.members.filter(id => id !== message.nodeId);
        logger.info(`Node ${message.nodeId} left federation ${federation.name}`);
      }
      break;
      
    case 'FEDERATION_RESOURCE_UPDATE':
      if (state.federations.has(message.federationId)) {
        const federation = state.federations.get(message.federationId);
        federation.resourcePolicy = message.resourcePolicy;
        logger.info(`Federation ${federation.name} resource policy updated`);
      }
      break;
    
    default:
      logger.warn(`Unknown message type: ${message.type}`);
  }
};

// Utility to broadcast to all peers
const broadcastToPeers = (message) => {
  for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
    if (peerInfo.connected) {
      try {
        peerInfo.connection.send(JSON.stringify(message));
      } catch (error) {
        logger.error(`Error broadcasting to peer ${peerId}:`, error);
        peerInfo.connected = false;
      }
    }
  }
};

// Utility to broadcast to federation members only
const broadcastToFederation = (federationId, message) => {
  if (!state.federations.has(federationId)) {
    return;
  }
  
  const federation = state.federations.get(federationId);
  
  for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
    if (peerInfo.connected && federation.members.includes(peerId)) {
      try {
        peerInfo.connection.send(JSON.stringify(message));
      } catch (error) {
        logger.error(`Error broadcasting to federation member ${peerId}:`, error);
        peerInfo.connected = false;
      }
    }
  }
};

// Start the server
const startServer = async () => {
  try {
    // Start P2P server
    const p2pServer = initializeP2PServer();
    
    // Connect to bootstrap nodes
    await connectToBootstrapNodes();
    
    // Start API server
    const apiPort = config.api.port || 3000;
    app.listen(apiPort, () => {
      logger.info(`API server listening on port ${apiPort}`);
    });
    
    // Start resource reporting
    setInterval(() => {
      // Update local resource info
      state.resources.memory.free = os.freemem();
      
      // Send resource updates to peers
      for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
        if (peerInfo.connected) {
          try {
            peerInfo.connection.send(JSON.stringify({
              type: 'RESOURCES',
              nodeId: state.nodeId,
              resources: {
                cpu: state.resources.cpu,
                memory: {
                  total: state.resources.memory.total,
                  free: state.resources.memory.free
                }
              }
            }));
          } catch (error) {
            logger.error(`Error sending resource update to peer ${peerId}:`, error);
            peerInfo.connected = false;
          }
        }
      }
    }, 30000);
    
    // Start peer discovery
    setInterval(() => {
      // In a real implementation, we'd use a proper peer discovery protocol
      // For now, we'll just maintain existing connections
      for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
        if (peerInfo.connected) {
          try {
            peerInfo.connection.send(JSON.stringify({
              type: 'PING',
              timestamp: Date.now(),
              nodeId: state.nodeId
            }));
          } catch (error) {
            logger.error(`Error sending ping to peer ${peerId}:`, error);
            peerInfo.connected = false;
          }
        }
      }
    }, 60000);
    
    logger.info('ICN node started successfully');
  } catch (error) {
    logger.error('Failed to start ICN node:', error);
    process.exit(1);
  }
};

// Handle shutdown
process.on('SIGINT', () => {
  logger.info('Shutting down ICN node...');
  
  // Close connections and clean up
  for (const [peerId, peerInfo] of state.connectedPeers.entries()) {
    if (peerInfo.connected) {
      try {
        peerInfo.connection.close();
      } catch (error) {
        logger.error(`Error closing connection to peer ${peerId}:`, error);
      }
    }
  }
  
  logger.info('ICN node shutdown complete');
  process.exit(0);
});

// Start the server
startServer();```

===================
File: ./scripts/backend/src/main.rs
Size: 45 bytes
===================
```rs
fn main() {
    println!("Hello, world!");
}
```

===================
File: ./src/api/mod.rs
Size: 160 bytes
===================
```rs
// API module for the ICN system
pub mod routes;
pub mod handlers;

use crate::icn_types::IcnResult;

pub async fn initialize() -> IcnResult<()> {
    Ok(())
} ```

===================
File: ./src/attestation/mod.rs
Size: 138 bytes
===================
```rs
//! Attestation module for ICN

pub struct AttestationService;

impl AttestationService {
    pub fn new() -> Self {
        Self
    }
}
```

===================
File: ./src/consensus/mod.rs
Size: 191 bytes
===================
```rs
use chrono::{DateTime, Utc};

#[derive(Debug)]
pub enum ConsensusMessage {
    ProposalExecution {
        id: String,
        changes: Vec<String>,
        timestamp: DateTime<Utc>,
    }
}
```

===================
File: ./src/dsl/mod.rs
Size: 149 bytes
===================
```rs
pub mod parser;
pub mod vm;
pub mod governance;

pub use parser::{CoopLangParser, parse};
pub use vm::IcnVM;
pub use governance::GovernanceExecutor;
```

===================
File: ./src/governance/mod.rs
Size: 2489 bytes
===================
```rs
mod rollback;

use rollback::{DisputeInfo, DisputeStatus, RollbackError, RollbackConfig};
use std::collections::HashMap;
use chrono::Utc;
use crate::icn_types::Proposal;

pub struct GovernanceService {
    // ...existing code...
    disputes: HashMap<String, DisputeInfo>,
    rollback_config: RollbackConfig,
    proposals: HashMap<String, Proposal>,
}

impl GovernanceService {
    pub async fn initiate_rollback(
        &mut self,
        proposal_id: &str,
        initiator: String,
        reason: String,
        evidence: Option<String>,
    ) -> Result<(), RollbackError> {
        let proposal = self.proposals
            .get(proposal_id)
            .ok_or(RollbackError::ProposalNotFound)?;

        if !self.is_within_rollback_window(&proposal) {
            return Err(RollbackError::TimeframePassed);
        }

        let dispute = DisputeInfo {
            initiator,
            reason,
            timestamp: Utc::now(),
            evidence,
            status: DisputeStatus::Pending,
            votes: HashMap::new(),
        };

        self.disputes.insert(proposal_id.to_string(), dispute);
        self.freeze_proposal(proposal_id)?;
        Ok(())
    }

    pub async fn execute_rollback(
        &mut self,
        proposal_id: &str,
    ) -> Result<(), RollbackError> {
        let dispute = self.disputes.get(proposal_id)
            .ok_or(RollbackError::InvalidRollbackState)?;

        if dispute.status != DisputeStatus::Pending {
            return Err(RollbackError::InvalidRollbackState);
        }

        if self.get_rollback_approvals(proposal_id) < self.rollback_config.required_approvals {
            return Err(RollbackError::UnauthorizedRollback);
        }

        self.proposals.remove(proposal_id)
            .ok_or(RollbackError::ProposalNotFound)?;
        self.disputes.remove(proposal_id);
        Ok(())
    }

    fn is_within_rollback_window(&self, proposal: &Proposal) -> bool {
        let now = Utc::now();
        let window = chrono::Duration::seconds(self.rollback_config.rollback_window.as_secs() as i64);
        now.signed_duration_since(proposal.created_at) <= window
    }

    fn freeze_proposal(&mut self, _proposal_id: &str) -> Result<(), RollbackError> {
        // Implementation to freeze proposal during dispute resolution
        Ok(())
    }

    fn get_rollback_approvals(&self, _proposal_id: &str) -> u32 {
        // Implementation to count governance members' approvals for rollback
        0
    }
}
```

===================
File: ./src/lib.rs
Size: 301 bytes
===================
```rs
pub mod api;
pub mod governance;
pub mod dsl;
pub mod attestation;
pub mod consensus;
pub mod network;
pub mod services;
pub mod storage;

/// Re-export commonly used types and functions
pub use icn_types;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}```

===================
File: ./src/main.rs
Size: 4057 bytes
===================
```rs
use std::sync::Arc;
use log::{info, error};
use icn_core::{
    core::Core,
    telemetry::{TelemetryManager, PrometheusMetrics, Logger, TracingSystem},
    storage::{StorageInterface, MemoryStorage},
    networking::{NetworkInterface, NetworkManager},
    identity::{IdentityInterface, IdentityManager},
    reputation::{ReputationInterface, ReputationSystem},
    models::{ResourceAllocationSystem, FederationManager},
    RuntimeManager, RuntimeInterface
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::default().default_filter_or("info"));
    info!("Starting ICN node initialization...");

    // Initialize core components
    let storage_manager = MemoryStorage::new();
    let network_manager = NetworkManager::new();
    let prometheus = PrometheusMetrics::new();
    let logger = Logger::new();
    let tracing = TracingSystem::new();
    let telemetry_manager = TelemetryManager::new(prometheus, logger, tracing);
    let identity_manager = IdentityManager::new();
    let reputation_manager = ReputationSystem::new();
    let runtime_manager = RuntimeManager::new();
    let resource_system = Arc::new(ResourceAllocationSystem::new());
    let federation_manager = Arc::new(FederationManager::new(resource_system.clone()));

    // Wrap components in Arc for shared ownership
    let storage: Arc<dyn StorageInterface> = Arc::new(storage_manager);
    let network: Arc<dyn NetworkInterface> = Arc::new(network_manager);
    let identity: Arc<dyn IdentityInterface> = Arc::new(identity_manager);
    let reputation: Arc<dyn ReputationInterface> = Arc::new(reputation_manager);
    let runtime: Arc<dyn RuntimeInterface> = Arc::new(runtime_manager);
    let _telemetry = Arc::new(telemetry_manager);

    // Create core system with the components it needs
    let core = Arc::new(Core::new(
        storage.clone(),
        network.clone(),
        identity.clone(),
        reputation.clone(),
        runtime.clone()
    ));

    // Start the core system
    info!("Starting core system components...");
    match core.start().await {
        Ok(_) => info!("Core system started successfully"),
        Err(e) => {
            error!("Failed to start core system: {}", e);
            std::process::exit(1);
        }
    }

    // Initialize P2P networking
    info!("Initializing P2P networking...");
    if let Err(e) = network.start().await {
        error!("Failed to start P2P networking: {}", e);
        std::process::exit(1);
    }

    // Start consensus engine
    info!("Starting consensus engine...");
    if let Err(e) = core.start_consensus().await {
        error!("Failed to start consensus engine: {}", e);
        std::process::exit(1);
    }

    // Start federation manager
    info!("Starting federation manager...");
    if let Err(e) = federation_manager.start().await {
        error!("Failed to start federation manager: {}", e);
        std::process::exit(1);
    }

    // Set up signal handlers for graceful shutdown
    let core_clone = core.clone();
    let network_clone = network.clone();
    let federation_clone = federation_manager.clone();
    
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.expect("Failed to listen for ctrl+c");
        info!("Received shutdown signal, initiating graceful shutdown...");
        
        // Shutdown sequence
        if let Err(e) = federation_clone.stop().await {
            error!("Error stopping federation manager: {}", e);
        }
        if let Err(e) = network_clone.stop().await {
            error!("Error stopping P2P networking: {}", e);
        }
        if let Err(e) = core_clone.stop().await {
            error!("Error stopping core system: {}", e);
        }
        
        info!("Node shutdown completed");
        std::process::exit(0);
    });

    info!("ICN node startup complete - running...");

    // Keep the main thread alive
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
}```

===================
File: ./src/network/mod.rs
Size: 22 bytes
===================
```rs
pub mod communication;```

===================
File: ./src/services/mod.rs
Size: 22 bytes
===================
```rs
pub mod event_service;```

===================
File: ./src/storage/mod.rs
Size: 20 bytes
===================
```rs
pub mod event_store;```

===================
File: ./backend/src/api/federation_resource_sharing.rs
Size: 15287 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::federation_service::FederationService;
use crate::services::p2p::P2PManager;
use crate::errors::IcnError;

/// Request to share resources between federations
#[derive(Debug, Deserialize, Serialize)]
pub struct FederationResourceSharingRequest {
    /// ID of the source federation sharing the resource
    pub source_federation_id: String,
    /// ID of the target federation receiving the resource
    pub target_federation_id: String,
    /// Type of resource being shared
    pub resource_type: String,
    /// Amount of resource to share
    pub amount: u64,
    /// Optional duration for the sharing agreement (in seconds)
    pub duration_seconds: Option<u64>,
    /// Terms of the sharing agreement
    pub terms: String,
    /// Minimum reputation score required for the target federation
    pub min_reputation_score: i64,
    /// Cryptographic signature of the request
    pub signature: String,
}

/// Response for federation resource sharing operations
#[derive(Debug, Serialize, Deserialize)]
pub struct FederationResourceSharingResponse {
    /// Whether the operation was successful
    pub success: bool,
    /// Message describing the result
    pub message: String,
    /// ID of the created sharing agreement (if successful)
    pub agreement_id: Option<String>,
}

/// Request to allocate resources from a sharing agreement
#[derive(Debug, Deserialize, Serialize)]
pub struct AllocateSharedResourceRequest {
    /// ID of the sharing agreement
    pub agreement_id: String,
    /// Amount of resource to allocate
    pub amount: u64,
    /// DID of the requester
    pub requester_did: String,
    /// Cryptographic signature of the request
    pub signature: String,
}

/// Request to release resources back to a sharing agreement
#[derive(Debug, Deserialize, Serialize)]
pub struct ReleaseSharedResourceRequest {
    /// ID of the sharing agreement
    pub agreement_id: String,
    /// ID of the allocation
    pub allocation_id: String,
    /// Amount of resource to release
    pub amount: u64,
}

/// Response for resource allocation operations
#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceAllocationResponse {
    /// Whether the operation was successful
    pub success: bool,
    /// Message describing the result
    pub message: String,
    /// ID of the allocation (if successful)
    pub allocation_id: Option<String>,
}

/// Generate federation resource sharing API routes
pub fn federation_resource_sharing_routes(
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let share_resources = warp::path!("api" / "v1" / "federation" / "resources" / "share")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(share_federation_resources_handler);

    let allocate_shared_resource = warp::path!("api" / "v1" / "federation" / "resources" / "shared" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(allocate_shared_resource_handler);

    let release_shared_resource = warp::path!("api" / "v1" / "federation" / "resources" / "shared" / "release")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_federation_service(federation_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone()))
        .and_then(release_shared_resource_handler);

    let list_federation_sharing_agreements = warp::path!("api" / "v1" / "federation" / String / "sharing-agreements")
        .and(warp::get())
        .and(with_federation_service(federation_service.clone()))
        .and_then(list_federation_sharing_agreements_handler);

    share_resources
        .or(allocate_shared_resource)
        .or(release_shared_resource)
        .or(list_federation_sharing_agreements)
}

/// Helper to include federation service in route handlers
fn with_federation_service(
    federation_service: Arc<Mutex<FederationService>>,
) -> impl Filter<Extract = (Arc<Mutex<FederationService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || federation_service.clone())
}

/// Helper to include P2P manager in route handlers
fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

/// Handler for sharing resources between federations
async fn share_federation_resources_handler(
    request: FederationResourceSharingRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature
    if !verify_signature(&request.source_federation_id, &request.signature).await {
        return Ok(warp::reply::json(&FederationResourceSharingResponse {
            success: false,
            message: "Invalid signature".to_string(),
            agreement_id: None,
        }));
    }

    // Process the request
    let mut service = federation_service.lock().await;
    match service.share_federation_resources(
        request.source_federation_id,
        request.target_federation_id,
        request.resource_type,
        request.amount,
        request.duration_seconds,
        request.terms,
        request.min_reputation_score,
    ).await {
        Ok(agreement_id) => {
            // Publish event
            let event = FederationEvent::ResourceSharing {
                source_federation_id: request.source_federation_id,
                target_federation_id: request.target_federation_id,
                resource_type: request.resource_type,
                amount: request.amount,
                agreement_id: agreement_id.clone(),
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Ok(warp::reply::json(&FederationResourceSharingResponse {
                    success: false,
                    message: format!("Failed to publish event: {}", e),
                    agreement_id: None,
                }));
            }
            
            Ok(warp::reply::json(&FederationResourceSharingResponse {
                success: true,
                message: "Resource sharing agreement created successfully".to_string(),
                agreement_id: Some(agreement_id),
            }))
        },
        Err(e) => {
            Ok(warp::reply::json(&FederationResourceSharingResponse {
                success: false,
                message: format!("Failed to share resources: {}", e),
                agreement_id: None,
            }))
        }
    }
}

/// Handler for allocating resources from a sharing agreement
async fn allocate_shared_resource_handler(
    request: AllocateSharedResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature
    if !verify_signature(&request.requester_did, &request.signature).await {
        return Ok(warp::reply::json(&ResourceAllocationResponse {
            success: false,
            message: "Invalid signature".to_string(),
            allocation_id: None,
        }));
    }

    // Process the request
    let mut service = federation_service.lock().await;
    match service.allocate_shared_resource(
        &request.agreement_id,
        &request.requester_did,
        request.amount,
    ).await {
        Ok(allocation_id) => {
            // Publish event
            let event = FederationEvent::ResourceAllocation {
                agreement_id: request.agreement_id,
                requester_did: request.requester_did,
                amount: request.amount,
                allocation_id: allocation_id.clone(),
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Ok(warp::reply::json(&ResourceAllocationResponse {
                    success: false,
                    message: format!("Failed to publish event: {}", e),
                    allocation_id: None,
                }));
            }
            
            Ok(warp::reply::json(&ResourceAllocationResponse {
                success: true,
                message: "Resources allocated successfully".to_string(),
                allocation_id: Some(allocation_id),
            }))
        },
        Err(e) => {
            Ok(warp::reply::json(&ResourceAllocationResponse {
                success: false,
                message: format!("Failed to allocate resources: {}", e),
                allocation_id: None,
            }))
        }
    }
}

/// Handler for releasing resources back to a sharing agreement
async fn release_shared_resource_handler(
    request: ReleaseSharedResourceRequest,
    federation_service: Arc<Mutex<FederationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Process the request
    let mut service = federation_service.lock().await;
    match service.release_shared_resource(
        &request.agreement_id,
        &request.allocation_id,
        request.amount,
    ).await {
        Ok(_) => {
            // Publish event
            let event = FederationEvent::ResourceRelease {
                agreement_id: request.agreement_id,
                allocation_id: request.allocation_id,
                amount: request.amount,
            };
            
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(IcnError::NetworkError(e.to_string())));
            }
            
            Ok(warp::reply::json(&"Resources released successfully"))
        },
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e.to_string()))),
    }
}

/// Handler for listing all sharing agreements of a federation
async fn list_federation_sharing_agreements_handler(
    federation_id: String,
    federation_service: Arc<Mutex<FederationService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = federation_service.lock().await;
    match service.list_federation_sharing_agreements(&federation_id).await {
        Ok(agreements) => Ok(warp::reply::json(&agreements)),
        Err(e) => Err(warp::reject::custom(IcnError::FederationError(e.to_string()))),
    }
}

/// Helper function to verify cryptographic signatures
async fn verify_signature(did: &str, signature: &str) -> bool {
    // This is a placeholder. In a real implementation, this would:
    // 1. Fetch the DID Document to get the public key
    // 2. Verify the signature against the public key
    // 3. Return true if valid, false otherwise
    
    // For now, we'll just return true for development purposes
    // TODO: Replace with actual signature verification
    true
}

/// Events related to federation activities
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FederationEvent {
    ResourceSharing {
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        agreement_id: String,
    },
    ResourceAllocation {
        agreement_id: String,
        requester_did: String,
        amount: u64,
        allocation_id: String,
    },
    ResourceRelease {
        agreement_id: String,
        allocation_id: String,
        amount: u64,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use crate::services::federation_service::FederationService;
    use crate::services::p2p::P2PManager;

    #[tokio::test]
    async fn test_share_federation_resources_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = FederationResourceSharingRequest {
            source_federation_id: "source_federation".to_string(),
            target_federation_id: "target_federation".to_string(),
            resource_type: "resource_type".to_string(),
            amount: 100,
            duration_seconds: Some(3600),
            terms: "terms".to_string(),
            min_reputation_score: 50,
            signature: "signature".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/share")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_allocate_shared_resource_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = AllocateSharedResourceRequest {
            agreement_id: "agreement_id".to_string(),
            amount: 50,
            requester_did: "requester_did".to_string(),
            signature: "signature".to_string(),
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/shared/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_release_shared_resource_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let request = ReleaseSharedResourceRequest {
            agreement_id: "agreement_id".to_string(),
            allocation_id: "allocation_id".to_string(),
            amount: 50,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/federation/resources/shared/release")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }

    #[tokio::test]
    async fn test_list_federation_sharing_agreements_handler() {
        let federation_service = Arc::new(Mutex::new(FederationService::new()));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        let api = federation_resource_sharing_routes(federation_service, p2p_manager);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/federation/source_federation/sharing-agreements")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), 200);
    }
}
```

===================
File: ./backend/src/api/governance.rs
Size: 15527 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::governance_service::{GovernanceService, Proposal, Vote};
use icn_networking::p2p::{P2PManager, GovernanceEvent}; // Import P2PManager and GovernanceEvent
use crate::services::identity_service::IdentityService; // Import IdentityService
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use futures::future::join_all; // Import join_all for concurrency

#[derive(Debug, Deserialize, Serialize)]
struct CreateProposalRequest {
    title: String,
    description: String,
    created_by: String,
    ends_at: String,
    _did: String, // Add did field for DID-based access control
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct VoteRequest {
    proposal_id: String,
    voter: String,
    approve: bool,
    zk_snark_proof: String, // Added zk-SNARK proof field
    verifiable_credential: String, // Add verifiable credential field
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize)]
struct RecallVoteRequest {
    target_member: String,
    voter: String,
    approve: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct DelegatedGovernanceRequest {
    federation_id: String,
    representative_id: String,
}

pub fn governance_routes(
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to governance_routes
    identity_service: Arc<dyn IdentityService>, // Add IdentityService to governance_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_proposal = warp::path!("api" / "v1" / "governance" / "proposals")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(create_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / String / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let sybil_resistance = warp::path!("api" / "v1" / "governance" / "sybil_resistance")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(sybil_resistance_handler);

    let reputation_decay = warp::path!("api" / "v1" / "governance" / "reputation_decay")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(reputation_decay_handler);

    let proposal_status = warp::path!("api" / "v1" / "governance" / "proposals" / String / "status")
        .and(warp::get())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(proposal_status_handler);

    let submit_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "submit")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(submit_proposal_handler);

    let vote_on_proposal = warp::path!("api" / "v1" / "governance" / "proposals" / "vote")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and(with_identity_service(identity_service.clone())) // Add with_identity_service
        .and_then(vote_on_proposal_handler);

    let delegated_governance = warp::path!("api" / "v1" / "governance" / "delegated")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_governance_service(governance_service.clone()))
        .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
        .and_then(delegated_governance_handler);

    create_proposal
        .or(vote_on_proposal)
        .or(sybil_resistance)
        .or(reputation_decay)
        .or(proposal_status)
        .or(submit_proposal)
        .or(vote_on_proposal)
        .or(delegated_governance)
}

fn with_governance_service(
    governance_service: Arc<Mutex<GovernanceService>>,
) -> impl Filter<Extract = (Arc<Mutex<GovernanceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || governance_service.clone())
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn create_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::CreateProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn sybil_resistance_handler(
    request: SybilResistanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_sybil_resistance(request.did, request.reputation_score).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::SybilResistance {
                did: request.did,
                reputation_score: request.reputation_score,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Sybil resistance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn reputation_decay_handler(
    request: ReputationDecayRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.apply_reputation_decay(request.did, request.decay_rate).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::ReputationDecay {
                did: request.did,
                decay_rate: request.decay_rate,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Reputation decay applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn proposal_status_handler(
    proposal_id: String,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let service = governance_service.lock().await;
    match service.get_proposal_status(&proposal_id).await {
        Ok(status) => {
            // Publish event
            let event = GovernanceEvent::ProposalStatus {
                proposal_id: proposal_id.clone(),
                status: status.clone(),
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&status))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn submit_proposal_handler(
    request: CreateProposalRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify DID using IdentityService
    if !identity_service.verify_did(&request.did).await {
        return Err(warp::reject::custom("Invalid DID"));
    }

    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let proposal = Proposal {
        title: request.title,
        description: request.description,
        created_by: request.created_by,
        ends_at: request.ends_at,
    };

    let mut service = governance_service.lock().await;
    match service.create_proposal(proposal).await {
        Ok(proposal_id) => {
            // Publish event
            let event = GovernanceEvent::SubmitProposal {
                title: request.title,
                description: request.description,
                created_by: request.created_by,
                ends_at: request.ends_at,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&proposal_id))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn vote_on_proposal_handler(
    request: VoteRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
    identity_service: Arc<dyn IdentityService>, // Add identity_service parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Validate verifiable credential
    if !identity_service.verify_credential(&request.verifiable_credential).await {
        return Err(warp::reject::custom("Invalid verifiable credential"));
    }

    let vote = Vote {
        proposal_id: request.proposal_id,
        voter: request.voter,
        approve: request.approve,
        zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
    };

    let mut service = governance_service.lock().await;
    match service.record_vote(vote).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::Vote {
                proposal_id: request.proposal_id,
                voter: request.voter,
                approve: request.approve,
                zk_snark_proof: request.zk_snark_proof, // Added zk-SNARK proof field
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Vote recorded"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn delegated_governance_handler(
    request: DelegatedGovernanceRequest,
    governance_service: Arc<Mutex<GovernanceService>>,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = governance_service.lock().await;
    match service.handle_delegated_governance(request.federation_id, request.representative_id).await {
        Ok(_) => {
            // Publish event
            let event = GovernanceEvent::DelegatedGovernance {
                federation_id: request.federation_id,
                representative_id: request.representative_id,
            };
            let mut p2p = p2p_manager.lock().await;
            if let Err(e) = p2p.publish(event).await {
                return Err(warp::reject::custom(e));
            }
            Ok(warp::reply::json(&"Delegated governance applied"))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}
```

===================
File: ./backend/src/api/health.rs
Size: 343 bytes
===================
```rs
use warp::Filter;
use sqlx::PgPool;
use std::sync::Arc;

pub fn health_routes() -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let api_health = warp::path!("api" / "v1" / "health")
        .and(warp::get())
        .map(|| warp::reply::json(&serde_json::json!({ "status": "ok" })));
        
    api_health
}```

===================
File: ./backend/src/api/identity.rs
Size: 6473 bytes
===================
```rs
use warp::Filter;
use crate::services::identity_service::{IdentityService, IdentityServiceImpl};
use std::sync::Arc;
use icn_core::verifiable_credentials::{VerifiableCredential, Proof}; // Import VerifiableCredential and Proof
use icn_zkp::zk_snark; // Import zk-SNARK
use icn_crypto::KeyPair; // Import KeyPair for signature verification

pub fn identity_routes(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let create_identity = warp::path!("api" / "v1" / "identity" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_create_identity);

    let get_identity = warp::path!("api" / "v1" / "identity" / "get" / String)
        .and(warp::get())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_get_identity);

    let rotate_key = warp::path!("api" / "v1" / "identity" / "rotate_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_rotate_key);

    let revoke_key = warp::path!("api" / "v1" / "identity" / "revoke_key" / String)
        .and(warp::post())
        .and(with_identity_service(identity_service.clone()))
        .and_then(handle_revoke_key);

    create_identity.or(get_identity).or(rotate_key).or(revoke_key)
}

fn with_identity_service(
    identity_service: Arc<dyn IdentityService>,
) -> impl Filter<Extract = (Arc<dyn IdentityService>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || identity_service.clone())
}

async fn handle_create_identity(
    _identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&_identity, &identity_service).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    identity_service.create_identity(&_identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate ICN-compliant verifiable credential
    let credential = VerifiableCredential {
        credential_type: "IdentityCredential".to_string(),
        issuer_did: "did:icn:issuer".to_string(),
        subject_did: _identity.clone(),
        issuance_date: chrono::Utc::now().to_rfc3339(),
        expiration_date: None,
        credential_status: None,
        credential_schema: None,
        proof: Proof {
            type_: "Ed25519Signature2018".to_string(),
            created: chrono::Utc::now().to_rfc3339(),
            proof_purpose: "assertionMethod".to_string(),
            verification_method: "did:icn:issuer#keys-1".to_string(),
            jws: "example-jws".to_string(),
        },
    };

    Ok(warp::reply::json(&credential))
}

async fn handle_get_identity(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let data = identity_service.get_identity(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    // Generate zk-SNARK proof for identity validation
    let proof = zk_snark::generate_proof(&data);

    Ok(warp::reply::json(&proof))
}

async fn handle_rotate_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.rotate_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key rotated", warp::http::StatusCode::OK))
}

async fn handle_revoke_key(
    identity: String,
    identity_service: Arc<dyn IdentityService>,
) -> Result<impl warp::Reply, warp::Rejection> {
    identity_service.revoke_key(&identity).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;
    Ok(warp::reply::with_status("Key revoked", warp::http::StatusCode::OK))
}

async fn verify_signature(identity: &str, identity_service: &Arc<dyn IdentityService>) -> bool {
    if let Some(public_key) = identity_service.get_public_key(identity).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(identity.as_bytes(), identity.as_bytes());
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::identity_service::IdentityServiceImpl;
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_create_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/create")
            .json(&"did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::CREATED);
    }

    #[tokio::test]
    async fn test_get_identity() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/identity/get/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_rotate_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/rotate_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_revoke_key() {
        let identity_service = Arc::new(IdentityServiceImpl::new(Arc::new(Database::new())));
        let api = identity_routes(identity_service);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/identity/revoke_key/did:icn:test")
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/reputation.rs
Size: 10381 bytes
===================
```rs
use warp::Filter;
use crate::services::reputation_service::{get_reputation, adjust_reputation, verify_contribution, handle_sybil_resistance, apply_reputation_decay, batch_reputation_updates};
use icn_networking::p2p::{P2PManager, ReputationEvent}; // Import P2PManager and ReputationEvent
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct ZkSnarkProofRequest {
    proof: String,
    did: String,
    signature: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct SybilResistanceRequest {
    did: String,
    reputation_score: i64,
}

#[derive(Debug, Deserialize, Serialize)]
struct ReputationDecayRequest {
    did: String,
    decay_rate: f64,
}

#[derive(Debug, Deserialize, Serialize)]
struct BatchReputationUpdateRequest {
    events: Vec<ReputationEvent>,
}

pub fn reputation_routes(
    p2p_manager: Arc<Mutex<P2PManager>>, // Add P2PManager to reputation_routes
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    warp::path("api")
        .and(
            warp::path("v1")
                .and(
                    warp::path("reputation")
                        .and(
                            warp::path("get")
                                .and(warp::get())
                                .and(warp::query::<String>())
                                .and_then(get_reputation)
                        )
                        .or(
                            warp::path("adjust")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(adjust_reputation)
                        )
                        .or(
                            warp::path("verify")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(verify_contribution)
                        )
                        .or(
                            warp::path("zk_snark_proof")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(submit_zk_snark_proof_handler)
                        )
                        .or(
                            warp::path("sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance)
                        )
                        .or(
                            warp::path("reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay)
                        )
                        .or(
                            warp::path("apply_reputation_decay")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(apply_reputation_decay_handler)
                        )
                        .or(
                            warp::path("handle_sybil_resistance")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and_then(handle_sybil_resistance_handler)
                        )
                        .or(
                            warp::path("batch_updates")
                                .and(warp::post())
                                .and(warp::body::json())
                                .and(with_p2p_manager(p2p_manager.clone())) // Add with_p2p_manager
                                .and_then(batch_reputation_updates_handler)
                        )
                )
        )
}

fn with_p2p_manager(
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = (Arc<Mutex<P2PManager>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || p2p_manager.clone())
}

async fn submit_zk_snark_proof_handler(
    request: ZkSnarkProofRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.did, &request.signature, &request.proof).await {
        return Err(warp::reject::custom("Invalid signature"));
    }

    // Verify zk-SNARK proof
    if !verify_proof(&request.proof) {
        return Err(warp::reject::custom("Invalid zk-SNARK proof"));
    }

    // Publish event
    let event = ReputationEvent::ZkSnarkProofSubmitted {
        proof: request.proof.clone(),
    };
    let mut p2p = p2p_manager.lock().await;
    if let Err(e) = p2p.publish(event).await {
        return Err(warp::reject::custom(e));
    }

    // Placeholder logic for zk-SNARK proof submission
    Ok(warp::reply::json(&"zk-SNARK proof submitted"))
}

async fn verify_signature(did: &str, signature: &str, message: &str) -> bool {
    // Retrieve public key from IdentityService
    if let Some(public_key) = get_public_key(did).await {
        let key_pair = KeyPair {
            public_key,
            private_key: vec![], // Not needed for verification
            algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
        };
        return key_pair.verify(message.as_bytes(), signature.as_bytes());
    }
    false
}

async fn get_public_key(did: &str) -> Option<Vec<u8>> {
    // Placeholder function to retrieve public key
    Some(vec![]) // Replace with actual implementation
}

async fn apply_reputation_decay_handler(
    request: ReputationDecayRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to apply reputation decay
    apply_reputation_decay_in_ledger(&request.did, request.decay_rate).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Reputation decay applied"))
}

async fn handle_sybil_resistance_handler(
    request: SybilResistanceRequest,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Interact with icn-identity ledger to handle sybil resistance
    handle_sybil_resistance_in_ledger(&request.did, request.reputation_score).await.map_err(|e| {
        warp::reject::custom(warp::reject::custom(e))
    })?;

    Ok(warp::reply::json(&"Sybil resistance handled"))
}

async fn batch_reputation_updates_handler(
    request: BatchReputationUpdateRequest,
    p2p_manager: Arc<Mutex<P2PManager>>, // Add p2p_manager parameter
) -> Result<impl warp::Reply, warp::Rejection> {
    // Publish events
    let publish_futures = request.events.iter().map(|event| {
        let p2p = p2p_manager.clone();
        async move {
            let mut p2p = p2p.lock().await;
            p2p.publish(event.clone()).await
        }
    });

    let results = futures::future::join_all(publish_futures).await;
    for result in results {
        if let Err(e) = result {
            return Err(warp::reject::custom(e));
        }
    }

    // Placeholder logic for batch reputation updates
    Ok(warp::reply::json(&"Batch reputation updates applied"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::reputation_service::{ReputationService, ReputationServiceImpl};
    use std::sync::Arc;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_submit_zk_snark_proof() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/zk_snark_proof")
            .json(&ZkSnarkProofRequest { proof: "test_proof".to_string(), did: "did:icn:test".to_string(), signature: "test_signature".to_string() })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/reputation_decay")
            .json(&ReputationDecayRequest { did: "did:icn:test".to_string(), decay_rate: 0.1 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let api = reputation_routes();

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/sybil_resistance")
            .json(&SybilResistanceRequest { did: "did:icn:test".to_string(), reputation_score: 50 })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_batch_reputation_updates() {
        let reputation_service = Arc::new(ReputationServiceImpl::new(Arc::new(Database::new())));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new())); // Add P2PManager instance
        let api = reputation_routes(p2p_manager);

        let events = vec![
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof1".to_string() },
            ReputationEvent::ZkSnarkProofSubmitted { proof: "proof2".to_string() },
        ];

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/reputation/batch_updates")
            .json(&BatchReputationUpdateRequest { events })
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/api/resources.rs
Size: 10501 bytes
===================
```rs
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::services::resource_service::{ResourceService, ResourceQuery};
use icn_crypto::KeyPair; // Import KeyPair for signature verification

#[derive(Debug, Deserialize, Serialize)]
struct QuerySharedResourcesRequest {
    _resource_type: String,
    owner: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
    signature: String, // Add signature field
}

#[derive(Debug, Deserialize, Serialize)]
struct ResourceSharingResponse {
    success: bool,
    message: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct TransferResourceRequest {
    resource_id: String,
    recipient_id: String,
    amount: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct AllocateResourceSharesRequest {
    resource_id: String,
    shares: u64,
}

#[derive(Debug, Deserialize, Serialize)]
struct CreateLocalClusterRequest {
    cluster_name: String,
    region: String,
    members: Vec<String>,
}

pub fn resource_routes(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let query_shared_resources = warp::path!("api" / "v1" / "resources" / "query")
        .and(warp::get())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(query_shared_resources_handler);

    let share_resource = warp::path!("api" / "v1" / "resources" / "share")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(share_resource_handler);

    let transfer_resource = warp::path!("api" / "v1" / "resources" / "transfer")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(transfer_resource_handler);

    let allocate_resource_shares = warp::path!("api" / "v1" / "resources" / "allocate")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(allocate_resource_shares_handler);

    let create_local_cluster = warp::path!("api" / "v1" / "resources" / "local_cluster" / "create")
        .and(warp::post())
        .and(warp::body::json())
        .and(with_resource_service(resource_service.clone()))
        .and_then(create_local_cluster_handler);

    query_shared_resources
        .or(share_resource)
        .or(transfer_resource)
        .or(allocate_resource_shares)
        .or(create_local_cluster)
}

fn with_resource_service(
    resource_service: Arc<Mutex<ResourceService>>,
) -> impl Filter<Extract = (Arc<Mutex<ResourceService>>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || resource_service.clone())
}

async fn query_shared_resources_handler(
    request: QuerySharedResourcesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let query = ResourceQuery {
        resource_type: request._resource_type,
        owner: request.owner,
    };

    let mut service = resource_service.lock().await;
    match service.query_shared_resources(query).await {
        Ok(resources) => {
            // Use EXPLAIN ANALYZE to verify index usage
            let explain_query = format!(
                "EXPLAIN ANALYZE SELECT * FROM resources WHERE resource_type = '{}' AND owner = '{}'",
                request._resource_type,
                request.owner.clone().unwrap_or_default()
            );
            let explain_result = sqlx::query(&explain_query)
                .fetch_all(&service.pool)
                .await
                .map_err(|e| warp::reject::custom(e))?;
            println!("EXPLAIN ANALYZE result: {:?}", explain_result);

            Ok(warp::reply::json(&resources))
        },
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn share_resource_handler(
    request: ResourceSharingRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    // Verify signature using icn-crypto
    if !verify_signature(&request.resource_id, &request.signature, &request.recipient_id).await {
        return Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: "Invalid signature".to_string(),
        }));
    }

    let mut service = resource_service.lock().await;
    match service.share_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: true,
            message: "Resource shared successfully".to_string(),
        })),
        Err(e) => Ok(warp::reply::json(&ResourceSharingResponse {
            success: false,
            message: format!("Failed to share resource: {}", e),
        })),
    }
}

async fn transfer_resource_handler(
    request: TransferResourceRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.transfer_resource(request.resource_id, request.recipient_id, request.amount).await {
        Ok(_) => Ok(warp::reply::json(&"Resource transferred successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn allocate_resource_shares_handler(
    request: AllocateResourceSharesRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let mut service = resource_service.lock().await;
    match service.allocate_resource_shares(request.resource_id, request.shares).await {
        Ok(_) => Ok(warp::reply::json(&"Resource shares allocated successfully")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn create_local_cluster_handler(
    request: CreateLocalClusterRequest,
    resource_service: Arc<Mutex<ResourceService>>,
) -> Result<impl warp::Reply, warp::Rejection> {
    let operation = ResourceOperation::CreateLocalCluster {
        cluster_name: request.cluster_name,
        region: request.region,
        members: request.members,
    };

    let mut service = resource_service.lock().await;
    match service.handle_operation(operation).await {
        Ok(_) => Ok(warp::reply::json(&"Local cluster created")),
        Err(e) => Err(warp::reject::custom(e)),
    }
}

async fn verify_signature(resource_id: &str, signature: &str, recipient_id: &str) -> bool {
    // Retrieve public key from IdentityService (placeholder)
    let public_key = vec![]; // Replace with actual public key retrieval logic
    let key_pair = KeyPair {
        public_key,
        private_key: vec![], // Not needed for verification
        algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
    };
    key_pair.verify(resource_id.as_bytes(), signature.as_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;
    use warp::Filter;
    use crate::services::resource_service::ResourceService;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    use warp::http::StatusCode;

    #[tokio::test]
    async fn test_query_shared_resources() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = QuerySharedResourcesRequest {
            resource_type: "test_type".to_string(),
            owner: Some("test_owner".to_string()),
        };

        let resp = warp::test::request()
            .method("GET")
            .path("/api/v1/resources/query")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_share_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = ResourceSharingRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
            signature: "test_signature".to_string(), // Add signature field
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/share")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_transfer_resource() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = TransferResourceRequest {
            resource_id: "test_resource".to_string(),
            recipient_id: "test_recipient".to_string(),
            amount: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/transfer")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_allocate_resource_shares() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = AllocateResourceSharesRequest {
            resource_id: "test_resource".to_string(),
            shares: 10,
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/allocate")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_create_local_cluster() {
        let resource_service = Arc::new(Mutex::new(ResourceService::new()));
        let api = resource_routes(resource_service);

        let request = CreateLocalClusterRequest {
            cluster_name: "test_cluster".to_string(),
            region: "test_region".to_string(),
            members: vec!["member1".to_string(), "member2".to_string()],
        };

        let resp = warp::test::request()
            .method("POST")
            .path("/api/v1/resources/local_cluster/create")
            .json(&request)
            .reply(&api)
            .await;

        assert_eq!(resp.status(), StatusCode::OK);
    }
}
```

===================
File: ./backend/src/blockchain.rs
Size: 9752 bytes
===================
```rs
use icn_types::{Block, Transaction};
use sha2::{Sha256, Digest};
use tendermint::block::Block as TendermintBlock;
use tendermint::lite::TrustedState;
use tendermint::rpc::Client;
use tokio::sync::Mutex;
use std::sync::Arc;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::collections::HashMap;
use log::{info, error};
use futures::future::join_all; // Import join_all for concurrency
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

pub trait BlockchainOperations {
    fn add_block(&mut self, block: Block);
    fn get_latest_block(&self) -> Option<&Block>;
    fn get_block_by_index(&self, index: usize) -> Option<&Block>;
    fn add_transaction(&mut self, transaction: Transaction);
    fn process_pending_transactions(&mut self) -> Result<(), String>;
    fn validate_transaction(&self, transaction: &Transaction) -> Result<bool, String>;
    fn calculate_hash(block: &Block) -> String;
    async fn start_consensus_round(&mut self, block: &mut Block) -> Result<(), String>;
    async fn vote_on_block(&mut self, block: &mut Block, validator_did: String, vote: bool) -> Result<(), String>;
    async fn finalize_block(&mut self, block: &mut Block) -> Result<(), String>;
    fn validate_contribution(&self, contribution: &Contribution) -> Result<bool, String>;
    async fn propose_block(&self, block: TendermintBlock) -> Result<(), String>;
    async fn vote_on_tendermint_block(&self, block: TendermintBlock, vote: bool) -> Result<(), String>;
    async fn finalize_tendermint_block(&self, block: TendermintBlock) -> Result<(), String>;
}

pub struct Blockchain {
    pub blocks: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub tendermint_client: Client,
    pub trusted_state: Arc<Mutex<TrustedState>>,
    pub cache: HashMap<String, Block>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
}

impl Blockchain {
    pub fn new(tendermint_client: Client, trusted_state: TrustedState, identity_system: Arc<Mutex<IdentitySystem>>, reputation_system: Arc<Mutex<ReputationSystem>>) -> Self {
        Self {
            blocks: vec![Block::new(0, "genesis".to_string(), vec![], "genesis".to_string())],
            pending_transactions: vec![],
            tendermint_client,
            trusted_state: Arc::new(Mutex::new(trusted_state)),
            cache: HashMap::new(),
            identity_system,
            reputation_system,
        }
    }

    pub async fn add_transaction(&mut self, _transaction: Transaction) -> Result<(), String> {
        // Validate transaction
        let sender = &_transaction.sender;
        
        // Check if sender has permission
        {
            let identity_system = self.identity_system.lock().unwrap();
            match _transaction.transaction_type {
                icn_types::TransactionType::Transfer { .. } => {
                    if !identity_system.has_permission(sender, "transfer") {
                        return Err("Sender does not have transfer permission".to_string());
                    }
                },
                _ => {
                    // Other transaction types validation
                }
            }
        }
        
        // Add to pending transactions
        self.pending_transactions.push(_transaction);
        Ok(())
    }

    pub async fn add_block(&mut self, mut block: Block) -> Result<(), String> {
        // Verify block
        let last_block = self.blocks.last().ok_or("No blocks in chain")?;
        if block.previous_hash != last_block.hash {
            return Err("Invalid previous hash".to_string());
        }
        
        // Process transactions in block
        for transaction in &block.transactions {
            // Process transaction effects
            match &transaction.transaction_type {
                icn_types::TransactionType::Transfer { receiver, amount } => {
                    // In a real implementation, this would update balances
                    // For now, just adjust reputation based on transaction
                    {
                        let mut reputation = self.reputation_system.lock().unwrap();
                        reputation.increase_reputation(&transaction.sender, 1);
                    }
                },
                _ => {
                    // Process other transaction types
                }
            }
        }
        
        // Finalize and add block
        block.finalize().await?;
        self.blocks.push(block);
        
        // Clear processed transactions from pending
        self.pending_transactions.clear();
        
        Ok(())
    }

    pub async fn verify_chain(&self) -> Result<(), String> {
        if self.blocks.is_empty() {
            return Ok(());
        }
        
        // Check that each block links to previous block
        for i in 1..self.blocks.len() {
            let current_block = &self.blocks[i];
            let previous_block = &self.blocks[i-1];
            
            // Verify previous hash
            if current_block.previous_hash != previous_block.hash {
                return Err(format!("Block {} has invalid previous_hash", i));
            }
            
            // Verify block hash
            if current_block.hash != current_block.calculate_hash() {
                return Err(format!("Block {} has invalid hash", i));
            }
        }
        
        Ok(())
    }
}

impl BlockchainOperations for Blockchain {
    fn add_block(&mut self, block: Block) {
        info!("Adding block with index: {}", block.index);
        self.cache.insert(block.index.to_string(), block.clone());
        self.blocks.push(block);
    }

    fn get_latest_block(&self) -> Option<&Block> {
        self.blocks.last()
    }

    fn get_block_by_index(&self, index: usize) -> Option<&Block> {
        if let Some(block) = self.cache.get(&index.to_string()) {
            return Some(block);
        }
        self.blocks.get(index)
    }

    fn add_transaction(&mut self, transaction: Transaction) {
        info!("Adding transaction with ID: {}", transaction.id);
        self.pending_transactions.push(transaction);
    }

    fn process_pending_transactions(&mut self) -> Result<(), String> {
        info!("Processing pending transactions");
        let mut new_block = Block::new();
        for transaction in &self.pending_transactions {
            if self.validate_transaction(transaction)? {
                new_block.add_transaction(transaction.clone());
            } else {
                return Err("Invalid transaction".to_string());
            }
        }
        self.add_block(new_block);
        self.pending_transactions.clear();
        Ok(())
    }

    fn validate_transaction(&self, transaction: &Transaction) -> Result<bool, String> {
        info!("Validating transaction with ID: {}", transaction.id);
        if let Some(proof) = &transaction.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(true)
    }

    fn calculate_hash(block: &Block) -> String {
        let mut hasher = Sha256::new();
        hasher.update(block.index.to_string());
        hasher.update(&block.previous_hash);
        hasher.update(block.timestamp.to_string());
        for tx in &block.transactions {
            hasher.update(serde_json::to_string(tx).unwrap());
        }
        hasher.update(&block.proposer);
        format!("{:x}", hasher.finalize())
    }

    async fn start_consensus_round(&mut self, block: &mut Block) -> Result<(), String> {
        info!("Starting consensus round for block with index: {}", block.index);
        block.start_consensus_round().await.map_err(|e| e.to_string())
    }

    async fn vote_on_block(&mut self, block: &mut Block, validator_did: String, vote: bool) -> Result<(), String> {
        info!("Voting on block with index: {} by validator: {}", block.index, validator_did);
        block.vote_on_block(validator_did, vote).await.map_err(|e| e.to_string())
    }

    async fn finalize_block(&mut self, block: &mut Block) -> Result<(), String> {
        info!("Finalizing block with index: {}", block.index);
        if block.metadata.validator_count >= 3 { // Assuming 3 is the required number of validators for consensus
            block.finalize().await.map_err(|e| e.to_string())?;
            self.add_block(block.clone());
            Ok(())
        } else {
            Err("Consensus not reached".to_string())
        }
    }

    fn validate_contribution(&self, contribution: &Contribution) -> Result<bool, String> {
        info!("Validating contribution");
        Ok(true)
    }

    async fn propose_block(&self, block: TendermintBlock) -> Result<(), String> {
        info!("Proposing block with height: {}", block.header.height);
        if let Some(proof) = &block.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(())
    }

    async fn vote_on_tendermint_block(&self, block: TendermintBlock, vote: bool) -> Result<(), String> {
        info!("Voting on Tendermint block with height: {}", block.header.height);
        if let Some(proof) = &block.zk_snark_proof {
            if !verify_proof(proof) {
                return Err("Invalid zk-SNARK proof".to_string());
            }
        }
        Ok(())
    }

    async fn finalize_tendermint_block(&self, block: TendermintBlock) -> Result<(), String> {
        info!("Finalizing Tendermint block with height: {}", block.header.height);
        Ok(())
    }
}
```

===================
File: ./backend/src/core.rs
Size: 6329 bytes
===================
```rs
use std::sync::{Arc, Mutex};
use crate::blockchain::Blockchain;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::governance::ProposalHistory;
use crate::services::{BlockchainService, IdentityService, GovernanceService};
use async_trait::async_trait;
use icn_consensus::ConsensusEngine;
use tendermint::rpc::Client;
use tendermint::lite::TrustedState;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_identity::ledger::{get_identity_from_ledger}; // Import icn-identity ledger function
use std::collections::HashMap;
use log::{info, error};
use crate::networking::p2p::P2PManager;

pub trait CoreOperations {
    fn start(&self) -> Result<(), String>;
    fn stop(&self) -> Result<(), String>;
    fn secure_communication(&self, address: &str, message: &[u8]) -> Result<(), String>;
    fn handle_mutual_credit_transaction(&self, sender: &str, receiver: &str, amount: f64) -> Result<(), String>;
    fn handle_mutual_credit_transaction_with_proof(&self, sender: &str, receiver: &str, amount: f64, proof: &str) -> Result<(), String>;
    fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String>;
    fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String>;
    fn manage_federation_lifecycle(&self, federation_id: &str, action: &str) -> Result<(), String>;
    fn update_proposal_status(&self, proposal_id: i64, status: &str) -> Result<(), String>;
    fn handle_resource_sharing(&self, resource_id: &str, action: &str) -> Result<(), String>;
    fn create_local_cluster(&self, cluster_name: &str, region: &str, members: Vec<String>) -> Result<(), String>;
    fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String>;
}

pub struct Core {
    pub blockchain_service: Arc<BlockchainService>,
    pub identity_service: Arc<IdentityService>,
    pub governance_service: Arc<GovernanceService>,
    pub p2p_manager: Arc<Mutex<P2PManager>>,
}

impl Core {
    pub fn new() -> Self {
        // Create the foundational systems
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        
        // Create blockchain with references to identity and reputation
        let blockchain = Arc::new(Mutex::new(
            Blockchain::new(identity_system.clone(), reputation_system.clone())
        ));
        
        // Create proposal history
        let proposal_history = Arc::new(Mutex::new(ProposalHistory::new()));
        
        // Create services
        let blockchain_service = Arc::new(BlockchainService::new(blockchain));
        let identity_service = Arc::new(IdentityService::new(identity_system));
        let governance_service = Arc::new(GovernanceService::new(proposal_history));
        let p2p_manager = Arc::new(Mutex::new(P2PManager::new()));
        
        Self {
            blockchain_service,
            identity_service,
            governance_service,
            p2p_manager,
        }
    }
    
    pub async fn start(&self) -> Result<(), String> {
        println!("Starting ICN core services...");
        
        // Initialize any systems that need startup
        // For demonstration purposes, this doesn't do much
        
        println!("ICN core services started successfully");
        Ok(())
    }
    
    pub async fn shutdown(&self) -> Result<(), String> {
        println!("Shutting down ICN core services...");
        
        // Clean up any resources
        
        println!("ICN core services shut down successfully");
        Ok(())
    }
}

#[async_trait]
impl ConsensusEngine for Core {
    async fn start(&self) -> Result<(), String> {
        self.start().await
    }

    async fn stop(&self) -> Result<(), String> {
        self.shutdown().await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use crate::storage::StorageManager;
    use crate::networking::NetworkManager;
    use crate::identity::IdentityManager;
    use crate::reputation::ReputationManager;
    use crate::core::consensus::TendermintConsensus;
    use async_trait::async_trait;

    struct MockTelemetryManager;

    impl MockTelemetryManager {
        fn log(&self, _message: &str) {
            // Mock logging
        }
    }

    struct MockRuntimeManager;

    #[async_trait]
    impl RuntimeManager for MockRuntimeManager {
        async fn start(&self) -> Result<(), String> {
            Ok(())
        }

        async fn stop(&self) -> Result<(), String> {
            Ok(())
        }
    }

    struct MockConsensusEngine;

    #[async_trait]
    impl ConsensusEngine for MockConsensusEngine {
        async fn start(&self) -> Result<(), String> {
            Ok(())
        }

        async fn stop(&self) -> Result<(), String> {
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_handle_mutual_credit_transaction() {
        let core = Core::new();

        let result = core.handle_mutual_credit_transaction("sender", "receiver", 100.0).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_submit_proposal() {
        let core = Core::new();

        let result = core.submit_proposal("title", "description", "creator", "2025-12-31").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote() {
        let core = Core::new();

        let result = core.vote(1, "voter", true).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_manage_federation_lifecycle() {
        let core = Core::new();

        let result = core.manage_federation_lifecycle("federation_id", "action").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_create_local_cluster() {
        let core = Core::new();

        let result = core.create_local_cluster("cluster_name", "region", vec!["member1".to_string(), "member2".to_string()]).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_delegated_governance() {
        let core = Core::new();

        let result = core.handle_delegated_governance("federation_id", "representative_id").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/core/consensus.rs
Size: 13611 bytes
===================
```rs
use async_trait::async_trait;
use crate::reputation::ReputationManager;
use tendermint::lite::{self, TrustedState, ValidatorSet};
use tendermint::rpc::Client;
use tokio::sync::Mutex;
use std::sync::Arc;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions

#[async_trait]
pub trait ConsensusEngine {
    async fn start(&self) -> Result<(), String>;
    async fn stop(&self) -> Result<(), String>;
    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String>;
    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String>;
    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String>;
    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String>;
    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String>;
    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String>;
    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String>;
    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String>;
    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String>;
    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String>;
    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String>; // Pfffb
    async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String>; // Pf5c9
}

pub struct ProofOfCooperation {
    reputation_manager: ReputationManager,
    current_round: u64,
    participants: Vec<String>,
    proposed_block: Option<tendermint::block::Block>,
    votes: Vec<bool>,
    timeout: std::time::Duration,
    round_start_time: std::time::Instant,
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: ReputationManager) -> Self {
        Self {
            reputation_manager,
            current_round: 0,
            participants: Vec::new(),
            proposed_block: None,
            votes: Vec::new(),
            timeout: std::time::Duration::from_secs(60),
            round_start_time: std::time::Instant::now(),
        }
    }

    pub fn start_round(&mut self) {
        self.current_round += 1;
        self.proposed_block = None;
        self.votes.clear();
        self.round_start_time = std::time::Instant::now();
    }

    pub fn propose_block(&mut self, block: tendermint::block::Block) {
        self.proposed_block = Some(block);
    }

    pub fn vote(&mut self, participant: String, vote: bool) {
        if self.is_eligible(&participant) {
            self.participants.push(participant);
            self.votes.push(vote);
        }
    }

    pub async fn finalize_block(&mut self) -> Result<Option<tendermint::block::Block>, String> {
        let (total_reputation, approval_reputation) = self.parallel_vote_counting().await?;

        // BFT requirement: Need more than 2/3 of total reputation for finalization
        let bft_threshold = (total_reputation as f64 * 2.0 / 3.0) as i64;

        if approval_reputation > bft_threshold {
            if let Some(block) = &self.proposed_block {
                // Update block metadata before finalization
                let mut final_block = block.clone();
                let consensus_duration = self.round_start_time.elapsed().as_millis() as u64;
                final_block.header.time = tendermint::time::Time::from_unix_timestamp(consensus_duration as i64, 0).unwrap();

                // Clear round state
                self.start_round();

                Ok(Some(final_block))
            } else {
                Err("No proposed block".into())
            }
        } else {
            Ok(None)
        }
    }

    pub async fn handle_timeout(&self) {
        // Placeholder logic for handling timeout
    }

    fn is_eligible(&self, participant: &str) -> bool {
        self.reputation_manager.is_eligible(participant, 10, "consensus").unwrap_or(false)
    }

    pub async fn parallel_vote_counting(&self) -> Result<(i64, i64), String> {
        let total_reputation: i64 = self.participants.iter().map(|p| self.reputation_manager.get_reputation(p, "consensus").unwrap_or(0)).sum();
        let approval_reputation: i64 = self.participants.iter().zip(&self.votes).filter(|(_, &v)| v).map(|(p, _)| self.reputation_manager.get_reputation(p, "consensus").unwrap_or(0)).sum();
        Ok((total_reputation, approval_reputation))
    }

    pub async fn select_validators(&mut self, min_reputation: i64) -> Result<Vec<String>, String> {
        let mut validators = Vec::new();
        for participant in &self.participants {
            if self.reputation_manager.is_eligible(participant, min_reputation, "consensus").unwrap_or(false) {
                validators.push(participant.clone());
            }
        }

        // BFT requirement: Need at least 3f + 1 validators where f is max faulty nodes
        let min_validators = (self.participants.len() / 3) * 3 + 1;
        if validators.len() < min_validators {
            return Err(format!("Insufficient validators: {} (need {})", validators.len(), min_validators));
        }

        Ok(validators)
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| e.to_string())
    }

    pub async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        apply_reputation_decay_in_ledger(_did, decay_rate).await.map_err(|e| e.to_string())
    }
}

#[async_trait]
impl ConsensusEngine for ProofOfCooperation {
    async fn start(&self) -> Result<(), String> {
        // Placeholder logic for starting the consensus engine
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        // Placeholder logic for stopping the consensus engine
        Ok(())
    }

    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String> {
        self.reputation_manager.get_reputation(did, category).await
    }

    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String> {
        self.reputation_manager.is_eligible(did, min_reputation, category).await
    }

    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String> {
        self.reputation_manager.adjust_reputation(did, contribution, "consensus").await
    }

    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> {
        self.reputation_manager.apply_decay(_did, decay_rate).await
    }

    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String> {
        self.reputation_based_access(did, min_reputation).await
    }

    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        self.propose_block(block);
        Ok(())
    }

    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String> {
        self.vote(block.header.proposer_address.to_string(), vote);
        Ok(())
    }

    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        self.finalize_block().await.map(|_| ()).map_err(|e| e.to_string())
    }

    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Placeholder logic for submitting a proposal
        Ok(1) // Placeholder proposal ID
    }

    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        // Placeholder logic for voting on a proposal
        Ok(())
    }

    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        self.handle_sybil_resistance(did, reputation_score).await
    }

    async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        self.apply_reputation_decay(_did, decay_rate).await
    }
}

pub struct TendermintConsensus {
    client: Client,
    trusted_state: Arc<Mutex<TrustedState>>,
}

impl TendermintConsensus {
    pub fn new(client: Client, trusted_state: TrustedState) -> Self {
        Self {
            client,
            trusted_state: Arc::new(Mutex::new(trusted_state)),
        }
    }
}

#[async_trait]
impl ConsensusEngine for TendermintConsensus {
    async fn start(&self) -> Result<(), String> {
        // Placeholder logic for starting the Tendermint consensus engine
        Ok(())
    }

    async fn stop(&self) -> Result<(), String> {
        // Placeholder logic for stopping the Tendermint consensus engine
        Ok(())
    }

    async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, String> {
        // Placeholder logic for getting reputation
        Ok(0)
    }

    async fn is_eligible(&self, did: &str, min_reputation: i64, category: &str) -> Result<bool, String> {
        // Placeholder logic for checking eligibility
        Ok(true)
    }

    async fn dynamic_adjustment(&self, did: &str, contribution: i64) -> Result<(), String> {
        // Placeholder logic for dynamic adjustment
        Ok(())
    }

    async fn apply_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> {
        // Placeholder logic for applying decay
        Ok(())
    }

    async fn reputation_based_access(&self, did: &str, min_reputation: i64) -> Result<bool, String> {
        // Placeholder logic for reputation-based access
        Ok(true)
    }

    async fn propose_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        // Placeholder logic for proposing a block
        Ok(())
    }

    async fn vote_on_block(&self, block: tendermint::block::Block, vote: bool) -> Result<(), String> {
        // Placeholder logic for voting on a block
        Ok(())
    }

    async fn finalize_block(&self, block: tendermint::block::Block) -> Result<(), String> {
        // Placeholder logic for finalizing a block
        Ok(())
    }

    async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Placeholder logic for submitting a proposal
        Ok(1) // Placeholder proposal ID
    }

    async fn vote(&self, proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        // Placeholder logic for voting on a proposal
        Ok(())
    }

    async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> { // Pfffb
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }

    async fn apply_reputation_decay(&self, _did: &str, decay_rate: f64) -> Result<(), String> { // Pf5c9
        // Placeholder logic for applying reputation decay
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::reputation::ReputationManager;
    use tokio::sync::Mutex;
    use std::sync::Arc;
    use tendermint::lite::TrustedState;
    use tendermint::rpc::Client;

    #[tokio::test]
    async fn test_propose_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.propose_block(block).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote_on_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.vote_on_block(block, true).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_finalize_block() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let block = tendermint::block::Block::default();
        let result = consensus.finalize_block(block).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_submit_proposal() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let result = consensus.submit_proposal("Test Proposal", "This is a test proposal", "did:icn:test", "2024-12-31T23:59:59Z").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_vote_on_proposal() {
        let client = Client::new("http://localhost:26657").unwrap();
        let trusted_state = TrustedState::default();
        let consensus = TendermintConsensus::new(client, trusted_state);

        let result = consensus.vote(1, "did:icn:test", true).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/core/ledger.rs
Size: 3137 bytes
===================
```rs
use crate::database::models::{Proposal, Vote};
use crate::database::queries::{create_proposal, record_vote};
use sqlx::PgPool;
use std::sync::Arc;

pub struct Ledger {
    db_pool: Arc<PgPool>,
}

impl Ledger {
    pub fn new(db_pool: Arc<PgPool>) -> Self {
        Self { db_pool }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        create_proposal(&self.db_pool, &proposal).await
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        record_vote(&self.db_pool, &vote).await
    }

    pub async fn record_federation_transaction(&self, federation_id: i64, transaction: &str) -> Result<(), sqlx::Error> {
        // Placeholder logic for recording federation transaction
        Ok(())
    }

    pub async fn record_proposal_transaction(&self, proposal_id: i64, transaction: &str) -> Result<(), sqlx::Error> {
        // Placeholder logic for recording proposal transaction
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::database::models::{Proposal, Vote};
    use sqlx::{PgPool, Executor};
    use std::sync::Arc;
    use chrono::NaiveDateTime;

    async fn setup_test_db() -> Arc<PgPool> {
        let pool = PgPool::connect("postgres://icnuser:icnpass@localhost/icndb").await.unwrap();
        pool.execute("TRUNCATE TABLE proposals, votes").await.unwrap();
        Arc::new(pool)
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let result = ledger.create_proposal(proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = ledger.record_vote(vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_federation_transaction() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let result = ledger.record_federation_transaction(1, "Test Federation Transaction").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_proposal_transaction() {
        let db_pool = setup_test_db().await;
        let ledger = Ledger::new(db_pool.clone());

        let result = ledger.record_proposal_transaction(1, "Test Proposal Transaction").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/database.rs
Size: 3228 bytes
===================
```rs
use sqlx::PgPool;
use std::sync::Arc;
use std::env;
use crate::models::*;

pub struct Database {
    pub pool: Arc<PgPool>,
}

impl Database {
    pub async fn new() -> Result<Self, sqlx::Error> {
        let database_url = env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@localhost:5432/icndb".to_string());
            
        let pool = PgPool::connect(&database_url).await?;
        
        Ok(Self {
            pool: Arc::new(pool),
        })
    }
    
    pub async fn create_proposal(&self, _proposal: &Proposal) -> Result<i64, sqlx::Error> {
        // This is a mock implementation for testing
        Ok(1) // Return a dummy proposal ID
    }
    
    pub async fn get_proposal(&self, id: i64) -> Result<Proposal, sqlx::Error> {
        // This is a mock implementation for testing
        // In a real system, this would query the database
        Ok(Proposal {
            id,
            title: "Test Proposal".to_string(),
            description: "A test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp_opt(1714000000, 0).unwrap(),
            created_at: chrono::NaiveDateTime::from_timestamp_opt(1613000000, 0).unwrap(),
            verifiable_credential: None,
            did: "did:icn:test".to_string(),
        })
    }
    
    pub async fn record_vote(&self, vote: &Vote) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn get_identity(&self, did: &str) -> Result<String, sqlx::Error> {
        // This is a mock implementation for testing
        Ok(did.to_string())
    }
    
    pub async fn update_identity(&self, did: &str, data: &str) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn create_federation(&self, federation: &Federation) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn add_federation_member(&self, member: &FederationMember) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn register_resource(&self, resource: &Resource) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn update_resource_usage(&self, id: &str, usage: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
    
    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
}

// For tests that don't need a real database connection
#[cfg(test)]
pub fn create_test_database() -> Database {
    use std::sync::Arc;
    use sqlx::PgPool;
    
    Database {
        pool: Arc::new(PgPool::new("postgres://icnuser:icnpass@localhost:5432/icndb_test")),
    }
}
```

===================
File: ./backend/src/database/db.rs
Size: 7343 bytes
===================
```rs
use sqlx::PgPool;
use crate::models::{Proposal, Vote};
use std::env;

pub struct Database {
    pool: PgPool,
}

impl Database {
    pub async fn new() -> Result<Self, sqlx::Error> {
        // Load from environment variable with fallback
        let database_url = env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
            
        let pool = PgPool::connect(&database_url).await?;
        
        // Run migrations
        sqlx::migrate!("./migrations")
            .run(&pool)
            .await?;
            
        Ok(Self { pool })
    }

    pub async fn create_proposal(&self, proposal: &Proposal) -> Result<i64, sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO proposals (title, description, created_by, ends_at, did)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id
            "#,
            proposal.title,
            proposal.description,
            proposal.created_by,
            proposal.ends_at,
            proposal.did
        )
        .fetch_one(&self.pool)
        .await
        .map(|row| row.id)
        .map_err(|e| {
            eprintln!("Error creating proposal: {}", e);
            e
        })
    }

    pub async fn record_vote(&self, _vote: &Vote) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO votes (proposal_id, voter, approve)
            VALUES ($1, $2, $3)
            "#,
            _vote.proposal_id,
            _vote.voter,
            _vote.approve
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error recording vote: {}", e);
            e
        })?;
        
        Ok(())
    }

    pub async fn store_identity(&self, identity: &str, data: &str) -> Result<(), sqlx::Error> {
        sqlx::query!(
            r#"
            INSERT INTO identities (identity, data)
            VALUES ($1, $2)
            ON CONFLICT (identity) DO UPDATE SET data = $2
            "#,
            identity,
            data
        )
        .execute(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error storing identity: {}", e);
            e
        })?;
        
        Ok(())
    }

    pub async fn retrieve_identity(&self, identity: &str) -> Result<String, sqlx::Error> {
        let result = sqlx::query!(
            r#"
            SELECT data FROM identities WHERE identity = $1
            "#,
            identity
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| {
            eprintln!("Error retrieving identity: {}", e);
            e
        })?;
        
        Ok(result.data)
    }

    pub async fn execute_query(&self, query: &str) -> Result<sqlx::Row, sqlx::Error> {
        sqlx::query(query)
            .fetch_one(&self.pool)
            .await
    }

    pub async fn run_migration(&self, migration: &str) -> Result<(), sqlx::Error> {
        sqlx::query(migration)
            .execute(&self.pool)
            .await?;
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as f64;
        let contributions = sqlx::query_as!(
            Contribution,
            r#"
            SELECT score, timestamp FROM contributions WHERE did = $1
            "#,
            did
        )
        .fetch_all(&self.pool)
        .await?;

        for contribution in contributions {
            let age = now - contribution.timestamp;
            let decayed_score = (contribution.score as f64 * (-decay_rate * age).exp()) as i64;
            sqlx::query!(
                r#"
                UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
                "#,
                decayed_score,
                did,
                contribution.timestamp
            )
            .execute(&self.pool)
            .await?;
        }

        Ok(())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> PgPool {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        PgPool::connect(&database_url).await.unwrap()
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let proposal = Proposal {
            id: 0,
            title: "Test Proposal".to_string(),
            description: "Test Description".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            did: "did:icn:test".to_string(),
        };

        let result = db.create_proposal(&proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = db.record_vote(&vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_store_and_retrieve_identity() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let identity = "did:icn:test";
        let data = "test data";

        let store_result = db.store_identity(identity, data).await;
        assert!(store_result.is_ok());

        let retrieve_result = db.retrieve_identity(identity).await;
        assert!(retrieve_result.is_ok());
        assert_eq!(retrieve_result.unwrap(), data);
    }

    #[tokio::test]
    async fn test_execute_query() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let query = "SELECT 1";
        let result = db.execute_query(query).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_run_migration() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let migration = "CREATE TABLE test_table (id SERIAL PRIMARY KEY)";
        let result = db.run_migration(migration).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let did = "did:icn:test";
        let decay_rate = 0.05;

        let result = db.apply_reputation_decay(did, decay_rate).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let pool = setup_test_db().await;
        let db = Database { pool };

        let did = "did:icn:test";
        let reputation_score = 50;

        let result = db.handle_sybil_resistance(did, reputation_score).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/database/migrations.rs
Size: 301 bytes
===================
```rs
use sqlx::migrate::Migrator;
use std::path::Path;

pub async fn run_migrations() -> Result<(), sqlx::Error> {
    let migrator = Migrator::new(Path::new("./migrations")).await?;
    let pool = sqlx::PgPool::connect(&std::env::var("DATABASE_URL")?).await?;
    migrator.run(&pool).await?;
    Ok(())
}
```

===================
File: ./backend/src/database/models.rs
Size: 3954 bytes
===================
```rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Proposal {
    pub id: i64,
    pub title: String,
    pub description: String,
    pub created_by: String,
    pub ends_at: chrono::NaiveDateTime,
    pub created_at: chrono::NaiveDateTime,
    pub _did: String, // Add did field for DID-based access control
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: i64,
    pub voter: String,
    pub approve: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Contribution {
    pub id: i64,
    pub did: String,
    pub score: i64,
    pub timestamp: f64,
    pub zk_snark_proof: Option<String>, // Added zk-SNARK proof field
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Federation {
    pub id: i64,
    pub name: String,
    pub description: String,
    pub created_at: chrono::NaiveDateTime,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Resource {
    pub id: i64,
    pub name: String,
    pub resource_type: String,
    pub owner: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_proposal_serialization() {
        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            _did: "did:icn:test".to_string(), // Add did field for DID-based access control
        };

        let serialized = serde_json::to_string(&proposal).unwrap();
        let deserialized: Proposal = serde_json::from_str(&serialized).unwrap();

        assert_eq!(proposal, deserialized);
    }

    #[test]
    fn test_vote_serialization() {
        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let serialized = serde_json::to_string(&vote).unwrap();
        let deserialized: Vote = serde_json::from_str(&serialized).unwrap();

        assert_eq!(vote, deserialized);
    }

    #[test]
    fn test_contribution_serialization() {
        let contribution = Contribution {
            id: 1,
            did: "did:icn:test".to_string(),
            score: 100,
            timestamp: 1_614_000_000.0,
            zk_snark_proof: Some("proof".to_string()),
        };

        let serialized = serde_json::to_string(&contribution).unwrap();
        let deserialized: Contribution = serde_json::from_str(&serialized).unwrap();

        assert_eq!(contribution, deserialized);
    }

    #[test]
    fn test_federation_serialization() {
        let federation = Federation {
            id: 1,
            name: "Test Federation".to_string(),
            description: "This is a test federation".to_string(),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let serialized = serde_json::to_string(&federation).unwrap();
        let deserialized: Federation = serde_json::from_str(&serialized).unwrap();

        assert_eq!(federation, deserialized);
    }

    #[test]
    fn test_resource_serialization() {
        let resource = Resource {
            id: 1,
            name: "Test Resource".to_string(),
            resource_type: "cpu".to_string(),
            owner: "did:icn:test".to_string(),
            created_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
            updated_at: chrono::NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let serialized = serde_json::to_string(&resource).unwrap();
        let deserialized: Resource = serde_json::from_str(&serialized).unwrap();

        assert_eq!(resource, deserialized);
    }
}
```

===================
File: ./backend/src/database/queries.rs
Size: 6448 bytes
===================
```rs
use sqlx::PgPool;
use crate::database::models::{Proposal, Vote, Contribution, Federation, Resource};

pub async fn create_proposal(pool: &PgPool, _proposal: &Proposal) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO proposals (title, description, created_by, ends_at, created_at, did)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
        "#,
        _proposal.title,
        _proposal.description,
        _proposal.created_by,
        _proposal.ends_at,
        _proposal.created_at,
        _proposal.did
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn record_vote(pool: &PgPool, vote: &Vote) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        INSERT INTO votes (proposal_id, voter, approve)
        VALUES ($1, $2, $3)
        "#,
        vote.proposal_id,
        vote.voter,
        vote.approve
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn query_shared_resources(pool: &PgPool, resource_type: &str, owner: Option<&str>) -> Result<Vec<Resource>, sqlx::Error> {
    let query = match owner {
        Some(owner) => {
            sqlx::query_as!(
                Resource,
                r#"
                SELECT * FROM resources
                WHERE resource_type = $1 AND owner = $2
                "#,
                resource_type,
                owner
            )
        }
        None => {
            sqlx::query_as!(
                Resource,
                r#"
                SELECT * FROM resources
                WHERE resource_type = $1
                "#,
                resource_type
            )
        }
    };

    let resources = query.fetch_all(pool).await?;
    Ok(resources)
}

pub async fn store_contribution(pool: &PgPool, contribution: &Contribution) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO contributions (did, score, timestamp, zk_snark_proof)
        VALUES ($1, $2, $3, $4)
        RETURNING id
        "#,
        contribution.did,
        contribution.score,
        contribution.timestamp,
        contribution.zk_snark_proof
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn retrieve_contributions(pool: &PgPool, did: &str) -> Result<Vec<Contribution>, sqlx::Error> {
    let contributions = sqlx::query_as!(
        Contribution,
        r#"
        SELECT id, did, score, timestamp, zk_snark_proof FROM contributions
        WHERE did = $1
        "#,
        did
    )
    .fetch_all(pool)
    .await?;

    Ok(contributions)
}

pub async fn store_proposal(pool: &PgPool, proposal: &Proposal) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO proposals (title, description, created_by, ends_at, created_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
        "#,
        proposal.title,
        proposal.description,
        proposal.created_by,
        proposal.ends_at,
        proposal.created_at
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn store_vote(pool: &PgPool, vote: &Vote) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        INSERT INTO votes (proposal_id, voter, approve)
        VALUES ($1, $2, $3)
        "#,
        vote.proposal_id,
        vote.voter,
        vote.approve
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn create_federation(pool: &PgPool, federation: &Federation) -> Result<i64, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        INSERT INTO federations (name, description, created_at)
        VALUES ($1, $2, $3)
        RETURNING id
        "#,
        federation.name,
        federation.description,
        federation.created_at
    )
    .fetch_one(pool)
    .await?;

    Ok(row.id)
}

pub async fn update_federation_status(pool: &PgPool, federation_id: i64, status: &str) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        UPDATE federations
        SET status = $1
        WHERE id = $2
        "#,
        status,
        federation_id
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn dissolve_federation(pool: &PgPool, federation_id: i64) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        DELETE FROM federations
        WHERE id = $1
        "#,
        federation_id
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn get_federation_status(pool: &PgPool, federation_id: i64) -> Result<String, sqlx::Error> {
    let row = sqlx::query!(
        r#"
        SELECT status FROM federations
        WHERE id = $1
        "#,
        federation_id
    )
    .fetch_one(pool)
    .await?;

    Ok(row.status)
}

pub async fn get_federation_assets(pool: &PgPool, federation_id: i64) -> Result<Vec<Resource>, sqlx::Error> {
    let resources = sqlx::query_as!(
        Resource,
        r#"
        SELECT * FROM resources
        WHERE federation_id = $1
        "#,
        federation_id
    )
    .fetch_all(pool)
    .await?;

    Ok(resources)
}

pub async fn get_federation_debts(pool: &PgPool, federation_id: i64) -> Result<Vec<Resource>, sqlx::Error> {
    let resources = sqlx::query_as!(
        Resource,
        r#"
        SELECT * FROM resources
        WHERE federation_id = $1 AND type = 'debt'
        "#,
        federation_id
    )
    .fetch_all(pool)
    .await?;

    Ok(resources)
}

pub async fn apply_reputation_decay(pool: &PgPool, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
    let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as f64;
    let contributions = sqlx::query_as!(
        Contribution,
        r#"
        SELECT score, timestamp FROM contributions WHERE did = $1
        "#,
        did
    )
    .fetch_all(pool)
    .await?;

    for contribution in contributions {
        let age = now - contribution.timestamp;
        let decayed_score = (contribution.score as f64 * (-decay_rate * age).exp()) as i64;
        sqlx::query!(
            r#"
            UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
            "#,
            decayed_score,
            did,
            contribution.timestamp
        )
        .execute(pool)
        .await?;
    }

    Ok(())
}

pub async fn handle_sybil_resistance(pool: &PgPool, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
    // Placeholder logic for handling Sybil resistance
    Ok(())
}
```

===================
File: ./backend/src/db.rs
Size: 1396 bytes
===================
```rs
use sqlx::PgPool;
use std::sync::Arc;
use std::env;
use crate::models::{Proposal, Vote};

pub struct Database {
    pub db_pool: Arc<PgPool>,
}

impl Database {
    pub fn new(pool: PgPool) -> Self {
        Self {
            db_pool: Arc::new(pool),
        }
    }

    pub async fn create_proposal(&self, proposal: &Proposal) -> Result<i64, sqlx::Error> {
        // This is a mock implementation for testing
        // In a real system, this would insert into a database
        Ok(1)
    }

    pub async fn record_vote(&self, vote: &Vote) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        // This is a mock implementation for testing
        Ok(())
    }
}

pub async fn create_pool() -> Result<PgPool, sqlx::Error> {
    let database_url = env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        
    let pool = PgPool::connect(&database_url).await?;
    
    // Run migrations
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await?;
        
    Ok(pool)
}
```

===================
File: ./backend/src/db/indexing.rs
Size: 1102 bytes
===================
```rs
use sqlx::{PgPool, Row};
use log::{info, warn};

// Index usage monitoring
pub async fn analyze_index_usage(pool: &PgPool) -> Result<(), sqlx::Error> {
    // Query to get index usage statistics
    let index_stats = sqlx::query(r#"
        SELECT
            schemaname,
            relname AS table_name,
            indexrelname AS index_name,
            idx_scan AS scan_count,
            idx_tup_read AS tuples_read,
            idx_tup_fetch AS tuples_fetched
        FROM
            pg_stat_user_indexes
        ORDER BY
            idx_scan DESC
    "#)
    .fetch_all(pool)
    .await?;
    
    info!("Index usage statistics:");
    for stat in index_stats {
        let schema: String = stat.get("schemaname");
        let table: String = stat.get("table_name");
        let index: String = stat.get("index_name");
        let scans: i64 = stat.get("scan_count");
        
        if scans == 0 {
            warn!("Unused index: {}.{}.{}", schema, table, index);
        } else {
            info!("Index {}.{}.{} used {} times", schema, table, index, scans);
        }
    }
    
    Ok```

===================
File: ./backend/src/federation.rs
Size: 3169 bytes
===================
```rs
use std::collections::HashMap;
use crate::governance::{Federation, FederationType, FederationTerms};

pub struct FederationManager {
    federations: HashMap<String, Federation>,
}

impl FederationManager {
    pub fn new() -> Self {
        Self {
            federations: HashMap::new(),
        }
    }
    
    pub fn create_federation(&mut self, id: String, _federation_type: FederationType, terms: FederationTerms, admin: String) -> Result<(), String> {
        if self.federations.contains_key(&id) {
            return Err("Federation already exists".to_string());
        }
        
        let federation = Federation::new(id.clone(), _federation_type, terms, admin);
        self.federations.insert(id, federation);
        
        Ok(())
    }
    
    pub fn get_federation(&self, id: &str) -> Option<&Federation> {
        self.federations.get(id)
    }
    
    pub fn get_federations_by_member(&self, member_did: &str) -> Vec<&Federation> {
        self.federations.values()
            .filter(|f| f.members.contains_key(member_did))
            .collect()
    }
    
    pub fn add_member_to_federation(&mut self, federation_id: &str, member_did: String, role: crate::governance::MemberRole) -> Result<(), String> {
        let federation = self.federations.get_mut(federation_id)
            .ok_or("Federation not found")?;
            
        federation.add_member(member_did, role)
    }
    
    pub async fn detect_conflicts(&self, federation_id: &str) -> Result<Vec<(String, String)>, String> {
        let federation = self.federations.get(federation_id)
            .ok_or("Federation not found")?;
            
        Ok(federation.detect_resource_conflicts().await)
    }
    
    pub async fn resolve_conflicts(&mut self, federation_id: &str, conflicts: Vec<(String, String)>) -> Result<(), String> {
        let federation = self.federations.get(federation_id)
            .ok_or("Federation not found")?;
            
        federation.resolve_conflicts(conflicts).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_create_federation() {
        let mut manager = FederationManager::new();
        
        let result = manager.create_federation(
            "fed1".to_string(),
            FederationType::Cooperative,
            FederationTerms::default(),
            "admin1".to_string()
        );
        
        assert!(result.is_ok());
        assert!(manager.get_federation("fed1").is_some());
    }
    
    #[test]
    fn test_add_member_to_federation() {
        let mut manager = FederationManager::new();
        
        manager.create_federation(
            "fed1".to_string(),
            FederationType::Cooperative,
            FederationTerms::default(),
            "admin1".to_string()
        ).unwrap();
        
        let result = manager.add_member_to_federation(
            "fed1",
            "member1".to_string(),
            crate::governance::MemberRole::Member
        );
        
        assert!(result.is_ok());
        
        let federation = manager.get_federation("fed1").unwrap();
        assert!(federation.members.contains_key("member1"));
    }
}
```

===================
File: ./backend/src/governance.rs
Size: 19808 bytes
===================
```rs
use crate::models::{Proposal, Vote};
use sqlx::PgPool;
use std::sync::Arc;
use log::{info, error};
use crate::db::Database;
use crate::identity::IdentityManager;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use futures::future::join_all; // Import join_all for concurrency
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalType {
    ResourceAllocation {
        resource: String,
        amount: u64,
    },
    ConfigUpdate {
        parameter: String,
        new_value: String,
    },
    MembershipChange {
        did: String,
        action: String,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub proposer: String,
    pub proposal_type: ProposalType,
    pub votes_for: u32,
    pub votes_against: u32,
    pub timestamp: u64,
    pub status: ProposalStatus,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Executed,
}

impl Proposal {
    pub fn new(proposer: String, proposal_type: ProposalType) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            proposer,
            proposal_type,
            votes_for: 0,
            votes_against: 0,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            status: ProposalStatus::Active,
        }
    }

    pub fn is_approved(&self) -> bool {
        self.status == ProposalStatus::Approved
            || (self.votes_for > self.votes_against && self.votes_for >= 3)
    }
}

pub struct ProposalHistory {
    pub proposals: HashMap<String, Proposal>,
    pub votes: HashMap<String, HashMap<String, bool>>, // proposal_id -> (voter -> vote)
    pub network_connection: Option<String>, // Simulated network connection
}

impl ProposalHistory {
    pub fn new() -> Self {
        Self {
            proposals: HashMap::new(),
            votes: HashMap::new(),
            network_connection: Some("connected".to_string()),
        }
    }

    pub fn add_proposal(&mut self, proposal: Proposal) {
        let proposal_id = proposal.id.clone();
        self.proposals.insert(proposal_id.clone(), proposal);
        self.votes.insert(proposal_id, HashMap::new());
    }

    pub fn get_proposal(&self, id: String) -> Option<Proposal> {
        self.proposals.get(&id).cloned()
    }

    pub fn vote(&mut self, voter: String, proposal_id: String, vote: bool) -> Result<(), String> {
        // Check if network is connected
        if self.network_connection.is_none() {
            return Err("Network disconnected".to_string());
        }

        // Check if proposal exists
        let proposal = self.proposals.get_mut(&proposal_id).ok_or("Proposal not found")?;

        // Check if voter has already voted
        let votes = self.votes.get_mut(&proposal_id).ok_or("Votes not found")?;
        if votes.contains_key(&voter) {
            return Err("Already voted".to_string());
        }

        // Record vote
        votes.insert(voter, vote);

        // Update proposal vote count
        if vote {
            proposal.votes_for += 1;
        } else {
            proposal.votes_against += 1;
        }

        // Check if proposal is now approved or rejected
        if proposal.votes_for >= 3 {
            proposal.status = ProposalStatus::Approved;
        } else if proposal.votes_against >= 3 {
            proposal.status = ProposalStatus::Rejected;
        }

        Ok(())
    }

    pub fn update_proposal(&mut self, updated_proposal: Proposal) {
        if let Some(proposal) = self.proposals.get_mut(&updated_proposal.id) {
            *proposal = updated_proposal;
        }
    }

    pub async fn reconnect(&mut self) -> Result<(), String> {
        // Simulate network reconnection
        self.network_connection = Some("connected".to_string());
        Ok(())
    }

    pub fn execute_proposal(&mut self, proposal_id: &str) -> Result<(), String> {
        let proposal = self.proposals.get_mut(proposal_id).ok_or("Proposal not found")?;
        
        if proposal.status != ProposalStatus::Approved {
            return Err("Proposal is not approved".to_string());
        }
        
        // Execute proposal actions based on type
        match &proposal.proposal_type {
            ProposalType::ResourceAllocation { resource: _, amount: _ } => {
                // In a real system, this would allocate resources
                // For testing, we just mark it as executed
            }
            ProposalType::ConfigUpdate { parameter: _, new_value: _ } => {
                // In a real system, this would update configuration
            }
            ProposalType::MembershipChange { did: _, action: _ } => {
                // In a real system, this would change membership
            }
        }
        
        proposal.status = ProposalStatus::Executed;
        
        Ok(())
    }
}

pub struct Federation {
    pub id: String,
    pub federation_type: FederationType,
    pub terms: FederationTerms,
    pub admin: String,
    pub members: HashMap<String, MemberRole>,
    pub member_status: HashMap<String, MemberStatus>,
    pub proposals: HashMap<String, Proposal>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FederationType {
    Cooperative,
    Mutual,
    Association,
    Custom(String),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FederationTerms {
    pub minimum_reputation: u64,
    pub resource_sharing_policies: String,
    pub governance_rules: String,
    pub duration: String,
}

impl Default for FederationTerms {
    fn default() -> Self {
        Self {
            minimum_reputation: 0,
            resource_sharing_policies: "Equal".to_string(),
            governance_rules: "Majority".to_string(),
            duration: "2025-12-31T23:59:59Z".to_string(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MemberRole {
    Admin,
    Member,
    Observer,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MemberStatus {
    Active,
    Suspended,
    Inactive,
}

impl Federation {
    pub fn new(id: String, federation_type: FederationType, terms: FederationTerms, admin: String) -> Self {
        let mut members = HashMap::new();
        members.insert(admin.clone(), MemberRole::Admin);
        
        let mut member_status = HashMap::new();
        member_status.insert(admin.clone(), MemberStatus::Active);
        
        Self {
            id,
            federation_type,
            terms,
            admin,
            members,
            member_status,
            proposals: HashMap::new(),
        }
    }
    
    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        
        self.members.insert(did.clone(), role);
        self.member_status.insert(did, MemberStatus::Active);
        
        Ok(())
    }
    
    pub fn get_member_status(&self, did: &str) -> Option<&MemberStatus> {
        self.member_status.get(did)
    }
    
    pub fn update_member_status(&mut self, did: &str, status: MemberStatus) -> Result<(), String> {
        if !self.members.contains_key(did) {
            return Err("Member not found".to_string());
        }
        
        self.member_status.insert(did.to_string(), status);
        
        Ok(())
    }
    
    pub fn get_active_members(&self) -> Vec<String> {
        self.member_status
            .iter()
            .filter(|(_, status)| **status == MemberStatus::Active)
            .map(|(did, _)| did.clone())
            .collect()
    }
    
    pub async fn submit_proposal(&self, proposal: Proposal) -> Result<String, String> {
        // In a real implementation, this would add the proposal to the system
        Ok(proposal.id)
    }
    
    pub async fn detect_resource_conflicts(&self) -> Vec<(String, String)> {
        // This is a simplified conflict detection for testing
        let mut conflicts = Vec::new();
        
        // Find any proposals that allocate more than 70% of the same resource
        let mut resource_allocations = HashMap::new();
        
        for (id, proposal) in &self.proposals {
            if let ProposalType::ResourceAllocation { resource, amount } = &proposal.proposal_type {
                let entry = resource_allocations.entry(resource.clone()).or_insert_with(Vec::new);
                if *amount > 70 {
                    entry.push(id.clone());
                }
            }
        }
        
        // Create conflicts for resources with multiple high-allocation proposals
        for (resource, proposals) in resource_allocations {
            if proposals.len() > 1 {
                for i in 0..proposals.len() {
                    for j in i+1..proposals.len() {
                        conflicts.push((proposals[i].clone(), proposals[j].clone()));
                    }
                }
            }
        }
        
        conflicts
    }
    
    pub async fn resolve_conflicts(&self, _conflicts: Vec<(String, String)>) -> Result<(), String> {
        // In a real implementation, this would resolve conflicts
        Ok(())
    }
}

// Function for handling federation operations used in tests
pub async fn handle_federation_operation(operation: icn_types::FederationOperation) -> Result<String, String> {
    // This is a simplified implementation for testing
    match operation {
        icn_types::FederationOperation::InitiateFederation { 
            federation_type: _, partner_id: _, terms: _ 
        } => {
            Ok("federation123".to_string())
        },
        icn_types::FederationOperation::JoinFederation {
            federation_id, commitment: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::LeaveFederation {
            federation_id, reason: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::ProposeAction {
            federation_id, action_type: _, description: _, resources: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::VoteOnProposal {
            federation_id, proposal_id: _, approve: _, notes: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::ShareResources {
            federation_id, resource_type: _, amount: _, recipient_id: _
        } => {
            Ok(federation_id)
        },
        icn_types::FederationOperation::UpdateFederationTerms {
            federation_id, new_terms: _
        } => {
            Ok(federation_id)
        },
    }
}

pub struct GovernanceEngine {
    db: Arc<Database>,
    identity_manager: Arc<IdentityManager>,
}

impl GovernanceEngine {
    pub fn new(db: Arc<Database>, identity_manager: Arc<IdentityManager>) -> Self {
        Self {
            db,
            identity_manager,
        }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        // Verify DID using IdentityManager
        if !self.identity_manager.verify_did(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Invalid DID".to_string()));
        }

        // Validate verifiable credential
        if !self.identity_manager.verify_credential(&proposal.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        self.db.create_proposal(&proposal).await.map_err(|e| {
            error!("Error creating proposal: {}", e);
            e
        })
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        // Validate verifiable credential
        if !self.identity_manager.verify_credential(&vote.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        if let Some(proof) = &vote.zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }
        self.db.record_vote(&vote).await.map_err(|e| {
            error!("Error recording vote: {}", e);
            e
        })
    }

    pub async fn list_proposals(&self) -> Result<Vec<Proposal>, sqlx::Error> {
        let proposals = sqlx::query_as!(
            Proposal,
            r#"
            SELECT id, title, description, created_by, ends_at, created_at
            FROM proposals
            "#
        )
        .fetch_all(&*self.db.db_pool)
        .await
        .map_err(|e| {
            error!("Error listing proposals: {}", e);
            e
        })?;
        Ok(proposals)
    }

    pub async fn create_identity(&self, identity: &str) -> Result<(), String> {
        self.identity_manager.create_identity(identity).await
    }

    pub async fn get_identity(&self, identity: &str) -> Result<String, String> {
        self.identity_manager.get_identity(identity).await
    }

    pub async fn update_identity(&self, identity: &str, new_data: &str) -> Result<(), String> {
        self.identity_manager.update_identity(identity, new_data).await
    }

    pub async fn delete_identity(&self, identity: &str) -> Result<(), String> {
        self.identity_manager.delete_identity(identity).await
    }

    pub async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        // Verify DID using IdentityManager
        if !self.identity_manager.verify_did(created_by).await {
            return Err("Invalid DID".to_string());
        }

        let proposal = Proposal {
            id: 0, // Placeholder, will be set by the database
            title: title.to_string(),
            description: description.to_string(),
            created_by: created_by.to_string(),
            ends_at: chrono::NaiveDateTime::parse_from_str(ends_at, "%Y-%m-%d %H:%M:%S").map_err(|e| e.to_string())?,
            created_at: chrono::Utc::now().naive_utc(),
            did: created_by.to_string(), // Add did field for DID-based access control
        };

        self.create_proposal(proposal).await.map_err(|e| e.to_string())
    }

    pub async fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        let vote = Vote {
            proposal_id: _proposal_id,
            voter: voter.to_string(),
            approve,
        };

        self.record_vote(vote).await.map_err(|e| e.to_string())
    }

    pub async fn get_proposal_status(&self, proposal_id: &str) -> Result<String, sqlx::Error> {
        let status = sqlx::query!(
            r#"
            SELECT status FROM proposals WHERE id = $1
            "#,
            proposal_id
        )
        .fetch_one(&*self.db.db_pool)
        .await
        .map_err(|e| {
            error!("Error getting proposal status: {}", e);
            e
        })?;
        Ok(status.status)
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        self.db.apply_reputation_decay(did, decay_rate).await.map_err(|e| {
            error!("Error applying reputation decay: {}", e);
            e
        })
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        self.db.handle_sybil_resistance(did, reputation_score).await.map_err(|e| {
            error!("Error handling sybil resistance: {}", e);
            e
        })
    }

    pub async fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String> {
        // Placeholder logic for handling delegated governance
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::{Proposal, Vote};
    use crate::db::Database;
    use crate::identity::IdentityManager;
    use sqlx::{PgPool, Executor};
    use std::sync::Arc;
    use chrono::NaiveDateTime;

    async fn setup_test_db() -> Arc<Database> {
        let pool = PgPool::connect("postgres://icnuser:icnpass@localhost/icndb").await.unwrap();
        pool.execute("TRUNCATE TABLE proposals, votes").await.unwrap();
        Arc::new(Database::new(pool))
    }

    #[tokio::test]
    async fn test_create_proposal() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let proposal = Proposal {
            id: 1,
            title: "Test Proposal".to_string(),
            description: "This is a test proposal".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
            created_at: NaiveDateTime::from_timestamp(1_614_000_000, 0),
        };

        let result = governance_engine.create_proposal(proposal).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_record_vote() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let vote = Vote {
            proposal_id: 1,
            voter: "did:icn:test".to_string(),
            approve: true,
        };

        let result = governance_engine.record_vote(vote).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_list_proposals() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let proposals = governance_engine.list_proposals().await;
        assert!(proposals.is_ok());
    }

    #[tokio::test]
    async fn test_get_proposal_status() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let status = governance_engine.get_proposal_status("1").await;
        assert!(status.is_ok());
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.apply_reputation_decay("did:icn:test", 0.1).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.handle_sybil_resistance("did:icn:test", 50).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_handle_delegated_governance() {
        let db = setup_test_db().await;
        let identity_manager = Arc::new(IdentityManager::new(db.clone()));
        let governance_engine = GovernanceEngine::new(db.clone(), identity_manager.clone());

        let result = governance_engine.handle_delegated_governance("federation_id", "representative_id").await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/identity.rs
Size: 17896 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use icn_identity::ledger::{create_identity_in_ledger, get_identity_from_ledger, rotate_key_in_ledger, revoke_key_in_ledger};
use icn_core::verifiable_credentials::{VerifiableCredential, Proof};
use futures::future::join_all; // Import join_all for concurrency
use rand::rngs::OsRng;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone)]
pub struct BlsPrivateKey {
    key_data: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct BlsPublicKey {
    key_data: Vec<u8>,
}

impl BlsPrivateKey {
    pub fn generate(rng: &mut impl rand::RngCore) -> Self {
        let mut key_data = vec![0u8; 32];
        rng.fill_bytes(&mut key_data);
        Self { key_data }
    }
}

impl From<&BlsPrivateKey> for BlsPublicKey {
    fn from(private_key: &BlsPrivateKey) -> Self {
        // In a real implementation, we'd derive the public key from the private key
        // Here we just create a simple hash-like derivative for testing
        let mut key_data = private_key.key_data.clone();
        for byte in &mut key_data {
            *byte = byte.wrapping_add(1);
        }
        Self { key_data }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Algorithm {
    Secp256k1,
    Ed25519,
    Kyber,
    Dilithium,
    Falcon,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    pub algorithm: Algorithm,
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
    pub is_revoked: bool,
}

pub enum DIDError {
    SigningError(String),
    VerificationError(String),
    RevocationError(String),
}

impl DID {
    pub fn new(id: String, algorithm: Algorithm) -> Self {
        // In a real application, this would generate proper keypairs
        // For testing, we'll simulate key generation
        let mut rng = OsRng;
        
        // Generate random "keys" for testing
        let mut public_key = vec![0u8; 32];
        let mut private_key = vec![0u8; 32];
        rand::Rng::fill(&mut rng, &mut public_key[..]);
        rand::Rng::fill(&mut rng, &mut private_key[..]);
        
        Self {
            id,
            algorithm,
            public_key,
            private_key,
            is_revoked: false,
        }
    }
    
    pub fn sign_message(&self, _message: &[u8]) -> Result<Vec<u8>, DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Key has been revoked".to_string()));
        }
        
        // In a real implementation, this would use the actual crypto library
        // For testing, we'll just simulate a signature
        let mut signature = Vec::with_capacity(64);
        signature.extend_from_slice(&self.private_key);
        signature.extend_from_slice(_message);
        
        Ok(signature)
    }
    
    pub fn verify_signature(&self, message: &[u8], signature: &[u8]) -> Result<bool, DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Key has been revoked".to_string()));
        }
        
        // In a real implementation, this would use the actual crypto library
        // For testing, we'll just verify that the signature contains our private key
        if signature.len() < self.private_key.len() {
            return Err(DIDError::VerificationError("Signature too short".to_string()));
        }
        
        let key_part = &signature[0..self.private_key.len()];
        Ok(key_part == self.private_key.as_slice())
    }
    
    pub fn rotate_key(&mut self) -> Result<(), DIDError> {
        if self.is_revoked {
            return Err(DIDError::RevocationError("Cannot rotate revoked key".to_string()));
        }
        
        // Generate new keypair
        let mut rng = OsRng;
        rand::Rng::fill(&mut rng, &mut self.public_key[..]);
        rand::Rng::fill(&mut rng, &mut self.private_key[..]);
        
        Ok(())
    }
    
    pub fn revoke_key(&mut self) -> Result<(), DIDError> {
        self.is_revoked = true;
        Ok(())
    }
}

pub struct IdentitySystem {
    pub dids: HashMap<String, DID>,
    pub permissions: HashMap<String, Vec<String>>,
    pub public_keys: HashMap<String, (Vec<u8>, Algorithm)>,
    pub federation_roles: HashMap<String, HashMap<String, Vec<String>>>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        Self {
            dids: HashMap::new(),
            permissions: HashMap::new(),
            public_keys: HashMap::new(),
            federation_roles: HashMap::new(),
        }
    }
    
    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.dids.insert(did.id.clone(), did.clone());
        self.permissions.insert(did.id.clone(), permissions);
        self.public_keys.insert(did.id.clone(), (did.public_key.clone(), did.algorithm));
    }
    
    pub fn has_permission(&self, did_str: &str, permission: &str) -> bool {
        if let Some(perms) = self.permissions.get(did_str) {
            perms.contains(&permission.to_string())
        } else {
            false
        }
    }
    
    pub fn rotate_key(&mut self, did_str: &str) -> Result<(), DIDError> {
        if let Some(did) = self.dids.get_mut(did_str) {
            did.rotate_key()?;
            self.public_keys.insert(did_str.to_string(), (did.public_key.clone(), did.algorithm.clone()));
            Ok(())
        } else {
            Err(DIDError::SigningError("DID not found".to_string()))
        }
    }
    
    pub fn assign_federation_role(&mut self, federation_id: String, did: String, role: String) -> Result<(), String> {
        let federation_roles = self.federation_roles
            .entry(federation_id)
            .or_insert_with(HashMap::new);
            
        let roles = federation_roles
            .entry(did)
            .or_insert_with(Vec::new);
            
        if !roles.contains(&role) {
            roles.push(role);
        }
        
        Ok(())
    }
    
    pub fn revoke_federation_role(&mut self, federation_id: &str, did: &str, role: &str) -> Result<(), String> {
        if let Some(federation_roles) = self.federation_roles.get_mut(federation_id) {
            if let Some(roles) = federation_roles.get_mut(did) {
                roles.retain(|r| r != role);
                return Ok(());
            }
        }
        Err("Federation or DID not found".to_string())
    }
    
    pub fn get_federation_roles(&self, federation_id: &str, did: &str) -> Vec<String> {
        self.federation_roles
            .get(federation_id)
            .and_then(|federation_roles| federation_roles.get(did))
            .cloned()
            .unwrap_or_else(Vec::new)
    }
    
    pub fn generate_bls_threshold_signature(&self, message: &[u8], _private_keys: Vec<BlsPrivateKey>) -> Result<Vec<u8>, String> {
        // This is a simplified mock for testing
        Ok(message.to_vec())
    }
    
    pub fn verify_bls_threshold_signature(&self, message: &[u8], signature: &[u8], _public_keys: Vec<BlsPublicKey>) -> Result<bool, String> {
        // This is a simplified mock for testing
        Ok(message == signature)
    }
}

pub struct IdentityManager {
    identities: Arc<Mutex<HashMap<String, String>>>,
    local_clusters: Arc<Mutex<HashMap<String, Vec<String>>>>,
}

impl IdentityManager {
    pub fn new() -> Self {
        IdentityManager {
            identities: Arc::new(Mutex::new(HashMap::new())),
            local_clusters: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn create_identity(&self, identity: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if identities.contains_key(identity) {
            return Err("Identity already exists".to_string());
        }
        identities.insert(identity.to_string(), String::new());

        // Issue Verifiable Credential in ICN format
        let credential = VerifiableCredential {
            credential_type: "IdentityCredential".to_string(),
            issuer_did: "did:icn:issuer".to_string(),
            subject_did: identity.to_string(),
            issuance_date: chrono::Utc::now().to_rfc3339(),
            expiration_date: None,
            credential_status: None,
            credential_schema: None,
            proof: Proof {
                type_: "Ed25519Signature2018".to_string(),
                created: chrono::Utc::now().to_rfc3339(),
                proof_purpose: "assertionMethod".to_string(),
                verification_method: "did:icn:issuer#keys-1".to_string(),
                jws: "example-jws".to_string(),
            },
        };

        // Store identity in icn-identity ledger
        create_identity_in_ledger(identity, &credential).await.map_err(|e| e.to_string())?;

        Ok(())
    }

    pub async fn get_identity(&self, identity: &str) -> Result<String, String> {
        // Retrieve identity from icn-identity ledger
        get_identity_from_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn update_identity(&self, identity: &str, new_data: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if let Some(existing_identity) = identities.get_mut(identity) {
            *existing_identity = new_data.to_string();
            Ok(())
        } else {
            Err("Identity not found".to_string())
        }
    }

    pub async fn delete_identity(&self, identity: &str) -> Result<(), String> {
        let mut identities = self.identities.lock().await;
        if identities.remove(identity).is_some() {
            Ok(())
        } else {
            Err("Identity not found".to_string())
        }
    }

    pub async fn rotate_key(&self, identity: &str) -> Result<(), String> {
        // Rotate key in icn-identity ledger
        rotate_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn revoke_key(&self, identity: &str) -> Result<(), String> {
        // Revoke key in icn-identity ledger
        revoke_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    pub async fn create_local_cluster(&self, cluster_name: &str, members: Vec<String>) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if local_clusters.contains_key(cluster_name) {
            return Err("Local cluster already exists".to_string());
        }
        local_clusters.insert(cluster_name.to_string(), members);
        Ok(())
    }

    pub async fn get_local_cluster(&self, cluster_name: &str) -> Result<Vec<String>, String> {
        let local_clusters = self.local_clusters.lock().await;
        local_clusters.get(cluster_name).cloned().ok_or_else(|| "Local cluster not found".to_string())
    }

    pub async fn add_member_to_cluster(&self, cluster_name: &str, member: String) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if let Some(cluster) = local_clusters.get_mut(cluster_name) {
            if cluster.contains(&member) {
                return Err("Member already in cluster".to_string());
            }
            cluster.push(member);
            Ok(())
        } else {
            Err("Local cluster not found".to_string())
        }
    }

    pub async fn remove_member_from_cluster(&self, cluster_name: &str, member: &str) -> Result<(), String> {
        let mut local_clusters = self.local_clusters.lock().await;
        if let Some(cluster) = local_clusters.get_mut(cluster_name) {
            if let Some(pos) = cluster.iter().position(|x| x == member) {
                cluster.remove(pos);
                Ok(())
            } else {
                Err("Member not found in cluster".to_string())
            }
        } else {
            Err("Local cluster not found".to_string())
        }
    }

    pub async fn verify_signature_concurrently(&self, dids: Vec<&str>, signatures: Vec<&str>, messages: Vec<&str>) -> Result<Vec<bool>, String> {
        let verification_futures: Vec<_> = dids.iter().zip(signatures.iter()).zip(messages.iter())
            .map(|((&did, &signature), &message)| {
                async move {
                    // Placeholder for actual signature verification logic
                    // Replace with actual implementation
                    Ok(true)
                }
            })
            .collect();

        let results = join_all(verification_futures).await;
        results.into_iter().collect()
    }
}

// BLS key types for threshold signatures
pub struct BlsPrivateKey(Vec<u8>);
pub struct BlsPublicKey(Vec<u8>);

impl BlsPrivateKey {
    pub fn new() -> Self {
        // In a real implementation, this would generate a proper BLS key
        Self(vec![0u8; 32])
    }
    
    pub fn to_bytes(&self) -> &[u8] {
        &self.0
    }
}

impl BlsPublicKey {
    pub fn from_private(private: &BlsPrivateKey) -> Self {
        // In a real implementation, this would derive the public key from private
        // For testing, we just use a different pattern
        let mut bytes = vec![0u8; 48];
        bytes[0] = 1; // Mark as public key
        Self(bytes)
    }
    
    pub fn to_bytes(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::runtime::Runtime;

    #[test]
    fn test_create_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let result = identity_manager.create_identity("test_identity").await;
            assert!(result.is_ok());
        });
    }

    #[test]
    fn test_get_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.get_identity("test_identity").await;
            assert_eq!(result.unwrap(), "");
        });
    }

    #[test]
    fn test_update_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.update_identity("test_identity", "new_data").await;
            assert!(result.is_ok());
            let updated_identity = identity_manager.get_identity("test_identity").await.unwrap();
            assert_eq!(updated_identity, "new_data");
        });
    }

    #[test]
    fn test_delete_identity() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_identity("test_identity").await.unwrap();
            let result = identity_manager.delete_identity("test_identity").await;
            assert!(result.is_ok());
            let deleted_identity = identity_manager.get_identity("test_identity").await;
            assert!(deleted_identity.is_err());
        });
    }

    #[test]
    fn test_create_local_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let result = identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await;
            assert!(result.is_ok());
        });
    }

    #[test]
    fn test_get_local_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.get_local_cluster("test_cluster").await;
            assert_eq!(result.unwrap(), vec!["member1".to_string(), "member2".to_string()]);
        });
    }

    #[test]
    fn test_add_member_to_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.add_member_to_cluster("test_cluster", "member3".to_string()).await;
            assert!(result.is_ok());
            let cluster = identity_manager.get_local_cluster("test_cluster").await.unwrap();
            assert_eq!(cluster, vec!["member1".to_string(), "member2".to_string(), "member3".to_string()]);
        });
    }

    #[test]
    fn test_remove_member_from_cluster() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            identity_manager.create_local_cluster("test_cluster", vec!["member1".to_string(), "member2".to_string()]).await.unwrap();
            let result = identity_manager.remove_member_from_cluster("test_cluster", "member1").await;
            assert!(result.is_ok());
            let cluster = identity_manager.get_local_cluster("test_cluster").await.unwrap();
            assert_eq!(cluster, vec!["member2".to_string()]);
        });
    }

    #[test]
    fn test_verify_signature_concurrently() {
        let rt = Runtime::new().unwrap();
        let identity_manager = IdentityManager::new();

        rt.block_on(async {
            let dids = vec!["did:example:123", "did:example:456"];
            let signatures = vec!["signature1", "signature2"];
            let messages = vec!["message1", "message2"];
            let result = identity_manager.verify_signature_concurrently(dids, signatures, messages).await;
            assert!(result.is_ok());
            let verification_results = result.unwrap();
            assert_eq!(verification_results, vec![true, true]);
        });
    }
}
```

===================
File: ./backend/src/middleware/rate_limit.rs
Size: 6982 bytes
===================
```rs
use crate::reputation::ReputationManager;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::Instant;
use tower::ServiceBuilder;
use tower::limit::RateLimit;
use warp::Filter;
use std::collections::HashMap;
use log::{info, error};
use tokio::sync::Mutex;
use icn_types::IcnError;

pub trait RateLimitingOperations {
    fn calculate_limit_multiplier(&self, did: &str) -> f64;
    fn get_rate_limit(&self, did: &str) -> u32;
    fn check_rate_limit(&self, did: &str) -> bool;
}

pub struct AdaptiveRateLimiter {
    reputation_manager: Arc<ReputationManager>,
    base_limit: u32,
    max_limit: u32,
    min_limit: u32,
    cache: HashMap<String, u32>,
}

impl AdaptiveRateLimiter {
    pub fn new(reputation_manager: Arc<ReputationManager>) -> Self {
        Self {
            reputation_manager,
            base_limit: 10,
            max_limit: 50,
            min_limit: 5,
            cache: HashMap::new(),
        }
    }

    async fn calculate_limit_multiplier(&self, did: &str) -> f64 {
        let reputation = self.reputation_manager.get_reputation(did, "api").await;
        let base_multiplier = (reputation as f64 / 100.0).min(1.0).max(0.1);
        
        // Additional multipliers based on federation status
        let federation_multiplier = if self.is_federation_admin(did).await {
            2.0
        } else {
            1.0
        };

        base_multiplier * federation_multiplier
    }

    async fn get_rate_limit(&self, did: &str) -> u32 {
        if let Some(&cached_limit) = self.cache.get(did) {
            return cached_limit;
        }

        let multiplier = self.calculate_limit_multiplier(did).await;
        let limit = (self.base_limit as f64 * multiplier) as u32;
        let clamped_limit = limit.clamp(self.min_limit, self.max_limit);
        self.cache.insert(did.to_string(), clamped_limit);
        clamped_limit
    }

    async fn check_rate_limit(&self, did: &str) -> bool {
        let limit = self.get_rate_limit(did).await;
        // ...existing rate check logic...
        info!("Rate limit for {}: {}", did, limit);
        true
    }
}

impl RateLimitingOperations for AdaptiveRateLimiter {
    fn calculate_limit_multiplier(&self, did: &str) -> f64 {
        // Placeholder implementation
        1.0
    }

    fn get_rate_limit(&self, did: &str) -> u32 {
        // Placeholder implementation
        10
    }

    fn check_rate_limit(&self, did: &str) -> bool {
        // Placeholder implementation
        true
    }
}

pub fn with_rate_limit<F: Filter>(
    filter: F,
    requests_per_second: u64
) -> impl Filter<Extract = F::Extract, Error = warp::Rejection> + Clone {
    let rate_limiter = ServiceBuilder::new()
        .layer(RateLimit::new(
            requests_per_second, 
            Duration::from_secs(1)
        ))
        .service(warp::service(filter));

    warp::service(rate_limiter)
}

// Rate limit settings by reputation tier
struct RateLimitTier {
    requests_per_minute: u32,
    burst_capacity: u32,
}

pub struct ReputationAwareRateLimiter {
    rate_limits: HashMap<String, RateLimitTier>, // endpoint -> limit settings
    user_limits: Arc<Mutex<HashMap<String, HashMap<String, (Instant, u32)>>>>, // user_id -> endpoint -> (last_reset, count)
    reputation_manager: Arc<ReputationManager>,
}

impl ReputationAwareRateLimiter {
    pub fn new(reputation_manager: Arc<ReputationManager>) -> Self {
        let mut rate_limits = HashMap::new();
        
        // Define default rate limits for different endpoints
        rate_limits.insert("api/v1/governance/proposals".to_string(), RateLimitTier { 
            requests_per_minute: 10, 
            burst_capacity: 15 
        });
        rate_limits.insert("api/v1/federation".to_string(), RateLimitTier { 
            requests_per_minute: 5, 
            burst_capacity: 10 
        });
        
        Self {
            rate_limits,
            user_limits: Arc::new(Mutex::new(HashMap::new())),
            reputation_manager,
        }
    }
    
    pub async fn is_rate_limited(&self, user_id: &str, endpoint: &str) -> bool {
        // Get user reputation
        let reputation = self.reputation_manager.get_reputation(user_id, "api").await;
        
        // Get base rate limits for this endpoint
        let base_tier = self.rate_limits.get(endpoint).unwrap_or(&RateLimitTier {
            requests_per_minute: 5,
            burst_capacity: 10,
        });
        
        // Calculate adjusted limits based on reputation
        // Higher reputation = higher limits, up to 5x the base limit
        let reputation_multiplier = (1.0 + (reputation as f64 / 100.0)).min(5.0);
        let adjusted_rpm = (base_tier.requests_per_minute as f64 * reputation_multiplier) as u32;
        let adjusted_burst = (base_tier.burst_capacity as f64 * reputation_multiplier) as u32;
        
        // Check current usage
        let mut user_limits = self.user_limits.lock().await;
        let endpoint_limits = user_limits
            .entry(user_id.to_string())
            .or_insert_with(HashMap::new);
            
        let now = Instant::now();
        let (last_reset, count) = endpoint_limits
            .entry(endpoint.to_string())
            .or_insert_with(|| (now, 0));
            
        // Reset counter if a minute has passed
        if now.duration_since(*last_reset) > Duration::from_secs(60) {
            *last_reset = now;
            *count = 0;
        }
        
        // Check if user has exceeded their limit
        if *count >= adjusted_burst {
            return true;
        }
        
        // Increment count
        *count += 1;
        false
    }
}

// Create a warp filter that applies reputation-aware rate limiting
pub fn with_reputation_rate_limit(
    reputation_manager: Arc<ReputationManager>,
    path: &str,
) -> impl Filter<Extract = (), Error = warp::Rejection> + Clone {
    let rate_limiter = Arc::new(ReputationAwareRateLimiter::new(reputation_manager));
    let path_str = path.to_string();
    
    warp::any()
        .and(warp::header::<String>("authorization"))
        .and_then(move |auth_header: String| {
            let user_id = extract_user_id_from_auth(&auth_header);
            let rate_limiter = rate_limiter.clone();
            let endpoint = path_str.clone();
            
            async move {
                if rate_limiter.is_rate_limited(&user_id, &endpoint).await {
                    Err(warp::reject::custom(
                        IcnError::RateLimitError(format!("Rate limit exceeded for {}", endpoint))
                    ))
                } else {
                    Ok(())
                }
            }
        })
}

fn extract_user_id_from_auth(auth_header: &str) -> String {
    // Extract user ID from JWT or other auth mechanism
    // This is a placeholder implementation
    if auth_header.starts_with("Bearer ") {
        auth_header[7..].to_string()
    } else {
        "anonymous".to_string()
    }
}
```

===================
File: ./backend/src/models.rs
Size: 1686 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use chrono::NaiveDateTime;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: i64,
    pub title: String,
    pub description: String,
    pub created_by: String,
    pub ends_at: NaiveDateTime,
    pub created_at: NaiveDateTime,
    pub verifiable_credential: Option<String>,
    pub did: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    pub proposal_id: i64,
    pub voter: String,
    pub approve: bool,
    pub verifiable_credential: Option<String>,
    pub zk_snark_proof: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contribution {
    pub id: i64,
    pub contributor: String,
    pub description: String,
    pub impact_score: i64,
    pub timestamp: NaiveDateTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Federation {
    pub id: String,
    pub name: String,
    pub description: String,
    pub admin_did: String,
    pub created_at: NaiveDateTime,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMember {
    pub federation_id: String,
    pub member_did: String,
    pub role: String,
    pub joined_at: NaiveDateTime,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperation {
    pub id: i64,
    pub name: String,
    pub description: String,
    pub admin_did: String,
    pub created_at: NaiveDateTime,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub owner_did: String,
    pub resource_type: String,
    pub capacity: i64,
    pub usage: i64,
    pub status: String,
}
```

===================
File: ./backend/src/networking.rs
Size: 6871 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::time::{Duration, sleep};
use log::{info, error};

pub enum PeerStatus {
    Connected,
    Disconnected,
    Syncing,
}

pub struct Peer {
    id: String,
    address: String,
    status: PeerStatus,
    latency: u64,
}

pub enum Message {
    Block { hash: String, data: Vec<u8> },
    Transaction { hash: String, data: Vec<u8> },
    Proposal { id: String, data: Vec<u8> },
    Vote { proposal_id: String, voter: String, approve: bool },
    Identity { did: String, data: Vec<u8> },
    Reputation { did: String, score: i64 },
    Ping,
    Pong,
}

pub trait NetworkingOperations {
    fn start(&self) -> Result<(), String>;
    fn stop(&self) -> Result<(), String>;
    fn connect(&self, address: &str) -> Result<(), String>;
    fn disconnect(&self, address: &str) -> Result<(), String>;
    fn send_message(&self, address: &str, message: &[u8]) -> Result<(), String>;
    fn receive_message(&self, address: &str) -> Result<Vec<u8>, String>;
}

pub struct NetworkManager {
    peers: HashMap<String, Peer>,
    message_sender: Option<Sender<Message>>,
    max_peers: usize,
    network_key: Vec<u8>,
    cache: HashMap<String, Vec<u8>>,
}

impl NetworkManager {
    pub fn new(max_peers: usize) -> Self {
        let network_key = vec![0u8; 32]; // In a real application, this would be a proper crypto key
        
        Self {
            peers: HashMap::new(),
            message_sender: None,
            max_peers,
            network_key,
            cache: HashMap::new(),
        }
    }
    
    pub fn start(&mut self) -> Result<(), String> {
        let (sender, receiver) = mpsc::channel(100);
        self.message_sender = Some(sender);
        
        // Start background task for processing messages
        let receiver_handle = tokio::spawn(async move {
            Self::process_messages(receiver).await;
        });
        
        Ok(())
    }
    
    async fn process_messages(mut receiver: Receiver<Message>) {
        while let Some(message) = receiver.recv().await {
            // In a real implementation, this would process the message
            // For testing, we just print info about it
            match message {
                Message::Block { hash, data: _ } => {
                    println!("Received block with hash: {}", hash);
                },
                Message::Transaction { hash, data: _ } => {
                    println!("Received transaction with hash: {}", hash);
                },
                Message::Proposal { id, data: _ } => {
                    println!("Received proposal with id: {}", id);
                },
                Message::Vote { proposal_id, voter, approve } => {
                    println!("Received vote on proposal {} from {}: {}", proposal_id, voter, approve);
                },
                Message::Identity { did, data: _ } => {
                    println!("Received identity for DID: {}", did);
                },
                Message::Reputation { did, score } => {
                    println!("Received reputation update for DID: {}, new score: {}", did, score);
                },
                Message::Ping => {
                    println!("Received ping");
                },
                Message::Pong => {
                    println!("Received pong");
                },
            }
        }
    }
    
    pub fn add_peer(&mut self, id: String, address: String) -> Result<(), String> {
        if self.peers.len() >= self.max_peers {
            return Err("Maximum number of peers reached".to_string());
        }
        
        let peer = Peer {
            id: id.clone(),
            address,
            status: PeerStatus::Disconnected,
            latency: 0,
        };
        
        self.peers.insert(id, peer);
        Ok(())
    }
    
    pub fn remove_peer(&mut self, id: &str) -> Result<(), String> {
        if self.peers.remove(id).is_none() {
            return Err("Peer not found".to_string());
        }
        Ok(())
    }
    
    pub fn get_peers(&self) -> Vec<&Peer> {
        self.peers.values().collect()
    }
    
    pub fn send_message(&self, peer_id: &str, message: Message) -> Result<(), String> {
        if !self.peers.contains_key(peer_id) {
            return Err("Peer not found".to_string());
        }
        
        let sender = self.message_sender.as_ref().ok_or("Network not started")?;
        
        // In a real implementation, this would actually send to the peer
        // For testing, we just forward to our own message processor
        let sender_clone = sender.clone();
        tokio::spawn(async move {
            sender_clone.send(message).await.unwrap();
        });
        
        Ok(())
    }
    
    pub async fn broadcast_message(&self, message: Message) -> Result<(), String> {
        let sender = self.message_sender.as_ref().ok_or("Network not started")?;
        
        // In a real implementation, this would send to all peers
        // For testing, we just forward to our own message processor
        let sender_clone = sender.clone();
        tokio::spawn(async move {
            sender_clone.send(message).await.unwrap();
        });
        
        Ok(())
    }
    
    pub async fn ping_all_peers(&mut self) -> Result<(), String> {
        for peer in self.peers.values_mut() {
            // In a real implementation, this would actually ping each peer
            // For testing, we just update latency with a random value
            peer.latency = rand::random::<u64>() % 100;
            peer.status = if peer.latency < 50 { PeerStatus::Connected } else { PeerStatus::Disconnected };
        }
        
        Ok(())
    }
}

impl NetworkingOperations for NetworkManager {
    fn start(&self) -> Result<(), String> {
        info!("Starting network connections");
        Ok(())
    }

    fn stop(&self) -> Result<(), String> {
        info!("Stopping network connections");
        Ok(())
    }

    fn connect(&self, address: &str) -> Result<(), String> {
        info!("Connecting to network address: {}", address);
        Ok(())
    }

    fn disconnect(&self, address: &str) -> Result<(), String> {
        info!("Disconnecting from network address: {}", address);
        Ok(())
    }

    fn send_message(&self, address: &str, message: &[u8]) -> Result<(), String> {
        info!("Sending message to network address: {}", address);
        self.cache.insert(address.to_string(), message.to_vec());
        Ok(())
    }

    fn receive_message(&self, address: &str) -> Result<Vec<u8>, String> {
        info!("Receiving message from network address: {}", address);
        if let Some(message) = self.cache.get(address) {
            Ok(message.clone())
        } else {
            Ok(vec![])
        }
    }
}
```

===================
File: ./backend/src/networking/p2p.rs
Size: 4516 bytes
===================
```rs
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::error::Error;
use libp2p::{
    floodsub::{Floodsub, FloodsubEvent, Topic},
    mdns::{Mdns, MdnsConfig, MdnsEvent},
    swarm::{SwarmBuilder, SwarmEvent},
    PeerId, Swarm, NetworkBehaviour, identity,
};
use futures::prelude::*;
use async_trait::async_trait;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub enum Event {
    Federation(FederationEvent),
    Governance(GovernanceEvent),
    Identity(IdentityEvent),
    Reputation(ReputationEvent),
}

#[derive(Debug, Serialize, Deserialize)]
pub enum FederationEvent {
    JoinRequest { federation_id: String, member_did: String },
    // Add other federation events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum GovernanceEvent {
    Vote { proposal_id: String, voter: String, approve: bool, zk_snark_proof: String },
    // Add other governance events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum IdentityEvent {
    CreateIdentity { identity: String },
    // Add other identity events here
}

#[derive(Debug, Serialize, Deserialize)]
pub enum ReputationEvent {
    ZkSnarkProofSubmitted { proof: String },
    // Add other reputation events here
}

pub struct P2PManager {
    peers: Vec<String>,
    swarm: Swarm<MyBehaviour>,
}

impl P2PManager {
    pub fn new() -> Self {
        let local_key = identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());
        println!("Local peer id: {:?}", local_peer_id);

        let floodsub = Floodsub::new(local_peer_id.clone());
        let mdns = Mdns::new(MdnsConfig::default()).expect("Failed to create mDNS service");

        let behaviour = MyBehaviour { floodsub, mdns };

        let swarm = SwarmBuilder::new(behaviour, local_peer_id.clone())
            .executor(Box::new(|fut| {
                tokio::spawn(fut);
            }))
            .build();

        P2PManager { peers: Vec::new(), swarm }
    }

    pub async fn connect(&mut self, address: &str) -> Result<(), Box<dyn Error>> {
        let stream = TcpStream::connect(address).await?;
        self.peers.push(address.to_string());
        println!("Connected to {}", address);
        Ok(())
    }

    pub async fn send_message(&self, address: &str, message: &[u8]) -> Result<(), Box<dyn Error>> {
        if let Some(peer) = self.peers.iter().find(|&&peer| peer == address) {
            let mut stream = TcpStream::connect(peer).await?;
            stream.write_all(message).await?;
            println!("Message sent to {}", address);
            Ok(())
        } else {
            Err("Peer not connected".into())
        }
    }

    pub async fn publish(&mut self, event: Event) -> Result<(), Box<dyn Error>> {
        let topic = Topic::new("icn-events");
        let message = serde_json::to_vec(&event)?;
        self.swarm.behaviour_mut().floodsub.publish(topic, message);
        Ok(())
    }

    pub async fn subscribe(&mut self) -> Result<(), Box<dyn Error>> {
        let topic = Topic::new("icn-events");
        self.swarm.behaviour_mut().floodsub.subscribe(topic);

        loop {
            match self.swarm.next().await {
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Floodsub(FloodsubEvent::Message(message)))) => {
                    let event: Event = serde_json::from_slice(&message.data)?;
                    println!("Received event: {:?}", event);
                }
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(MdnsEvent::Discovered(peers)))) => {
                    for (peer_id, _) in peers {
                        self.swarm.behaviour_mut().floodsub.add_node_to_partial_view(peer_id);
                    }
                }
                Some(SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(MdnsEvent::Expired(peers)))) => {
                    for (peer_id, _) in peers {
                        if !self.swarm.behaviour().mdns.has_node(&peer_id) {
                            self.swarm.behaviour_mut().floodsub.remove_node_from_partial_view(&peer_id);
                        }
                    }
                }
                _ => {}
            }
        }
    }
}

#[derive(NetworkBehaviour)]
struct MyBehaviour {
    floodsub: Floodsub,
    mdns: Mdns,
}

enum MyBehaviourEvent {
    Floodsub(FloodsubEvent),
    Mdns(MdnsEvent),
}
```

===================
File: ./backend/src/networking/rpc.rs
Size: 1067 bytes
===================
```rs
use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::error::Error;

pub struct RpcManager;

impl RpcManager {
    pub fn new() -> Self {
        RpcManager
    }

    pub async fn handle_rpc(&self, address: &str) -> Result<(), Box<dyn Error>> {
        let listener = TcpListener::bind(address).await?;
        println!("RPC server listening on {}", address);

        loop {
            let (mut socket, _) = listener.accept().await?;
            tokio::spawn(async move {
                let mut buffer = [0; 1024];
                match socket.read(&mut buffer).await {
                    Ok(_) => {
                        let response = b"RPC response";
                        if let Err(e) = socket.write_all(response).await {
                            eprintln!("Failed to write to socket: {}", e);
                        }
                    }
                    Err(e) => {
                        eprintln!("Failed to read from socket: {}", e);
                    }
                }
            });
        }
    }
}
```

===================
File: ./backend/src/networking/websocket.rs
Size: 2162 bytes
===================
```rs
use warp::ws::{Message, WebSocket};
use futures_util::{StreamExt, SinkExt};
use std::sync::Arc;
use dashmap::DashMap;
use log::{info, error};

pub type WebSocketClients = Arc<DashMap<String, warp::ws::Sender>>;

pub trait WebSocketOperations {
    fn handle_websocket(&self, ws: WebSocket, clients: WebSocketClients);
    fn process_message(&self, msg: Message, clients: &WebSocketClients) -> Result<(), String>;
    fn broadcast_message(&self, msg: &Message, clients: &WebSocketClients);
}

pub struct WebSocketManager {
    cache: DashMap<String, String>,
}

impl WebSocketManager {
    pub fn new() -> Self {
        WebSocketManager {
            cache: DashMap::new(),
        }
    }
}

impl WebSocketOperations for WebSocketManager {
    fn handle_websocket(&self, ws: WebSocket, clients: WebSocketClients) {
        let (mut ws_tx, mut ws_rx) = ws.split();
        let client_id = uuid::Uuid::new_v4().to_string();
        clients.insert(client_id.clone(), ws_tx.clone());

        tokio::spawn(async move {
            while let Some(result) = ws_rx.next().await {
                match result {
                    Ok(msg) => {
                        if let Err(e) = self.process_message(msg, &clients).await {
                            error!("Error processing message: {}", e);
                        }
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                }
            }

            clients.remove(&client_id);
        });
    }

    fn process_message(&self, msg: Message, clients: &WebSocketClients) -> Result<(), String> {
        if let Ok(text) = msg.to_str() {
            self.cache.insert(text.to_string(), text.to_string());
            self.broadcast_message(&Message::text(text), clients);
        }
        Ok(())
    }

    fn broadcast_message(&self, msg: &Message, clients: &WebSocketClients) {
        for client in clients.iter() {
            if let Err(e) = client.value().send(msg.clone()).await {
                error!("Error sending message to client: {}", e);
            }
        }
    }
}
```

===================
File: ./backend/src/notification.rs
Size: 3465 bytes
===================
```rs
use std::sync::Arc;
use reqwest::Client;
use std::error::Error;
use std::fmt;
use tokio::sync::mpsc::{self, Sender, Receiver};

#[derive(Debug)]
pub enum NotificationError {
    SendError(String),
    NetworkError(String),
}

impl fmt::Display for NotificationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            NotificationError::SendError(msg) => write!(f, "Failed to send notification: {}", msg),
            NotificationError::NetworkError(msg) => write!(f, "Network error: {}", msg),
        }
    }
}

impl Error for NotificationError {}

pub struct NotificationManager {
    http_client: Client,
    email_endpoint: String,
    sms_endpoint: String,
    event_sender: Option<Sender<NotificationEvent>>,
}

#[derive(Debug, Clone)]
pub enum NotificationEvent {
    Email { subject: String, body: String, recipient: String },
    SMS { message: String, recipient: String },
    Push { title: String, message: String, device_id: String },
}

impl NotificationManager {
    pub fn new(email_endpoint: String, sms_endpoint: String) -> Self {
        let (sender, receiver) = mpsc::channel(100);
        
        let manager = Self {
            http_client: Client::new(),
            email_endpoint,
            sms_endpoint,
            event_sender: Some(sender),
        };
        
        // Start background listener
        manager.start_event_listener(receiver);
        
        manager
    }
    
    fn start_event_listener(&self, mut receiver: Receiver<NotificationEvent>) {
        tokio::spawn(async move {
            while let Some(event) = receiver.recv().await {
                match event {
                    NotificationEvent::Email { subject, body, recipient } => {
                        println!("Email to {}: {}", recipient, subject);
                        // In a real implementation, this would send the email
                    }
                    NotificationEvent::SMS { message, recipient } => {
                        println!("SMS to {}: {}", recipient, message);
                        // In a real implementation, this would send the SMS
                    }
                    NotificationEvent::Push { title, message, device_id } => {
                        println!("Push to {}: {}", device_id, title);
                        // In a real implementation, this would send the push notification
                    }
                }
            }
        });
    }
    
    pub async fn send_email(&self, subject: &str, body: &str) -> Result<(), NotificationError> {
        // In a real implementation, this would send a HTTP request to the email service
        // For testing, we just simulate success
        Ok(())
    }
    
    pub async fn send_sms(&self, message: &str) -> Result<(), NotificationError> {
        // In a real implementation, this would send a HTTP request to the SMS service
        // For testing, we just simulate success
        Ok(())
    }
    
    pub async fn send_notification(&self, subject: &str, body: &str) -> Result<(), NotificationError> {
        // Try to send email first
        match self.send_email(subject, body).await {
            Ok(_) => return Ok(()),
            Err(_) => {
                // If email fails, try SMS
                println!("Email failed, falling back to SMS");
                self.send_sms(&format!("{}: {}", subject, body)).await?;
            }
        }
        
        Ok(())
    }
}
```

===================
File: ./backend/src/reputation.rs
Size: 11394 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::task;
use tokio::time::{self, Duration};
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions
use futures::future::join_all; // Import join_all for concurrency

pub struct ReputationManager {
    reputations: Mutex<HashMap<String, i64>>,
    event_sender: Sender<ReputationEvent>,
}

impl ReputationManager {
    pub fn new() -> Self {
        let (event_sender, event_receiver) = mpsc::channel(100);
        let manager = ReputationManager {
            reputations: Mutex::new(HashMap::new()),
            event_sender,
        };
        manager.start_event_listener(event_receiver);
        manager
    }

    pub fn get_reputation(&self, did: &str) -> i64 {
        let reputations = self.reputations.lock().unwrap();
        *reputations.get(did).unwrap_or(&0)
    }

    pub fn adjust_reputation(&self, _did: &str, adjustment: i64) {
        let mut reputations = self.reputations.lock().unwrap();
        let entry = reputations.entry(_did.to_string()).or_insert(0);
        *entry += adjustment;
    }

    pub fn apply_decay(&self, decay_rate: f64) {
        let mut reputations = self.reputations.lock().unwrap();
        for value in reputations.values_mut() {
            *value = (*value as f64 * (1.0 - decay_rate)).round() as i64;
        }
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String> {
        apply_reputation_decay_in_ledger(did, decay_rate).await.map_err(|e| e.to_string())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> {
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| e.to_string())
    }

    pub fn emit_event(&self, event: ReputationEvent) {
        let sender = self.event_sender.clone();
        task::spawn(async move {
            sender.send(event).await.unwrap();
        });
    }

    fn start_event_listener(&self, mut event_receiver: Receiver<ReputationEvent>) {
        task::spawn(async move {
            while let Some(event) = event_receiver.recv().await {
                match event {
                    ReputationEvent::ReputationAdjusted { did, adjustment } => {
                        // Handle reputation adjustment event
                    }
                    ReputationEvent::ReputationDecayApplied { did, decay_rate } => {
                        // Handle reputation decay event
                    }
                }
            }
        });
    }

    pub async fn batch_reputation_updates(&self, events: Vec<ReputationEvent>) -> Result<(), String> {
        let publish_futures = events.iter().map(|event| {
            let sender = self.event_sender.clone();
            async move {
                sender.send(event.clone()).await.map_err(|e| e.to_string())
            }
        });

        let results = join_all(publish_futures).await;
        for result in results {
            if let Err(e) = result {
                return Err(e);
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_reputation() {
        let manager = ReputationManager::new();
        assert_eq!(manager.get_reputation("did:example:123"), 0);
    }

    #[test]
    fn test_adjust_reputation() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 10);
        assert_eq!(manager.get_reputation("did:example:123"), 10);
    }

    #[test]
    fn test_apply_decay() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 100);
        manager.apply_decay(0.1);
        assert_eq!(manager.get_reputation("did:example:123"), 90);
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let manager = ReputationManager::new();
        manager.adjust_reputation("did:example:123", 100);
        manager.apply_reputation_decay("did:example:123", 0.1).await.unwrap();
        assert_eq!(manager.get_reputation("did:example:123"), 90);
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let manager = ReputationManager::new();
        manager.handle_sybil_resistance("did:example:123", 50).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[test]
    fn test_emit_event() {
        let manager = ReputationManager::new();
        manager.emit_event(ReputationEvent::ReputationAdjusted {
            did: "did:example:123".to_string(),
            adjustment: 10,
        });
        // Add assertions based on the expected behavior of emit_event
    }

    #[tokio::test]
    async fn test_batch_reputation_updates() {
        let manager = ReputationManager::new();
        let events = vec![
            ReputationEvent::ReputationAdjusted {
                did: "did:example:123".to_string(),
                adjustment: 10,
            },
            ReputationEvent::ReputationDecayApplied {
                did: "did:example:123".to_string(),
                decay_rate: 0.1,
            },
        ];
        manager.batch_reputation_updates(events).await.unwrap();
        // Add assertions based on the expected behavior of batch_reputation_updates
    }
}

pub struct Contribution {
    pub score: i64,
    pub timestamp: f64,
}

impl Contribution {
    pub fn new(score: i64) -> Self {
        Self {
            score,
            timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64,
        }
    }
}

pub enum ReputationEvent {
    ReputationAdjusted { did: String, adjustment: i64 },
    ReputationDecayApplied { did: String, decay_rate: f64 },
}

#[cfg(test)]
mod integration_tests {
    use super::*;
    use std::env;
    use sqlx::PgPool;

    async fn setup_test_db() -> Arc<Database> {
        let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        let pool = PgPool::connect(&database_url).await.unwrap();
        Arc::new(Database { pool })
    }

    #[tokio::test]
    async fn test_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }
}

pub struct ReputationSystem {
    // DID -> (category -> reputation score)
    reputation_scores: HashMap<String, HashMap<String, i32>>,
}

impl ReputationSystem {
    pub fn new() -> Self {
        Self {
            reputation_scores: HashMap::new(),
        }
    }
    
    pub fn increase_reputation(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, amount, "consensus".to_string());
    }
    
    pub fn decrease_reputation(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, -amount, "consensus".to_string());
    }
    
    pub fn adjust_reputation(&mut self, did: &str, amount: i32, category: String) {
        let categories = self.reputation_scores
            .entry(did.to_string())
            .or_insert_with(HashMap::new);
            
        let score = categories.entry(category).or_insert(0);
        *score += amount;
    }
    
    pub fn get_reputation(&self, did: &str, category: String) -> i32 {
        self.reputation_scores
            .get(did)
            .and_then(|categories| categories.get(&category))
            .copied()
            .unwrap_or(0)
    }
    
    pub fn is_eligible(&self, did: &str, threshold: i32, category: String) -> bool {
        self.get_reputation(did, category) >= threshold
    }
    
    // Apply decay to a specific category
    pub fn apply_decay(&mut self, did: &str, decay_factor: f64, category: String) {
        if let Some(categories) = self.reputation_scores.get_mut(did) {
            if let Some(score) = categories.get_mut(&category) {
                *score = (*score as f64 * (1.0 - decay_factor)) as i32;
            }
        }
    }
    
    // Apply decay to all categories
    pub fn apply_decay_all(&mut self, did: &str, decay_factor: f64) {
        if let Some(categories) = self.reputation_scores.get_mut(did) {
            for score in categories.values_mut() {
                *score = (*score as f64 * (1.0 - decay_factor)) as i32;
            }
        }
    }
    
    pub fn dynamic_adjustment(&mut self, did: &str, amount: i32) {
        self.adjust_reputation(did, amount, "consensus".to_string());
    }
    
    pub fn reputation_based_access(&self, did: &str, threshold: i32) -> bool {
        self.reputation_scores
            .get(did)
            .map(|categories| {
                categories.values().sum::<i32>() >= threshold
            })
            .unwrap_or(false)
    }
}
```

===================
File: ./backend/src/resources.rs
Size: 1739 bytes
===================
```rs
use std::collections::HashMap;

pub struct ResourceManager {
    resources: HashMap<String, Resource>,
}

pub struct Resource {
    pub id: String,
    pub type_: String,
    pub capacity: u64,
    pub available: u64,
    pub owner_did: String,
}

impl ResourceManager {
    pub fn new() -> Self {
        ResourceManager {
            resources: HashMap::new(),
        }
    }
    
    pub fn register_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }
    
    pub fn get_resource(&self, id: &str) -> Option<&Resource> {
        self.resources.get(id)
    }
    
    pub fn list_available_resources(&self) -> Vec<&Resource> {
        self.resources.values()
            .filter(|r| r.available > 0)
            .collect()
    }
    
    pub fn request_resource(&mut self, id: &str, amount: u64) -> Result<(), String> {
        let resource = self.resources.get_mut(id).ok_or("Resource not found")?;
        
        if resource.available < amount {
            return Err("Insufficient resources available".to_string());
        }
        
        resource.available -= amount;
        Ok(())
    }
    
    pub fn release_resource(&mut self, id: &str, amount: u64) -> Result<(), String> {
        let resource = self.resources.get_mut(id).ok_or("Resource not found")?;
        
        if resource.available + amount > resource.capacity {
            return Err("Cannot release more resources than capacity".to_string());
        }
        
        resource.available += amount;
        Ok(())
    }
}
```

===================
File: ./backend/src/routes.rs
Size: 1937 bytes
===================
```rs
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;

use crate::api::health::health_routes;
use crate::api::identity::identity_routes;
use crate::api::governance::governance_routes;
use crate::api::resource::resource_routes;
use crate::api::federation::federation_routes;
use crate::api::federation_resource_sharing::federation_resource_sharing_routes;
use crate::api::reputation::reputation_routes;
use crate::services::identity_service::IdentityService;
use crate::services::governance_service::GovernanceService;
use crate::services::resource_service::ResourceService;
use crate::services::federation_service::FederationService;
use crate::services::reputation_service::ReputationService;
use crate::services::p2p::P2PManager;
use crate::middleware::auth::with_auth;
use crate::middleware::cors::cors;

pub fn routes(
    identity_service: Arc<Mutex<IdentityService>>,
    governance_service: Arc<Mutex<GovernanceService>>,
    resource_service: Arc<Mutex<ResourceService>>,
    federation_service: Arc<Mutex<FederationService>>,
    reputation_service: Arc<Mutex<ReputationService>>,
    p2p_manager: Arc<Mutex<P2PManager>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    // Routes that don't require auth
    let health_route = health_routes();

    // Routes that require auth
    let auth_routes = identity_routes(identity_service.clone())
        .or(governance_routes(governance_service.clone(), p2p_manager.clone()))
        .or(resource_routes(resource_service.clone()))
        .or(federation_routes(federation_service.clone(), p2p_manager.clone()))
        .or(federation_resource_sharing_routes(federation_service.clone(), p2p_manager.clone()))
        .or(reputation_routes(reputation_service.clone()));

    // Apply middleware
    let auth_routes = auth_routes.and(with_auth(identity_service.clone()));

    // Combine routes
    health_route.or(auth_routes).with(cors())
}```

===================
File: ./backend/src/services.rs
Size: 3043 bytes
===================
```rs
use std::sync::{Arc, Mutex};
use icn_types::{Block, Transaction, FederationOperation};
use crate::identity::IdentitySystem;
use crate::blockchain::Blockchain;
use crate::governance::{ProposalHistory, Proposal, ProposalType, handle_federation_operation};
use crate::reputation::ReputationSystem;

pub struct BlockchainService {
    blockchain: Arc<Mutex<Blockchain>>,
}

impl BlockchainService {
    pub fn new(blockchain: Arc<Mutex<Blockchain>>) -> Self {
        Self { blockchain }
    }
    
    pub async fn add_transaction(&self, transaction: Transaction) -> Result<(), String> {
        let mut chain = self.blockchain.lock().unwrap();
        chain.add_transaction(transaction).await
    }
    
    pub async fn add_block(&self, block: Block) -> Result<(), String> {
        let mut chain = self.blockchain.lock().unwrap();
        chain.add_block(block).await
    }
    
    pub fn get_latest_block(&self) -> Option<Block> {
        let chain = self.blockchain.lock().unwrap();
        chain.blocks.last().cloned()
    }
}

pub struct IdentityService {
    identity_system: Arc<Mutex<IdentitySystem>>,
}

impl IdentityService {
    pub fn new(identity_system: Arc<Mutex<IdentitySystem>>) -> Self {
        Self { identity_system }
    }
    
    pub fn register_identity(&self, did: crate::identity::DID, permissions: Vec<String>) -> Result<(), String> {
        let mut system = self.identity_system.lock().unwrap();
        system.register_did(did, permissions);
        Ok(())
    }
    
    pub fn has_permission(&self, did: &str, permission: &str) -> bool {
        let system = self.identity_system.lock().unwrap();
        system.has_permission(did, permission)
    }
}

pub struct GovernanceService {
    proposal_history: Arc<Mutex<ProposalHistory>>,
}

impl GovernanceService {
    pub fn new(proposal_history: Arc<Mutex<ProposalHistory>>) -> Self {
        Self { proposal_history }
    }
    
    pub fn add_proposal(&self, proposer: String, proposal_type: ProposalType) -> Result<Proposal, String> {
        let mut history = self.proposal_history.lock().unwrap();
        let proposal = Proposal::new(proposer, proposal_type);
        let proposal_clone = proposal.clone();
        history.add_proposal(proposal);
        Ok(proposal_clone)
    }
    
    pub fn vote(&self, voter: String, _proposal_id: String, approve: bool) -> Result<(), String> {
        let mut history = self.proposal_history.lock().unwrap();
        history.vote(voter, _proposal_id, approve)
    }
    
    pub fn get_proposal(&self, id: String) -> Option<Proposal> {
        let history = self.proposal_history.lock().unwrap();
        history.get_proposal(id)
    }
    
    pub fn execute_proposal(&self, proposal_id: &str) -> Result<(), String> {
        let mut history = self.proposal_history.lock().unwrap();
        history.execute_proposal(proposal_id)
    }
    
    pub async fn handle_federation_operation(&self, operation: FederationOperation) -> Result<String, String> {
        handle_federation_operation(operation).await
    }
}
```

===================
File: ./backend/src/services/federation_service.rs
Size: 10648 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use chrono::Utc;
use uuid::Uuid;
use thiserror::Error;
use log::{info, error, debug};

use icn_federation::{
    FederationManager, FederationType, FederationTerms, FederationProposal, FederationError, Vote,
    ResourceSharingAgreement, ResourceAllocation, FederationResourceManager, ResourceError,
};
use icn_reputation::ReputationManager;
use icn_resource::ResourceAllocationSystem;
use crate::errors::IcnError;

/// Federation service to manage federation operations
pub struct FederationService {
    federation_manager: Arc<Mutex<FederationManager>>,
    reputation_manager: Arc<dyn ReputationManager>,
    resource_system: Arc<ResourceAllocationSystem>,
    federation_resource_manager: Arc<FederationResourceManager>,
}

#[derive(Error, Debug)]
pub enum FederationServiceError {
    #[error("Federation error: {0}")]
    FederationError(#[from] FederationError),
    
    #[error("Resource error: {0}")]
    ResourceError(#[from] ResourceError),
    
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Resource allocation error: {0}")]
    ResourceAllocationError(String),
}

/// Integration between ResourceManager trait and the ResourceAllocationSystem
struct ResourceSystemAdapter {
    resource_system: Arc<ResourceAllocationSystem>,
    reputation_manager: Arc<dyn ReputationManager>,
}

#[async_trait::async_trait]
impl icn_federation::ResourceProvider for ResourceSystemAdapter {
    async fn has_sufficient_resources(
        &self,
        federation_id: &str,
        resource_type: &str, 
        amount: u64
    ) -> Result<bool, ResourceError> {
        self.resource_system.check_resource_availability(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
    
    async fn get_federation_reputation(
        &self,
        federation_id: &str
    ) -> Result<i64, ResourceError> {
        self.reputation_manager.get_federation_reputation(federation_id)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(format!("Failed to get reputation: {}", e)))
    }
    
    async fn reserve_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError> {
        self.resource_system.reserve_resources(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
    
    async fn release_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError> {
        self.resource_system.release_resources(federation_id, resource_type, amount)
            .await
            .map_err(|e| ResourceError::ResourceSystemError(e.to_string()))
    }
}

impl FederationService {
    /// Create a new federation service
    pub fn new(
        federation_manager: Arc<Mutex<FederationManager>>,
        reputation_manager: Arc<dyn ReputationManager>,
        resource_system: Arc<ResourceAllocationSystem>,
    ) -> Self {
        // Create adapter for the resource system
        let resource_provider = Arc::new(ResourceSystemAdapter {
            resource_system: resource_system.clone(),
            reputation_manager: reputation_manager.clone(),
        });
        
        // Create federation resource manager
        let federation_resource_manager = Arc::new(FederationResourceManager::new(resource_provider));
        
        Self {
            federation_manager,
            reputation_manager,
            resource_system,
            federation_resource_manager,
        }
    }

    /// Create a new federation
    pub async fn create_federation(
        &mut self,
        name: String,
        federation_type: FederationType,
        terms: FederationTerms,
        founding_member: String,
    ) -> Result<String, FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        let federation_id = manager.create_federation(name, federation_type, terms, founding_member).await?;
        Ok(federation_id)
    }

    /// Join an existing federation
    pub async fn join_federation(
        &mut self,
        federation_id: &str,
        member_id: &str,
        commitment: Vec<String>,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.join_federation(federation_id, member_id, commitment).await?;
        Ok(())
    }

    /// Submit a proposal to a federation
    pub async fn submit_proposal(
        &mut self,
        federation_id: &str,
        proposal: FederationProposal,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.submit_proposal(federation_id, proposal).await?;
        Ok(())
    }

    /// Vote on a proposal in a federation
    pub async fn vote(
        &mut self,
        federation_id: &str,
        vote: Vote,
    ) -> Result<(), FederationServiceError> {
        let manager = self.federation_manager.lock().await;
        manager.vote(federation_id, vote).await?;
        Ok(())
    }

    // --- Federation Resource Sharing Methods ---

    /// Share resources between federations
    pub async fn share_federation_resources(
        &mut self,
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        duration_seconds: Option<u64>,
        terms: String,
        min_reputation_score: i64,
    ) -> Result<String, FederationServiceError> {
        info!(
            "Creating resource sharing agreement: {} -> {}, type: {}, amount: {}", 
            source_federation_id, target_federation_id, resource_type, amount
        );
        
        // Verify federations exist
        let manager = self.federation_manager.lock().await;
        
        // Create the resource sharing agreement
        let agreement_id = self.federation_resource_manager.propose_agreement(
            source_federation_id,
            target_federation_id,
            resource_type,
            amount,
            duration_seconds,
            terms,
            min_reputation_score,
        ).await?;
        
        info!("Resource sharing agreement created: {}", agreement_id);
        Ok(agreement_id)
    }
    
    /// Accept a resource sharing agreement
    pub async fn accept_sharing_agreement(
        &mut self,
        agreement_id: &str,
        target_federation_id: &str,
        signer_did: &str,
        signature: String,
    ) -> Result<(), FederationServiceError> {
        info!("Accepting resource sharing agreement: {}", agreement_id);
        
        self.federation_resource_manager.accept_agreement(
            agreement_id,
            target_federation_id,
            signer_did,
            signature,
        ).await?;
        
        info!("Resource sharing agreement accepted: {}", agreement_id);
        Ok(())
    }
    
    /// Allocate resources from a sharing agreement
    pub async fn allocate_shared_resource(
        &mut self,
        agreement_id: &str,
        requester_did: &str,
        amount: u64,
    ) -> Result<String, FederationServiceError> {
        info!(
            "Allocating resources from agreement {}: requester {}, amount {}", 
            agreement_id, requester_did, amount
        );
        
        // Get agreement to find the requester's federation
        let agreement = self.federation_resource_manager.get_agreement(agreement_id).await
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Allocate resources
        let allocation_id = self.federation_resource_manager.allocate_from_agreement(
            agreement_id,
            &agreement.target_federation_id, // Federation ID from the agreement
            requester_did,
            amount,
        ).await?;
        
        info!("Resources allocated, allocation ID: {}", allocation_id);
        Ok(allocation_id)
    }
    
    /// Release resources back to a sharing agreement
    pub async fn release_shared_resource(
        &mut self,
        agreement_id: &str,
        allocation_id: &str,
        amount: u64,
    ) -> Result<(), FederationServiceError> {
        info!(
            "Releasing resources to agreement {}: allocation {}, amount {}", 
            agreement_id, allocation_id, amount
        );
        
        self.federation_resource_manager.release_to_agreement(
            agreement_id,
            allocation_id,
            amount,
        ).await?;
        
        info!("Resources released successfully");
        Ok(())
    }
    
    /// Terminate a resource sharing agreement
    pub async fn terminate_sharing_agreement(
        &mut self,
        agreement_id: &str,
        federation_id: &str,
        reason: &str,
    ) -> Result<(), FederationServiceError> {
        info!(
            "Terminating resource sharing agreement {}: federation {}, reason: {}", 
            agreement_id, federation_id, reason
        );
        
        self.federation_resource_manager.terminate_agreement(
            agreement_id,
            federation_id,
            reason,
        ).await?;
        
        info!("Resource sharing agreement terminated");
        Ok(())
    }
    
    /// List all sharing agreements for a federation
    pub async fn list_federation_sharing_agreements(
        &self,
        federation_id: &str,
    ) -> Result<Vec<ResourceSharingAgreement>, FederationServiceError> {
        let agreements = self.federation_resource_manager.get_federation_agreements(federation_id).await;
        Ok(agreements)
    }

    /// Transfer resources between federations (direct transfer not through agreement)
    pub async fn transfer_resource(
        &mut self,
        resource_id: String,
        recipient_id: String,
        amount: u64,
    ) -> Result<(), FederationServiceError> {
        // Implement direct resource transfer
        // This is a simplified implementation and would need more logic in production
        Ok(())
    }

    /// Allocate resource shares within a federation
    pub async fn allocate_resource_shares(
        &mut self,
        resource_id: String,
        shares: HashMap<String, u64>,
    ) -> Result<(), FederationServiceError> {
        // Implement resource share allocation within a federation
        // This is a simplified implementation and would need more logic in production
        Ok(())
    }
}```

===================
File: ./backend/src/services/governance.rs
Size: 4788 bytes
===================
```rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::reputation::ReputationManager;
use tokio::sync::RwLock;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Invalid recall vote")]
    InvalidRecallVote,
    #[error("Insufficient reputation")]
    InsufficientReputation,
    #[error("Proposal expired")]
    ProposalExpired,
    #[error("Member not found")]
    MemberNotFound,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceMember {
    pub did: String,
    pub joined_at: DateTime<Utc>,
    pub missed_votes: u32,
    pub last_activity: DateTime<Utc>,
    pub reputation_score: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecallVote {
    pub target_member: String,
    pub reason: String,
    pub votes: HashMap<String, bool>,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

pub struct GovernanceService {
    members: RwLock<HashMap<String, GovernanceMember>>,
    recall_votes: RwLock<HashMap<String, RecallVote>>,
    reputation_manager: ReputationManager,
    inactivity_threshold_days: u32,
    missed_votes_threshold: u32,
}

impl GovernanceService {
    pub fn new(reputation_manager: ReputationManager) -> Self {
        Self {
            members: RwLock::new(HashMap::new()),
            recall_votes: RwLock::new(HashMap::new()),
            reputation_manager,
            inactivity_threshold_days: 30,
            missed_votes_threshold: 3,
        }
    }

    pub async fn track_vote_participation(&self, member_did: &str, voted: bool) {
        let mut members = self.members.write().await;
        if let Some(member) = members.get_mut(member_did) {
            if !voted {
                member.missed_votes += 1;
                
                // Check if recall vote should be triggered
                if member.missed_votes >= self.missed_votes_threshold {
                    self.initiate_recall_vote(member_did).await;
                }
            } else {
                member.last_activity = Utc::now();
                // Reset missed votes on participation
                member.missed_votes = 0;
            }
        }
    }

    async fn initiate_recall_vote(&self, member_did: &str) {
        let recall = RecallVote {
            target_member: member_did.to_string(),
            reason: format!("Member missed {} consecutive votes", self.missed_votes_threshold),
            votes: HashMap::new(),
            created_at: Utc::now(),
            expires_at: Utc::now() + chrono::Duration::days(7),
        };

        let mut recall_votes = self.recall_votes.write().await;
        recall_votes.insert(member_did.to_string(), recall);
    }

    pub async fn process_recall_vote(&self, voter: &str, target: &str, approve: bool) -> Result<(), GovernanceError> {
        let mut recall_votes = self.recall_votes.write().await;
        
        if let Some(recall) = recall_votes.get_mut(target) {
            recall.votes.insert(voter.to_string(), approve);
            
            // Check if recall threshold met
            let total_votes = recall.votes.len();
            let approve_votes = recall.votes.values().filter(|&&v| v).count();
            
            if total_votes >= 10 && (approve_votes * 2) > total_votes {
                self.remove_member(target).await?;
                recall_votes.remove(target);
            }
        }
        Ok(())
    }

    pub async fn check_proposal_expiration(&self, proposal_id: &str) -> Result<bool, GovernanceError> {
        // Check if proposal is nearing expiration and notify if needed
        // Return true if expiring soon
        Ok(false) // Placeholder
    }

    pub async fn decay_inactive_reputation(&self) {
        let members = self.members.read().await;
        let now = Utc::now();
        
        for member in members.values() {
            let days_inactive = (now - member.last_activity).num_days();
            if days_inactive > self.inactivity_threshold_days as i64 {
                // Apply reputation decay
                let decay_factor = -0.1 * (days_inactive as f64 / self.inactivity_threshold_days as f64);
                self.reputation_manager.dynamic_adjustment(&member.did, decay_factor as i64).await
                    .unwrap_or_else(|e| eprintln!("Failed to decay reputation: {}", e));
            }
        }
    }

    async fn remove_member(&self, member_did: &str) -> Result<(), GovernanceError> {
        let mut members = self.members.write().await;
        members.remove(member_did).ok_or(GovernanceError::MemberNotFound)?;
        Ok(())
    }
}
```

===================
File: ./backend/src/services/governance_service.rs
Size: 7590 bytes
===================
```rs
use crate::database::queries::{create_proposal_in_db, record_vote_in_db};
use crate::database::models::{Proposal, Vote};
use std::sync::Arc;
use tokio::sync::Mutex;
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use crate::services::identity_service::IdentityService; // Import IdentityService
use icn_crypto::KeyPair; // Import KeyPair for signature verification
use crate::reputation::ReputationManager; // Import ReputationManager
use futures::future::join_all; // Import join_all for concurrency

pub struct GovernanceService {
    db: Arc<Mutex<dyn Database>>,
    identity_service: Arc<dyn IdentityService>, // Add IdentityService to GovernanceService
    reputation_manager: Arc<ReputationManager>, // Add ReputationManager to GovernanceService
}

impl GovernanceService {
    pub fn new(db: Arc<Mutex<dyn Database>>, identity_service: Arc<dyn IdentityService>, reputation_manager: Arc<ReputationManager>) -> Self {
        Self { db, identity_service, reputation_manager }
    }

    pub async fn create_proposal(&self, proposal: Proposal) -> Result<i64, sqlx::Error> {
        // Verify DID using IdentityService
        if !self.identity_service.verify_did(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Invalid DID".to_string()));
        }

        // Validate verifiable credential
        if !self.identity_service.verify_credential(&proposal.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        // Check reputation using ReputationManager
        if !self.verify_member_eligibility(&proposal.created_by).await {
            return Err(sqlx::Error::Protocol("Insufficient reputation".to_string()));
        }

        let db = self.db.lock().await;
        create_proposal_in_db(&*db, &proposal).await
    }

    pub async fn record_vote(&self, vote: Vote) -> Result<(), sqlx::Error> {
        // Validate verifiable credential
        if !self.identity_service.verify_credential(&vote.verifiable_credential).await {
            return Err(sqlx::Error::Protocol("Invalid verifiable credential".to_string()));
        }

        // Verify signature using icn-crypto
        if !self.verify_signature(&vote.voter, &vote.signature, &vote.proposal_id).await {
            return Err(sqlx::Error::Protocol("Invalid signature".to_string()));
        }

        if let Some(proof) = &vote.zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }
        let db = self.db.lock().await;
        record_vote_in_db(&*db, &vote).await
    }

    async fn verify_signature(&self, did: &str, signature: &str, message: &str) -> bool {
        // Retrieve public key from IdentityService
        if let Some(public_key) = self.identity_service.get_public_key(did).await {
            let key_pair = KeyPair {
                public_key,
                private_key: vec![], // Not needed for verification
                algorithm: icn_crypto::Algorithm::Secp256k1, // Assuming Secp256k1 for this example
            };
            return key_pair.verify(message.as_bytes(), signature.as_bytes());
        }
        false
    }

    async fn verify_member_eligibility(&self, did: &str) -> bool {
        self.reputation_manager.get_reputation(did, "governance") >= 50 // Example threshold
    }

    // New handler for creating proposals
    pub async fn handle_create_proposal(
        &self,
        proposal: Proposal,
        notification_manager: crate::notification::NotificationManager,
        websocket_clients: crate::websocket::WebSocketClients,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        match self.create_proposal(proposal.clone()).await {
            Ok(id) => {
                let subject = format!("New Proposal Created: {}", proposal.title);
                let body = format!("A new proposal has been created by {}. Description: {}",
                    proposal.created_by, proposal.description);
                notification_manager.send_notification(&subject, &body).await;
                let message = warp::ws::Message::text(serde_json::to_string(&proposal).unwrap());
                crate::websocket::broadcast_message(&message, websocket_clients).await;
                Ok(warp::reply::json(&id))
            },
            Err(e) => Err(warp::reject::custom(e)),
        }
    }

    // New handler for voting on proposals
    pub async fn handle_vote_on_proposal(
        &self,
        vote: Vote,
        notification_manager: crate::notification::NotificationManager,
        websocket_clients: crate::websocket::WebSocketClients,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        match self.record_vote(vote.clone()).await {
            Ok(_) => {
                let subject = format!("New Vote on Proposal: {}", vote.proposal_id);
                let body = format!("A new vote has been cast by {}. Approve: {}", vote.voter, vote.approve);
                notification_manager.send_notification(&subject, &body).await;
                let message = warp::ws::Message::text(serde_json::to_string(&vote).unwrap());
                crate::websocket::broadcast_message(&message, websocket_clients).await;
                Ok(warp::reply::json(&"Vote recorded"))
            },
            Err(e) => Err(warp::reject::custom(e)),
        }
    }

    pub async fn submit_proposal(&self, title: &str, description: &str, created_by: &str, ends_at: &str) -> Result<i64, String> {
        let proposal = Proposal {
            id: 0, // Placeholder, will be set by the database
            title: title.to_string(),
            description: description.to_string(),
            created_by: created_by.to_string(),
            ends_at: chrono::NaiveDateTime::parse_from_str(ends_at, "%Y-%m-%d %H:%M:%S").map_err(|e| e.to_string())?,
            created_at: chrono::Utc::now().naive_utc(),
            did: created_by.to_string(), // Add did field for DID-based access control
        };

        self.create_proposal(proposal).await.map_err(|e| e.to_string())
    }

    pub async fn vote(&self, _proposal_id: i64, voter: &str, approve: bool) -> Result<(), String> {
        let vote = Vote {
            proposal_id: _proposal_id,
            voter: voter.to_string(),
            approve,
        };

        self.record_vote(vote).await.map_err(|e| e.to_string())
    }

    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), String> {
        // Placeholder logic for handling Sybil resistance
        Ok(())
    }

    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), String> {
        let db = self.db.lock().await;
        db.apply_reputation_decay(did, decay_rate).await.map_err(|e| e.to_string())
    }

    pub async fn handle_delegated_governance(&self, federation_id: &str, representative_id: &str) -> Result<(), String> {
        // Placeholder logic for handling delegated governance
        Ok(())
    }

    pub async fn verify_signatures_concurrently(&self, dids: Vec<&str>, signatures: Vec<&str>, messages: Vec<&str>) -> Result<Vec<bool>, String> {
        let verification_futures: Vec<_> = dids.iter().zip(signatures.iter()).zip(messages.iter())
            .map(|((&did, &signature), &message)| {
                self.verify_signature(did, signature, message)
            })
            .collect();

        let results = join_all(verification_futures).await;
        Ok(results)
    }
}
```

===================
File: ./backend/src/services/identity_service.rs
Size: 7920 bytes
===================
```rs
use async_trait::async_trait;
use std::sync::Arc;
use crate::database::db::Database;
use icn_identity::ledger::{create_identity_in_ledger, get_identity_from_ledger, rotate_key_in_ledger, revoke_key_in_ledger};
use icn_core::verifiable_credentials::{VerifiableCredential, Proof};
use futures::future::join_all; // Import join_all for concurrency

#[async_trait]
pub trait IdentityService: Send + Sync {
    async fn create_identity(&self, identity: &str) -> Result<(), String>;
    async fn get_identity(&self, identity: &str) -> Result<String, String>;
    async fn rotate_key(&self, identity: &str) -> Result<(), String>;
    async fn revoke_key(&self, identity: &str) -> Result<(), String>;
    async fn verify_did(&self, _did: &str) -> Result<bool, String>; // Add verify_did method
    async fn verify_credential(&self, credential: &str) -> Result<bool, String>; // Add verify_credential method
    async fn get_public_key(&self, did: &str) -> Result<Option<Vec<u8>>, String>; // Add get_public_key method
}

pub struct IdentityServiceImpl {
    db: Arc<Database>,
}

impl IdentityServiceImpl {
    pub fn new(db: Arc<Database>) -> Self {
        Self { db }
    }
}

#[async_trait]
impl IdentityService for IdentityServiceImpl {
    async fn create_identity(&self, identity: &str) -> Result<(), String> {
        let credential = VerifiableCredential {
            credential_type: "IdentityCredential".to_string(),
            issuer_did: "did:icn:issuer".to_string(),
            subject_did: identity.to_string(),
            issuance_date: chrono::Utc::now().to_rfc3339(),
            expiration_date: None,
            credential_status: None,
            credential_schema: None,
            proof: Proof {
                type_: "Ed25519Signature2018".to_string(),
                created: chrono::Utc::now().to_rfc3339(),
                proof_purpose: "assertionMethod".to_string(),
                verification_method: "did:icn:issuer#keys-1".to_string(),
                jws: "example-jws".to_string(),
            },
        };

        create_identity_in_ledger(identity, &credential).await.map_err(|e| e.to_string())
    }

    async fn get_identity(&self, identity: &str) -> Result<String, String> {
        get_identity_from_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn rotate_key(&self, identity: &str) -> Result<(), String> {
        rotate_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn revoke_key(&self, identity: &str) -> Result<(), String> {
        revoke_key_in_ledger(identity).await.map_err(|e| e.to_string())
    }

    async fn verify_did(&self, _did: &str) -> Result<bool, String> {
        // Placeholder logic for verifying DID
        Ok(true)
    }

    async fn verify_credential(&self, credential: &str) -> Result<bool, String> {
        // Implement actual validation logic for verifying credential
        // For example, you can use a library to parse and validate the credential
        // Here, we assume the credential is a JSON string and validate its structure

        let parsed_credential: Result<VerifiableCredential, _> = serde_json::from_str(credential);
        match parsed_credential {
            Ok(vc) => {
                // Perform additional validation checks if needed
                // For example, check the issuer, expiration date, etc.
                if vc.issuer_did == "did:icn:issuer" {
                    Ok(true)
                } else {
                    Err("Invalid issuer".to_string())
                }
            }
            Err(_) => Err("Invalid credential format".to_string()),
        }
    }

    async fn get_public_key(&self, did: &str) -> Result<Option<Vec<u8>>, String> {
        // Placeholder logic for retrieving public key
        Ok(Some(vec![]))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> PgPool {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        PgPool::connect(&database_url).await.unwrap()
    }

    #[tokio::test]
    async fn test_create_identity() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.create_identity("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_get_identity() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let _ = service.create_identity("did:icn:test").await;
        let result = service.get_identity("did:icn:test").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "");
    }

    #[tokio::test]
    async fn test_rotate_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.rotate_key("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_revoke_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.revoke_key("did:icn:test").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_verify_did() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.verify_did("did:icn:test").await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_verify_credential() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let valid_credential = r#"
        {
            "credential_type": "IdentityCredential",
            "issuer_did": "did:icn:issuer",
            "subject_did": "did:icn:test",
            "issuance_date": "2023-01-01T00:00:00Z",
            "expiration_date": null,
            "credential_status": null,
            "credential_schema": null,
            "proof": {
                "type_": "Ed25519Signature2018",
                "created": "2023-01-01T00:00:00Z",
                "proof_purpose": "assertionMethod",
                "verification_method": "did:icn:issuer#keys-1",
                "jws": "example-jws"
            }
        }
        "#;

        let invalid_credential = r#"
        {
            "credential_type": "IdentityCredential",
            "issuer_did": "did:icn:invalid",
            "subject_did": "did:icn:test",
            "issuance_date": "2023-01-01T00:00:00Z",
            "expiration_date": null,
            "credential_status": null,
            "credential_schema": null,
            "proof": {
                "type_": "Ed25519Signature2018",
                "created": "2023-01-01T00:00:00Z",
                "proof_purpose": "assertionMethod",
                "verification_method": "did:icn:issuer#keys-1",
                "jws": "example-jws"
            }
        }
        "#;

        let result = service.verify_credential(valid_credential).await;
        assert!(result.is_ok());
        assert!(result.unwrap());

        let result = service.verify_credential(invalid_credential).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_get_public_key() {
        let pool = setup_test_db().await;
        let db = Arc::new(Database { pool });
        let service = IdentityServiceImpl::new(db);

        let result = service.get_public_key("did:icn:test").await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_some());
    }
}
```

===================
File: ./backend/src/services/reputation_service.rs
Size: 16423 bytes
===================
```rs
use crate::database::db::Database;
use crate::models::Reputation;
use std::sync::Arc;
use dashmap::DashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use zk_snarks::verify_proof; // Import zk-SNARK verification function
use std::time::{SystemTime, Duration, UNIX_EPOCH};
use tokio::sync::mpsc::{self, Sender, Receiver};
use tokio::task;
use tokio::time::{self, Duration};
use icn_identity::ledger::{apply_reputation_decay_in_ledger, handle_sybil_resistance_in_ledger}; // Import icn-identity ledger functions

/// A cache for storing reputation scores.
pub struct ReputationCache {
    cache: DashMap<String, i32>,
    max_size: usize,
}

impl ReputationCache {
    /// Creates a new ReputationCache with the specified maximum size.
    fn new(max_size: usize) -> Self {
        Self {
            cache: DashMap::new(),
            max_size,
        }
    }

    /// Retrieves the reputation score for the given DID from the cache.
    fn get(&self, did: &str) -> Option<i32> {
        self.cache.get(did).map(|v| *v)
    }

    /// Sets the reputation score for the given DID in the cache.
    fn set(&self, did: &str, score: i32) {
        if self.cache.len() >= self.max_size {
            // Implement a simple eviction policy (e.g., remove a random entry)
            if let Some(key) = self.cache.iter().next().map(|entry| entry.key().clone()) {
                self.cache.remove(&key);
            }
        }
        self.cache.insert(did.to_string(), score);
    }
}

/// A service for managing reputation scores.
pub struct ReputationService {
    db: Arc<Database>,
    cache: ReputationCache,
    decay_rate: f64,
    event_sender: Sender<ReputationEvent>,
}

pub struct ReputationConfig {
    base_decay_rate: f64,
    min_decay_rate: f64,
    max_decay_rate: f64,
    grace_period_days: u64,
    reputation_half_life: f64,
}

impl Default for ReputationConfig {
    fn default() -> Self {
        Self {
            base_decay_rate: 0.1,
            min_decay_rate: 0.02, // Minimum 2% decay for long-standing members
            max_decay_rate: 0.2,  // Maximum 20% decay for new/inactive members
            grace_period_days: 30, // 30 day grace period
            reputation_half_life: 365.0, // 1 year half-life for reputation weight
        }
    }
}

impl ReputationService {
    /// Creates a new ReputationService with the specified database, cache size, and decay rate.
    pub fn new(db: Arc<Database>, max_cache_size: usize, decay_rate: f64) -> Self {
        let (event_sender, event_receiver) = mpsc::channel(100);
        let service = ReputationService {
            db,
            cache: ReputationCache::new(max_cache_size),
            decay_rate,
            event_sender,
        };
        service.start_event_listener(event_receiver);
        service
    }

    /// Retrieves the reputation score for the given DID and category.
    pub async fn get_reputation(&self, did: &str, category: &str) -> Result<i64, sqlx::Error> {
        if let Some(score) = self.cache.get(did) {
            return Ok(score as i64);
        }

        let reputation = sqlx::query_as!(
            Reputation,
            r#"
            SELECT score FROM reputations WHERE did = $1 AND category = $2
            "#,
            did,
            category
        )
        .fetch_one(&*self.db.pool)
        .await?;

        self.cache.set(did, reputation.score as i32);
        Ok(reputation.score)
    }

    /// Adjusts the reputation score for the given DID and category by the specified adjustment value.
    pub async fn adjust_reputation(&self, did: &str, category: &str, adjustment: i64, zk_snark_proof: Option<&str>) -> Result<(), sqlx::Error> {
        if let Some(proof) = zk_snark_proof {
            if !verify_proof(proof) {
                return Err(sqlx::Error::Protocol("Invalid zk-SNARK proof".to_string()));
            }
        }

        sqlx::query!(
            r#"
            INSERT INTO reputations (did, category, score)
            VALUES ($1, $2, $3)
            ON CONFLICT (did, category) DO UPDATE SET score = reputations.score + $3
            "#,
            did,
            category,
            adjustment
        )
        .execute(&*self.db.pool)
        .await?;

        // Update the cache after adjusting the reputation
        if let Some(mut score) = self.cache.get(did) {
            score += adjustment as i32;
            self.cache.set(did, score);
        } else {
            let reputation = sqlx::query_as!(
                Reputation,
                r#"
                SELECT score FROM reputations WHERE did = $1 AND category = $2
                "#,
                did,
                category
            )
            .fetch_one(&*self.db.pool)
            .await?;
            self.cache.set(did, reputation.score as i32);
        }

        Ok(())
    }

    /// Applies decay to the reputation scores for the given DID.
    pub async fn apply_decay(&self, did: &str) -> Result<(), sqlx::Error> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64;
        let contributions = sqlx::query_as!(
            Contribution,
            r#"
            SELECT score, timestamp FROM contributions WHERE did = $1
            "#,
            did
        )
        .fetch_all(&*self.db.pool)
        .await?;

        for contribution in contributions {
            let age = now - contribution.timestamp;
            let decayed_score = (contribution.score as f64 * (-self.decay_rate * age).exp()) as i64;
            sqlx::query!(
                r#"
                UPDATE contributions SET score = $1 WHERE did = $2 AND timestamp = $3
                "#,
                decayed_score,
                did,
                contribution.timestamp
            )
            .execute(&*self.db.pool)
            .await?;
        }

        Ok(())
    }

    /// Handles Sybil resistance mechanisms for DID reputation tracking.
    pub async fn handle_sybil_resistance(&self, did: &str, reputation_score: i64) -> Result<(), sqlx::Error> {
        handle_sybil_resistance_in_ledger(did, reputation_score).await.map_err(|e| sqlx::Error::Protocol(e.to_string()))
    }

    /// Applies reputation decay for the given DID with a specified decay rate.
    pub async fn apply_reputation_decay(&self, did: &str, decay_rate: f64) -> Result<(), sqlx::Error> {
        apply_reputation_decay_in_ledger(did, decay_rate).await.map_err(|e| sqlx::Error::Protocol(e.to_string()))
    }

    pub async fn apply_adaptive_decay(&self, did: &str) -> Result<(), sqlx::Error> {
        let config = ReputationConfig::default();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();

        // Get member history
        let history = sqlx::query!(
            r#"
            SELECT 
                join_date,
                last_contribution,
                total_contributions,
                current_reputation
            FROM member_history 
            WHERE did = $1
            "#,
            did
        )
        .fetch_one(&*self.db.pool)
        .await?;

        // Calculate member tenure in days
        let tenure_days = (now.as_secs() - history.join_date) / 86400;
        
        // Check grace period
        let days_since_contribution = (now.as_secs() - history.last_contribution) / 86400;
        if days_since_contribution <= config.grace_period_days {
            return Ok(()); // No decay during grace period
        }

        // Calculate adaptive decay rate based on tenure and contribution history
        let tenure_factor = (-tenure_days as f64 / config.reputation_half_life).exp();
        let contribution_factor = (history.total_contributions as f64).sqrt() / 10.0;
        
        let adaptive_rate = config.base_decay_rate * 
            (1.0 - tenure_factor) * 
            (1.0 - contribution_factor)
            .clamp(config.min_decay_rate, config.max_decay_rate);

        // Apply the decay
        let new_reputation = (history.current_reputation as f64 * 
            (1.0 - adaptive_rate)).round() as i64;

        sqlx::query!(
            r#"
            UPDATE member_history 
            SET current_reputation = $1
            WHERE did = $2
            "#,
            new_reputation,
            did
        )
        .execute(&*self.db.pool)
        .await?;

        // Update cache
        self.cache.set(did, new_reputation as i32);

        Ok(())
    }

    pub async fn record_contribution(&self, did: &str) -> Result<(), sqlx::Error> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        
        sqlx::query!(
            r#"
            UPDATE member_history 
            SET 
                last_contribution = $1,
                total_contributions = total_contributions + 1
            WHERE did = $2
            "#,
            now as i64,
            did
        )
        .execute(&*self.db.pool)
        .await?;

        Ok(())
    }

    pub async fn batch_reputation_updates(&self, events: Vec<ReputationEvent>) -> Result<(), sqlx::Error> {
        for event in events {
            self.emit_event(event);
        }
        Ok(())
    }

    pub fn emit_event(&self, event: ReputationEvent) {
        let sender = self.event_sender.clone();
        task::spawn(async move {
            if let Err(e) = sender.send(event).await {
                eprintln!("Failed to send event: {}", e);
            }
        });
    }

    fn start_event_listener(&self, mut event_receiver: Receiver<ReputationEvent>) {
        task::spawn(async move {
            while let Some(event) = event_receiver.recv().await {
                match event {
                    ReputationEvent::ReputationAdjusted { did, adjustment } => {
                        // Handle reputation adjustment event
                    }
                    ReputationEvent::ReputationDecayApplied { did, decay_rate } => {
                        // Handle reputation decay event
                    }
                }
            }
        });
    }
}

/// Represents a contribution with a score and timestamp.
pub struct Contribution {
    pub score: i64,
    pub timestamp: f64,
}

impl Contribution {
    /// Creates a new Contribution with the specified score and the current timestamp.
    pub fn new(score: i64) -> Self {
        Self {
            score,
            timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as f64,
        }
    }
}

pub enum ReputationEvent {
    ReputationAdjusted { did: String, adjustment: i64 },
    ReputationDecayApplied { did: String, decay_rate: f64 },
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;

    async fn setup_test_db() -> Arc<Database> {
        let database_url = env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb".to_string());
        let pool = PgPool::connect(&database_url).await.unwrap();
        Arc::new(Database { pool })
    }

    #[tokio::test]
    async fn test_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }

    #[tokio::test]
    async fn test_integration_get_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 0); // Assuming initial score is 0
    }

    #[tokio::test]
    async fn test_integration_adjust_reputation() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let category = "governance";
        service.adjust_reputation(did, category, 10, None).await.unwrap();
        let score = service.get_reputation(did, category).await.unwrap();
        assert_eq!(score, 10);
    }

    #[tokio::test]
    async fn test_integration_apply_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_decay(did).await.unwrap();
        let score = service.get_reputation(did, "governance").await.unwrap();
        assert!(score < 10); // Assuming initial score was 10 and decay was applied
    }

    #[tokio::test]
    async fn test_integration_handle_sybil_resistance() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let reputation_score = 50;
        service.handle_sybil_resistance(did, reputation_score).await.unwrap();
        // Add assertions based on the expected behavior of handle_sybil_resistance
    }

    #[tokio::test]
    async fn test_integration_apply_reputation_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        let decay_rate = 0.05;
        service.apply_reputation_decay(did, decay_rate).await.unwrap();
        // Add assertions based on the expected behavior of apply_reputation_decay
    }

    #[tokio::test]
    async fn test_integration_apply_adaptive_decay() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.apply_adaptive_decay(did).await.unwrap();
        // Add assertions based on the expected behavior of apply_adaptive_decay
    }

    #[tokio::test]
    async fn test_integration_record_contribution() {
        let db = setup_test_db().await;
        let service = ReputationService::new(db, 100, 0.1);

        let did = "did:icn:test";
        service.record_contribution(did).await.unwrap();
        // Add assertions based on the expected behavior of record_contribution
    }
}
```

===================
File: ./backend/src/services/storage_service.rs
Size: 5251 bytes
===================
```rs
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;
use crate::storage::{StorageBackend, StorageResult, StorageError};

pub struct StorageService {
    pool: Arc<PgPool>,
}

impl StorageService {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }

    pub async fn store_on_chain(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        // Implement on-chain storage logic here
        Ok(())
    }

    pub async fn retrieve_on_chain(&self, key: &str) -> StorageResult<Vec<u8>> {
        // Implement on-chain retrieval logic here
        Ok(vec![])
    }

    pub async fn delete_on_chain(&self, key: &str) -> StorageResult<()> {
        // Implement on-chain deletion logic here
        Ok(())
    }

    pub async fn store_off_chain(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        self.set(key, value).await
    }

    pub async fn retrieve_off_chain(&self, key: &str) -> StorageResult<Vec<u8>> {
        self.get(key).await
    }

    pub async fn delete_off_chain(&self, key: &str) -> StorageResult<()> {
        self.delete(key).await
    }
}

#[async_trait]
impl StorageBackend for StorageService {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.exists.unwrap_or(false))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;
    use std::sync::Arc;

    async fn setup_test_db() -> Arc<PgPool> {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        Arc::new(PgPool::connect(&database_url).await.unwrap())
    }

    #[tokio::test]
    async fn test_store_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.store_on_chain("test_key", b"test_value").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_retrieve_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.retrieve_on_chain("test_key").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"test_value");
    }

    #[tokio::test]
    async fn test_delete_on_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.delete_on_chain("test_key").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_store_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.store_off_chain("test_key", b"test_value").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_retrieve_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.retrieve_off_chain("test_key").await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"test_value");
    }

    #[tokio::test]
    async fn test_delete_off_chain() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let result = storage_service.delete_off_chain("test_key").await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_exists() {
        let pool = setup_test_db().await;
        let storage_service = StorageService::new(pool);

        let key = "test_key";
        let value = b"test_value";

        storage_service.store_off_chain(key, value).await.unwrap();
        let exists = storage_service.exists(key).await.unwrap();
        assert!(exists);

        storage_service.delete_off_chain(key).await.unwrap();
        let exists = storage_service.exists(key).await.unwrap();
        assert!(!exists);
    }
}
```

===================
File: ./backend/src/storage.rs
Size: 5796 bytes
===================
```rs
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;

pub type StorageResult<T> = Result<T, StorageError>;

#[derive(Debug, thiserror::Error)]
pub enum StorageError {
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    #[error("Key not found: {0}")]
    KeyNotFound(String),
    #[error("Database error: {0}")]
    DatabaseError(#[from] sqlx::Error),
}

#[async_trait]
pub trait StorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()>;
    async fn get(&self, key: &str) -> StorageResult<Vec<u8>>;
    async fn delete(&self, key: &str) -> StorageResult<()>;
    async fn exists(&self, key: &str) -> StorageResult<bool>;
}

pub struct StorageManager {
    backend: Box<dyn StorageBackend + Send + Sync>,
}

impl StorageManager {
    pub fn new(backend: Box<dyn StorageBackend + Send + Sync>) -> Self {
        Self { backend }
    }
}

pub struct DatabaseStorageBackend {
    pool: Arc<PgPool>,
}

impl DatabaseStorageBackend {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl StorageBackend for DatabaseStorageBackend {
    async fn set(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        sqlx::query!(
            r#"
            INSERT INTO storage (key, value)
            VALUES ($1, $2)
            ON CONFLICT (key) DO UPDATE SET value = $2
            "#,
            key,
            value
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn get(&self, key: &str) -> StorageResult<Vec<u8>> {
        let result = sqlx::query!(
            r#"
            SELECT value FROM storage WHERE key = $1
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.value)
    }

    async fn delete(&self, key: &str) -> StorageResult<()> {
        sqlx::query!(
            r#"
            DELETE FROM storage WHERE key = $1
            "#,
            key
        )
        .execute(&*self.pool)
        .await?;
        Ok(())
    }

    async fn exists(&self, key: &str) -> StorageResult<bool> {
        let result = sqlx::query!(
            r#"
            SELECT EXISTS(SELECT 1 FROM storage WHERE key = $1)
            "#,
            key
        )
        .fetch_one(&*self.pool)
        .await?;
        Ok(result.exists.unwrap_or(false))
    }
}

pub struct OnChainStorage {
    // Add fields for on-chain storage management
}

impl OnChainStorage {
    pub async fn store(&self, key: &str, value: &[u8]) -> StorageResult<()> {
        // Implement on-chain storage logic here
        Ok(())
    }

    pub async fn retrieve(&self, key: &str) -> StorageResult<Vec<u8>> {
        // Implement on-chain retrieval logic here
        Ok(vec![])
    }

    pub async fn delete(&self, key: &str) -> StorageResult<()> {
        // Implement on-chain deletion logic here
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use std::env;
    use std::sync::Arc;

    async fn setup_test_db() -> Arc<PgPool> {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        Arc::new(PgPool::connect(&database_url).await.unwrap())
    }

    #[tokio::test]
    async fn test_set_and_get() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        let retrieved_value = backend.get(key).await.unwrap();
        assert_eq!(retrieved_value, value);
    }

    #[tokio::test]
    async fn test_delete() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        backend.delete(key).await.unwrap();
        let result = backend.get(key).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_exists() {
        let pool = setup_test_db().await;
        let backend = DatabaseStorageBackend::new(pool);

        let key = "test_key";
        let value = b"test_value";

        backend.set(key, value).await.unwrap();
        let exists = backend.exists(key).await.unwrap();
        assert!(exists);

        backend.delete(key).await.unwrap();
        let exists = backend.exists(key).await.unwrap();
        assert!(!exists);
    }

    #[tokio::test]
    async fn test_on_chain_store() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";
        let value = b"on_chain_value";

        let result = on_chain_storage.store(key, value).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_on_chain_retrieve() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";

        let result = on_chain_storage.retrieve(key).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), b"on_chain_value");
    }

    #[tokio::test]
    async fn test_on_chain_delete() {
        let on_chain_storage = OnChainStorage {
            // Initialize fields for on-chain storage management
        };

        let key = "on_chain_key";

        let result = on_chain_storage.delete(key).await;
        assert!(result.is_ok());
    }
}
```

===================
File: ./backend/src/test_config.rs
Size: 1365 bytes
===================
```rs
use lazy_static::lazy_static;
use std::env;
use std::sync::Once;

static INIT: Once = Once::new();

lazy_static! {
    pub static ref TEST_CONFIG: TestConfig = TestConfig::new();
}

pub struct TestConfig {
    pub database_url: String,
    pub test_did: String,
    pub test_public_key: String,
    pub test_private_key: String,
}

impl TestConfig {
    pub fn new() -> Self {
        // Initialize test environment
        INIT.call_once(|| {
            env_logger::init();
        });

        Self {
            database_url: env::var("TEST_DATABASE_URL")
                .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string()),
            test_did: "did:icn:test".to_string(),
            test_public_key: "test_public_key".to_string(),
            test_private_key: "test_private_key".to_string(),
        }
    }
}

/// Test environment setup
pub fn setup_test_env() {
    INIT.call_once(|| {
        env_logger::init();
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_initialization() {
        let config = TestConfig::new();
        assert!(!config.database_url.is_empty());
        assert!(!config.test_did.is_empty());
    }

    #[test]
    fn test_env_setup() {
        setup_test_env();
        // Verify it can be called multiple times without issues
        setup_test_env();
    }
} ```

===================
File: ./backend/src/test_macros.rs
Size: 1413 bytes
===================
```rs
#[macro_export]
macro_rules! async_test {
    ($name:ident, $body:expr) => {
        #[tokio::test]
        async fn $name() {
            crate::test_config::setup_test_env();
            let services = crate::test_utils::TestServices::new().await;
            
            // Run the test
            let result = $body(&services).await;
            
            // Cleanup
            services.cleanup().await;
            
            // Propagate any test failures
            if let Err(e) = result {
                panic!("Test failed: {}", e);
            }
        }
    };
}

#[macro_export]
macro_rules! setup_test_db {
    () => {{
        use crate::test_utils::TestDb;
        TestDb::new().await
    }};
}

#[macro_export]
macro_rules! with_test_services {
    ($services:ident, $body:expr) => {{
        let $services = crate::test_utils::TestServices::new().await;
        let result = $body;
        $services.cleanup().await;
        result
    }};
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::TestServices;

    async_test!(test_macro_works, |_services| async {
        Ok(())
    });

    #[tokio::test]
    async fn test_with_services_macro() {
        with_test_services!(services, async {
            assert!(services.database.pool.ping().await.is_ok());
            Ok::<_, Box<dyn std::error::Error>>(())
        })
        .await
        .unwrap();
    }
} ```

===================
File: ./backend/src/test_utils.rs
Size: 7302 bytes
===================
```rs
use sqlx::PgPool;
use std::env;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::database::Database;
use crate::identity::IdentityManager;
use crate::reputation::ReputationManager;
use crate::networking::p2p::P2PManager;

/// Test database configuration
pub struct TestDb {
    pub pool: PgPool,
}

impl TestDb {
    /// Creates a new test database connection
    pub async fn new() -> Self {
        let database_url = env::var("TEST_DATABASE_URL")
            .unwrap_or_else(|_| "postgres://icnuser:icnpass@db:5432/icndb_test".to_string());
        let pool = PgPool::connect(&database_url)
            .await
            .expect("Failed to connect to test database");
        Self { pool }
    }

    /// Cleans up test database tables
    pub async fn cleanup(&self) {
        // List of tables to truncate
        let tables = vec![
            "proposals",
            "votes",
            "identities",
            "reputation_scores",
            "storage",
            "federation_operations",
        ];

        for table in tables {
            let _ = sqlx::query(&format!("TRUNCATE TABLE {} CASCADE", table))
                .execute(&self.pool)
                .await;
        }
    }
}

/// Creates mock services for testing
pub struct TestServices {
    pub identity_manager: Arc<IdentityManager>,
    pub reputation_manager: Arc<ReputationManager>,
    pub p2p_manager: Arc<Mutex<P2PManager>>,
    pub database: Arc<Database>,
}

impl TestServices {
    /// Creates new test services with a shared database connection
    pub async fn new() -> Self {
        let test_db = TestDb::new().await;
        let database = Arc::new(Database { pool: test_db.pool });
        
        Self {
            identity_manager: Arc::new(IdentityManager::new(database.clone())),
            reputation_manager: Arc::new(ReputationManager::new(
                database.clone(),
                100, // max_cache_size
                0.1, // decay_rate
            )),
            p2p_manager: Arc::new(Mutex::new(P2PManager::new())),
            database,
        }
    }

    /// Cleans up all test data
    pub async fn cleanup(&self) {
        let test_db = TestDb {
            pool: self.database.pool.clone(),
        };
        test_db.cleanup().await;
    }
}

/// Test helper functions
pub mod helpers {
    use super::*;
    use crate::models::{Proposal, Vote};
    use chrono::{NaiveDateTime, Utc};

    /// Creates a test proposal
    pub fn create_test_proposal(id: i32) -> Proposal {
        Proposal {
            id,
            title: format!("Test Proposal {}", id),
            description: "Test Description".to_string(),
            created_by: "did:icn:test".to_string(),
            ends_at: NaiveDateTime::from_timestamp(Utc::now().timestamp() + 3600, 0),
            created_at: NaiveDateTime::from_timestamp(Utc::now().timestamp(), 0),
        }
    }

    /// Creates a test vote
    pub fn create_test_vote(proposal_id: i32, voter: &str, approve: bool) -> Vote {
        Vote {
            proposal_id,
            voter: voter.to_string(),
            approve,
        }
    }
}

pub mod test_utils {
    use crate::identity::{IdentitySystem, DID, Algorithm};
    use crate::reputation::ReputationSystem;
    use crate::blockchain::Blockchain;
    use crate::governance::ProposalHistory;
    use crate::federation::FederationManager;
    use std::sync::{Arc, Mutex};
    use std::collections::HashMap;

    /// Set up a test environment with basic components
    pub fn setup_test_environment() -> (
        Arc<Mutex<IdentitySystem>>, 
        Arc<Mutex<ReputationSystem>>,
        Arc<Mutex<Blockchain>>,
        Arc<Mutex<ProposalHistory>>,
        Arc<Mutex<FederationManager>>
    ) {
        // Create the identity system
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        
        // Create the reputation system
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        
        // Create the blockchain
        let blockchain = Arc::new(Mutex::new(
            Blockchain::new(identity_system.clone(), reputation_system.clone())
        ));
        
        // Create proposal history
        let proposal_history = Arc::new(Mutex::new(ProposalHistory::new()));
        
        // Create federation manager
        let federation_manager = Arc::new(Mutex::new(FederationManager::new()));
        
        // Return all components
        (identity_system, reputation_system, blockchain, proposal_history, federation_manager)
    }

    /// Create DIDs for testing
    pub fn create_test_dids(count: usize) -> Vec<DID> {
        let mut dids = Vec::with_capacity(count);
        
        for i in 0..count {
            let did = DID::new(
                format!("did:icn:test{}", i),
                Algorithm::Ed25519
            );
            dids.push(did);
        }
        
        dids
    }

    /// Register DIDs with permissions
    pub fn register_dids_with_permissions(
        identity_system: &mut IdentitySystem,
        dids: Vec<DID>,
        permissions: &[&str]
    ) {
        for did in dids {
            identity_system.register_did(
                did,
                permissions.iter().map(|&p| p.to_string()).collect()
            );
        }
    }

    /// Set up reputation scores for DIDs
    pub fn setup_reputations(
        reputation_system: &mut ReputationSystem,
        dids: &[&str],
        scores: &[i32]
    ) {
        for (did, &score) in dids.iter().zip(scores.iter()) {
            reputation_system.increase_reputation(did, score);
        }
    }

    /// Create a test blockchain with genesis block
    pub fn create_test_blockchain(
        identity_system: Arc<Mutex<IdentitySystem>>,
        reputation_system: Arc<Mutex<ReputationSystem>>
    ) -> Blockchain {
        Blockchain::new(identity_system, reputation_system)
    }

    /// Sample helper to verify transaction validity
    pub fn verify_transaction_validity(
        blockchain: &Blockchain,
        sender: &str,
        transaction_type: &str
    ) -> bool {
        let identity_system = blockchain.identity_system.lock().unwrap();
        match transaction_type {
            "transfer" => identity_system.has_permission(sender, "transfer"),
            "governance" => identity_system.has_permission(sender, "governance"),
            "resource" => identity_system.has_permission(sender, "resource"),
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_database_connection() {
        let test_db = TestDb::new().await;
        assert!(sqlx::query("SELECT 1")
            .execute(&test_db.pool)
            .await
            .is_ok());
    }

    #[tokio::test]
    async fn test_services_creation() {
        let services = TestServices::new().await;
        assert!(services.database.pool.ping().await.is_ok());
    }

    #[tokio::test]
    async fn test_cleanup() {
        let services = TestServices::new().await;
        services.cleanup().await;
        // Verify tables are empty
        let count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM proposals")
            .fetch_one(&services.database.pool)
            .await
            .unwrap();
        assert_eq!(count.0, 0);
    }
}```

===================
File: ./backend/src/vm.rs
Size: 6560 bytes
===================
```rs
use std::sync::Arc;
use icn_types::RuntimeError;
use icn_core::vm::{OpCode, Contract, CooperativeMetadata, VM as CoreVM};
use std::error::Error;
use std::collections::HashMap;
use icn_core::vm::{VM, VMConfig};

pub mod opcode {
    #[derive(Debug, PartialEq, Clone)]
    pub enum OpCode {
        // Stack operations
        Push(i32),
        Pop,
        Dup,
        Swap,
        
        // Math operations
        Add,
        Sub,
        Mul,
        Div,
        
        // Memory operations
        Load(String),
        Store(String),
        
        // Control flow
        Jump(usize),
        JumpIf(usize),
        Call(String),
        Return,
        
        // Cooperative operations
        ShareResource(String),
        RequestResource(String),
        ReleaseResource(String),
        
        // Federation operations
        JoinFederation(String),
        LeaveFederation(String),
        VoteOnProposal(String),
        
        // Reputation operations
        GetReputation(String),
        IncreaseReputation(String, i32),
        DecreaseReputation(String, i32),
    }
}

pub mod cooperative_metadata {
    use std::collections::HashMap;
    use serde::{Serialize, Deserialize};

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ResourceImpact {
        pub cpu: f64,
        pub memory: f64,
        pub storage: f64,
        pub bandwidth: f64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CooperativeMetadata {
        pub name: String,
        pub version: String,
        pub author: String,
        pub description: String,
        pub resource_impact: ResourceImpact,
        pub permissions: Vec<String>,
        pub dependencies: HashMap<String, String>, // name -> version
    }
    
    impl CooperativeMetadata {
        pub fn new(
            name: String,
            version: String,
            author: String,
            description: String,
        ) -> Self {
            Self {
                name,
                version,
                author,
                description,
                resource_impact: ResourceImpact {
                    cpu: 0.0,
                    memory: 0.0,
                    storage: 0.0,
                    bandwidth: 0.0,
                },
                permissions: Vec::new(),
                dependencies: HashMap::new(),
            }
        }
        
        pub fn with_resource_impact(mut self, impact: ResourceImpact) -> Self {
            self.resource_impact = impact;
            self
        }
        
        pub fn with_permissions(mut self, permissions: Vec<String>) -> Self {
            self.permissions = permissions;
            self
        }
        
        pub fn add_dependency(mut self, name: String, version: String) -> Self {
            self.dependencies.insert(name, version);
            self
        }
    }
}

pub struct BackendVM {
    inner: VM
}

impl BackendVM {
    pub fn new(config: VMConfig) -> Self {
        Self {
            inner: VM::new(config)
        }
    }

    pub fn execute(&mut self, contract_id: &str, method: &str, args: Vec<Vec<u8>>) -> Result<Vec<u8>, String> {
        self.inner.execute(contract_id, method, args)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::opcode::OpCode;
    use super::cooperative_metadata::{CooperativeMetadata, ResourceImpact};

    #[test]
    fn test_simple_program() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "TestProgram".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "A test program".to_string(),
        );
        
        // Create a simple program that calculates (5 + 3) * 2
        let program = vec![
            OpCode::Push(5),
            OpCode::Push(3),
            OpCode::Add,     // Stack now contains [8]
            OpCode::Push(2),
            OpCode::Mul,     // Stack now contains [16]
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![16]);
    }
    
    #[test]
    fn test_memory_operations() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "MemoryTest".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "Tests memory operations".to_string(),
        );
        
        // Create a program that stores and loads values from memory
        let program = vec![
            OpCode::Push(42),
            OpCode::Store("answer".to_string()),  // Store 42 in "answer"
            OpCode::Push(10),                     // Push something else to ensure we're loading
            OpCode::Load("answer".to_string()),   // Load "answer" (42)
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![42]);
    }
    
    #[test]
    fn test_control_flow() {
        // Create a metadata for the VM
        let metadata = CooperativeMetadata::new(
            "ControlFlowTest".to_string(),
            "1.0.0".to_string(),
            "Test Author".to_string(),
            "Tests control flow".to_string(),
        );
        
        // Create a program with conditional jumps
        let program = vec![
            OpCode::Push(1),                  // Condition true
            OpCode::JumpIf(3),                // Jump to position 3 if condition is true
            OpCode::Push(0),                  // This should be skipped
            OpCode::Push(42),                 // This is where we jump to
            OpCode::Push(0),                  // Condition false
            OpCode::JumpIf(7),                // This jump should NOT happen
            OpCode::Push(100),                // This should be executed
        ];
        
        let mut vm = BackendVM::new(VMConfig { code: program, metadata });
        let result = vm.execute("contract_id", "method", vec![]);
        
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![100]);
    }
}
```

===================
File: ./contracts/cooperative/src/proposals.rs
Size: 4401 bytes
===================
```rs
use std::collections::HashMap;
use icn_zkp::{ProofVerifier, RollupBatch, ZKProof, VerificationKey};
use ethers::prelude::*;

pub struct ProposalContract {
    proposals: HashMap<String, Proposal>,
    vote_batches: Vec<RollupBatch>,
    min_quorum: u32,
    verifier: ProofVerifier,
    verification_key: VerificationKey,
    contract_address: Address,
    client: Provider<Http>,
}

pub struct Proposal {
    id: String,
    creator: String,
    voting_ends_at: u64,
    votes: HashMap<String, bool>,
    rollup_root: Option<[u8; 32]>,
    status: ProposalStatus,
    vote_count: VoteCount,
}

struct VoteCount {
    approve: u32,
    reject: u32,
    total: u32,
}

#[derive(PartialEq)]
enum ProposalStatus {
    Active,
    Approved,
    Rejected,
    Finalized,
}

impl ProposalContract {
    pub fn new(min_quorum: u32, verification_key: VerificationKey, contract_address: Address) -> Self {
        Self {
            proposals: HashMap::new(),
            vote_batches: Vec::new(),
            min_quorum,
            verifier: ProofVerifier::new(),
            verification_key,
            contract_address,
            client: Provider::<Http>::try_from(
                "http://localhost:8545"
            ).expect("could not instantiate HTTP Provider"),
        }
    }

    pub async fn submit_vote_batch(&mut self, batch: RollupBatch) -> Result<(), String> {
        // First verify the ZK proof locally
        if !self.verifier.verify_proof(&batch.proof) {
            return Err("Invalid vote batch proof".to_string());
        }

        // Create contract call to submit batch
        let data = ethers::abi::encode(&[
            Token::Bytes(batch.rollup_root.to_vec()),
            Token::Bytes(batch.proof.to_vec())
        ]);

        let tx = TransactionRequest::new()
            .to(self.contract_address)
            .data(data)
            .into();

        // Submit transaction
        match self.client.send_transaction(tx, None).await {
            Ok(tx_hash) => {
                // Wait for confirmation
                let receipt = self.client.get_transaction_receipt(tx_hash)
                    .await
                    .map_err(|e| e.to_string())?
                    .ok_or("Transaction not found")?;

                if receipt.status.unwrap() == U64::from(1) {
                    self.vote_batches.push(batch);
                    Ok(())
                } else {
                    Err("Transaction failed".to_string())
                }
            },
            Err(e) => Err(e.to_string())
        }
    }

    pub async fn execute_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        // Create call to execute proposal on-chain
        let data = ethers::abi::encode(&[Token::String(proposal_id.to_string())]);

        let tx = TransactionRequest::new()
            .to(self.contract_address)
            .data(data)
            .into();

        match self.client.send_transaction(tx, None).await {
            Ok(tx_hash) => {
                let receipt = self.client.get_transaction_receipt(tx_hash)
                    .await
                    .map_err(|e| e.to_string())?
                    .ok_or("Transaction not found")?;

                // Parse result from logs
                if let Some(logs) = receipt.logs.get(0) {
                    let topics = logs.topics.clone();
                    if topics.len() >= 2 {
                        let approved = topics[1] == H256::from([1u8; 32]);
                        
                        // Update local state
                        if let Some(proposal) = self.proposals.get_mut(proposal_id) {
                            proposal.status = if approved {
                                ProposalStatus::Approved
                            } else {
                                ProposalStatus::Rejected
                            };
                        }
                        
                        return Ok(approved);
                    }
                }
                Err("Could not parse result".to_string())
            },
            Err(e) => Err(e.to_string())
        }
    }

    pub fn handle_zk_snark_proof_verification(&self, proof: &ZKProof) -> Result<bool, String> {
        if self.verifier.verify_proof(proof) {
            Ok(true)
        } else {
            Err("Invalid zk-SNARK proof".to_string())
        }
    }
}
```

===================
File: ./crates/icn-cli/src/client.rs
Size: 4213 bytes
===================
```rs
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::error::Error;

pub struct IcnClient {
    client: Client,
    base_url: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Identity {
    pub did: String,
    pub public_key: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub member_count: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub resource_type: String,
    pub capacity: String,
    pub owner: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Proposal {
    pub id: String,
    pub title: String,
    pub description: String,
    pub status: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HealthStatus {
    pub status: String,
    pub version: String,
    pub uptime: u64,
}

impl IcnClient {
    pub fn new(base_url: String) -> Self {
        Self {
            client: Client::new(),
            base_url,
        }
    }

    pub async fn check_health(&self) -> Result<HealthStatus, Box<dyn Error>> {
        let response = self.client
            .get(&format!("{}/health", self.base_url))
            .send()
            .await?;
            
        if response.status().is_success() {
            let health = response.json().await?;
            Ok(health)
        } else {
            Err(format!("API health check failed with status: {}", response.status()).into())
        }
    }

    pub async fn create_identity(&self) -> Result<Identity, Box<dyn Error>> {
        let response = self.client
            .post(&format!("{}/api/v1/identity/create", self.base_url))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn list_identities(&self) -> Result<Vec<Identity>, Box<dyn Error>> {
        let response = self.client
            .get(&format!("{}/api/v1/identity/list", self.base_url))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn join_cooperative(&self, coop_id: &str) -> Result<(), Box<dyn Error>> {
        self.client
            .post(&format!("{}/api/v1/cooperative/join/{}", self.base_url, coop_id))
            .send()
            .await?;
        Ok(())
    }

    pub async fn list_cooperatives(&self) -> Result<Vec<Cooperative>, Box<dyn Error>> {
        let response = self.client
            .get(&format!("{}/api/v1/cooperative/list", self.base_url))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn register_resource(&self, resource_type: &str, capacity: &str) -> Result<Resource, Box<dyn Error>> {
        let response = self.client
            .post(&format!("{}/api/v1/resource/register", self.base_url))
            .json(&serde_json::json!({
                "type": resource_type,
                "capacity": capacity
            }))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn list_resources(&self) -> Result<Vec<Resource>, Box<dyn Error>> {
        let response = self.client
            .get(&format!("{}/api/v1/resource/list", self.base_url))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn create_proposal(&self, title: &str, description: &str) -> Result<Proposal, Box<dyn Error>> {
        let response = self.client
            .post(&format!("{}/api/v1/governance/propose", self.base_url))
            .json(&serde_json::json!({
                "title": title,
                "description": description
            }))
            .send()
            .await?
            .json()
            .await?;
        Ok(response)
    }

    pub async fn vote_proposal(&self, proposal_id: &str, vote: bool) -> Result<(), Box<dyn Error>> {
        self.client
            .post(&format!("{}/api/v1/governance/vote/{}", self.base_url, proposal_id))
            .json(&serde_json::json!({
                "vote": vote
            }))
            .send()
            .await?;
        Ok(())
    }
}```

===================
File: ./crates/icn-consensus/src/federation.rs
Size: 3501 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum FederationError {
    #[error("Invalid federation configuration: {0}")]
    InvalidConfiguration(String),
    #[error("Federation already exists: {0}")]
    AlreadyExists(String),
    #[error("Insufficient reputation: {0}")]
    InsufficientReputation(String),
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Federation {
    pub id: String,
    pub federation_type: FederationType,
    pub terms: FederationTerms,
    pub members: HashMap<String, MemberStatus>,
    pub created_at: u64,
    pub status: FederationStatus,
    pub proposals: HashMap<i64, Proposal>,
    pub votes: HashMap<i64, Vec<Vote>>,
}

#[derive(Serialize, Deserialize, Clone)]
pub enum MemberStatus {
    Active,
    Pending,
    Suspended,
}

#[derive(Serialize, Deserialize, Clone)]
pub enum FederationStatus {
    Forming,
    Active,
    Suspended,
    Dissolved,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: i64,
    pub title: String,
    pub description: String,
    pub created_by: String,
    pub ends_at: u64,
    pub created_at: u64,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Vote {
    pub proposal_id: i64,
    pub voter: String,
    pub approve: bool,
}

impl Federation {
    pub fn new(
        id: String,
        federation_type: FederationType,
        terms: FederationTerms,
        creator_id: String,
    ) -> Self {
        let mut members = HashMap::new();
        members.insert(creator_id, MemberStatus::Active);

        Self {
            id,
            federation_type,
            terms,
            members,
            created_at: chrono::Utc::now().timestamp() as u64,
            status: FederationStatus::Forming,
            proposals: HashMap::new(),
            votes: HashMap::new(),
        }
    }

    pub fn can_join(&self, participant_reputation: i64) -> bool {
        participant_reputation >= self.terms.minimum_reputation
    }

    pub fn add_member(&mut self, member_id: String) -> Result<(), FederationError> {
        if self.members.contains_key(&member_id) {
            return Err(FederationError::AlreadyExists(
                "Member already exists in federation".to_string(),
            ));
        }
        self.members.insert(member_id, MemberStatus::Pending);
        Ok(())
    }

    pub fn submit_proposal(&mut self, title: String, description: String, created_by: String, ends_at: u64) -> Result<i64, FederationError> {
        let proposal_id = self.proposals.len() as i64 + 1;
        let proposal = Proposal {
            id: proposal_id,
            title,
            description,
            created_by,
            ends_at,
            created_at: chrono::Utc::now().timestamp() as u64,
        };
        self.proposals.insert(proposal_id, proposal);
        Ok(proposal_id)
    }

    pub fn vote(&mut self, proposal_id: i64, voter: String, approve: bool) -> Result<(), FederationError> {
        if !self.proposals.contains_key(&proposal_id) {
            return Err(FederationError::InvalidConfiguration("Proposal not found".to_string()));
        }
        let vote = Vote {
            proposal_id,
            voter,
            approve,
        };
        self.votes.entry(proposal_id).or_insert_with(Vec::new).push(vote);
        Ok(())
    }
}
```

===================
File: ./crates/icn-consensus/src/federation/cross_federation.rs
Size: 17830 bytes
===================
```rs
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::RwLock;
use thiserror::Error;
use serde::{Serialize, Deserialize};
use icn_crypto::{KeyPair, Algorithm, hash};
use super::{Federation, FederationError};

/// Error types for cross-federation communication
#[derive(Error, Debug)]
pub enum CrossFederationError {
    #[error("Message verification failed: {0}")]
    VerificationFailed(String),

    #[error("Federation not found: {0}")]
    FederationNotFound(String),

    #[error("Not authorized: {0}")]
    NotAuthorized(String),

    #[error("Message delivery failed: {0}")]
    DeliveryFailed(String),
    
    #[error("Protocol error: {0}")]
    ProtocolError(String),
}

/// Types of cross-federation messages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    ResourceRequest,
    ResourceOffer,
    CollaborationProposal,
    CollaborationResponse,
    JointValidation,
    InfoExchange,
    ConflictResolution,
    FederationStatus,
}

/// Cross-federation message structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMessage {
    /// Unique message ID
    pub id: String,
    
    /// Message type
    pub message_type: MessageType,
    
    /// Source federation ID
    pub source_federation_id: String,
    
    /// Destination federation ID
    pub destination_federation_id: String,
    
    /// Message content (JSON serialized)
    pub content: String,
    
    /// Timestamp when message was created
    pub created_at: u64,
    
    /// Message expiration timestamp
    pub expires_at: Option<u64>,
    
    /// Digital signature from source federation
    pub signature: String,
    
    /// Previous message ID in conversation (if applicable)
    pub previous_message_id: Option<String>,
}

/// Cross-federation protocol adapter
pub struct CrossFederationProtocol {
    /// Local federation ID
    federation_id: String,
    
    /// Federation keypair for signing messages
    keypair: KeyPair,
    
    /// Known federations and their public keys
    federation_keys: HashMap<String, Vec<u8>>,
    
    /// Outgoing message queue
    outgoing_messages: VecDeque<FederationMessage>,
    
    /// Received messages awaiting processing
    incoming_messages: VecDeque<FederationMessage>,
    
    /// Message history by conversation
    message_history: HashMap<String, Vec<FederationMessage>>,
    
    /// Trust levels with other federations (0-100)
    trust_levels: HashMap<String, u8>,
    
    /// Active federations we can communicate with
    active_federations: HashMap<String, Arc<RwLock<Federation>>>,
}

impl CrossFederationProtocol {
    /// Create a new cross-federation protocol instance
    pub fn new(federation_id: String, keypair: KeyPair) -> Self {
        Self {
            federation_id,
            keypair,
            federation_keys: HashMap::new(),
            outgoing_messages: VecDeque::new(),
            incoming_messages: VecDeque::new(),
            message_history: HashMap::new(),
            trust_levels: HashMap::new(),
            active_federations: HashMap::new(),
        }
    }
    
    /// Register a known federation and its public key
    pub fn register_federation(&mut self, federation_id: String, public_key: Vec<u8>, initial_trust: u8) {
        self.federation_keys.insert(federation_id.clone(), public_key);
        self.trust_levels.insert(federation_id, initial_trust);
    }
    
    /// Create a new message to send to another federation
    pub fn create_message(
        &self,
        destination_federation_id: String,
        message_type: MessageType,
        content: String,
        previous_message_id: Option<String>,
        expires_in_seconds: Option<u64>,
    ) -> Result<FederationMessage, CrossFederationError> {
        // Check if we know this federation
        if !self.federation_keys.contains_key(&destination_federation_id) {
            return Err(CrossFederationError::FederationNotFound(destination_federation_id));
        }
        
        let now = chrono::Utc::now().timestamp() as u64;
        let expires_at = expires_in_seconds.map(|s| now + s);
        
        // Create message ID
        let message_id = format!("msg_{}", uuid::Uuid::new_v4());
        
        // Prepare message for signing
        let message_content = format!(
            "{}:{}:{}:{}:{}",
            message_id,
            self.federation_id,
            destination_federation_id,
            content,
            now
        );
        
        // Sign message
        let signature = self.keypair.sign(message_content.as_bytes())
            .map_err(|e| CrossFederationError::ProtocolError(e.to_string()))?;
            
        let signature_hex = hex::encode(signature);
        
        let message = FederationMessage {
            id: message_id,
            message_type,
            source_federation_id: self.federation_id.clone(),
            destination_federation_id,
            content,
            created_at: now,
            expires_at,
            signature: signature_hex,
            previous_message_id,
        };
        
        Ok(message)
    }
    
    /// Queue a message to be sent
    pub fn queue_message(&mut self, message: FederationMessage) {
        // Add to outgoing queue
        self.outgoing_messages.push_back(message.clone());
        
        // Add to message history
        let conversation_id = message.previous_message_id
            .clone()
            .unwrap_or_else(|| message.id.clone());
            
        self.message_history
            .entry(conversation_id)
            .or_insert_with(Vec::new)
            .push(message);
    }
    
    /// Verify an incoming message signature
    pub fn verify_message(&self, message: &FederationMessage) -> Result<bool, CrossFederationError> {
        // Get sender's public key
        let public_key = self.federation_keys
            .get(&message.source_federation_id)
            .ok_or_else(|| CrossFederationError::FederationNotFound(
                message.source_federation_id.clone()
            ))?;
        
        // Check if message has expired
        if let Some(expires_at) = message.expires_at {
            let now = chrono::Utc::now().timestamp() as u64;
            if expires_at < now {
                return Err(CrossFederationError::VerificationFailed(
                    "Message has expired".to_string()
                ));
            }
        }
        
        // Reconstruct message content for verification
        let message_content = format!(
            "{}:{}:{}:{}:{}",
            message.id,
            message.source_federation_id,
            message.destination_federation_id,
            message.content,
            message.created_at
        );
        
        // Decode signature
        let signature = hex::decode(&message.signature)
            .map_err(|_| CrossFederationError::VerificationFailed(
                "Invalid signature format".to_string()
            ))?;
        
        // Create temporary keypair for verification
        let keypair = KeyPair {
            public_key: public_key.clone(),
            private_key: vec![],
            algorithm: Algorithm::Ed25519, // Assuming Ed25519 for signatures
        };
        
        // Verify signature
        match keypair.verify(message_content.as_bytes(), &signature) {
            Ok(true) => Ok(true),
            Ok(false) => Err(CrossFederationError::VerificationFailed(
                "Signature verification failed".to_string()
            )),
            Err(e) => Err(CrossFederationError::ProtocolError(e.to_string())),
        }
    }
    
    /// Receive and process an incoming message
    pub fn receive_message(&mut self, message: FederationMessage) -> Result<(), CrossFederationError> {
        // Verify the message is intended for us
        if message.destination_federation_id != self.federation_id {
            return Err(CrossFederationError::NotAuthorized(
                "Message not intended for this federation".to_string()
            ));
        }
        
        // Verify message signature
        self.verify_message(&message)?;
        
        // Add to incoming queue
        self.incoming_messages.push_back(message.clone());
        
        // Add to message history
        let conversation_id = message.previous_message_id
            .clone()
            .unwrap_or_else(|| message.id.clone());
            
        self.message_history
            .entry(conversation_id)
            .or_insert_with(Vec::new)
            .push(message);
        
        Ok(())
    }
    
    /// Process the next incoming message
    pub async fn process_next_message(&mut self) -> Option<Result<FederationMessage, CrossFederationError>> {
        let message = self.incoming_messages.pop_front()?;
        
        match message.message_type {
            MessageType::ResourceRequest => {
                // Process resource request
                self.handle_resource_request(&message).await
                    .map(|_| message.clone())
                    .map_err(|e| e)
            }
            MessageType::CollaborationProposal => {
                // Process collaboration proposal
                self.handle_collaboration_proposal(&message).await
                    .map(|_| message.clone())
                    .map_err(|e| e)
            }
            MessageType::JointValidation => {
                // Process joint validation
                self.handle_joint_validation(&message).await
                    .map(|_| message.clone())
                    .map_err(|e| e)
            }
            // Handle other message types
            _ => {
                // Default message handling
                Ok(message)
            }
        }.into()
    }
    
    /// Handle resource request message
    async fn handle_resource_request(&mut self, message: &FederationMessage) -> Result<(), CrossFederationError> {
        // Parse request content
        let request: ResourceRequest = serde_json::from_str(&message.content)
            .map_err(|e| CrossFederationError::ProtocolError(format!(
                "Invalid resource request format: {}", e
            )))?;
        
        // Check trust level
        let trust_level = self.trust_levels.get(&message.source_federation_id)
            .cloned()
            .unwrap_or(0);
            
        if trust_level < 50 {
            // Not enough trust to handle this request
            let response = ResourceResponse {
                request_id: request.request_id,
                approved: false,
                reason: Some("Insufficient trust level".to_string()),
                resource_id: None,
                access_conditions: None,
            };
            
            // Create response message
            self.respond_to_message(message, serde_json::to_string(&response).unwrap())?;
            return Ok(());
        }
        
        // TODO: Actual resource handling logic would go here
        let response = ResourceResponse {
            request_id: request.request_id,
            approved: true,
            reason: None,
            resource_id: Some(uuid::Uuid::new_v4().to_string()),
            access_conditions: Some("time_limit:3600".to_string()),
        };
        
        // Create response message
        self.respond_to_message(message, serde_json::to_string(&response).unwrap())?;
        
        Ok(())
    }
    
    /// Handle collaboration proposal
    async fn handle_collaboration_proposal(&mut self, message: &FederationMessage) -> Result<(), CrossFederationError> {
        // Parse proposal content
        let proposal: CollaborationProposal = serde_json::from_str(&message.content)
            .map_err(|e| CrossFederationError::ProtocolError(format!(
                "Invalid collaboration proposal format: {}", e
            )))?;
        
        // Check if we have the federation
        let federation = self.active_federations.get(&self.federation_id)
            .ok_or_else(|| CrossFederationError::FederationNotFound(
                "Local federation not found".to_string()
            ))?;
            
        let fed = federation.read().await;
        
        // Create token for proposal if approved
        let token = format!("collab_{}", uuid::Uuid::new_v4());
        
        let response = CollaborationResponse {
            proposal_id: proposal.proposal_id,
            approved: true,
            token: Some(token),
            start_time: chrono::Utc::now().timestamp() as u64,
            duration: proposal.requested_duration,
            terms: proposal.terms,
        };
        
        // Create response message
        self.respond_to_message(message, serde_json::to_string(&response).unwrap())?;
        
        Ok(())
    }
    
    /// Handle joint validation
    async fn handle_joint_validation(&mut self, message: &FederationMessage) -> Result<(), CrossFederationError> {
        // Parse validation content
        let validation: JointValidation = serde_json::from_str(&message.content)
            .map_err(|e| CrossFederationError::ProtocolError(format!(
                "Invalid joint validation format: {}", e
            )))?;
        
        // Validate hash provided
        let computed_hash = hash(&validation.data);
        let expected_hash = validation.expected_hash;
        
        let response = ValidationResponse {
            validation_id: validation.validation_id,
            confirmed: computed_hash == expected_hash,
            validator_signature: if computed_hash == expected_hash {
                // Sign the hash if it matches
                let signature = self.keypair.sign(computed_hash.as_bytes())
                    .map_err(|e| CrossFederationError::ProtocolError(e.to_string()))?;
                Some(hex::encode(signature))
            } else {
                None
            },
            timestamp: chrono::Utc::now().timestamp() as u64,
        };
        
        // Create response message
        self.respond_to_message(message, serde_json::to_string(&response).unwrap())?;
        
        Ok(())
    }
    
    /// Create and queue a response to a message
    fn respond_to_message(&mut self, original_message: &FederationMessage, content: String) 
        -> Result<FederationMessage, CrossFederationError> 
    {
        let response = self.create_message(
            original_message.source_federation_id.clone(),
            match original_message.message_type {
                MessageType::ResourceRequest => MessageType::ResourceOffer,
                MessageType::CollaborationProposal => MessageType::CollaborationResponse,
                MessageType::JointValidation => MessageType::JointValidation,
                _ => original_message.message_type.clone(),
            },
            content,
            Some(original_message.id.clone()),
            Some(3600), // Default 1 hour expiry
        )?;
        
        self.queue_message(response.clone());
        
        Ok(response)
    }
    
    /// Send all queued outgoing messages
    pub async fn send_pending_messages(&mut self) -> Vec<Result<String, CrossFederationError>> {
        let mut results = Vec::new();
        
        while let Some(message) = self.outgoing_messages.pop_front() {
            // In a real implementation, this would use a network transport layer
            // For now we just simulate successful sending
            results.push(Ok(message.id.clone()));
        }
        
        results
    }
    
    /// Get conversation history by ID
    pub fn get_conversation(&self, conversation_id: &str) -> Option<&Vec<FederationMessage>> {
        self.message_history.get(conversation_id)
    }
    
    /// Update trust level for a federation
    pub fn update_trust_level(&mut self, federation_id: &str, new_level: u8) -> Result<(), CrossFederationError> {
        if !self.federation_keys.contains_key(federation_id) {
            return Err(CrossFederationError::FederationNotFound(federation_id.to_string()));
        }
        
        self.trust_levels.insert(federation_id.to_string(), new_level);
        Ok(())
    }
}

/// Resource request message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceRequest {
    pub request_id: String,
    pub resource_type: String,
    pub quantity: u64,
    pub duration: u64,
    pub purpose: String,
    pub compensation_offer: Option<String>,
}

/// Resource response message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceResponse {
    pub request_id: String,
    pub approved: bool,
    pub reason: Option<String>,
    pub resource_id: Option<String>,
    pub access_conditions: Option<String>,
}

/// Collaboration proposal message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollaborationProposal {
    pub proposal_id: String,
    pub title: String,
    pub description: String,
    pub goals: Vec<String>,
    pub requested_duration: u64,
    pub terms: String,
}

/// Collaboration response message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollaborationResponse {
    pub proposal_id: String,
    pub approved: bool,
    pub token: Option<String>,
    pub start_time: u64,
    pub duration: u64,
    pub terms: String,
}

/// Joint validation message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JointValidation {
    pub validation_id: String,
    pub data: Vec<u8>,
    pub expected_hash: String,
    pub validation_type: String,
}

/// Validation response message content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResponse {
    pub validation_id: String,
    pub confirmed: bool,
    pub validator_signature: Option<String>,
    pub timestamp: u64,
}```

===================
File: ./crates/icn-consensus/src/governance.rs
Size: 6056 bytes
===================
```rs
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use thiserror::Error;
use tokio::sync::RwLock;
use async_trait::async_trait;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProposalData {
    pub id: String,
    pub title: String,
    pub description: String,
    pub creator_did: String,
    pub creation_time: DateTime<Utc>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoteData {
    pub proposal_id: String,
    pub voter_did: String,
    pub approve: bool,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProposalStatus {
    Active,
    Passed,
    Rejected,
    Finalized,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProposalOutcome {
    pub id: String,
    pub status: ProposalStatus,
    pub total_weight: u32,
    pub approval_weight: u32,
    pub finalization_time: DateTime<Utc>,
}

#[derive(Debug, Error)]
pub enum GovernanceError {
    #[error("Invalid proposal: {0}")]
    InvalidProposal(String),
    #[error("Invalid vote: {0}")]
    InvalidVote(String),
    #[error("Proposal not found: {0}")]
    ProposalNotFound(String),
    #[error("Insufficient cooperation score: {0}")]
    InsufficientCooperation(String),
    #[error("Storage error: {0}")]
    StorageError(String),
}

pub struct GovernanceSystem {
    proposals: RwLock<HashMap<String, ProposalData>>,
    votes: RwLock<HashMap<String, Vec<VoteData>>>,
    proof_of_cooperation: RwLock<ProofOfCooperation>,
}

impl GovernanceSystem {
    pub fn new(proof_of_cooperation: ProofOfCooperation) -> Self {
        Self {
            proposals: RwLock::new(HashMap::new()),
            votes: RwLock::new(HashMap::new()),
            proof_of_cooperation: RwLock::new(proof_of_cooperation),
        }
    }

    pub async fn create_proposal(&self, proposal: ProposalData) -> Result<(), GovernanceError> {
        // Verify creator's cooperation score
        let creator_score = self.verify_proof_of_cooperation(&proposal.creator_did).await?;
        if creator_score < 10 { // Minimum score to create proposals
            return Err(GovernanceError::InsufficientCooperation(
                format!("Score {} is below minimum threshold", creator_score)
            ));
        }

        // Store proposal
        let mut proposals = self.proposals.write().await;
        if proposals.contains_key(&proposal.id) {
            return Err(GovernanceError::InvalidProposal("Proposal ID already exists".into()));
        }
        
        proposals.insert(proposal.id.clone(), proposal);
        self.votes.write().await.insert(proposal.id, Vec::new());
        
        Ok(())
    }

    pub async fn cast_vote(&self, vote: VoteData) -> Result<(), GovernanceError> {
        // Verify proposal exists and is active
        let proposals = self.proposals.read().await;
        let proposal = proposals.get(&vote.proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Verify voter's cooperation score
        let voter_score = self.verify_proof_of_cooperation(&vote.voter_did).await?;
        if voter_score == 0 {
            return Err(GovernanceError::InsufficientCooperation(
                "No cooperation score found".into()
            ));
        }

        // Record vote with weight
        let mut votes = self.votes.write().await;
        let proposal_votes = votes.get_mut(&vote.proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(vote.proposal_id.clone()))?;

        // Check for duplicate votes
        if proposal_votes.iter().any(|v| v.voter_did == vote.voter_did) {
            return Err(GovernanceError::InvalidVote("Duplicate vote".into()));
        }

        proposal_votes.push(vote);
        Ok(())
    }

    pub async fn finalize_proposal(&self, proposal_id: &str) -> Result<ProposalOutcome, GovernanceError> {
        let mut proposals = self.proposals.write().await;
        let votes = self.votes.read().await;
        
        let proposal = proposals.get(proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))?;

        let proposal_votes = votes.get(proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))?;

        let mut total_weight = 0u32;
        let mut approval_weight = 0u32;

        // Calculate weighted votes
        for vote in proposal_votes {
            if let Ok(weight) = self.verify_proof_of_cooperation(&vote.voter_did).await {
                total_weight += weight;
                if vote.approve {
                    approval_weight += weight;
                }
            }
        }

        // Determine outcome (require >50% weighted approval)
        let status = if total_weight > 0 && approval_weight * 2 > total_weight {
            ProposalStatus::Passed
        } else {
            ProposalStatus::Rejected
        };

        let outcome = ProposalOutcome {
            id: proposal_id.to_string(),
            status,
            total_weight,
            approval_weight,
            finalization_time: Utc::now(),
        };

        Ok(outcome)
    }

    pub async fn verify_proof_of_cooperation(&self, voter: &str) -> Result<u32, GovernanceError> {
        let poc = self.proof_of_cooperation.read().await;
        
        // Get cooperation score from reputation system
        if let Some(score) = poc.get_cooperation_score(voter).await {
            Ok(score)
        } else {
            Err(GovernanceError::InsufficientCooperation(
                format!("No cooperation score found for {}", voter)
            ))
        }
    }
}

#[async_trait]
pub trait LedgerClient {
    async fn store_proposal(&self, proposal: &ProposalData) -> Result<(), GovernanceError>;
    async fn store_vote(&self, vote: &VoteData) -> Result<(), GovernanceError>;
    async fn store_outcome(&self, outcome: &ProposalOutcome) -> Result<(), GovernanceError>;
}
```

===================
File: ./crates/icn-consensus/src/pbft.rs
Size: 7207 bytes
===================
```rs
use std::collections::{HashMap, HashSet};
use serde::{Serialize, Deserialize};

/// Types of PBFT consensus messages
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageType {
    PrePrepare,
    Prepare,
    Commit,
    ViewChange,
    NewView,
}

/// PBFT consensus message structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusMessage {
    pub message_type: MessageType,
    pub view_number: u64,
    pub sequence_number: u64,
    pub block_hash: String,
    pub sender: String,
    pub signature: String, // Cryptographic signature of message content
}

/// PBFT consensus state
pub struct PbftConsensus {
    pub view_number: u64,
    pub sequence_number: u64,
    pub validators: Vec<String>,
    pub primary_idx: usize,
    pub prepared_msgs: HashMap<String, HashSet<String>>, // block_hash -> set of validators that prepared
    pub committed_msgs: HashMap<String, HashSet<String>>, // block_hash -> set of validators that committed
    pub committed_blocks: HashSet<String>,                // set of committed block hashes
}

impl PbftConsensus {
    pub fn new(validators: Vec<String>) -> Self {
        Self {
            view_number: 0,
            sequence_number: 0,
            validators,
            primary_idx: 0,
            prepared_msgs: HashMap::new(),
            committed_msgs: HashMap::new(),
            committed_blocks: HashSet::new(),
        }
    }

    /// Check if the current node is the primary/leader
    pub fn is_primary(&self, node_id: &str) -> bool {
        if self.validators.is_empty() {
            return false;
        }
        
        let primary_id = &self.validators[self.primary_idx % self.validators.len()];
        primary_id == node_id
    }

    /// Process a consensus message
    pub fn process_message(&mut self, message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // Verify the sender is a validator
        if !self.validators.contains(&message.sender) {
            return Err("Sender is not a validator".to_string());
        }

        // Verify message view number
        if message.view_number != self.view_number {
            return Err(format!(
                "Message view number mismatch: expected {}, got {}",
                self.view_number, message.view_number
            ));
        }

        match message.message_type {
            MessageType::PrePrepare => self.handle_pre_prepare(message),
            MessageType::Prepare => self.handle_prepare(message),
            MessageType::Commit => self.handle_commit(message),
            MessageType::ViewChange => self.handle_view_change(message),
            MessageType::NewView => self.handle_new_view(message),
        }
    }

    /// Handle pre-prepare message from the primary
    fn handle_pre_prepare(&mut self, message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // Verify the sender is the primary
        let expected_primary = &self.validators[self.primary_idx % self.validators.len()];
        if message.sender != *expected_primary {
            return Err("Pre-prepare message not from primary".to_string());
        }

        // Verify sequence number is correct
        if message.sequence_number != self.sequence_number {
            return Err("Incorrect sequence number".to_string());
        }

        // Create a prepare response
        Ok(Some(MessageType::Prepare))
    }

    /// Handle prepare message from validators
    fn handle_prepare(&mut self, message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // Track prepare message
        let prepared = self.prepared_msgs
            .entry(message.block_hash.clone())
            .or_insert_with(HashSet::new());

        prepared.insert(message.sender);

        // Check if we have enough prepare messages
        let prepared_count = prepared.len();
        let needed_count = self.get_quorum_size();

        if prepared_count >= needed_count && !self.is_committed(&message.block_hash) {
            // We can move to commit phase
            return Ok(Some(MessageType::Commit));
        }

        // Not enough prepare messages yet
        Ok(None)
    }

    /// Handle commit message from validators
    fn handle_commit(&mut self, message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // Track commit message
        let committed = self.committed_msgs
            .entry(message.block_hash.clone())
            .or_insert_with(HashSet::new);

        committed.insert(message.sender);

        // Check if we have enough commit messages
        let committed_count = committed.len();
        let needed_count = self.get_quorum_size();

        if committed_count >= needed_count && !self.committed_blocks.contains(&message.block_hash) {
            // Add to committed blocks
            self.committed_blocks.insert(message.block_hash.clone());

            // Move to next sequence
            self.sequence_number += 1;

            // No need for additional message types
            return Ok(None);
        }

        // Not enough commit messages yet
        Ok(None)
    }

    /// Handle view change message
    fn handle_view_change(&mut self, message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // View change logic (simplified)
        // In a real system, this would involve collecting view change messages
        // and transitioning to a new primary when enough messages are received
        self.view_number += 1;
        self.primary_idx = (self.primary_idx + 1) % self.validators.len();

        Ok(Some(MessageType::NewView))
    }

    /// Handle new view message
    fn handle_new_view(&mut self, _message: ConsensusMessage) -> Result<Option<MessageType>, String> {
        // New view confirmation logic
        // In a real system, this would involve more complex confirmation of the new view
        
        // Reset consensus state for new view
        self.prepared_msgs.clear();
        self.committed_msgs.clear();

        Ok(None)
    }

    /// Check if a block is already committed
    pub fn is_committed(&self, block_hash: &str) -> bool {
        self.committed_blocks.contains(block_hash)
    }

    /// Get the appropriate quorum size for BFT
    fn get_quorum_size(&self) -> usize {
        let f = (self.validators.len() - 1) / 3;  // max faulty nodes
        2 * f + 1 // BFT quorum = 2f+1 from total 3f+1
    }

    /// Force a view change (e.g., on timeout)
    pub fn force_view_change(&mut self) {
        self.view_number += 1;
        self.primary_idx = (self.primary_idx + 1) % self.validators.len();
        self.prepared_msgs.clear();
        self.committed_msgs.clear();
    }

    /// Reset sequence counter (for new consensus rounds)
    pub fn reset_sequence(&mut self) {
        self.sequence_number = 0;
        self.prepared_msgs.clear();
        self.committed_msgs.clear();
    }
    
    /// Get the number of validators
    pub fn validator_count(&self) -> usize {
        self.validators.len()
    }
    
    /// Get max faulty nodes this system can tolerate
    pub fn max_faulty_nodes(&self) -> usize {
        (self.validators.len() - 1) / 3
    }
}
```

===================
File: ./crates/icn-consensus/src/proof_of_cooperation.rs
Size: 2335 bytes
===================
```rs
use icn_zk::{ProofOfCooperation, Circuit, verify_proof};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use crate::reputation::{ReputationManager, ReputationInterface};

pub struct BatchVerifier {
    proofs: Vec<ProofOfCooperation<bls12_381::Scalar>>,
}

impl BatchVerifier {
    pub fn new() -> Self {
        Self {
            proofs: Vec::new()
        }
    }

    pub fn add_proof(&mut self, proof: ProofOfCooperation<bls12_381::Scalar>) {
        self.proofs.push(proof);
    }

    pub fn verify_all(&self) -> bool {
        // Placeholder for batch verification logic
        true
    }
}

pub struct ProofOfCooperation {
    reputation_manager: Arc<dyn ReputationInterface>,
    cooperation_scores: RwLock<HashMap<String, u32>>,
}

impl ProofOfCooperation {
    pub fn new(reputation_manager: Arc<dyn ReputationInterface>) -> Self {
        Self {
            reputation_manager,
            cooperation_scores: RwLock::new(HashMap::new()),
        }
    }

    pub async fn get_cooperation_score(&self, did: &str) -> Option<u32> {
        // First check cache
        if let Some(score) = self.cooperation_scores.read().await.get(did) {
            return Some(*score);
        }

        // If not in cache, calculate from reputation
        if let Ok(reputation) = self.reputation_manager.get_reputation(did.to_string(), "governance".to_string()).await {
            let score = self.calculate_score(reputation);
            self.cooperation_scores.write().await.insert(did.to_string(), score);
            Some(score)
        } else {
            None
        }
    }

    fn calculate_score(&self, reputation: i64) -> u32 {
        // Convert reputation to cooperation score (0-100)
        let score = (reputation as f64 / 10.0).max(0.0).min(100.0);
        score as u32
    }

    pub async fn verify_zk_snark_proof(&self, proof: &str) -> Result<bool, String> {
        if !verify_proof(proof) {
            return Err("Invalid zk-SNARK proof".to_string());
        }
        Ok(true)
    }

    pub async fn verify_all_proofs(&self) -> Result<bool, String> {
        for proof in &self.proofs {
            if !self.verify_zk_snark_proof(&proof).await? {
                return Err("One or more zk-SNARK proofs are invalid".to_string());
            }
        }
        Ok(true)
    }
}
```

===================
File: ./crates/icn-consensus/src/round_management.rs
Size: 11216 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{Mutex, RwLock};
use tokio::time::sleep;
use log::{info, warn, debug};
use thiserror::Error;
use crate::pbft::PbftConsensus;
use crate::timeout_handling::TimeoutStrategy;
use icn_types::{Block, BlockHeader};

/// Round states in the consensus process
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RoundState {
    Idle,
    Prepare,
    Commit,
    Finalize,
    ViewChange,
}

/// Error types for round management
#[derive(Error, Debug)]
pub enum RoundError {
    #[error("Round already in progress")]
    RoundInProgress,
    #[error("Invalid round state transition: {0}")]
    InvalidStateTransition(String),
    #[error("Round timeout: {0}")]
    RoundTimeout(String),
    #[error("Invalid block: {0}")]
    InvalidBlock(String),
    #[error("Insufficient participation: {0}")]
    InsufficientParticipation(String),
}

/// Structure to manage consensus rounds
pub struct RoundManager {
    /// Current round number
    pub round_number: u64,
    /// Current round state
    pub state: RoundState,
    /// Timestamp when the current round started
    pub round_start_time: Instant,
    /// Maximum allowed round duration
    pub round_timeout: Duration,
    /// Timeout strategy for rounds
    pub timeout_strategy: TimeoutStrategy,
    /// Current proposed block for this round
    pub current_block: Option<Block>,
    /// History of consensus rounds
    pub round_history: Vec<RoundMetrics>,
    /// PBFT instance for consensus
    pub pbft: Arc<Mutex<PbftConsensus>>,
    /// The identity of this validator
    pub validator_id: String,
    /// Active validator set
    pub validator_set: Vec<String>,
    /// Tracks participation statistics
    pub validator_participation: HashMap<String, ParticipationStats>,
}

/// Statistics about validator participation
pub struct ParticipationStats {
    /// Number of rounds participated in
    pub rounds_participated: u64,
    /// Number of rounds missed
    pub rounds_missed: u64,
    /// Total blocks proposed
    pub blocks_proposed: u64,
    /// Total valid votes cast
    pub valid_votes: u64,
    /// Last seen timestamp
    pub last_seen: Instant,
}

/// Metrics collected for each consensus round
pub struct RoundMetrics {
    /// Round number
    pub round_number: u64,
    /// Round duration in milliseconds
    pub duration_ms: u64,
    /// Number of participating validators
    pub validator_count: usize,
    /// Success or failure status
    pub success: bool,
    /// Block height if successful
    pub block_height: Option<u64>,
    /// Participation rate (0.0 - 1.0)
    pub participation_rate: f64,
}

impl RoundManager {
    /// Create a new round manager
    pub fn new(
        validator_id: String, 
        validator_set: Vec<String>,
        timeout: Duration,
        pbft: Arc<Mutex<PbftConsensus>>,
    ) -> Self {
        let mut validator_participation = HashMap::new();
        
        for validator in &validator_set {
            validator_participation.insert(validator.clone(), ParticipationStats {
                rounds_participated: 0,
                rounds_missed: 0,
                blocks_proposed: 0,
                valid_votes: 0,
                last_seen: Instant::now(),
            });
        }
        
        Self {
            round_number: 0,
            state: RoundState::Idle,
            round_start_time: Instant::now(),
            round_timeout: timeout,
            timeout_strategy: TimeoutStrategy::ExponentialBackoff {
                initial: timeout,
                max_timeout: Duration::from_secs(120),
                factor: 1.5,
            },
            current_block: None,
            round_history: Vec::new(),
            pbft,
            validator_id,
            validator_set,
            validator_participation,
        }
    }
    
    /// Start a new consensus round
    pub async fn start_round(&mut self) -> Result<(), RoundError> {
        if self.state != RoundState::Idle {
            return Err(RoundError::RoundInProgress);
        }
        
        // Update round number and reset state
        self.round_number += 1;
        self.state = RoundState::Prepare;
        self.round_start_time = Instant::now();
        self.current_block = None;
        
        info!("Starting consensus round {}", self.round_number);
        
        // Reset PBFT consensus state
        let mut pbft = self.pbft.lock().await;
        pbft.reset_sequence();
        
        Ok(())
    }
    
    /// Propose a block for the current round
    pub fn propose_block(&mut self, block: Block) -> Result<(), RoundError> {
        if self.state != RoundState::Prepare {
            return Err(RoundError::InvalidStateTransition(
                format!("Cannot propose block in {:?} state", self.state)
            ));
        }
        
        // Store the proposed block
        self.current_block = Some(block);
        
        // Update proposer stats
        if let Some(stats) = self.validator_participation.get_mut(&self.validator_id) {
            stats.blocks_proposed += 1;
            stats.last_seen = Instant::now();
        }
        
        // Transition to commit state
        self.state = RoundState::Commit;
        info!("Block proposed for round {}", self.round_number);
        
        Ok(())
    }
    
    /// Register participation for a validator
    pub fn register_participation(&mut self, validator_id: &str) {
        if let Some(stats) = self.validator_participation.get_mut(validator_id) {
            stats.rounds_participated += 1;
            stats.last_seen = Instant::now();
        }
    }
    
    /// Register a missed round for a validator
    pub fn register_missed_round(&mut self, validator_id: &str) {
        if let Some(stats) = self.validator_participation.get_mut(validator_id) {
            stats.rounds_missed += 1;
        }
    }
    
    /// Register a valid vote from a validator
    pub fn register_vote(&mut self, validator_id: &str) {
        if let Some(stats) = self.validator_participation.get_mut(validator_id) {
            stats.valid_votes += 1;
            stats.last_seen = Instant::now();
        }
    }
    
    /// Finalize the current round
    pub async fn finalize_round(&mut self, success: bool) -> Result<Option<Block>, RoundError> {
        if self.state != RoundState::Commit && self.state != RoundState::ViewChange {
            return Err(RoundError::InvalidStateTransition(
                format!("Cannot finalize round in {:?} state", self.state)
            ));
        }
        
        // Calculate round duration
        let duration_ms = self.round_start_time.elapsed().as_millis() as u64;
        
        // Calculate participation rate
        let participating_validators = self.validator_participation.values()
            .filter(|stats| stats.last_seen.elapsed() < Duration::from_secs(300)) // Active in last 5 minutes
            .count();
            
        let participation_rate = participating_validators as f64 / self.validator_set.len() as f64;
        
        // Record round metrics
        self.round_history.push(RoundMetrics {
            round_number: self.round_number,
            duration_ms,
            validator_count: self.validator_set.len(),
            success,
            block_height: self.current_block.as_ref().map(|b| b.header.height),
            participation_rate,
        });
        
        // Update validator stats for those who didn't participate
        for validator_id in &self.validator_set {
            let stats = self.validator_participation.get_mut(validator_id).unwrap();
            if stats.last_seen.elapsed() > Duration::from_secs(300) {
                stats.rounds_missed += 1;
            }
        }
        
        // Transition back to idle state
        self.state = RoundState::Idle;
        
        // If round was successful, return the finalized block
        let result = if success {
            self.current_block.take()
        } else {
            None
        };
        
        Ok(result)
    }
    
    /// Check if the current round has timed out
    pub fn is_timed_out(&self) -> bool {
        self.round_start_time.elapsed() > self.round_timeout
    }
    
    /// Handle a timeout in the current round
    pub async fn handle_timeout(&mut self) -> Result<(), RoundError> {
        warn!("Round {} timed out after {}ms", 
            self.round_number, 
            self.round_start_time.elapsed().as_millis()
        );
        
        // Transition to view change state
        self.state = RoundState::ViewChange;
        
        // Trigger PBFT view change
        let mut pbft = self.pbft.lock().await;
        pbft.force_view_change();
        
        // Calculate new timeout for next round
        let mut timeout_strategy = std::mem::replace(
            &mut self.timeout_strategy, 
            TimeoutStrategy::Fixed(Duration::from_secs(60))
        );
        let new_timeout = timeout_strategy.next_timeout();
        self.timeout_strategy = timeout_strategy;
        self.round_timeout = new_timeout;
        
        // Finalize the round as failed
        self.finalize_round(false).await?;
        
        Ok(())
    }
    
    /// Run timeout checking in the background
    pub async fn run_timeout_checker(round_manager: Arc<RwLock<RoundManager>>) {
        loop {
            sleep(Duration::from_millis(100)).await;
            
            let is_timed_out = {
                let rm = round_manager.read().await;
                rm.state != RoundState::Idle && rm.is_timed_out()
            };
            
            if is_timed_out {
                let mut rm = round_manager.write().await;
                if let Err(e) = rm.handle_timeout().await {
                    warn!("Error handling timeout: {:?}", e);
                }
            }
        }
    }
    
    /// Get participation score for a validator (0.0-1.0)
    pub fn get_participation_score(&self, validator_id: &str) -> Option<f64> {
        if let Some(stats) = self.validator_participation.get(validator_id) {
            let total_rounds = stats.rounds_participated + stats.rounds_missed;
            if total_rounds > 0 {
                Some(stats.rounds_participated as f64 / total_rounds as f64)
            } else {
                Some(0.0)
            }
        } else {
            None
        }
    }
    
    /// Get the average round duration from history
    pub fn average_round_duration(&self) -> Option<Duration> {
        if self.round_history.is_empty() {
            return None;
        }
        
        let total_ms: u64 = self.round_history.iter().map(|m| m.duration_ms).sum();
        let avg_ms = total_ms / self.round_history.len() as u64;
        
        Some(Duration::from_millis(avg_ms))
    }
    
    /// Get the success rate of rounds from history
    pub fn round_success_rate(&self) -> Option<f64> {
        if self.round_history.is_empty() {
            return None;
        }
        
        let successful_rounds = self.round_history.iter().filter(|m| m.success).count();
        Some(successful_rounds as f64 / self.round_history.len() as f64)
    }
}
```

===================
File: ./crates/icn-consensus/src/sharding.rs
Size: 6606 bytes
===================
```rs
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use serde::{Serialize, Deserialize};
use thiserror::Error;
use uuid::Uuid;
use icn_types::{Transaction, Block, ShardId, NodeId};

/// Config for the shard manager
#[derive(Clone, Debug)]
pub struct ShardConfig {
    pub shard_count: u32,
    pub shard_capacity: u32,
    pub rebalance_threshold: f64,
}

/// Error types for sharding module
#[derive(Error, Debug)]
pub enum ShardingError {
    #[error("Invalid shard configuration: {0}")]
    InvalidConfiguration(String),
    
    #[error("Shard not found: {0}")]
    ShardNotFound(String),
    
    #[error("Transaction not found: {0}")]
    TransactionNotFound(String),
    
    #[error("Node not in shard: {0}")]
    NodeNotInShard(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
}

// Simplified ShardManager for direct integration with ProofOfCooperation
pub struct ShardManager {
    pub config: ShardConfig,
    pub shards: HashMap<u32, Vec<Transaction>>,
    current_shard_id: u32,
}

impl ShardManager {
    pub fn new(config: ShardConfig) -> Self {
        // Initialize empty shards
        let mut shards = HashMap::new();
        for i in 0..config.shard_count {
            shards.insert(i, Vec::new());
        }
        
        Self {
            config,
            shards,
            current_shard_id: 0,
        }
    }
    
    // Assign a transaction to a shard
    pub fn assign_transaction(&mut self, transaction: Transaction) -> u32 {
        // Simple round-robin assignment
        let shard_id = self.current_shard_id;
        
        // Add to shard
        self.shards.entry(shard_id).or_insert_with(Vec::new).push(transaction);
        
        // Move to next shard
        self.current_shard_id = (self.current_shard_id + 1) % self.config.shard_count;
        
        shard_id
    }
    
    // Finalize a shard by creating a block from its transactions
    pub fn finalize_shard(&mut self, shard_id: u32) -> Option<Block> {
        if let Some(transactions) = self.shards.get(&shard_id) {
            if transactions.is_empty() {
                return None;
            }
            
            // Create a block from transactions
            let mut tx_ids = Vec::new();
            let mut tx_hashes = Vec::new();
            
            for tx in transactions {
                tx_ids.push(tx.id.clone());
                tx_hashes.push(tx.hash.clone());
            }
            
            // Create simple hash from transaction hashes
            let hash = format!("{:x}", md5::compute(tx_hashes.join("")));
            
            let block = Block {
                height: 0, // This would be set by blockchain
                hash,
                transactions: tx_ids,
                timestamp: chrono::Utc::now(),
                previous_hash: "".to_string(), // This would be set by blockchain
                shard_id: Some(shard_id),
                metadata: BlockMetadata {
                    consensus_duration_ms: 0, // Will be set later
                    validator_signatures: Vec::new(), // Will be set later
                    reputation_changes: Vec::new(), // Will be set later
                },
            };
            
            // Clear the shard's transactions
            self.shards.insert(shard_id, Vec::new());
            
            Some(block)
        } else {
            None
        }
    }
    
    // Balance load across shards
    pub fn rebalance(&mut self) {
        // Find average load
        let total_transactions: usize = self.shards.values().map(|v| v.len()).sum();
        let avg_load = total_transactions as f64 / self.config.shard_count as f64;
        
        // Identify overloaded and underloaded shards
        let mut overloaded = Vec::new();
        let mut underloaded = Vec::new();
        
        for (id, shard) in &self.shards {
            let load = shard.len() as f64;
            let diff = (load - avg_load) / avg_load;
            
            if diff > self.config.rebalance_threshold {
                overloaded.push(*id);
            } else if diff < -self.config.rebalance_threshold {
                underloaded.push(*id);
            }
        }
        
        // Balance if needed
        if !overloaded.is_empty() && !underloaded.is_empty() {
            let mut i = 0;
            let mut j = 0;
            
            while i < overloaded.len() && j < underloaded.len() {
                let over_id = overloaded[i];
                let under_id = underloaded[j];
                
                if let (Some(over_shard), Some(under_shard)) = 
                    (self.shards.get_mut(&over_id), self.shards.get_mut(&under_id)) {
                    
                    let over_len = over_shard.len();
                    let under_len = under_shard.len();
                    
                    // Calculate how many transactions to move
                    let target_len = ((over_len + under_len) as f64 / 2.0).round() as usize;
                    let to_move = over_len - target_len;
                    
                    // Move transactions
                    if to_move > 0 {
                        let mut transactions_to_move = Vec::new();
                        for _ in 0..to_move {
                            if let Some(tx) = over_shard.pop() {
                                transactions_to_move.push(tx);
                            }
                        }
                        under_shard.extend(transactions_to_move);
                    }
                }
                
                i += 1;
                j += 1;
            }
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    pub consensus_duration_ms: u64,
    pub validator_signatures: Vec<String>,
    pub reputation_changes: Vec<ReputationChange>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReputationChange {
    pub did: String,
    pub change: i64,
    pub reason: String,
}

// Implement these types if they're not defined elsewhere
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: u64,
    pub hash: String,
    pub transactions: Vec<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub previous_hash: String,
    pub shard_id: Option<u32>,
    pub metadata: BlockMetadata,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Transaction {
    pub id: String,
    pub hash: String,
    pub transaction_type: String,
    pub data: String,
}
```

===================
File: ./crates/icn-consensus/src/timeout_handling.rs
Size: 4254 bytes
===================
```rs
use std::time::Duration;
use tokio::time::sleep;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum TimeoutError {
    #[error("Timeout waiting for consensus")]
    ConsensusTimeout,
}

pub struct TimeoutHandling {
    pub timeout: Duration,
    pub max_retries: usize,
    current_retries: usize,
    exponential_backoff: bool,
}

impl TimeoutHandling {
    pub fn new(timeout: Duration) -> Self {
        Self {
            timeout,
            max_retries: 3,
            current_retries: 0,
            exponential_backoff: true,
        }
    }

    /// Creates a new TimeoutHandling instance with advanced options
    pub fn with_options(
        timeout: Duration, 
        max_retries: usize, 
        exponential_backoff: bool
    ) -> Self {
        Self {
            timeout,
            max_retries,
            current_retries: 0,
            exponential_backoff,
        }
    }

    /// Start timeout tracking, returns future that resolves on timeout
    pub async fn start_timeout(&self) -> Result<(), TimeoutError> {
        sleep(self.timeout).await;
        Err(TimeoutError::ConsensusTimeout)
    }

    /// Handle a timeout condition
    pub async fn handle_timeout(&self) -> Result<(), TimeoutError> {
        // Log the timeout
        println!("Timeout occurred in consensus round");

        if self.current_retries >= self.max_retries {
            return Err(TimeoutError::ConsensusTimeout);
        }

        Ok(())
    }

    /// Calculate next timeout duration with exponential backoff if enabled
    pub fn next_timeout(&mut self) -> Duration {
        self.current_retries += 1;
        
        if self.exponential_backoff {
            // Calculate exponential backoff: timeout * 2^retries
            let backoff_factor = 2u32.pow(self.current_retries as u32);
            self.timeout.mul_f32(backoff_factor as f32)
        } else {
            // Use constant timeout
            self.timeout
        }
    }

    /// Reset retry counter
    pub fn reset(&mut self) {
        self.current_retries = 0;
    }
}

/// A helper utility for handling consensus timeouts with different strategies
pub enum TimeoutStrategy {
    /// Simple fixed timeout
    Fixed(Duration),
    
    /// Timeout with exponential backoff
    ExponentialBackoff {
        initial: Duration,
        max_timeout: Duration,
        factor: f32,
    },
    
    /// Adaptive timeout based on network conditions
    Adaptive {
        min: Duration,
        max: Duration,
        current: Duration,
        network_latency: Duration,
    },
}

impl TimeoutStrategy {
    /// Calculate next timeout based on the strategy
    pub fn next_timeout(&mut self) -> Duration {
        match self {
            Self::Fixed(duration) => *duration,
            
            Self::ExponentialBackoff { initial, max_timeout, factor } => {
                let next = initial.mul_f32(*factor);
                *initial = if next < *max_timeout { next } else { *max_timeout };
                *initial
            },
            
            Self::Adaptive { min, max, current, network_latency } => {
                // Adjust timeout based on network latency
                let next = network_latency.mul_f32(2.0);
                *current = if next > *min {
                    if next < *max { next } else { *max }
                } else {
                    *min
                };
                *current
            }
        }
    }
    
    /// Reset the timeout strategy to its initial state
    pub fn reset(&mut self) {
        match self {
            Self::Fixed(_) => {}, // Nothing to reset
            
            Self::ExponentialBackoff { initial, .. } => {
                // Reset to initial value but keep other parameters
                *initial = Duration::from_secs(1); // Example initial value
            },
            
            Self::Adaptive { current, min, .. } => {
                // Reset to minimum value
                *current = *min;
            }
        }
    }
    
    /// Update network latency for adaptive strategy
    pub fn update_network_latency(&mut self, latency: Duration) {
        if let Self::Adaptive { network_latency, .. } = self {
            *network_latency = latency;
        }
    }
}
```

===================
File: ./crates/icn-consensus/src/validation.rs
Size: 377 bytes
===================
```rs
use icn_types::Block;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ValidationError {
    #[error("Invalid block structure: {0}")]
    InvalidBlockStructure(String),
    #[error("Invalid signature: {0}")]
    InvalidSignature(String),
}

pub fn validate_block(block: &Block) -> Result<(), ValidationError> {
    // Placeholder for block validation logic
    Ok(())
}
```

===================
File: ./crates/icn-core/src/did_registry.rs
Size: 2347 bytes
===================
```rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DidDocument {
    pub id: String,
    pub public_key: String,
    pub active: bool,
    pub is_verified: bool,
    pub verification_proof: Option<VerificationProof>,
    pub last_verification: Option<u64>,
}

pub struct DidRegistry {
    ledger: HashMap<String, DidDocument>,
}

impl DidRegistry {
    pub fn new() -> Self {
        DidRegistry {
            ledger: HashMap::new(),
        }
    }
    
    // Create (register) a new DID document
    pub fn register_did(&mut self, did: &str, pub_key: &str) {
        let doc = DidDocument {
            id: did.to_string(),
            public_key: pub_key.to_string(),
            active: true,
            is_verified: false,
            verification_proof: None,
            last_verification: None,
        };
        self.ledger.insert(did.to_string(), doc);
    }
    
    // Read (get) a DID document
    pub fn get_did(&self, did: &str) -> Option<&DidDocument> {
        self.ledger.get(did)
    }
    
    // Update a DID document's public key
    pub fn update_did(&mut self, did: &str, new_pub_key: &str) {
        if let Some(doc) = self.ledger.get_mut(did) {
            doc.public_key = new_pub_key.to_string();
        }
    }
    
    // Deactivate (mark inactive) a DID document
    pub fn deactivate_did(&mut self, did: &str) {
        if let Some(doc) = self.ledger.get_mut(did) {
            doc.active = false;
        }
    }
    
    // Implement proof verification logic using cryptographic libraries.
    // For simplicity, this placeholder verifies that the document exists and is active.
    pub fn verify_proofs(&self, did: &str) -> bool {
        if let Some(doc) = self.get_did(did) {
            // ...insert cryptographic verification logic here...
            doc.active
        } else {
            false
        }
    }

    pub fn verify_did(&mut self, did: &str, proof: VerificationProof) -> Result<bool, String> {
        if let Some(doc) = self.ledger.get_mut(did) {
            let mut did_instance = DID::new(doc.id.clone(), Algorithm::Secp256k1);
            did_instance.verify_sybil_resistance(proof)
                .map_err(|e| e.to_string())
        } else {
            Err("DID not found".to_string())
        }
    }
}```

===================
File: ./crates/icn-core/src/genesis.rs
Size: 1127 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use std::collections::HashSet;

#[derive(Debug, Serialize, Deserialize)]
pub struct GenesisConfig {
    pub timestamp: u64,
    pub initial_validators: HashSet<ValidatorInfo>,
    pub governance_params: GovernanceParams,
}

#[derive(Debug, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub struct ValidatorInfo {
    pub did: String,
    pub coop_id: String,
    pub public_key: String,
    pub stake: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GovernanceParams {
    pub min_validators: u32,
    pub max_validators_per_coop: u32,
    pub election_period: u64,
}

impl GenesisConfig {
    pub fn new_testnet() -> Self {
        Self {
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            initial_validators: HashSet::new(),
            governance_params: GovernanceParams {
                min_validators: 4,
                max_validators_per_coop: 2,
                election_period: 40320, // ~7 days with 15s blocks
            },
        }
    }
}
```

===================
File: ./crates/icn-core/src/governance.rs
Size: 2919 bytes
===================
```rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum ProposalState {
    Open,
    Closed,
    Finalized,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Proposal {
    pub id: String,
    pub description: String,
    pub state: ProposalState,
    pub votes: Vec<Vote>,
    pub final_result: Option<bool>, // true if accepted, false if rejected
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Vote {
    pub voter: String,
    pub approve: bool,
}

pub struct GovernanceManager {
    pub proposals: Vec<Proposal>,
}

impl GovernanceManager {
    pub fn new() -> Self {
        GovernanceManager { proposals: Vec::new() }
    }

    pub fn create_proposal(&mut self, id: String, description: String) -> Proposal {
        let proposal = Proposal {
            id: id.clone(),
            description,
            state: ProposalState::Open,
            votes: Vec::new(),
            final_result: None,
        };
        self.proposals.push(proposal.clone());
        proposal
    }

    pub fn cast_vote(&mut self, proposal_id: &str, vote: Vote) -> Result<(), String> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id);
        if let Some(prop) = proposal {
            if prop.state != ProposalState::Open {
                return Err("Voting is closed for this proposal".into());
            }
            if prop.votes.iter().any(|v| v.voter == vote.voter) {
                return Err("Voter has already voted".into());
            }
            // Basic role-based check: only DID-holding members allowed
            if !vote.voter.starts_with("did:") {
                return Err("Voter is not a valid DID holder".into());
            }
            prop.votes.push(vote);
            Ok(())
        } else {
            Err("Proposal not found".into())
        }
    }

    pub fn finalize_proposal(&mut self, proposal_id: &str) -> Result<bool, String> {
        let proposal = self.proposals.iter_mut().find(|p| p.id == proposal_id);
        if let Some(prop) = proposal {
            if prop.state != ProposalState::Open {
                return Err("Proposal voting already closed".into());
            }
            prop.state = ProposalState::Closed;
            let total_votes = prop.votes.len();
            if total_votes == 0 {
                prop.final_result = Some(false);
                prop.state = ProposalState::Finalized;
                return Ok(false);
            }
            let votes_for = prop.votes.iter().filter(|v| v.approve).count();
            // Threshold: proposal accepted if more than 50% approvals.
            let accepted = votes_for > total_votes / 2;
            prop.final_result = Some(accepted);
            prop.state = ProposalState::Finalized;
            Ok(accepted)
        } else {
            Err("Proposal not found".into())
        }
    }
}
```

===================
File: ./crates/icn-core/src/transactions.rs
Size: 4228 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use std::collections::HashSet;

#[derive(Debug, Serialize, Deserialize)]
pub enum Transaction {
    CoopResource(ResourceTransaction),
    Governance(GovernanceTransaction),
    ValidatorElection(ElectionTransaction),
    DidRegistry(DidRegistryTransaction),
    AttestMembership(AttestMembershipTransaction),
    MutualCredit(MutualCreditTransaction),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceTransaction {
    pub resource_id: String,
    pub operation: ResourceOperation,
    pub metadata: ResourceMetadata,
    pub did_proof: DidProof,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ResourceMetadata {
    pub storage_type: StorageType,
    pub content_hash: String,
    pub size: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum StorageType {
    OnChain,
    IPFS(String),
    Filecoin(String),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidProof {
    pub did: String,
    pub signature: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum GovernanceTransaction {
    SubmitProposal(VoteProposal),
    CastVote(Vote),
    FinalizeProposal(String), // proposal_id
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StorageReference {
    pub location: StorageType,
    pub metadata: ResourceMetadata,
    pub access_control: AccessControl,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccessControl {
    pub owner_did: String,
    pub allowed_coops: HashSet<String>,
    pub permissions: Permissions,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DidRegistryTransaction {
    pub registry_data: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AttestMembershipTransaction {
    pub member_did: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MutualCreditTransaction {
    pub sender_did: String,
    pub receiver_did: String,
    pub amount: i64, // positive value; sender’s balance decreases and receiver’s increases
    pub signature: String,
    pub timestamp: u64,
}

impl Transaction {
    pub fn verify_did_auth(&self) -> Result<bool, AuthError> {
        match self {
            Transaction::CoopResource(tx) => Self::verify_did_signature(
                &tx.did_proof.did,
                &tx.did_proof.signature,
                &tx.resource_id
            ),
            Transaction::Governance(tx) => match tx {
                GovernanceTransaction::SubmitProposal(proposal) => {
                    // Check DID verification status before allowing governance actions
                    let did_registry = DidRegistry::new();
                    if let Some(did_doc) = did_registry.get_did(&proposal.initiator_did) {
                        if !did_doc.is_verified {
                            return Err(AuthError("DID not verified for governance actions".into()));
                        }
                    }
                    Self::verify_did_signature(
                        &proposal.initiator_did,
                        &proposal.signature,
                        &proposal.proposal_id
                    )
                },
                // ... other governance verification cases
            },
            Transaction::ValidatorElection(tx) => {
                // ... validator election verification
                Ok(true)
            }
            Transaction::DidRegistry(did_tx) => {
                // Perform registry-specific DID verification
                Self::verify_did_signature("did:example", "signature", &did_tx.registry_data)
            }
            Transaction::AttestMembership(tx) => {
                Self::verify_did_signature(&tx.member_did, "zk_signature", "membership_claim")
            }
            Transaction::MutualCredit(tx) => {
                Self::verify_did_signature(&tx.sender_did, &tx.signature, &tx.receiver_did)
            },
        }
    }

    fn verify_did_signature(did: &str, signature: &str, message: &str) -> Result<bool, AuthError> {
        // Implement DID signature verification using did:key or did:web
        // This is a placeholder for the actual verification logic
        Ok(true)
    }
}

#[derive(Debug)]
pub struct AuthError(String);
```

===================
File: ./crates/icn-core/src/verifiable_credentials.rs
Size: 4743 bytes
===================
```rs
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerifiableCredential {
    pub credential_type: String,
    pub issuer_did: String,
    pub subject_did: String,
    pub issuance_date: String,
    pub expiration_date: Option<String>,
    pub credential_status: Option<CredentialStatus>,
    pub credential_schema: Option<String>,
    pub proof: Proof,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialStatus {
    pub id: String,
    pub type_: String,
    pub status: String,
    pub status_date: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub type_: String,
    pub created: String,
    pub proof_purpose: String,
    pub verification_method: String,
    pub jws: String,
}

#[derive(Debug)]
pub enum VerificationError {
    InvalidSignature,
    ExpiredCredential,
    RevokedCredential,
    MalformedCredential,
    UnknownIssuer,
}

impl VerifiableCredential {
    pub fn new(
        credential_type: String,
        issuer_did: String,
        subject_did: String,
        proof: Proof,
    ) -> Self {
        Self {
            credential_type,
            issuer_did,
            subject_did,
            issuance_date: Utc::now().to_rfc3339(),
            expiration_date: None,
            credential_status: None,
            credential_schema: None,
            proof,
        }
    }
    
    pub fn is_valid(&self) -> bool {
        // Check if credential is expired
        if let Some(expiry_date) = &self.expiration_date {
            if let Ok(expiry) = DateTime::parse_from_rfc3339(expiry_date) {
                // Use explicit type conversion instead of .into()
                if Utc::now() > expiry.with_timezone(&Utc) {
                    return false;
                }
            } else {
                return false; // Could not parse expiry date
            }
        }
        
        // Check if credential is revoked
        if let Some(status) = &self.credential_status {
            if status.status == "revoked" {
                return false;
            }
        }
        
        // In a real implementation, we would also verify the signature
        // using the issuer's public key
        
        true
    }
    
    pub fn verify(&self, _trusted_issuers: &[String]) -> Result<bool, VerificationError> {
        if !self.is_valid() {
            if let Some(expiry_date) = &self.expiration_date {
                if let Ok(expiry) = DateTime::parse_from_rfc3339(expiry_date) {
                    // Use explicit type conversion instead of .into()
                    if Utc::now() > expiry.with_timezone(&Utc) {
                        return Err(VerificationError::ExpiredCredential);
                    }
                }
            }
            
            if let Some(status) = &self.credential_status {
                if status.status == "revoked" {
                    return Err(VerificationError::RevokedCredential);
                }
            }
            
            return Err(VerificationError::MalformedCredential);
        }
        
        // In a real implementation, this would verify the signature using the 
        // issuer's public key from a trusted source
        
        Ok(true)
    }
}

pub struct CredentialManager;

impl CredentialManager {
    pub async fn verify_credential(&self, credential: &VerifiableCredential) -> Result<bool, String> {
        if let Some(expiry) = &credential.expiration_date {
            // Convert expiry to Utc for comparison by borrowing the string
            let expiry_utc: DateTime<Utc> = DateTime::parse_from_rfc3339(expiry)
                .map_err(|_| "Invalid expiry date format".to_string())?
                .with_timezone(&Utc);
            if Utc::now() > expiry_utc {
                return Ok(false);
            }
        }
        Ok(true)
    }

    pub async fn verify_presentation(&self, presentation: &VerifiablePresentation) -> Result<bool, String> {
        for credential in &presentation.verifiable_credentials {
            if let Some(expiry) = &credential.expiration_date {
                // Convert expiry to Utc for comparison by borrowing the string
                let expiry_utc: DateTime<Utc> = DateTime::parse_from_rfc3339(expiry)
                    .map_err(|_| "Invalid expiry date format".to_string())?
                    .with_timezone(&Utc);
                if Utc::now() > expiry_utc {
                    return Ok(false);
                }
            }
        }
        Ok(true)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerifiablePresentation {
    pub verifiable_credentials: Vec<VerifiableCredential>,
}```

===================
File: ./crates/icn-core/src/vm/contract.rs
Size: 997 bytes
===================
```rs
use crate::vm::opcode::OpCode;
use crate::vm::cooperative_metadata::CooperativeMetadata;
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Contract {
    pub id: String,
    pub code: Vec<OpCode>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}

impl Contract {
    pub fn new(code: Vec<OpCode>, metadata: CooperativeMetadata) -> Self {
        Self {
            id: generate_contract_id(),
            code,
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: metadata,
            version: "1.0.0".to_string(),
            dependencies: Vec::new(),
            permissions: Vec::new(),
        }
    }
}

fn generate_contract_id() -> String {
    use rand::{thread_rng, Rng};
    let mut rng = thread_rng();
    format!("contract-{}", rng.gen::<u64>())
}```

===================
File: ./crates/icn-core/src/vm/cooperative_metadata.rs
Size: 480 bytes
===================
```rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CooperativeMetadata {
    pub resource_impact: ResourceImpact,
    pub contract_version: Option<String>,
    pub creator: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ResourceImpact {
    pub cpu: u32,
    pub memory: u32,
    pub bandwidth: u32,
}```

===================
File: ./crates/icn-core/src/vm/opcode.rs
Size: 439 bytes
===================
```rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    
    // Stack
    Push(i64),
    Pop,
    Dup,
    Swap,
    
    // Memory
    Load,
    Store,
    
    // Control Flow
    Jump,
    JumpIf,
    Call,
    Return,
    
    // System
    Log,
    Halt,
    EmitEvent,
    GetTimestamp,
    GetCaller,
}```

===================
File: ./crates/icn-core/src/vm/runtime.rs
Size: 1438 bytes
===================
```rs
use std::collections::HashMap;
use async_trait::async_trait;
use icn_types::{Block, Transaction, RuntimeError, ExecutionError, RuntimeInterface, ContractInput, ExecutionContext};

pub struct RuntimeManager {
    max_instructions: u64,
    memory_limit: usize,
    execution_context: HashMap<String, ExecutionContext>,
}

impl RuntimeManager {
    pub fn new() -> Self {
        Self {
            max_instructions: 10000,
            memory_limit: 1024 * 1024, // 1MB
            execution_context: HashMap::new(),
        }
    }

    pub fn with_config(max_instructions: u64, memory_limit: usize) -> Self {
        Self {
            max_instructions,
            memory_limit,
            execution_context: HashMap::new(),
        }
    }
}

#[async_trait]
impl RuntimeInterface for RuntimeManager {
    async fn execute_transaction(&self, _transaction: &Transaction) -> Result<(), RuntimeError> {
        // Placeholder implementation
        Ok(())
    }
    
    async fn execute_block(&self, _block: &Block) -> Result<(), RuntimeError> {
        // Placeholder implementation
        Ok(())
    }

    async fn execute_contract(&self, _input: ContractInput) -> Result<Vec<u8>, ExecutionError> {
        // Placeholder implementation
        Ok(Vec::new())
    }

    async fn get_contract_state(&self, _contract_id: &str) -> Result<Vec<u8>, ExecutionError> {
        // Placeholder implementation  
        Ok(Vec::new())
    }
}
```

===================
File: ./crates/icn-core/src/vm/vm.rs
Size: 4366 bytes
===================
```rs
use crate::vm::contract::Contract;
use crate::vm::opcode::OpCode;
use std::collections::VecDeque;
use std::error::Error;
use std::fmt;

#[derive(Debug)]
pub enum VMError {
    StackUnderflow,
    InvalidOpCode,
    DivisionByZero,
    ExecutionLimit,
    MemoryExceeded,
}

impl Error for VMError {}

impl fmt::Display for VMError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            VMError::StackUnderflow => write!(f, "Stack underflow"),
            VMError::InvalidOpCode => write!(f, "Invalid opcode"),
            VMError::DivisionByZero => write!(f, "Division by zero"),
            VMError::ExecutionLimit => write!(f, "Execution limit reached"),
            VMError::MemoryExceeded => write!(f, "Memory limit exceeded"),
        }
    }
}

pub struct VM {
    stack: VecDeque<i64>,
    max_stack_size: usize,
    max_instructions: u64,
}

impl VM {
    pub fn new() -> Self {
        Self {
            stack: VecDeque::new(),
            max_stack_size: 1024,
            max_instructions: 10000,
        }
    }
    
    // Execute a contract and return the final result (value on top of stack)
    pub fn execute(&self, contract: &Contract) -> Result<i64, Box<dyn Error>> {
        let mut stack = VecDeque::with_capacity(self.max_stack_size);
        let mut instruction_count = 0;
        
        for op in &contract.code {
            instruction_count += 1;
            if instruction_count > self.max_instructions {
                return Err(Box::new(VMError::ExecutionLimit));
            }
            
            match op {
                OpCode::Push(val) => {
                    if stack.len() >= self.max_stack_size {
                        return Err(Box::new(VMError::MemoryExceeded));
                    }
                    stack.push_back(*val);
                },
                OpCode::Pop => {
                    if stack.is_empty() {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    stack.pop_back();
                },
                OpCode::Add => {
                    if stack.len() < 2 {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    let b = stack.pop_back().unwrap();
                    let a = stack.pop_back().unwrap();
                    stack.push_back(a + b);
                },
                OpCode::Sub => {
                    if stack.len() < 2 {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    let b = stack.pop_back().unwrap();
                    let a = stack.pop_back().unwrap();
                    stack.push_back(a - b);
                },
                OpCode::Mul => {
                    if stack.len() < 2 {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    let b = stack.pop_back().unwrap();
                    let a = stack.pop_back().unwrap();
                    stack.push_back(a * b);
                },
                OpCode::Div => {
                    if stack.len() < 2 {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    let b = stack.pop_back().unwrap();
                    if b == 0 {
                        return Err(Box::new(VMError::DivisionByZero));
                    }
                    let a = stack.pop_back().unwrap();
                    stack.push_back(a / b);
                },
                OpCode::Mod => {
                    if stack.len() < 2 {
                        return Err(Box::new(VMError::StackUnderflow));
                    }
                    let b = stack.pop_back().unwrap();
                    if b == 0 {
                        return Err(Box::new(VMError::DivisionByZero));
                    }
                    let a = stack.pop_back().unwrap();
                    stack.push_back(a % b);
                },
                // For simplicity, we're implementing only the opcodes needed for our test
                _ => {
                    return Err(Box::new(VMError::InvalidOpCode));
                }
            }
        }
        
        // Return the top value on the stack, or 0 if stack is empty
        Ok(stack.pop_back().unwrap_or(0))
    }
}```

===================
File: ./crates/icn-dsl/src/tests.rs
Size: 2403 bytes
===================
```rs
use super::*;

#[test]
fn test_parse_validation_rules() {
    let input = r#"
        validation:
          pre_checks:
            - balance >= 100: require_minimum_balance
            - reputation > 50: check_reputation
          post_checks:
            - total_supply < 1000000: ensure_supply_cap
          state_validation:
            current: "PENDING"
            expected: "APPROVED"
            transition: "PENDING->APPROVED"
    "#;

    let (_, ast) = CoopLangAST::parse(input).unwrap();
    let validation = ast.validation.unwrap();
    
    assert_eq!(validation.pre_checks.len(), 2);
    assert_eq!(validation.post_checks.len(), 1);
    assert!(validation.state_validation.is_some());
}

#[test]
fn test_bytecode_generation() {
    let ast = CoopLangAST {
        validation: Some(ValidationNode {
            pre_checks: vec![
                Check {
                    condition: "balance >= 100".to_string(),
                    action: "require_minimum_balance".to_string(),
                }
            ],
            post_checks: vec![],
            state_validation: None,
            resource_checks: None,
            custom_merge: None,
        }),
        governance: None,
        reputation: None,
        marketplace: None,
        federation: None,
        logging: None,
    };

    let bytecode = compile_to_icvm(&ast);
    
    // Verify bytecode structure
    assert_eq!(&bytecode[0..4], b"ICVM"); // Magic bytes
    assert_eq!(bytecode[4], 0x01); // Version
    assert_eq!(bytecode[5], 0x01); // Validation section
    assert_eq!(bytecode[6], 0x01); // One pre-check
}

#[test]
fn test_validation_rule_execution() {
    let runtime = RuntimeManager::new();
    let context = ExecutionContext::default();
    
    let validation = ValidationNode {
        pre_checks: vec![
            Check {
                condition: "balance >= 100".to_string(),
                action: "require_minimum_balance".to_string(),
            }
        ],
        post_checks: vec![],
        state_validation: Some(StateValidation {
            current: Some("PENDING".to_string()),
            expected: Some("APPROVED".to_string()),
            transition: Some("PENDING->APPROVED".to_string()),
        }),
        resource_checks: None,
        custom_merge: None,
    };

    let result = runtime.execute_validation_rules(&validation, &context);
    assert!(result.is_ok());
}
```

===================
File: ./crates/icn-federation/src/cross_federation.rs
Size: 25731 bytes
===================
```rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;
use chrono::Utc;

use crate::{
    Federation, FederationError, ResourceManager,
    ResourcePool, FederationResourcePool, FederationAccessControl
};

use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};
use thiserror::Error;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;
use icn_types::FederationId;
use icn_crypto::KeyPair;

/// Represents a cross-federation resource sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceSharingAgreement {
    pub id: String,
    pub source_federation_id: String,
    pub target_federation_id: String,
    pub resource_type: String,
    pub amount: u64,
    pub start_time: u64,
    pub end_time: Option<u64>,
    pub terms: String,
    pub status: SharingAgreementStatus,
    pub usage_metrics: ResourceUsageMetrics,
    pub min_reputation_score: i64,
    pub approval_signatures: HashMap<String, String>, // DID -> signature
}

/// Status of a resource sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SharingAgreementStatus {
    Proposed,
    Active,
    Expired,
    Terminated,
    Disputed,
}

/// Metrics for tracking resource usage in a sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUsageMetrics {
    pub total_allocated: u64,
    pub total_used: u64,
    pub last_activity: u64,
}

/// Error types specific to cross-federation operations
#[derive(Debug, thiserror::Error)]
pub enum CrossFederationError {
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Unauthorized federation: {0}")]
    UnauthorizedFederation(String),
    
    #[error("Insufficient reputation: required {required}, actual {actual}")]
    InsufficientReputation { required: i64, actual: i64 },
    
    #[error("Insufficient resources: requested {requested}, available {available}")]
    InsufficientResources { requested: u64, available: u64 },
    
    #[error("Invalid agreement: {0}")]
    InvalidAgreement(String),
    
    #[error("Resource not found: {0}")]
    ResourceNotFound(String),
    
    #[error("Agreement already exists: {0}")]
    AgreementAlreadyExists(String),
}

/// Manages cross-federation resource sharing
pub struct CrossFederationManager {
    agreements: RwLock<HashMap<String, ResourceSharingAgreement>>,
    resource_manager: Arc<dyn ResourceManager>,
}

impl CrossFederationManager {
    /// Create a new CrossFederationManager
    pub fn new(resource_manager: Arc<dyn ResourceManager>) -> Self {
        Self {
            agreements: RwLock::new(HashMap::new()),
            resource_manager,
        }
    }

    /// Propose a new resource sharing agreement
    pub async fn propose_sharing_agreement(
        &self,
        source_federation: &Federation,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        duration_seconds: Option<u64>,
        terms: String,
        min_reputation_score: i64,
    ) -> Result<String, FederationError> {
        // Verify the source federation has the requested resource
        let has_resource = source_federation.resources
            .get(&resource_type)
            .map(|pool| pool.available_amount >= amount)
            .unwrap_or(false);
        
        if !has_resource {
            return Err(FederationError::ResourceError(
                format!("Insufficient resources: {}", resource_type)
            ));
        }
        
        // Generate agreement ID
        let agreement_id = format!("share_agreement_{}", uuid::Uuid::new_v4());
        
        // Create agreement
        let now = Utc::now().timestamp() as u64;
        let end_time = duration_seconds.map(|duration| now + duration);
        
        let agreement = ResourceSharingAgreement {
            id: agreement_id.clone(),
            source_federation_id: source_federation.id.clone(),
            target_federation_id,
            resource_type,
            amount,
            start_time: now,
            end_time,
            terms,
            status: SharingAgreementStatus::Proposed,
            usage_metrics: ResourceUsageMetrics {
                total_allocated: 0,
                total_used: 0,
                last_activity: now,
            },
            min_reputation_score,
            approval_signatures: HashMap::new(),
        };
        
        // Store the agreement
        let mut agreements = self.agreements.write().await;
        agreements.insert(agreement_id.clone(), agreement);
        
        Ok(agreement_id)
    }

    /// Accept a proposed resource sharing agreement
    pub async fn accept_sharing_agreement(
        &self,
        agreement_id: &str,
        target_federation: &Federation,
        signature: String,
        signer_did: &str,
    ) -> Result<(), FederationError> {
        let mut agreements = self.agreements.write().await;
        
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| FederationError::NotFound(format!("Agreement not found: {}", agreement_id)))?;
        
        // Verify the agreement is for the correct target federation
        if agreement.target_federation_id != target_federation.id {
            return Err(FederationError::Unauthorized(
                "Federation is not the target of this agreement".to_string()
            ));
        }
        
        // Verify the agreement is still in proposed state
        if agreement.status != SharingAgreementStatus::Proposed {
            return Err(FederationError::InvalidState(
                format!("Agreement is not in proposed state: {:?}", agreement.status)
            ));
        }
        
        // Add signature
        agreement.approval_signatures.insert(signer_did.to_string(), signature);
        
        // If we have sufficient signatures, update status to active
        if agreement.approval_signatures.len() >= 1 { // Simplistic; in production could require multiple signatures
            agreement.status = SharingAgreementStatus::Active;
            
            // Log the acceptance in federation's audit log
            // (This would be implemented based on the Federation struct's audit capabilities)
        }
        
        Ok(())
    }

    /// Allocate resources from a sharing agreement
    pub async fn allocate_shared_resource(
        &self,
        agreement_id: &str,
        requester_did: &str,
        requester_federation: &Federation,
        amount: u64,
    ) -> Result<String, FederationError> {
        // Find the agreement
        let mut agreements = self.agreements.write().await;
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| FederationError::NotFound(format!("Agreement not found: {}", agreement_id)))?;
        
        // Verify agreement is active
        if agreement.status != SharingAgreementStatus::Active {
            return Err(FederationError::InvalidState(
                format!("Agreement is not active: {:?}", agreement.status)
            ));
        }
        
        // Verify federation is the target
        if agreement.target_federation_id != requester_federation.id {
            return Err(FederationError::Unauthorized(
                "Federation is not the target of this agreement".to_string()
            ));
        }
        
        // Check if amount is available (comparing against the agreement's allocation)
        let available = agreement.amount - agreement.usage_metrics.total_allocated;
        if amount > available {
            return Err(FederationError::ResourceError(
                format!("Insufficient resources in sharing agreement: requested {}, available {}", amount, available)
            ));
        }
        
        // Update the usage metrics
        agreement.usage_metrics.total_allocated += amount;
        agreement.usage_metrics.last_activity = Utc::now().timestamp() as u64;
        
        // Allocate the resource via the resource manager
        let allocation_result = self.resource_manager.allocate_resources(
            crate::ResourceAllocation {
                resource_type: agreement.resource_type.clone(),
                amount,
                recipient: requester_did.to_string(),
            }
        ).await;
        
        match allocation_result {
            Ok(_) => {
                // Generate allocation ID
                let allocation_id = format!("shared_alloc_{}_{}", agreement_id, uuid::Uuid::new_v4());
                Ok(allocation_id)
            },
            Err(e) => {
                // If allocation fails, revert the metrics update
                agreement.usage_metrics.total_allocated -= amount;
                Err(FederationError::ResourceError(e))
            }
        }
    }

    /// Release resources back to the sharing agreement
    pub async fn release_shared_resource(
        &self,
        agreement_id: &str,
        allocation_id: &str,
        amount: u64,
    ) -> Result<(), FederationError> {
        let mut agreements = self.agreements.write().await;
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| FederationError::NotFound(format!("Agreement not found: {}", agreement_id)))?;
        
        // Update metrics 
        agreement.usage_metrics.total_used += amount;
        agreement.usage_metrics.last_activity = Utc::now().timestamp() as u64;
        
        // Release through resource manager
        self.resource_manager.release_resources(&agreement.resource_type, amount).await
            .map_err(|e| FederationError::ResourceError(e))
    }

    /// Terminate a sharing agreement
    pub async fn terminate_sharing_agreement(
        &self,
        agreement_id: &str,
        federation_id: &str,
        reason: &str,
    ) -> Result<(), FederationError> {
        let mut agreements = self.agreements.write().await;
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| FederationError::NotFound(format!("Agreement not found: {}", agreement_id)))?;
        
        // Verify federation is involved in the agreement
        if agreement.source_federation_id != federation_id && agreement.target_federation_id != federation_id {
            return Err(FederationError::Unauthorized(
                "Federation is not involved in this agreement".to_string()
            ));
        }
        
        // Update status
        agreement.status = SharingAgreementStatus::Terminated;
        
        // In a more complex implementation:
        // 1. Release any remaining allocations
        // 2. Create a dispute if termination is contested
        // 3. Log the termination with the reason
        
        Ok(())
    }

    /// Get a specific sharing agreement
    pub async fn get_sharing_agreement(&self, agreement_id: &str) -> Option<ResourceSharingAgreement> {
        let agreements = self.agreements.read().await;
        agreements.get(agreement_id).cloned()
    }

    /// Get all sharing agreements for a federation
    pub async fn get_federation_agreements(&self, federation_id: &str) -> Vec<ResourceSharingAgreement> {
        let agreements = self.agreements.read().await;
        agreements.values()
            .filter(|a| a.source_federation_id == federation_id || a.target_federation_id == federation_id)
            .cloned()
            .collect()
    }

    /// Create a federation resource pool configured for cross-federation sharing
    pub async fn create_sharing_resource_pool(
        &self,
        federation_id: String,
        allowed_federations: Vec<String>,
        min_reputation: i64,
        max_allocation_per_federation: u64,
    ) -> Result<FederationResourcePool, FederationError> {
        // Create access control for the resource pool
        let access_control = FederationAccessControl {
            allowed_federations,
            min_reputation,
            max_allocation_per_federation,
        };
        
        // Create the resource pool
        let pool = FederationResourcePool {
            federation_id: federation_id.clone(),
            resources: HashMap::new(),
            access_control,
        };
        
        Ok(pool)
    }
}

/// Error types for cross-federation operations
#[derive(Error, Debug)]
pub enum CrossFederationError {
    #[error("Federation not found: {0}")]
    FederationNotFound(FederationId),
    #[error("Unauthorized federation access: {0}")]
    UnauthorizedAccess(FederationId),
    #[error("Message validation failed: {0}")]
    MessageValidationFailed(String),
    #[error("Communication error: {0}")]
    CommunicationError(String),
    #[error("Cryptographic error: {0}")]
    CryptoError(String),
}

/// Types of cross-federation messages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    /// Request to initiate collaboration between federations
    CollaborationRequest,
    /// Response to a collaboration request
    CollaborationResponse,
    /// Resource sharing proposal between federations
    ResourceSharingProposal,
    /// Notification of resource usage
    ResourceUsageUpdate,
    /// Dispute raised between federations
    DisputeNotification,
    /// Governance proposal that affects multiple federations
    GovernanceProposal,
    /// Vote on a cross-federation proposal
    FederationVote,
    /// Generic notification or update
    Notification,
}

/// A secure message exchanged between federations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossFederationMessage {
    /// Unique identifier for this message
    pub id: String,
    /// Sender federation ID
    pub sender: FederationId,
    /// Recipient federation ID 
    pub recipient: FederationId,
    /// Type of message
    pub message_type: MessageType,
    /// Message content in encrypted format
    pub encrypted_content: Vec<u8>,
    /// Time the message was created
    pub timestamp: DateTime<Utc>,
    /// Digital signature of the message content
    pub signature: String,
    /// Threshold required for multi-signature messages (optional)
    pub threshold: Option<u32>,
    /// Additional signatures for multi-signature messages (optional)
    pub additional_signatures: Option<HashMap<String, String>>,
    /// References to related messages
    pub references: Vec<String>,
    /// Time-to-live in seconds
    pub ttl: u64,
}

/// Status of a message
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageStatus {
    /// Message has been sent but not yet processed
    Pending,
    /// Message has been delivered to the recipient
    Delivered,
    /// Message has been processed by the recipient
    Processed,
    /// Message handling is waiting for additional actions
    Waiting,
    /// Message has failed to be delivered or processed
    Failed,
    /// Message has expired
    Expired,
}

/// Manager for cross-federation communication
pub struct CrossFederationMessenger {
    /// Federation ID of this instance
    federation_id: FederationId,
    /// Cryptographic key pair for message signing
    key_pair: KeyPair,
    /// Message registry
    message_registry: Arc<RwLock<HashMap<String, MessageStatus>>>,
    /// Federation registry mapping federation ID to their public keys
    federation_registry: Arc<RwLock<HashMap<FederationId, Vec<u8>>>>,
    /// Queue of outgoing messages
    outgoing_queue: Arc<Mutex<Vec<CrossFederationMessage>>>,
    /// Queue of incoming messages
    incoming_queue: Arc<Mutex<Vec<CrossFederationMessage>>>,
    /// Trusted federation relationships
    trusted_federations: Arc<RwLock<HashMap<FederationId, TrustLevel>>>,
}

/// Trust level between federations
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TrustLevel {
    /// Full trust with all permissions
    FullTrust,
    /// Trust for specific operations only
    LimitedTrust(Vec<String>),
    /// Trust with approval required for each operation
    ApprovalRequired,
    /// No trust established
    Untrusted,
}

impl CrossFederationMessenger {
    /// Create a new cross-federation messenger
    pub fn new(federation_id: FederationId, key_pair: KeyPair) -> Self {
        Self {
            federation_id,
            key_pair,
            message_registry: Arc::new(RwLock::new(HashMap::new())),
            federation_registry: Arc::new(RwLock::new(HashMap::new())),
            outgoing_queue: Arc::new(Mutex::new(Vec::new())),
            incoming_queue: Arc::new(Mutex::new(Vec::new())),
            trusted_federations: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Register a federation and its public key
    pub async fn register_federation(&self, federation_id: FederationId, public_key: Vec<u8>) {
        let mut registry = self.federation_registry.write().await;
        registry.insert(federation_id, public_key);
    }

    /// Set trust level for a federation
    pub async fn set_trust_level(&self, federation_id: FederationId, trust_level: TrustLevel) {
        let mut trusted = self.trusted_federations.write().await;
        trusted.insert(federation_id, trust_level);
    }

    /// Check if a federation is trusted for a specific operation
    pub async fn is_trusted_for_operation(&self, federation_id: &FederationId, operation: &str) -> bool {
        let trusted = self.trusted_federations.read().await;
        
        match trusted.get(federation_id) {
            Some(TrustLevel::FullTrust) => true,
            Some(TrustLevel::LimitedTrust(permissions)) => permissions.contains(&operation.to_string()),
            Some(TrustLevel::ApprovalRequired) => false, // Requires explicit approval
            Some(TrustLevel::Untrusted) | None => false,
        }
    }

    /// Create a new cross-federation message
    pub fn create_message(
        &self,
        recipient: FederationId,
        message_type: MessageType,
        content: &[u8],
        references: Vec<String>,
        ttl: u64,
    ) -> Result<CrossFederationMessage, CrossFederationError> {
        // Encrypt content using recipient's public key
        let encrypted_content = self.encrypt_for_recipient(&recipient, content)?;
        
        // Generate a unique message ID
        let message_id = Uuid::new_v4().to_string();
        
        // Create message timestamp
        let timestamp = Utc::now();
        
        // Create the signature
        let signature_data = format!(
            "{}:{}:{}:{}:{}",
            message_id, self.federation_id, recipient, timestamp, hex::encode(&encrypted_content)
        );
        
        let signature = match self.key_pair.sign(signature_data.as_bytes()) {
            Ok(sig) => hex::encode(sig),
            Err(_) => return Err(CrossFederationError::CryptoError("Failed to sign message".to_string())),
        };
        
        Ok(CrossFederationMessage {
            id: message_id,
            sender: self.federation_id.clone(),
            recipient,
            message_type,
            encrypted_content,
            timestamp,
            signature,
            threshold: None,
            additional_signatures: None,
            references,
            ttl,
        })
    }

    /// Encrypt content for a specific recipient federation
    fn encrypt_for_recipient(&self, recipient_id: &FederationId, content: &[u8]) -> Result<Vec<u8>, CrossFederationError> {
        // In a real implementation, this would use the recipient's public key to encrypt
        // For now, we're using a placeholder implementation
        let mut encrypted = Vec::new();
        encrypted.extend_from_slice(b"ENCRYPTED:"); // Prefix to simulate encryption
        encrypted.extend_from_slice(content);
        
        Ok(encrypted)
    }

    /// Decrypt content meant for this federation
    fn decrypt_message(&self, encrypted_content: &[u8]) -> Result<Vec<u8>, CrossFederationError> {
        // In a real implementation, this would use this federation's private key to decrypt
        // For now, we're using a placeholder implementation
        if encrypted_content.len() < 10 || &encrypted_content[0..10] != b"ENCRYPTED:" {
            return Err(CrossFederationError::CryptoError("Invalid encrypted format".to_string()));
        }
        
        Ok(encrypted_content[10..].to_vec())
    }

    /// Queue a message to be sent
    pub async fn queue_message(&self, message: CrossFederationMessage) -> Result<(), CrossFederationError> {
        // Add to outgoing queue
        let mut queue = self.outgoing_queue.lock().await;
        queue.push(message.clone());
        
        // Update message registry
        let mut registry = self.message_registry.write().await;
        registry.insert(message.id, MessageStatus::Pending);
        
        Ok(())
    }

    /// Send all queued outgoing messages
    pub async fn send_queued_messages(&self) -> Result<usize, CrossFederationError> {
        let mut queue = self.outgoing_queue.lock().await;
        let message_count = queue.len();
        
        for message in queue.iter() {
            // In a real implementation, we'd actually send the message over the network
            // For now, just update the message status
            let mut registry = self.message_registry.write().await;
            registry.insert(message.id.clone(), MessageStatus::Delivered);
        }
        
        // Clear the queue
        queue.clear();
        
        Ok(message_count)
    }

    /// Process a received message
    pub async fn process_message(&self, message: CrossFederationMessage) -> Result<Vec<u8>, CrossFederationError> {
        // Verify the message signature
        self.verify_message_signature(&message).await?;
        
        // Check if the sender is trusted
        if !self.is_trusted_for_operation(&message.sender, "receive_message").await {
            return Err(CrossFederationError::UnauthorizedAccess(message.sender));
        }
        
        // Decrypt the content
        let decrypted_content = self.decrypt_message(&message.encrypted_content)?;
        
        // Add to registry
        let mut registry = self.message_registry.write().await;
        registry.insert(message.id.clone(), MessageStatus::Processed);
        
        Ok(decrypted_content)
    }

    /// Queue a received message for processing
    pub async fn queue_received_message(&self, message: CrossFederationMessage) -> Result<(), CrossFederationError> {
        // Basic validation first
        if message.recipient != self.federation_id {
            return Err(CrossFederationError::UnauthorizedAccess(message.recipient));
        }
        
        // Add to incoming queue
        let mut queue = self.incoming_queue.lock().await;
        queue.push(message.clone());
        
        // Update registry
        let mut registry = self.message_registry.write().await;
        registry.insert(message.id, MessageStatus::Pending);
        
        Ok(())
    }

    /// Process all queued incoming messages
    pub async fn process_queued_messages(&self) -> Result<Vec<Vec<u8>>, CrossFederationError> {
        let mut queue = self.incoming_queue.lock().await;
        let mut results = Vec::new();
        
        for message in std::mem::take(&mut *queue) {
            match self.process_message(message).await {
                Ok(content) => results.push(content),
                Err(err) => {
                    // Log error but continue processing other messages
                    eprintln!("Error processing message: {:?}", err);
                }
            }
        }
        
        Ok(results)
    }

    /// Verify a message signature
    async fn verify_message_signature(&self, message: &CrossFederationMessage) -> Result<bool, CrossFederationError> {
        // Get the sender's public key
        let registry = self.federation_registry.read().await;
        let sender_public_key = registry.get(&message.sender)
            .ok_or_else(|| CrossFederationError::FederationNotFound(message.sender.clone()))?;
        
        // Recreate the signature data
        let signature_data = format!(
            "{}:{}:{}:{}:{}",
            message.id, message.sender, message.recipient, message.timestamp, hex::encode(&message.encrypted_content)
        );
        
        // Verify the signature
        // In a real implementation, we'd use proper cryptographic verification
        // For now, just check if it exists and isn't empty
        if message.signature.is_empty() {
            return Err(CrossFederationError::MessageValidationFailed("Empty signature".to_string()));
        }
        
        Ok(true)
    }

    /// Get the status of a message
    pub async fn get_message_status(&self, message_id: &str) -> Option<MessageStatus> {
        let registry = self.message_registry.read().await;
        registry.get(message_id).cloned()
    }

    /// Start the background message processor
    pub async fn start_background_processor(messenger: Arc<Self>) {
        tokio::spawn(async move {
            loop {
                // Process incoming messages
                if let Err(err) = messenger.process_queued_messages().await {
                    eprintln!("Error processing queued messages: {:?}", err);
                }
                
                // Send outgoing messages
                if let Err(err) = messenger.send_queued_messages().await {
                    eprintln!("Error sending queued messages: {:?}", err);
                }
                
                // Sleep for a bit before next cycle
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            }
        });
    }
}```

===================
File: ./crates/icn-federation/src/governance.rs
Size: 28671 bytes
===================
```rs
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use serde::{Serialize, Deserialize};
use thiserror::Error;
use chrono::{DateTime, Utc};
use uuid::Uuid;
use icn_types::{FederationId, Did};
use icn_reputation::{ReputationManager, ReputationScore};
use crate::messaging::{FederationMessenger, MessageType, MessagePriority, MessageVisibility};

/// Error types for federation governance
#[derive(Error, Debug)]
pub enum GovernanceError {
    #[error("Proposal not found: {0}")]
    ProposalNotFound(String),
    
    #[error("Vote not found: {0}")]
    VoteNotFound(String),
    
    #[error("Unauthorized action: {0}")]
    Unauthorized(String),
    
    #[error("Invalid proposal: {0}")]
    InvalidProposal(String),
    
    #[error("Invalid vote: {0}")]
    InvalidVote(String),
    
    #[error("Voting period ended")]
    VotingPeriodEnded,
    
    #[error("Insufficient reputation: required {required}, actual {actual}")]
    InsufficientReputation { required: i64, actual: i64 },
    
    #[error("Proposal already exists: {0}")]
    ProposalExists(String),
    
    #[error("Already voted on proposal")]
    AlreadyVoted,
    
    #[error("Federation messaging error: {0}")]
    MessagingError(String),
    
    #[error("Reputation system error: {0}")]
    ReputationError(String),
}

/// Types of federation governance proposals
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalType {
    /// Add a new member to the federation
    AddMember,
    
    /// Remove a member from the federation
    RemoveMember,
    
    /// Change federation parameters
    ChangeParameters,
    
    /// Allocate resources
    ResourceAllocation,
    
    /// Form partnership with another federation
    FormPartnership,
    
    /// Dissolve partnership with another federation
    DissolvePartnership,
    
    /// Modify federation rules
    ModifyRules,
    
    /// Generic proposal type
    Generic,
    
    /// Custom proposal type
    Custom(String),
}

/// Voting methods for proposals
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum VotingMethod {
    /// Simple majority voting (>50%)
    SimpleMajority,
    
    /// Super majority voting (e.g., 2/3 or 3/4)
    SuperMajority(f64),
    
    /// Unanimous voting (100%)
    Unanimous,
    
    /// Quadratic voting (votes weighted by square root of reputation)
    QuadraticVoting,
    
    /// Reputation-weighted voting
    ReputationWeighted,
    
    /// Delegation-based voting
    DelegatedVoting,
    
    /// Custom voting method
    Custom(String),
}

/// Current status of a proposal
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalStatus {
    /// Proposal has been created but not yet open for voting
    Draft,
    
    /// Proposal is open for voting
    Active,
    
    /// Proposal has been approved
    Approved,
    
    /// Proposal has been rejected
    Rejected,
    
    /// Proposal has been withdrawn
    Withdrawn,
    
    /// Proposal execution is in progress
    Executing,
    
    /// Proposal has been executed
    Executed,
    
    /// Proposal has failed execution
    Failed,
}

/// Voting options
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum VoteOption {
    /// Vote in favor of the proposal
    Approve,
    
    /// Vote against the proposal
    Reject,
    
    /// Abstain from voting (neutral)
    Abstain,
    
    /// Request more information before voting
    RequestInfo,
}

/// A governance proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    /// Unique proposal ID
    pub id: String,
    
    /// Title of the proposal
    pub title: String,
    
    /// Detailed description of the proposal
    pub description: String,
    
    /// Type of the proposal
    pub proposal_type: ProposalType,
    
    /// DID of the proposer
    pub proposer: Did,
    
    /// When the proposal was created
    pub created_at: DateTime<Utc>,
    
    /// When voting starts
    pub voting_starts_at: DateTime<Utc>,
    
    /// When voting ends
    pub voting_ends_at: DateTime<Utc>,
    
    /// Current status of the proposal
    pub status: ProposalStatus,
    
    /// Voting method to be used
    pub voting_method: VotingMethod,
    
    /// Minimum reputation required to vote
    pub min_reputation: i64,
    
    /// Proposal data (type-specific content)
    pub data: HashMap<String, String>,
    
    /// Proposal attachments (e.g., documents, evidence)
    pub attachments: Vec<ProposalAttachment>,
    
    /// Record of votes on this proposal
    pub votes: HashMap<Did, Vote>,
    
    /// Metadata and tags
    pub metadata: HashMap<String, String>,
    
    /// Federation this proposal belongs to
    pub federation_id: FederationId,
}

/// Attachment to a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProposalAttachment {
    /// Name of the attachment
    pub name: String,
    
    /// MIME type of the attachment
    pub mime_type: String,
    
    /// Content hash for integrity verification
    pub hash: String,
    
    /// URL or IPFS CID where the content can be retrieved
    pub url: String,
    
    /// Size in bytes
    pub size: u64,
}

/// A vote on a proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vote {
    /// ID of the vote
    pub id: String,
    
    /// ID of the proposal being voted on
    pub proposal_id: String,
    
    /// DID of the voter
    pub voter: Did,
    
    /// The vote choice
    pub vote: VoteOption,
    
    /// Optional explanation for the vote
    pub explanation: Option<String>,
    
    /// Reputation weight of the vote
    pub weight: f64,
    
    /// When the vote was cast
    pub timestamp: DateTime<Utc>,
    
    /// If this vote was delegated
    pub delegated: bool,
    
    /// If delegated, the original voter
    pub delegated_from: Option<Did>,
    
    /// Digital signature of the vote
    pub signature: String,
}

/// Results of a vote
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoteResults {
    /// ID of the proposal
    pub proposal_id: String,
    
    /// Total number of votes
    pub total_votes: usize,
    
    /// Number of approve votes
    pub approve_count: usize,
    
    /// Number of reject votes
    pub reject_count: usize,
    
    /// Number of abstain votes
    pub abstain_count: usize,
    
    /// Number of request info votes
    pub request_info_count: usize,
    
    /// Sum of approve vote weights
    pub approve_weight: f64,
    
    /// Sum of reject vote weights
    pub reject_weight: f64,
    
    /// Sum of abstain vote weights
    pub abstain_weight: f64,
    
    /// Sum of request info vote weights
    pub request_info_weight: f64,
    
    /// Total possible voting weight
    pub total_possible_weight: f64,
    
    /// Participation rate (0.0 - 1.0)
    pub participation_rate: f64,
    
    /// Whether the proposal passed
    pub passed: bool,
}

/// Federation governance system
pub struct FederationGovernance {
    /// Federation ID
    federation_id: FederationId,
    
    /// Active proposals
    proposals: RwLock<HashMap<String, Proposal>>,
    
    /// Archive of past proposals
    proposal_archive: RwLock<HashMap<String, Proposal>>,
    
    /// Federation messenger for proposal notifications
    messenger: Arc<FederationMessenger>,
    
    /// Reputation manager for vote weighting
    reputation_manager: Arc<dyn ReputationManager>,
    
    /// Vote delegates
    delegates: RwLock<HashMap<Did, Did>>,
    
    /// Minimum reputation to create proposals
    min_proposal_reputation: RwLock<i64>,
    
    /// Proposals pending execution
    pending_execution: RwLock<Vec<String>>,
    
    /// Vote proxy configurations
    vote_proxies: RwLock<HashMap<Did, Vec<Did>>>,
}

impl FederationGovernance {
    /// Create a new federation governance system
    pub fn new(
        federation_id: FederationId,
        messenger: Arc<FederationMessenger>,
        reputation_manager: Arc<dyn ReputationManager>,
    ) -> Self {
        Self {
            federation_id,
            proposals: RwLock::new(HashMap::new()),
            proposal_archive: RwLock::new(HashMap::new()),
            messenger,
            reputation_manager,
            delegates: RwLock::new(HashMap::new()),
            min_proposal_reputation: RwLock::new(100), // Default minimum reputation
            pending_execution: RwLock::new(Vec::new()),
            vote_proxies: RwLock::new(HashMap::new()),
        }
    }

    /// Set minimum reputation required to create proposals
    pub async fn set_min_proposal_reputation(&self, reputation: i64) {
        let mut min_rep = self.min_proposal_reputation.write().await;
        *min_rep = reputation;
    }

    /// Create a new proposal
    pub async fn create_proposal(
        &self,
        title: String,
        description: String,
        proposal_type: ProposalType,
        proposer: Did,
        voting_starts_at: DateTime<Utc>,
        voting_ends_at: DateTime<Utc>,
        voting_method: VotingMethod,
        min_reputation: i64,
        data: HashMap<String, String>,
        attachments: Vec<ProposalAttachment>,
        metadata: HashMap<String, String>,
    ) -> Result<String, GovernanceError> {
        // Check if proposer has sufficient reputation
        let proposer_reputation = self.reputation_manager.get_reputation(&proposer)
            .await
            .map_err(|e| GovernanceError::ReputationError(e.to_string()))?;
            
        let min_rep = *self.min_proposal_reputation.read().await;
        
        if proposer_reputation.score < min_rep {
            return Err(GovernanceError::InsufficientReputation { 
                required: min_rep,
                actual: proposer_reputation.score,
            });
        }
        
        // Validate proposal parameters
        if voting_starts_at >= voting_ends_at {
            return Err(GovernanceError::InvalidProposal("Voting end time must be after start time".to_string()));
        }
        
        // Create a new proposal ID
        let proposal_id = Uuid::new_v4().to_string();
        
        // Create the proposal
        let proposal = Proposal {
            id: proposal_id.clone(),
            title,
            description,
            proposal_type,
            proposer: proposer.clone(),
            created_at: Utc::now(),
            voting_starts_at,
            voting_ends_at,
            status: ProposalStatus::Draft,
            voting_method,
            min_reputation,
            data,
            attachments,
            votes: HashMap::new(),
            metadata,
            federation_id: self.federation_id.clone(),
        };
        
        // Store the proposal
        let mut proposals = self.proposals.write().await;
        proposals.insert(proposal_id.clone(), proposal.clone());
        
        // Notify federation members about the new proposal
        self.notify_new_proposal(&proposal).await?;
        
        Ok(proposal_id)
    }

    /// Notify federation members about a new proposal
    async fn notify_new_proposal(&self, proposal: &Proposal) -> Result<(), GovernanceError> {
        let title = format!("New Proposal: {}", proposal.title);
        let message = format!(
            "A new proposal has been created by {}.\n\nTitle: {}\n\nDescription: {}\n\nVoting starts: {}\nVoting ends: {}\n\nProposal ID: {}",
            proposal.proposer,
            proposal.title,
            proposal.description,
            proposal.voting_starts_at.to_rfc3339(),
            proposal.voting_ends_at.to_rfc3339(),
            proposal.id
        );
        
        // Send message via the messenger
        // In a production system, this would be more sophisticated with proper serialization
        self.messenger.send_new_message(
            &self.federation_id, // Send to all federation members
            MessageType::Proposal,
            &title,
            message.as_bytes(),
            MessageVisibility::Federation,
            MessagePriority::Normal,
            Vec::new(),
            None,
        )
        .await
        .map_err(|e| GovernanceError::MessagingError(e.to_string()))?;
        
        Ok(())
    }

    /// Get a proposal by ID
    pub async fn get_proposal(&self, proposal_id: &str) -> Result<Proposal, GovernanceError> {
        // Check active proposals
        let proposals = self.proposals.read().await;
        if let Some(proposal) = proposals.get(proposal_id) {
            return Ok(proposal.clone());
        }
        
        // Check archived proposals
        let archived = self.proposal_archive.read().await;
        archived.get(proposal_id)
            .cloned()
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))
    }

    /// List all active proposals
    pub async fn list_active_proposals(&self) -> Vec<Proposal> {
        let proposals = self.proposals.read().await;
        proposals.values()
            .filter(|p| p.status == ProposalStatus::Active)
            .cloned()
            .collect()
    }

    /// List all proposals
    pub async fn list_all_proposals(&self, include_archived: bool) -> Vec<Proposal> {
        let mut result = Vec::new();
        
        // Get active proposals
        {
            let proposals = self.proposals.read().await;
            result.extend(proposals.values().cloned());
        }
        
        // Get archived proposals if requested
        if include_archived {
            let archived = self.proposal_archive.read().await;
            result.extend(archived.values().cloned());
        }
        
        result
    }

    /// Cast a vote on a proposal
    pub async fn cast_vote(
        &self,
        proposal_id: &str,
        voter: Did,
        vote: VoteOption,
        explanation: Option<String>,
        signature: String,
    ) -> Result<String, GovernanceError> {
        // Get the proposal
        let mut proposals = self.proposals.write().await;
        let proposal = proposals.get_mut(proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))?;
        
        // Check if voting is open
        let now = Utc::now();
        if now < proposal.voting_starts_at {
            return Err(GovernanceError::InvalidVote("Voting has not started yet".to_string()));
        }
        if now > proposal.voting_ends_at {
            return Err(GovernanceError::VotingPeriodEnded);
        }
        
        // Check if proposal is active
        if proposal.status != ProposalStatus::Active {
            return Err(GovernanceError::InvalidVote(format!("Proposal is not active: {:?}", proposal.status)));
        }
        
        // Check if voter has already voted
        if proposal.votes.contains_key(&voter) {
            return Err(GovernanceError::AlreadyVoted);
        }
        
        // Check voter reputation
        let voter_reputation = self.reputation_manager.get_reputation(&voter)
            .await
            .map_err(|e| GovernanceError::ReputationError(e.to_string()))?;
            
        if voter_reputation.score < proposal.min_reputation {
            return Err(GovernanceError::InsufficientReputation {
                required: proposal.min_reputation,
                actual: voter_reputation.score,
            });
        }
        
        // Calculate vote weight based on voting method
        let weight = self.calculate_vote_weight(&proposal.voting_method, &voter_reputation).await;
        
        // Generate vote ID
        let vote_id = Uuid::new_v4().to_string();
        
        // Create the vote
        let vote_record = Vote {
            id: vote_id.clone(),
            proposal_id: proposal_id.to_string(),
            voter: voter.clone(),
            vote,
            explanation,
            weight,
            timestamp: now,
            delegated: false,
            delegated_from: None,
            signature,
        };
        
        // Record the vote
        proposal.votes.insert(voter, vote_record.clone());
        
        // Check if we should update proposal status
        self.update_proposal_status(proposal).await;
        
        Ok(vote_id)
    }

    /// Calculate vote weight based on voting method and reputation
    async fn calculate_vote_weight(&self, voting_method: &VotingMethod, reputation: &ReputationScore) -> f64 {
        match voting_method {
            VotingMethod::SimpleMajority | VotingMethod::SuperMajority(_) | VotingMethod::Unanimous => {
                // Each vote counts as 1
                1.0
            },
            VotingMethod::QuadraticVoting => {
                // Square root of reputation
                (reputation.score as f64).sqrt()
            },
            VotingMethod::ReputationWeighted => {
                // Weight is proportional to reputation
                reputation.score as f64
            },
            VotingMethod::DelegatedVoting => {
                // In delegated voting, we need to account for delegated votes
                // This is a simplification - real delegation would be more complex
                reputation.score as f64
            },
            VotingMethod::Custom(_) => {
                // Default for custom methods
                1.0
            },
        }
    }

    /// Update proposal status based on votes
    async fn update_proposal_status(&self, proposal: &mut Proposal) {
        // Calculate current vote totals
        let results = self.calculate_vote_results(proposal);
        
        // Check if we have a decision
        match proposal.voting_method {
            VotingMethod::SimpleMajority => {
                // Simple majority requires > 50% approval of total votes cast
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.approve_weight > results.reject_weight {
                    proposal.status = ProposalStatus::Approved;
                }
            },
            VotingMethod::SuperMajority(threshold) => {
                // Super majority requires approval to meet or exceed threshold
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.approve_weight / (results.approve_weight + results.reject_weight) >= threshold {
                    proposal.status = ProposalStatus::Approved;
                }
            },
            VotingMethod::Unanimous => {
                // Unanimous requires all votes to be approvals
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.reject_weight == 0.0 && results.approve_weight > 0.0 {
                    proposal.status = ProposalStatus::Approved;
                }
            },
            VotingMethod::QuadraticVoting | VotingMethod::ReputationWeighted => {
                // Weighted voting methods require more approval weight than rejection weight
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.approve_weight > results.reject_weight {
                    proposal.status = ProposalStatus::Approved;
                }
            },
            VotingMethod::DelegatedVoting => {
                // Delegated voting also needs more approval weight than rejection weight
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.approve_weight > results.reject_weight {
                    proposal.status = ProposalStatus::Approved;
                }
            },
            VotingMethod::Custom(_) => {
                // Custom methods would have their own implementation
                // For now, we use a simple majority as default
                if results.participation_rate >= 0.5 && // Minimum participation requirement
                   results.approve_weight > results.reject_weight {
                    proposal.status = ProposalStatus::Approved;
                }
            },
        }
    }

    /// Calculate vote results for a proposal
    pub fn calculate_vote_results(&self, proposal: &Proposal) -> VoteResults {
        let mut results = VoteResults {
            proposal_id: proposal.id.clone(),
            total_votes: proposal.votes.len(),
            approve_count: 0,
            reject_count: 0,
            abstain_count: 0,
            request_info_count: 0,
            approve_weight: 0.0,
            reject_weight: 0.0,
            abstain_weight: 0.0,
            request_info_weight: 0.0,
            total_possible_weight: 0.0, // This will be calculated later
            participation_rate: 0.0,    // This will be calculated later
            passed: false,
        };
        
        // Count votes and weights
        for vote in proposal.votes.values() {
            match vote.vote {
                VoteOption::Approve => {
                    results.approve_count += 1;
                    results.approve_weight += vote.weight;
                },
                VoteOption::Reject => {
                    results.reject_count += 1;
                    results.reject_weight += vote.weight;
                },
                VoteOption::Abstain => {
                    results.abstain_count += 1;
                    results.abstain_weight += vote.weight;
                },
                VoteOption::RequestInfo => {
                    results.request_info_count += 1;
                    results.request_info_weight += vote.weight;
                },
            }
        }
        
        // For simplicity in this implementation, we estimate total possible weight
        // In a real system, we'd calculate based on eligible voters
        results.total_possible_weight = results.approve_weight + 
                                       results.reject_weight + 
                                       results.abstain_weight + 
                                       results.request_info_weight;
                                       
        if results.total_possible_weight > 0.0 {
            results.participation_rate = (results.approve_weight + 
                                        results.reject_weight) / 
                                        results.total_possible_weight;
        }
        
        // Determine if proposal passed
        results.passed = proposal.status == ProposalStatus::Approved;
        
        results
    }

    /// Delegate voting authority to another member
    pub async fn set_voting_delegate(&self, delegator: Did, delegate: Did) -> Result<(), GovernanceError> {
        let mut delegates = self.delegates.write().await;
        delegates.insert(delegator, delegate);
        Ok(())
    }

    /// Remove voting delegation
    pub async fn remove_voting_delegate(&self, delegator: &Did) -> Result<(), GovernanceError> {
        let mut delegates = self.delegates.write().await;
        delegates.remove(delegator);
        Ok(())
    }

    /// Execute an approved proposal
    pub async fn execute_proposal(&self, proposal_id: &str) -> Result<(), GovernanceError> {
        let mut proposals = self.proposals.write().await;
        let proposal = proposals.get_mut(proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))?;
            
        // Check if proposal is approved
        if proposal.status != ProposalStatus::Approved {
            return Err(GovernanceError::InvalidProposal(
                format!("Proposal not approved: {:?}", proposal.status)
            ));
        }
        
        // Update status to executing
        proposal.status = ProposalStatus::Executing;
        
        // Add to pending execution queue
        let mut pending = self.pending_execution.write().await;
        pending.push(proposal_id.to_string());
        
        // In a real implementation, we'd have proposal handlers for different types
        // For now, just mark it as executed
        proposal.status = ProposalStatus::Executed;
        
        // Send notification about executed proposal
        self.notify_proposal_execution(proposal).await?;
        
        Ok(())
    }

    /// Notify federation members about proposal execution
    async fn notify_proposal_execution(&self, proposal: &Proposal) -> Result<(), GovernanceError> {
        let title = format!("Proposal Executed: {}", proposal.title);
        let message = format!(
            "Proposal has been executed.\n\nTitle: {}\n\nProposal ID: {}",
            proposal.title,
            proposal.id
        );
        
        // Send message via the messenger
        self.messenger.send_new_message(
            &self.federation_id, // Send to all federation members
            MessageType::SystemNotification,
            &title,
            message.as_bytes(),
            MessageVisibility::Federation,
            MessagePriority::High,
            Vec::new(),
            None,
        )
        .await
        .map_err(|e| GovernanceError::MessagingError(e.to_string()))?;
        
        Ok(())
    }

    /// Set up a new vote proxy
    pub async fn set_vote_proxy(&self, voter: Did, proxy_voters: Vec<Did>) -> Result<(), GovernanceError> {
        let mut proxies = self.vote_proxies.write().await;
        proxies.insert(voter, proxy_voters);
        Ok(())
    }

    /// Get vote results for a proposal
    pub async fn get_vote_results(&self, proposal_id: &str) -> Result<VoteResults, GovernanceError> {
        let proposal = self.get_proposal(proposal_id).await?;
        Ok(self.calculate_vote_results(&proposal))
    }

    /// Archive a proposal
    pub async fn archive_proposal(&self, proposal_id: &str) -> Result<(), GovernanceError> {
        let mut proposals = self.proposals.write().await;
        
        // Find and remove the proposal from active proposals
        let proposal = proposals.remove(proposal_id)
            .ok_or_else(|| GovernanceError::ProposalNotFound(proposal_id.to_string()))?;
            
        // Add to archive
        let mut archive = self.proposal_archive.write().await;
        archive.insert(proposal_id.to_string(), proposal);
        
        Ok(())
    }

    /// Check and update status of all proposals
    pub async fn update_all_proposal_statuses(&self) -> Result<usize, GovernanceError> {
        let now = Utc::now();
        let mut updated_count = 0;
        let mut to_archive = Vec::new();
        
        // First, get all proposals that need updating
        let mut proposals = self.proposals.write().await;
        
        for (id, proposal) in proposals.iter_mut() {
            // Check if voting period has ended
            if proposal.status == ProposalStatus::Active && now > proposal.voting_ends_at {
                // Update status based on votes
                self.update_proposal_status(proposal).await;
                
                // If still active after update, it didn't reach the threshold - mark as rejected
                if proposal.status == ProposalStatus::Active {
                    proposal.status = ProposalStatus::Rejected;
                }
                
                updated_count += 1;
            }
            
            // Check if proposal is final and should be archived
            match proposal.status {
                ProposalStatus::Executed | ProposalStatus::Rejected | ProposalStatus::Failed | ProposalStatus::Withdrawn => {
                    to_archive.push(id.clone());
                }
                _ => {}
            }
        }
        
        // Archive completed proposals
        for id in to_archive {
            if let Some(proposal) = proposals.remove(&id) {
                let mut archive = self.proposal_archive.write().await;
                archive.insert(id, proposal);
                updated_count += 1;
            }
        }
        
        Ok(updated_count)
    }

    /// Start the background proposal status updater
    pub async fn start_background_updater(governance: Arc<FederationGovernance>) {
        tokio::spawn(async move {
            loop {
                // Update proposal statuses
                if let Err(e) = governance.update_all_proposal_statuses().await {
                    eprintln!("Error updating proposal statuses: {:?}", e);
                }
                
                // Sleep for a reasonable interval
                tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
            }
        });
    }
}```

===================
File: ./crates/icn-federation/src/messaging.rs
Size: 21139 bytes
===================
```rs
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use serde::{Serialize, Deserialize};
use thiserror::Error;
use chrono::{DateTime, Utc};
use uuid::Uuid;
use icn_crypto::{KeyPair, encrypt, decrypt};
use icn_types::FederationId;
use sodiumoxide::crypto::box_;

/// Error types for federation messaging
#[derive(Error, Debug)]
pub enum MessagingError {
    #[error("Invalid recipient: {0}")]
    InvalidRecipient(String),
    
    #[error("Encryption failed: {0}")]
    EncryptionFailed(String),
    
    #[error("Decryption failed: {0}")]
    DecryptionFailed(String),
    
    #[error("Message not found: {0}")]
    MessageNotFound(String),
    
    #[error("Unauthorized: {0}")]
    Unauthorized(String),
}

/// Message visibility settings
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageVisibility {
    /// Visible only to direct recipient
    Private,
    
    /// Visible to specific roles in the federation
    Role(Vec<String>),
    
    /// Visible to all federation members
    Federation,
    
    /// Visible to member and linked federations
    FederationNetwork,
    
    /// Visible to all ICN participants (broadcast)
    Public,
}

/// Message priority levels
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, PartialOrd, Ord)]
pub enum MessagePriority {
    /// Lowest priority, non-urgent
    Low,
    
    /// Normal priority for most communication
    Normal,
    
    /// Higher priority for important messages
    High,
    
    /// Highest priority for critical messages
    Critical,
    
    /// System messages (highest priority)
    System,
}

/// Message status
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageStatus {
    /// Message has been composed but not sent
    Draft,
    
    /// Message has been sent but not delivered
    Sent,
    
    /// Message has been delivered to recipient
    Delivered,
    
    /// Message has been read by recipient
    Read,
    
    /// Message has been acknowledged by recipient
    Acknowledged,
    
    /// Message failed to deliver
    Failed,
    
    /// Message expired before delivery
    Expired,
}

/// Types of federation messages
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum MessageType {
    /// Standard text message
    Text,
    
    /// Governance proposal
    Proposal,
    
    /// Vote on a proposal
    Vote,
    
    /// Resource request
    ResourceRequest,
    
    /// Resource offer
    ResourceOffer,
    
    /// System notification
    SystemNotification,
    
    /// Custom message type
    Custom(String),
}

/// A secure message between federation members
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FederationMessage {
    /// Unique message ID
    pub id: String,
    
    /// Sender's DID
    pub sender: String,
    
    /// Recipient's DID or federation ID
    pub recipient: String,
    
    /// Message visibility
    pub visibility: MessageVisibility,
    
    /// Message type
    pub message_type: MessageType,
    
    /// Message priority
    pub priority: MessagePriority,
    
    /// Message subject
    pub subject: String,
    
    /// Encrypted message content
    pub encrypted_content: Vec<u8>,
    
    /// Timestamp when the message was created
    pub timestamp: DateTime<Utc>,
    
    /// Optional expiration time
    pub expires_at: Option<DateTime<Utc>>,
    
    /// Current message status
    pub status: MessageStatus,
    
    /// Digital signature of the message
    pub signature: String,
    
    /// References to other messages (e.g., for threading)
    pub references: Vec<String>,
    
    /// Custom message attributes
    pub attributes: HashMap<String, String>,
}

/// Manages the messaging system for federation members
pub struct FederationMessenger {
    /// The federation ID this messenger belongs to
    federation_id: FederationId,
    
    /// Key pair for encryption/decryption
    key_pair: KeyPair,
    
    /// Public keys of known participants
    public_keys: RwLock<HashMap<String, Vec<u8>>>,
    
    /// Inbox of received messages
    inbox: RwLock<Vec<FederationMessage>>,
    
    /// Outbox of sent messages
    outbox: RwLock<Vec<FederationMessage>>,
    
    /// Draft messages
    drafts: RwLock<HashMap<String, FederationMessage>>,
    
    /// Message delivery status
    delivery_status: RwLock<HashMap<String, MessageStatus>>,
    
    /// Message channels by topic
    channels: RwLock<HashMap<String, HashSet<String>>>,
    
    /// Message handlers by type
    message_handlers: RwLock<HashMap<MessageType, Box<dyn MessageHandler + Send + Sync>>>,
    
    /// Members of this federation
    federation_members: RwLock<HashSet<String>>,
}

/// Trait for handling different message types
#[async_trait::async_trait]
pub trait MessageHandler: Send + Sync {
    async fn handle_message(&self, message: &FederationMessage) -> Result<(), MessagingError>;
}

impl FederationMessenger {
    /// Create a new FederationMessenger
    pub fn new(federation_id: FederationId, key_pair: KeyPair) -> Self {
        Self {
            federation_id,
            key_pair,
            public_keys: RwLock::new(HashMap::new()),
            inbox: RwLock::new(Vec::new()),
            outbox: RwLock::new(Vec::new()),
            drafts: RwLock::new(HashMap::new()),
            delivery_status: RwLock::new(HashMap::new()),
            channels: RwLock::new(HashMap::new()),
            message_handlers: RwLock::new(HashMap::new()),
            federation_members: RwLock::new(HashSet::new()),
        }
    }

    /// Register public key for a participant
    pub async fn register_public_key(&self, did: &str, public_key: Vec<u8>) {
        let mut keys = self.public_keys.write().await;
        keys.insert(did.to_string(), public_key);
    }

    /// Register a member of the federation
    pub async fn register_member(&self, member_did: &str) {
        let mut members = self.federation_members.write().await;
        members.insert(member_did.to_string());
    }

    /// Register a message handler for a specific message type
    pub async fn register_handler(&self, message_type: MessageType, handler: Box<dyn MessageHandler + Send + Sync>) {
        let mut handlers = self.message_handlers.write().await;
        handlers.insert(message_type, handler);
    }

    /// Create a new message
    pub async fn create_message(
        &self,
        recipient: &str,
        message_type: MessageType,
        subject: &str,
        content: &[u8],
        visibility: MessageVisibility,
        priority: MessagePriority,
        references: Vec<String>,
        expires_in_hours: Option<u64>,
    ) -> Result<FederationMessage, MessagingError> {
        // Encrypt content for recipient
        let encrypted_content = self.encrypt_for_recipient(recipient, content).await?;
        
        // Generate message ID
        let message_id = Uuid::new_v4().to_string();
        
        // Set expiration time if provided
        let expires_at = expires_in_hours.map(|hours| {
            Utc::now() + chrono::Duration::hours(hours as i64)
        });
        
        // Create signature for message
        let signature_data = format!(
            "{}:{}:{}:{}:{}",
            message_id, self.federation_id, recipient, Utc::now(), hex::encode(&encrypted_content)
        );
        
        let signature = match self.key_pair.sign(signature_data.as_bytes()) {
            Ok(sig) => hex::encode(sig),
            Err(_) => return Err(MessagingError::EncryptionFailed("Failed to sign message".to_string())),
        };
        
        // Create the message
        let message = FederationMessage {
            id: message_id,
            sender: self.federation_id.clone(),
            recipient: recipient.to_string(),
            visibility,
            message_type,
            priority,
            subject: subject.to_string(),
            encrypted_content,
            timestamp: Utc::now(),
            expires_at,
            status: MessageStatus::Draft,
            signature,
            references,
            attributes: HashMap::new(),
        };
        
        // Store in drafts
        let mut drafts = self.drafts.write().await;
        drafts.insert(message.id.clone(), message.clone());
        
        Ok(message)
    }

    /// Encrypt content for a specific recipient
    async fn encrypt_for_recipient(&self, recipient: &str, content: &[u8]) -> Result<Vec<u8>, MessagingError> {
        // Get recipient's public key
        let keys = self.public_keys.read().await;
        let public_key = keys.get(recipient)
            .ok_or_else(|| MessagingError::InvalidRecipient(format!("No public key for {}", recipient)))?;
        
        // Encrypt the content
        encrypt(content, public_key).map_err(|e| MessagingError::EncryptionFailed(e.to_string()))
    }

    /// Decrypt content of a message
    async fn decrypt_message(&self, message: &FederationMessage) -> Result<Vec<u8>, MessagingError> {
        // Verify the message is for us
        if message.recipient != self.federation_id {
            return Err(MessagingError::Unauthorized("Message not intended for this recipient".to_string()));
        }
        
        // Decrypt using our private key
        decrypt(&message.encrypted_content, &self.key_pair.private_key)
            .map_err(|e| MessagingError::DecryptionFailed(e.to_string()))
    }

    /// Send a message that was previously created
    pub async fn send_message(&self, message_id: &str) -> Result<(), MessagingError> {
        // Get the message from drafts
        let mut drafts = self.drafts.write().await;
        let message = drafts.remove(message_id)
            .ok_or_else(|| MessagingError::MessageNotFound(message_id.to_string()))?;
        
        // Update status
        let mut message = message;
        message.status = MessageStatus::Sent;
        
        // Store in outbox
        let mut outbox = self.outbox.write().await;
        outbox.push(message.clone());
        
        // Update delivery status
        let mut status = self.delivery_status.write().await;
        status.insert(message.id.clone(), MessageStatus::Sent);
        
        // In a real implementation, we would now send the message over the network
        
        Ok(())
    }

    /// Create and send a message in one step
    pub async fn send_new_message(
        &self,
        recipient: &str,
        message_type: MessageType,
        subject: &str,
        content: &[u8],
        visibility: MessageVisibility,
        priority: MessagePriority,
        references: Vec<String>,
        expires_in_hours: Option<u64>,
    ) -> Result<String, MessagingError> {
        let message = self.create_message(
            recipient,
            message_type.clone(),
            subject,
            content,
            visibility,
            priority.clone(),
            references,
            expires_in_hours,
        ).await?;
        
        let message_id = message.id.clone();
        self.send_message(&message_id).await?;
        
        Ok(message_id)
    }

    /// Process a received message
    pub async fn process_received_message(&self, message: FederationMessage) -> Result<(), MessagingError> {
        // Verify this message is intended for us
        if message.recipient != self.federation_id && !self.is_broadcast(&message).await {
            return Err(MessagingError::Unauthorized("Message not intended for this recipient".to_string()));
        }
        
        // Verify the signature
        self.verify_message(&message).await?;
        
        // Update status
        let mut updated_message = message.clone();
        updated_message.status = MessageStatus::Delivered;
        
        // Store in inbox
        let mut inbox = self.inbox.write().await;
        inbox.push(updated_message.clone());
        
        // Update delivery status
        let mut status = self.delivery_status.write().await;
        status.insert(updated_message.id.clone(), MessageStatus::Delivered);
        
        // Check if we have a handler for this message type
        let handlers = self.message_handlers.read().await;
        if let Some(handler) = handlers.get(&message.message_type) {
            handler.handle_message(&updated_message).await?;
        }
        
        Ok(())
    }

    /// Mark a message as read
    pub async fn mark_as_read(&self, message_id: &str) -> Result<(), MessagingError> {
        let mut inbox = self.inbox.write().await;
        let msg_index = inbox.iter().position(|m| m.id == message_id)
            .ok_or_else(|| MessagingError::MessageNotFound(message_id.to_string()))?;
        
        inbox[msg_index].status = MessageStatus::Read;
        
        // Update delivery status
        let mut status = self.delivery_status.write().await;
        status.insert(message_id.to_string(), MessageStatus::Read);
        
        Ok(())
    }

    /// Mark a message as acknowledged
    pub async fn acknowledge_message(&self, message_id: &str) -> Result<(), MessagingError> {
        let mut inbox = self.inbox.write().await;
        let msg_index = inbox.iter().position(|m| m.id == message_id)
            .ok_or_else(|| MessagingError::MessageNotFound(message_id.to_string()))?;
        
        inbox[msg_index].status = MessageStatus::Acknowledged;
        
        // Update delivery status
        let mut status = self.delivery_status.write().await;
        status.insert(message_id.to_string(), MessageStatus::Acknowledged);
        
        Ok(())
    }

    /// Check if a message is a broadcast message
    async fn is_broadcast(&self, message: &FederationMessage) -> bool {
        matches!(message.visibility, MessageVisibility::Public | MessageVisibility::FederationNetwork)
    }

    /// Verify a message signature
    async fn verify_message(&self, message: &FederationMessage) -> Result<bool, MessagingError> {
        // Get sender's public key
        let keys = self.public_keys.read().await;
        let sender_public_key = keys.get(&message.sender)
            .ok_or_else(|| MessagingError::InvalidRecipient(format!("No public key for {}", message.sender)))?;
        
        // Recreate signature data
        let signature_data = format!(
            "{}:{}:{}:{}:{}",
            message.id, message.sender, message.recipient, message.timestamp, hex::encode(&message.encrypted_content)
        );
        
        // Verify the signature
        // In a real implementation, we'd use proper signature verification
        // For now, just check if it's not empty
        if message.signature.is_empty() {
            return Err(MessagingError::Unauthorized("Invalid signature".to_string()));
        }
        
        Ok(true)
    }

    /// Subscribe to a message channel
    pub async fn subscribe_to_channel(&self, channel: &str) {
        let member_id = self.federation_id.clone();
        let mut channels = self.channels.write().await;
        
        let subscribers = channels.entry(channel.to_string()).or_insert_with(HashSet::new);
        subscribers.insert(member_id);
    }

    /// Unsubscribe from a message channel
    pub async fn unsubscribe_from_channel(&self, channel: &str) {
        let member_id = self.federation_id.clone();
        let mut channels = self.channels.write().await;
        
        if let Some(subscribers) = channels.get_mut(channel) {
            subscribers.remove(&member_id);
        }
    }

    /// Send a message to a channel
    pub async fn send_to_channel(
        &self,
        channel: &str,
        subject: &str,
        content: &[u8],
        message_type: MessageType,
        priority: MessagePriority,
        expires_in_hours: Option<u64>,
    ) -> Result<Vec<String>, MessagingError> {
        let mut message_ids = Vec::new();
        
        // Get all subscribers
        let channels = self.channels.read().await;
        let subscribers = channels.get(channel)
            .ok_or_else(|| MessagingError::InvalidRecipient(format!("Channel not found: {}", channel)))?;
        
        // Send to each subscriber
        for subscriber in subscribers {
            if subscriber != &self.federation_id {
                let msg_id = self.send_new_message(
                    subscriber,
                    message_type.clone(),
                    subject,
                    content,
                    MessageVisibility::Private,
                    priority.clone(),
                    vec![],
                    expires_in_hours,
                ).await?;
                
                message_ids.push(msg_id);
            }
        }
        
        Ok(message_ids)
    }

    /// Get all messages in the inbox
    pub async fn get_inbox_messages(&self) -> Vec<FederationMessage> {
        let inbox = self.inbox.read().await;
        inbox.clone()
    }

    /// Get all sent messages
    pub async fn get_sent_messages(&self) -> Vec<FederationMessage> {
        let outbox = self.outbox.read().await;
        outbox.clone()
    }

    /// Get message by ID
    pub async fn get_message(&self, message_id: &str) -> Option<FederationMessage> {
        // Check inbox
        let inbox = self.inbox.read().await;
        if let Some(msg) = inbox.iter().find(|m| m.id == message_id) {
            return Some(msg.clone());
        }
        
        // Check outbox
        let outbox = self.outbox.read().await;
        if let Some(msg) = outbox.iter().find(|m| m.id == message_id) {
            return Some(msg.clone());
        }
        
        // Check drafts
        let drafts = self.drafts.read().await;
        drafts.get(message_id).cloned()
    }

    /// Delete a message
    pub async fn delete_message(&self, message_id: &str) -> Result<(), MessagingError> {
        // Check and remove from inbox
        {
            let mut inbox = self.inbox.write().await;
            if let Some(pos) = inbox.iter().position(|m| m.id == message_id) {
                inbox.remove(pos);
                return Ok(());
            }
        }
        
        // Check and remove from outbox
        {
            let mut outbox = self.outbox.write().await;
            if let Some(pos) = outbox.iter().position(|m| m.id == message_id) {
                outbox.remove(pos);
                return Ok(());
            }
        }
        
        // Check and remove from drafts
        {
            let mut drafts = self.drafts.write().await;
            if drafts.remove(message_id).is_some() {
                return Ok(());
            }
        }
        
        Err(MessagingError::MessageNotFound(message_id.to_string()))
    }

    /// Clean up expired messages
    pub async fn cleanup_expired_messages(&self) -> usize {
        let now = Utc::now();
        let mut expired_count = 0;
        
        // Clean inbox
        {
            let mut inbox = self.inbox.write().await;
            let before_len = inbox.len();
            inbox.retain(|msg| {
                msg.expires_at.map(|exp| exp > now).unwrap_or(true)
            });
            expired_count += before_len - inbox.len();
        }
        
        // Clean outbox
        {
            let mut outbox = self.outbox.write().await;
            let before_len = outbox.len();
            outbox.retain(|msg| {
                msg.expires_at.map(|exp| exp > now).unwrap_or(true)
            });
            expired_count += before_len - outbox.len();
        }
        
        // Clean drafts
        {
            let mut drafts = self.drafts.write().await;
            let before_len = drafts.len();
            drafts.retain(|_, msg| {
                msg.expires_at.map(|exp| exp > now).unwrap_or(true)
            });
            expired_count += before_len - drafts.len();
        }
        
        expired_count
    }

    /// Start background message processing
    pub async fn start_background_processor(messenger: Arc<FederationMessenger>) {
        tokio::spawn(async move {
            loop {
                // Clean up expired messages
                let expired_count = messenger.cleanup_expired_messages().await;
                if expired_count > 0 {
                    println!("Cleaned up {} expired messages", expired_count);
                }
                
                // Sleep for a bit
                tokio::time::sleep(tokio::time::Duration::from_secs(300)).await;
            }
        });
    }
}
```

===================
File: ./crates/icn-federation/src/resource_manager.rs
Size: 9420 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use async_trait::async_trait;
use thiserror::Error;

use crate::resource_sharing::{ResourceSharingAgreement, SharingAgreementStatus};

/// Error types for federation resource operations
#[derive(Debug, Error)]
pub enum ResourceError {
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Resource not found: {0}")]
    ResourceNotFound(String),
    
    #[error("Agreement not found: {0}")]
    AgreementNotFound(String),
    
    #[error("Insufficient resources: requested {requested}, available {available}")]
    InsufficientResources { requested: u64, available: u64 },
    
    #[error("Invalid agreement state: {0}")]
    InvalidState(String),
    
    #[error("Unauthorized operation: {0}")]
    Unauthorized(String),
    
    #[error("Insufficient reputation: required {required}, actual {actual}")]
    InsufficientReputation { required: i64, actual: i64 },
    
    #[error("Resource system error: {0}")]
    ResourceSystemError(String),
}

/// Defines methods for managing resource operations
#[async_trait]
pub trait ResourceProvider: Send + Sync {
    /// Check if a federation has sufficient resources of a given type
    async fn has_sufficient_resources(
        &self,
        federation_id: &str, 
        resource_type: &str, 
        amount: u64
    ) -> Result<bool, ResourceError>;
    
    /// Check a federation's reputation score
    async fn get_federation_reputation(
        &self, 
        federation_id: &str
    ) -> Result<i64, ResourceError>;
    
    /// Reserve resources from a federation
    async fn reserve_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError>;
    
    /// Release resources back to a federation
    async fn release_resources(
        &self,
        federation_id: &str,
        resource_type: &str,
        amount: u64
    ) -> Result<(), ResourceError>;
}

/// Manages cross-federation resource sharing agreements
pub struct FederationResourceManager {
    /// Store of all resource sharing agreements
    agreements: RwLock<HashMap<String, ResourceSharingAgreement>>,
    
    /// Provider of resource and reputation operations
    resource_provider: Arc<dyn ResourceProvider>,
}

impl FederationResourceManager {
    /// Create a new FederationResourceManager
    pub fn new(resource_provider: Arc<dyn ResourceProvider>) -> Self {
        Self {
            agreements: RwLock::new(HashMap::new()),
            resource_provider,
        }
    }
    
    /// Propose a new resource sharing agreement
    pub async fn propose_agreement(
        &self,
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        duration_seconds: Option<u64>,
        terms: String,
        min_reputation_score: i64,
    ) -> Result<String, ResourceError> {
        // Check if source federation has sufficient resources
        let has_resources = self.resource_provider
            .has_sufficient_resources(&source_federation_id, &resource_type, amount)
            .await?;
        
        if !has_resources {
            return Err(ResourceError::InsufficientResources {
                requested: amount,
                available: 0, // Actual amount unknown at this level
            });
        }
        
        // Create the agreement
        let agreement = ResourceSharingAgreement::new(
            source_federation_id,
            target_federation_id,
            resource_type,
            amount,
            duration_seconds,
            terms,
            min_reputation_score,
        );
        
        let agreement_id = agreement.id.clone();
        
        // Store the agreement
        let mut agreements = self.agreements.write().await;
        agreements.insert(agreement_id.clone(), agreement);
        
        Ok(agreement_id)
    }
    
    /// Accept a proposed sharing agreement
    pub async fn accept_agreement(
        &self,
        agreement_id: &str,
        target_federation_id: &str,
        signer_did: &str,
        signature: String,
    ) -> Result<(), ResourceError> {
        let mut agreements = self.agreements.write().await;
        
        // Find agreement
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Verify the federation matches
        if agreement.target_federation_id != target_federation_id {
            return Err(ResourceError::Unauthorized(
                "Federation is not the target of this agreement".to_string()
            ));
        }
        
        // Verify federation meets reputation requirements
        let reputation = self.resource_provider
            .get_federation_reputation(target_federation_id)
            .await?;
        
        if reputation < agreement.min_reputation_score {
            return Err(ResourceError::InsufficientReputation {
                required: agreement.min_reputation_score,
                actual: reputation,
            });
        }
        
        // Accept the agreement
        agreement.accept(signer_did, signature)
            .map_err(|e| ResourceError::InvalidState(e))?;
        
        // Reserve the resources from the source federation
        self.resource_provider
            .reserve_resources(
                &agreement.source_federation_id,
                &agreement.resource_type,
                agreement.amount
            )
            .await?;
        
        Ok(())
    }
    
    /// Allocate resources from a sharing agreement
    pub async fn allocate_from_agreement(
        &self,
        agreement_id: &str,
        requester_federation_id: &str,
        requester_did: &str,
        amount: u64,
    ) -> Result<String, ResourceError> {
        let mut agreements = self.agreements.write().await;
        
        // Find agreement
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Verify federation matches
        if agreement.target_federation_id != requester_federation_id {
            return Err(ResourceError::Unauthorized(
                "Federation is not authorized to use this agreement".to_string()
            ));
        }
        
        // Allocate resources
        let allocation_id = agreement.allocate(requester_did, amount)
            .map_err(|e| ResourceError::InvalidState(e))?;
        
        Ok(allocation_id)
    }
    
    /// Release resources back to a sharing agreement
    pub async fn release_to_agreement(
        &self,
        agreement_id: &str,
        allocation_id: &str,
        amount: u64,
    ) -> Result<(), ResourceError> {
        let mut agreements = self.agreements.write().await;
        
        // Find agreement
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Release resources
        agreement.release(allocation_id, amount)
            .map_err(|e| ResourceError::InvalidState(e))?;
        
        Ok(())
    }
    
    /// Terminate a sharing agreement
    pub async fn terminate_agreement(
        &self,
        agreement_id: &str,
        federation_id: &str,
        reason: &str,
    ) -> Result<(), ResourceError> {
        let mut agreements = self.agreements.write().await;
        
        // Find agreement
        let agreement = agreements.get_mut(agreement_id)
            .ok_or_else(|| ResourceError::AgreementNotFound(agreement_id.to_string()))?;
        
        // Verify federation is involved
        if agreement.source_federation_id != federation_id && agreement.target_federation_id != federation_id {
            return Err(ResourceError::Unauthorized(
                "Federation is not involved in this agreement".to_string()
            ));
        }
        
        // Terminate agreement
        agreement.terminate(reason)
            .map_err(|e| ResourceError::InvalidState(e))?;
        
        // If there are any unused resources, release them back to the source federation
        let unused = agreement.amount - agreement.usage_metrics.total_used;
        if unused > 0 {
            self.resource_provider
                .release_resources(
                    &agreement.source_federation_id,
                    &agreement.resource_type,
                    unused
                )
                .await?;
        }
        
        Ok(())
    }
    
    /// Get all agreements for a federation (as source or target)
    pub async fn get_federation_agreements(
        &self,
        federation_id: &str,
    ) -> Vec<ResourceSharingAgreement> {
        let agreements = self.agreements.read().await;
        
        agreements.values()
            .filter(|a| a.source_federation_id == federation_id || a.target_federation_id == federation_id)
            .cloned()
            .collect()
    }
    
    /// Get a specific agreement by ID
    pub async fn get_agreement(
        &self,
        agreement_id: &str,
    ) -> Option<ResourceSharingAgreement> {
        let agreements = self.agreements.read().await;
        agreements.get(agreement_id).cloned()
    }
}```

===================
File: ./crates/icn-federation/src/resource_sharing.rs
Size: 8632 bytes
===================
```rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::Utc;

/// Status of a resource sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SharingAgreementStatus {
    /// Agreement has been proposed but not yet activated
    Proposed,
    /// Agreement is active and resources can be allocated
    Active,
    /// Agreement has expired based on its duration
    Expired,
    /// Agreement has been manually terminated
    Terminated,
    /// Agreement is in dispute resolution
    Disputed,
}

/// Metrics for tracking resource usage in a sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUsageMetrics {
    /// Total amount of resources allocated from this agreement
    pub total_allocated: u64,
    /// Total amount of resources that have been used and released
    pub total_used: u64,
    /// Timestamp of the last activity on this agreement
    pub last_activity: u64,
}

/// Represents a federation resource allocation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAllocation {
    /// Unique identifier for this allocation
    pub id: String,
    /// ID of the agreement this allocation is from
    pub agreement_id: String,
    /// DID of the requester who received the allocation
    pub requester_did: String,
    /// Amount of resources allocated
    pub amount: u64,
    /// When the allocation was created
    pub allocated_at: u64,
    /// When the allocation expires (if applicable)
    pub expires_at: Option<u64>,
}

/// Represents a cross-federation resource sharing agreement
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceSharingAgreement {
    /// Unique identifier for this agreement
    pub id: String,
    /// ID of the source federation that owns the resources
    pub source_federation_id: String,
    /// ID of the target federation receiving the resources
    pub target_federation_id: String,
    /// Type of resource being shared
    pub resource_type: String,
    /// Total amount of resources available in this agreement
    pub amount: u64,
    /// When the agreement started
    pub start_time: u64,
    /// When the agreement ends (if it has a set duration)
    pub end_time: Option<u64>,
    /// Terms of the resource sharing agreement
    pub terms: String,
    /// Current status of the agreement
    pub status: SharingAgreementStatus,
    /// Usage metrics for monitoring and accounting
    pub usage_metrics: ResourceUsageMetrics,
    /// Minimum reputation score required to access resources
    pub min_reputation_score: i64,
    /// Signatures from approving parties (DID -> signature)
    pub approval_signatures: HashMap<String, String>,
    /// Current allocations from this agreement (allocation ID -> allocation)
    pub active_allocations: HashMap<String, ResourceAllocation>,
}

impl ResourceSharingAgreement {
    /// Create a new resource sharing agreement
    pub fn new(
        source_federation_id: String,
        target_federation_id: String,
        resource_type: String,
        amount: u64,
        duration_seconds: Option<u64>,
        terms: String,
        min_reputation_score: i64,
    ) -> Self {
        let id = format!("share_agreement_{}", uuid::Uuid::new_v4());
        let now = Utc::now().timestamp() as u64;
        let end_time = duration_seconds.map(|duration| now + duration);
        
        Self {
            id,
            source_federation_id,
            target_federation_id,
            resource_type,
            amount,
            start_time: now,
            end_time,
            terms,
            status: SharingAgreementStatus::Proposed,
            usage_metrics: ResourceUsageMetrics {
                total_allocated: 0,
                total_used: 0,
                last_activity: now,
            },
            min_reputation_score,
            approval_signatures: HashMap::new(),
            active_allocations: HashMap::new(),
        }
    }
    
    /// Check if the agreement is currently valid for use
    pub fn is_valid(&self) -> bool {
        // Must be in active status
        if self.status != SharingAgreementStatus::Active {
            return false;
        }
        
        // Check if the agreement has expired
        if let Some(end_time) = self.end_time {
            let now = Utc::now().timestamp() as u64;
            if now > end_time {
                return false;
            }
        }
        
        true
    }
    
    /// Calculate how many resources are available for allocation
    pub fn available_resources(&self) -> u64 {
        if self.status != SharingAgreementStatus::Active {
            return 0;
        }
        
        if self.amount <= self.usage_metrics.total_allocated {
            return 0;
        }
        
        self.amount - self.usage_metrics.total_allocated
    }
    
    /// Create a new allocation from this agreement
    pub fn allocate(
        &mut self,
        requester_did: &str,
        amount: u64,
    ) -> Result<String, String> {
        // Check if agreement is valid
        if !self.is_valid() {
            return Err(format!("Agreement is not active: {:?}", self.status));
        }
        
        // Check if enough resources are available
        let available = self.available_resources();
        if amount > available {
            return Err(format!("Insufficient resources: requested {}, available {}", amount, available));
        }
        
        // Create allocation
        let allocation_id = format!("alloc_{}", uuid::Uuid::new_v4());
        let now = Utc::now().timestamp() as u64;
        
        let allocation = ResourceAllocation {
            id: allocation_id.clone(),
            agreement_id: self.id.clone(),
            requester_did: requester_did.to_string(),
            amount,
            allocated_at: now,
            expires_at: None,
        };
        
        // Update metrics
        self.usage_metrics.total_allocated += amount;
        self.usage_metrics.last_activity = now;
        
        // Store allocation
        self.active_allocations.insert(allocation_id.clone(), allocation);
        
        Ok(allocation_id)
    }
    
    /// Release resources from an allocation back to the pool
    pub fn release(&mut self, allocation_id: &str, amount: u64) -> Result<(), String> {
        // Find the allocation
        let allocation = self.active_allocations.get(allocation_id)
            .ok_or_else(|| format!("Allocation not found: {}", allocation_id))?;
        
        // Check if enough resources are allocated
        if amount > allocation.amount {
            return Err(format!(
                "Cannot release more than allocated: requested {}, allocated {}",
                amount, allocation.amount
            ));
        }
        
        // Update metrics
        self.usage_metrics.total_used += amount;
        self.usage_metrics.total_allocated -= amount;
        self.usage_metrics.last_activity = Utc::now().timestamp() as u64;
        
        // If the entire allocation is released, remove it
        if amount == allocation.amount {
            self.active_allocations.remove(allocation_id);
        } else {
            // Otherwise update the allocation amount
            let mut updated_allocation = allocation.clone();
            updated_allocation.amount -= amount;
            self.active_allocations.insert(allocation_id.to_string(), updated_allocation);
        }
        
        Ok(())
    }
    
    /// Accept the agreement, updating its status to Active
    pub fn accept(&mut self, signer_did: &str, signature: String) -> Result<(), String> {
        if self.status != SharingAgreementStatus::Proposed {
            return Err(format!("Agreement is not in proposed state: {:?}", self.status));
        }
        
        // Add signature
        self.approval_signatures.insert(signer_did.to_string(), signature);
        
        // In a real system, we might require multiple signatures
        // For simplicity, we'll activate with just one signature
        self.status = SharingAgreementStatus::Active;
        
        Ok(())
    }
    
    /// Terminate the agreement
    pub fn terminate(&mut self, reason: &str) -> Result<(), String> {
        if self.status != SharingAgreementStatus::Active {
            return Err(format!("Agreement is not active: {:?}", self.status));
        }
        
        self.status = SharingAgreementStatus::Terminated;
        
        // In a real system, we would log the termination reason
        // and handle active allocations
        
        Ok(())
    }
}```

===================
File: ./crates/icn-federation/src/treasury.rs
Size: 16847 bytes
===================
```rs
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use thiserror::Error;
use chrono::{DateTime, Utc};
use uuid::Uuid;
use icn_types::FederationId;
use crate::FederationError;

/// Error types for treasury operations
#[derive(Error, Debug)]
pub enum TreasuryError {
    #[error("Insufficient funds: required {required}, available {available}")]
    InsufficientFunds { required: u64, available: u64 },
    
    #[error("Invalid transaction: {0}")]
    InvalidTransaction(String),
    
    #[error("Unauthorized operation: {0}")]
    Unauthorized(String),
    
    #[error("Asset not found: {0}")]
    AssetNotFound(String),
    
    #[error("Federation not found: {0}")]
    FederationNotFound(String),
    
    #[error("Treasury operation failed: {0}")]
    OperationFailed(String),
}

/// Types of assets managed by the treasury
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub enum AssetType {
    /// Mutual credit units internal to federation
    Credit,
    
    /// Reputation tokens
    ReputationToken,
    
    /// Compute resource allocation
    ComputeResource,
    
    /// Storage resource allocation
    StorageResource,
    
    /// Bandwidth resource allocation
    BandwidthResource,
    
    /// Custom asset type
    Custom(String),
}

/// A transaction in the treasury ledger
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TreasuryTransaction {
    /// Unique transaction ID
    pub id: String,
    
    /// Asset type for this transaction
    pub asset_type: AssetType,
    
    /// Amount being transferred
    pub amount: u64,
    
    /// Sender DID or federation ID
    pub from: String,
    
    /// Recipient DID or federation ID
    pub to: String,
    
    /// Timestamp of the transaction
    pub timestamp: DateTime<Utc>,
    
    /// Transaction state
    pub state: TransactionState,
    
    /// Transaction purpose or description
    pub description: Option<String>,
    
    /// Optional reference to other transactions
    pub references: Vec<String>,
    
    /// Transaction metadata (custom key-value pairs)
    pub metadata: HashMap<String, String>,
}

/// Current state of a transaction
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TransactionState {
    /// Transaction is pending approval
    Pending,
    
    /// Transaction has been executed successfully
    Completed,
    
    /// Transaction has been rejected
    Rejected,
    
    /// Transaction has failed
    Failed,
}

/// Asset balance entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetBalance {
    /// Asset type
    pub asset_type: AssetType,
    
    /// Available balance
    pub available: u64,
    
    /// Reserved/allocated balance
    pub reserved: u64,
    
    /// Total balance (available + reserved)
    pub total: u64,
    
    /// Last update timestamp
    pub last_updated: DateTime<Utc>,
}

/// Budget allocation parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BudgetAllocation {
    /// Asset type
    pub asset_type: AssetType,
    
    /// Total amount to allocate
    pub amount: u64,
    
    /// Period for the allocation (in seconds)
    pub period_seconds: u64,
    
    /// Start timestamp for the allocation
    pub start_time: DateTime<Utc>,
    
    /// End timestamp for the allocation (None means indefinite)
    pub end_time: Option<DateTime<Utc>>,
    
    /// Purpose or use case for this budget
    pub purpose: String,
    
    /// Optional restrictions on usage
    pub restrictions: Option<HashMap<String, String>>,
}

/// Treasury for managing federation assets
pub struct Treasury {
    /// Federation ID owning this treasury
    federation_id: FederationId,
    
    /// Asset balances by asset type
    balances: RwLock<HashMap<AssetType, AssetBalance>>,
    
    /// Transaction history
    transactions: RwLock<Vec<TreasuryTransaction>>,
    
    /// Budget allocations
    budget_allocations: RwLock<HashMap<String, BudgetAllocation>>,
    
    /// Pending transactions requiring approval
    pending_transactions: RwLock<Vec<TreasuryTransaction>>,
    
    /// Multi-signature requirements for transactions
    required_signatures: RwLock<HashMap<AssetType, u32>>,
    
    /// Spending limits by asset type
    spending_limits: RwLock<HashMap<AssetType, u64>>,
}

impl Treasury {
    /// Create a new treasury for a federation
    pub fn new(federation_id: FederationId) -> Self {
        Self {
            federation_id,
            balances: RwLock::new(HashMap::new()),
            transactions: RwLock::new(Vec::new()),
            budget_allocations: RwLock::new(HashMap::new()),
            pending_transactions: RwLock::new(Vec::new()),
            required_signatures: RwLock::new(HashMap::new()),
            spending_limits: RwLock::new(HashMap::new()),
        }
    }

    /// Initialize an asset balance
    pub async fn initialize_asset(&self, asset_type: AssetType, initial_balance: u64) -> Result<(), TreasuryError> {
        let mut balances = self.balances.write().await;
        
        // Check if asset already exists
        if balances.contains_key(&asset_type) {
            return Err(TreasuryError::InvalidTransaction(
                format!("Asset {} already initialized", asset_type_to_string(&asset_type))
            ));
        }
        
        // Create new asset balance
        let balance = AssetBalance {
            asset_type: asset_type.clone(),
            available: initial_balance,
            reserved: 0,
            total: initial_balance,
            last_updated: Utc::now(),
        };
        
        balances.insert(asset_type, balance);
        
        // Record initialization transaction
        let tx = TreasuryTransaction {
            id: Uuid::new_v4().to_string(),
            asset_type: asset_type.clone(),
            amount: initial_balance,
            from: "system".to_string(),
            to: self.federation_id.clone(),
            timestamp: Utc::now(),
            state: TransactionState::Completed,
            description: Some(format!("Initialize {} asset", asset_type_to_string(&asset_type))),
            references: vec![],
            metadata: HashMap::new(),
        };
        
        self.record_transaction(tx).await;
        
        Ok(())
    }

    /// Set required signature count for an asset type
    pub async fn set_required_signatures(&self, asset_type: AssetType, signatures: u32) {
        let mut required = self.required_signatures.write().await;
        required.insert(asset_type, signatures);
    }

    /// Set spending limit for an asset type
    pub async fn set_spending_limit(&self, asset_type: AssetType, limit: u64) {
        let mut limits = self.spending_limits.write().await;
        limits.insert(asset_type, limit);
    }

    /// Record a transaction in the ledger
    async fn record_transaction(&self, transaction: TreasuryTransaction) {
        let mut transactions = self.transactions.write().await;
        transactions.push(transaction);
    }

    /// Get balance for an asset type
    pub async fn get_balance(&self, asset_type: &AssetType) -> Result<AssetBalance, TreasuryError> {
        let balances = self.balances.read().await;
        
        balances.get(asset_type)
            .cloned()
            .ok_or_else(|| TreasuryError::AssetNotFound(asset_type_to_string(asset_type)))
    }

    /// Create a transfer transaction
    pub async fn create_transfer(
        &self,
        asset_type: AssetType,
        amount: u64,
        from: String,
        to: String,
        description: Option<String>,
        references: Vec<String>,
    ) -> Result<String, TreasuryError> {
        // Verify the asset exists
        let mut balances = self.balances.write().await;
        
        let balance = balances.get_mut(&asset_type)
            .ok_or_else(|| TreasuryError::AssetNotFound(asset_type_to_string(&asset_type)))?;
        
        // Check for sufficient funds
        if balance.available < amount {
            return Err(TreasuryError::InsufficientFunds {
                required: amount,
                available: balance.available,
            });
        }
        
        // Check if the transaction needs approval
        let required_signatures = {
            let sigs = self.required_signatures.read().await;
            sigs.get(&asset_type).cloned().unwrap_or(0)
        };
        
        // Check spending limits
        let is_within_limit = {
            let limits = self.spending_limits.read().await;
            match limits.get(&asset_type) {
                Some(&limit) => amount <= limit,
                None => true, // No limit set
            }
        };
        
        let transaction = TreasuryTransaction {
            id: Uuid::new_v4().to_string(),
            asset_type: asset_type.clone(),
            amount,
            from: from.clone(),
            to: to.clone(),
            timestamp: Utc::now(),
            state: if required_signatures > 0 { TransactionState::Pending } else { TransactionState::Completed },
            description,
            references,
            metadata: HashMap::new(),
        };
        
        // If no approval is needed, execute immediately
        if required_signatures == 0 && is_within_limit {
            // Update balances
            balance.available -= amount;
            balance.last_updated = Utc::now();
            
            // Record the transaction
            self.record_transaction(transaction.clone()).await;
            
            return Ok(transaction.id);
        }
        
        // Otherwise, queue for approval
        let mut pending = self.pending_transactions.write().await;
        pending.push(transaction.clone());
        
        // Record as pending transaction
        self.record_transaction(transaction.clone()).await;
        
        Ok(transaction.id)
    }

    /// Approve a pending transaction
    pub async fn approve_transaction(&self, transaction_id: &str, approver: &str) -> Result<(), TreasuryError> {
        let mut pending = self.pending_transactions.write().await;
        let tx_index = pending.iter().position(|tx| tx.id == transaction_id)
            .ok_or_else(|| TreasuryError::InvalidTransaction(format!("Transaction not found: {}", transaction_id)))?;
        
        let transaction = &mut pending[tx_index];
        
        // Add approval to metadata
        let approver_key = format!("approved_by_{}", approver);
        transaction.metadata.insert(approver_key, Utc::now().to_rfc3339());
        
        // Count approvals
        let approval_count = transaction.metadata.keys()
            .filter(|k| k.starts_with("approved_by_"))
            .count() as u32;
        
        // Get required approvals for this asset type
        let required_approvals = {
            let sigs = self.required_signatures.read().await;
            sigs.get(&transaction.asset_type).cloned().unwrap_or(0)
        };
        
        // Execute if we have enough approvals
        if approval_count >= required_approvals {
            // Update transaction state
            transaction.state = TransactionState::Completed;
            
            // Update balances
            let mut balances = self.balances.write().await;
            
            let from_balance = balances.get_mut(&transaction.asset_type)
                .ok_or_else(|| TreasuryError::AssetNotFound(asset_type_to_string(&transaction.asset_type)))?;
            
            // Update sender's balance
            from_balance.available -= transaction.amount;
            from_balance.last_updated = Utc::now();
            
            // Remove from pending queue
            pending.remove(tx_index);
        }
        
        Ok(())
    }

    /// Reject a pending transaction
    pub async fn reject_transaction(&self, transaction_id: &str, rejector: &str, reason: &str) -> Result<(), TreasuryError> {
        let mut pending = self.pending_transactions.write().await;
        let tx_index = pending.iter().position(|tx| tx.id == transaction_id)
            .ok_or_else(|| TreasuryError::InvalidTransaction(format!("Transaction not found: {}", transaction_id)))?;
        
        let transaction = &mut pending[tx_index];
        
        // Update transaction state
        transaction.state = TransactionState::Rejected;
        
        // Add rejection details to metadata
        let rejector_key = format!("rejected_by_{}", rejector);
        transaction.metadata.insert(rejector_key, Utc::now().to_rfc3339());
        transaction.metadata.insert("rejection_reason".to_string(), reason.to_string());
        
        // Remove from pending queue
        pending.remove(tx_index);
        
        Ok(())
    }

    /// Create a new budget allocation
    pub async fn create_budget_allocation(&self, allocation: BudgetAllocation) -> Result<String, TreasuryError> {
        // Verify the asset exists
        let balances = self.balances.read().await;
        if !balances.contains_key(&allocation.asset_type) {
            return Err(TreasuryError::AssetNotFound(asset_type_to_string(&allocation.asset_type)));
        }
        
        // Generate allocation ID
        let allocation_id = Uuid::new_v4().to_string();
        
        // Store the allocation
        let mut budget_allocations = self.budget_allocations.write().await;
        budget_allocations.insert(allocation_id.clone(), allocation);
        
        Ok(allocation_id)
    }

    /// Get all transactions for an asset type
    pub async fn get_transactions_by_asset(&self, asset_type: &AssetType) -> Vec<TreasuryTransaction> {
        let transactions = self.transactions.read().await;
        transactions.iter()
            .filter(|tx| tx.asset_type == *asset_type)
            .cloned()
            .collect()
    }

    /// Get all transactions within a time range
    pub async fn get_transactions_by_time_range(
        &self,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
    ) -> Vec<TreasuryTransaction> {
        let transactions = self.transactions.read().await;
        transactions.iter()
            .filter(|tx| tx.timestamp >= start_time && tx.timestamp <= end_time)
            .cloned()
            .collect()
    }

    /// Get all pending transactions
    pub async fn get_pending_transactions(&self) -> Vec<TreasuryTransaction> {
        let pending = self.pending_transactions.read().await;
        pending.clone()
    }

    /// Reconcile and adjust balances (e.g., for periodic budget allocations)
    pub async fn reconcile_balances(&self) -> Result<HashMap<AssetType, u64>, TreasuryError> {
        let now = Utc::now();
        let mut adjustments = HashMap::new();
        
        // Process budget allocations
        let budget_allocations = self.budget_allocations.read().await;
        
        for (allocation_id, allocation) in budget_allocations.iter() {
            // Skip allocations that haven't started yet
            if allocation.start_time > now {
                continue;
            }
            
            // Skip allocations that have ended
            if let Some(end_time) = allocation.end_time {
                if end_time < now {
                    continue;
                }
            }
            
            // Calculate time since last allocation
            // In a real implementation, we'd track the last allocation time
            // For now, we'll just allocate the full amount as a demonstration
            
            // Update adjustments
            let entry = adjustments.entry(allocation.asset_type.clone()).or_insert(0);
            *entry += allocation.amount;
        }
        
        // Apply adjustments to balances
        let mut balances = self.balances.write().await;
        
        for (asset_type, adjustment) in &adjustments {
            let balance = balances.get_mut(asset_type)
                .ok_or_else(|| TreasuryError::AssetNotFound(asset_type_to_string(asset_type)))?;
            
            balance.available += *adjustment;
            balance.total += *adjustment;
            balance.last_updated = now;
        }
        
        Ok(adjustments)
    }
}

/// Helper function to convert asset type to string
fn asset_type_to_string(asset_type: &AssetType) -> String {
    match asset_type {
        AssetType::Credit => "Credit".to_string(),
        AssetType::ReputationToken => "ReputationToken".to_string(),
        AssetType::ComputeResource => "ComputeResource".to_string(),
        AssetType::StorageResource => "StorageResource".to_string(),
        AssetType::BandwidthResource => "BandwidthResource".to_string(),
        AssetType::Custom(name) => format!("Custom({})", name),
    }
}
```

===================
File: ./crates/icn-governance/src/reputation.rs
Size: 1196 bytes
===================
```rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    pub governance_participation: u32,
    pub resource_contributions: u32,
    pub technical_support: u32,
    pub dispute_resolutions: u32,
    pub last_decay: DateTime<Utc>,
}

impl ReputationScore {
    pub fn apply_decay(&mut self) {
        let now = Utc::now();
        let days_since_decay = (now - self.last_decay).num_days();
        if days_since_decay > 0 {
            let decay_factor = 0.98f64.powi(days_since_decay as i32);
            self.governance_participation = (self.governance_participation as f64 * decay_factor).round() as u32;
            self.resource_contributions = (self.resource_contributions as f64 * decay_factor).round() as u32;
            self.technical_support = (self.technical_support as f64 * decay_factor).round() as u32;
            self.dispute_resolutions = (self.dispute_resolutions as f64 * decay_factor).round() as u32;
            self.last_decay = now;
        }
    }

    pub fn get_aggregate_score(&self) -> u32 {
        self.governance_participation +
        self.resource_contributions +
        self.technical_support +
        self.dispute_resolutions
    }
}
```

===================
File: ./crates/icn-mutual-credit/src/credit_risk.rs
Size: 3526 bytes
===================
```rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use crate::types::{CooperativeId, FederationId};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreditRiskScore {
    pub cooperative_id: CooperativeId,
    pub overall_score: f64,
    pub factors: RiskFactors,
    pub last_updated: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskFactors {
    pub governance_participation: f64,  // 0-1 score based on voting history
    pub resource_contributions: f64,    // 0-1 score based on resource sharing
    pub credit_history: f64,           // 0-1 score based on repayment history
    pub network_endorsements: f64,     // 0-1 score based on federation endorsements
    pub age_factor: f64,               // 0-1 score based on cooperative age
}

pub struct CreditRiskManager {
    risk_scores: HashMap<CooperativeId, CreditRiskScore>,
    factor_weights: RiskWeights,
}

#[derive(Debug, Clone)]
pub struct RiskWeights {
    governance: f64,
    resources: f64,
    credit_history: f64,
    endorsements: f64,
    age: f64,
}

impl CreditRiskManager {
    pub fn new() -> Self {
        Self {
            risk_scores: HashMap::new(),
            factor_weights: RiskWeights {
                governance: 0.25,
                resources: 0.20,
                credit_history: 0.30,
                endorsements: 0.15,
                age: 0.10,
            },
        }
    }

    pub fn calculate_credit_score(&self, cooperative_id: &CooperativeId, factors: RiskFactors) -> f64 {
        let weights = &self.factor_weights;
        
        (factors.governance_participation * weights.governance) +
        (factors.resource_contributions * weights.resources) +
        (factors.credit_history * weights.credit_history) +
        (factors.network_endorsements * weights.endorsements) +
        (factors.age_factor * weights.age)
    }

    pub fn get_borrowing_limit(&self, credit_score: f64, base_limit: f64) -> f64 {
        let multiplier = match credit_score {
            score if score >= 0.8 => 2.0,   // High trust - 2x base limit
            score if score >= 0.6 => 1.5,   // Good standing - 1.5x base limit
            score if score >= 0.4 => 1.0,   // Average - base limit
            score if score >= 0.2 => 0.5,   // Below average - 0.5x base limit
            _ => 0.25,                      // Poor standing - 0.25x base limit
        };
        
        base_limit * multiplier
    }

    pub fn calculate_required_collateral(&self, credit_score: f64) -> f64 {
        match credit_score {
            score if score >= 0.8 => 0.20,  // 20% collateral for high trust
            score if score >= 0.6 => 0.30,  // 30% collateral for good standing
            score if score >= 0.4 => 0.40,  // 40% collateral for average
            score if score >= 0.2 => 0.50,  // 50% collateral for below average
            _ => 0.60,                      // 60% collateral for poor standing
        }
    }

    pub fn update_credit_score(&mut self, cooperative_id: CooperativeId, factors: RiskFactors) {
        let score = self.calculate_credit_score(&cooperative_id, factors.clone());
        let risk_score = CreditRiskScore {
            cooperative_id: cooperative_id.clone(),
            overall_score: score,
            factors,
            last_updated: chrono::Utc::now().timestamp(),
        };
        self.risk_scores.insert(cooperative_id, risk_score);
    }
}
```

===================
File: ./crates/icn-mutual-credit/src/debt_management.rs
Size: 4313 bytes
===================
```rs
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use crate::types::{CooperativeId, DebtId};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebtStatus {
    pub debt_id: DebtId,
    pub cooperative_id: CooperativeId,
    pub amount: f64,
    pub due_date: DateTime<Utc>,
    pub stage: RecoveryStage,
    pub last_updated: DateTime<Utc>,
    pub resolution_attempts: Vec<ResolutionAttempt>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RecoveryStage {
    GracePeriod { ends_at: DateTime<Utc> },
    IncreasedInterest { rate: f64 },
    DisputeResolution { voting_ends_at: DateTime<Utc> },
    FinalPenalty,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolutionAttempt {
    pub timestamp: DateTime<Utc>,
    pub action: ResolutionAction,
    pub outcome: ResolutionOutcome,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResolutionAction {
    PaymentPlan { installments: u32, amount_per_installment: f64 },
    DebtRestructuring { new_terms: String },
    FederationVote { proposal_id: String },
    CollateralLiquidation { amount: f64 },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResolutionOutcome {
    Pending,
    Approved,
    Rejected,
    Completed,
    Failed(String),
}

pub struct DebtManager {
    grace_period: Duration,
    resolution_config: ResolutionConfig,
}

struct ResolutionConfig {
    grace_period_days: i64,
    interest_increase_percent: f64,
    dispute_resolution_days: i64,
}

impl DebtManager {
    pub fn new() -> Self {
        Self {
            grace_period: Duration::days(14), // 14 day grace period
            resolution_config: ResolutionConfig {
                grace_period_days: 14,
                interest_increase_percent: 5.0,
                dispute_resolution_days: 7,
            },
        }
    }

    pub fn initiate_recovery(&self, debt: &mut DebtStatus) {
        let now = Utc::now();
        debt.stage = RecoveryStage::GracePeriod {
            ends_at: now + self.grace_period
        };
        debt.last_updated = now;
    }

    pub fn progress_recovery_stage(&self, debt: &mut DebtStatus) {
        let now = Utc::now();
        debt.stage = match &debt.stage {
            RecoveryStage::GracePeriod { ends_at } if now > *ends_at => {
                RecoveryStage::IncreasedInterest { 
                    rate: self.resolution_config.interest_increase_percent 
                }
            },
            RecoveryStage::IncreasedInterest { .. } => {
                RecoveryStage::DisputeResolution {
                    voting_ends_at: now + Duration::days(self.resolution_config.dispute_resolution_days)
                }
            },
            RecoveryStage::DisputeResolution { voting_ends_at } if now > *voting_ends_at => {
                RecoveryStage::FinalPenalty
            },
            _ => debt.stage.clone(),
        };
        debt.last_updated = now;
    }

    pub fn apply_resolution(&mut self, debt: &mut DebtStatus, action: ResolutionAction) -> ResolutionOutcome {
        let attempt = ResolutionAttempt {
            timestamp: Utc::now(),
            action: action.clone(),
            outcome: ResolutionOutcome::Pending,
        };
        
        let outcome = match action {
            ResolutionAction::PaymentPlan { .. } => {
                // Implement payment plan logic
                ResolutionOutcome::Approved
            },
            ResolutionAction::DebtRestructuring { .. } => {
                // Implement debt restructuring logic
                ResolutionOutcome::Pending
            },
            ResolutionAction::FederationVote { .. } => {
                // Implement federation voting logic
                ResolutionOutcome::Pending
            },
            ResolutionAction::CollateralLiquidation { .. } => {
                // Implement collateral liquidation logic
                ResolutionOutcome::Pending
            },
        };

        debt.resolution_attempts.push(ResolutionAttempt {
            timestamp: attempt.timestamp,
            action,
            outcome: outcome.clone(),
        });

        outcome
    }
}
```

===================
File: ./crates/icn-mutual-credit/src/finance.rs
Size: 3234 bytes
===================
```rs
use serde::{Deserialize, Serialize};
use crate::credit_risk::CreditRiskManager;
use crate::types::{CooperativeId, FederationId};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CollateralRequirement {
    pub amount: f64,
    pub collateral_type: CollateralType,
    pub percentage: f64,
    pub minimum_time_locked: i64,  // Duration in seconds
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CollateralType {
    Tokens { token_id: String },
    Assets { asset_id: String },
    Labor { commitment_hours: u32 },
    FederationGuarantee { federation_id: FederationId },
}

pub struct CreditManager {
    risk_manager: CreditRiskManager,
    credit_limits: HashMap<CooperativeId, f64>,
    collateral_holdings: HashMap<CooperativeId, Vec<CollateralRequirement>>,
}

impl CreditManager {
    pub fn new(risk_manager: CreditRiskManager) -> Self {
        Self {
            risk_manager,
            credit_limits: HashMap::new(),
            collateral_holdings: HashMap::new(),
        }
    }

    pub fn calculate_credit_limit(
        &self,
        cooperative_id: &CooperativeId,
        base_amount: f64,
        credit_score: f64,
    ) -> f64 {
        self.risk_manager.get_borrowing_limit(credit_score, base_amount)
    }

    pub fn calculate_collateral_requirement(
        &self,
        cooperative_id: &CooperativeId,
        credit_amount: f64,
        credit_score: f64,
    ) -> CollateralRequirement {
        let percentage = self.risk_manager.calculate_required_collateral(credit_score);
        let amount = credit_amount * percentage;

        CollateralRequirement {
            amount,
            collateral_type: CollateralType::Tokens {
                token_id: "ICN".to_string(),
            },
            percentage,
            minimum_time_locked: 30 * 24 * 60 * 60, // 30 days in seconds
        }
    }

    pub fn verify_federation_guarantee(
        &self,
        federation_id: &FederationId,
        cooperative_id: &CooperativeId,
        amount: f64,
    ) -> bool {
        // Logic to verify federation members have voted to guarantee the credit
        // This would integrate with the federation's governance system
        true // Placeholder
    }

    pub fn lock_collateral(
        &mut self,
        cooperative_id: CooperativeId,
        requirement: CollateralRequirement,
    ) -> Result<(), String> {
        let holdings = self.collateral_holdings
            .entry(cooperative_id)
            .or_insert_with(Vec::new);
        
        holdings.push(requirement);
        Ok(())
    }

    pub fn release_collateral(
        &mut self,
        cooperative_id: &CooperativeId,
        amount: f64,
    ) -> Result<(), String> {
        if let Some(holdings) = self.collateral_holdings.get_mut(cooperative_id) {
            // Find and remove collateral that matches the amount
            if let Some(pos) = holdings.iter().position(|x| x.amount == amount) {
                holdings.remove(pos);
                return Ok(());
            }
        }
        Err("No matching collateral found".to_string())
    }
}
```

===================
File: ./crates/icn-p2p/src/networking.rs
Size: 36 bytes
===================
```rs
// Empty module file for networking
```

===================
File: ./crates/icn-p2p/src/protocol.rs
Size: 34 bytes
===================
```rs
// Empty module file for protocol
```

===================
File: ./crates/icn-p2p/src/sdp.rs
Size: 6310 bytes
===================
```rs
use std::net::{SocketAddr, UdpSocket};
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Serialize, Deserialize};
use rand::Rng;
use rand::rngs::OsRng;
use x25519_dalek::{PublicKey, EphemeralSecret};
use std::fmt;

// Custom SecretWrapper without deriving Debug
struct SecretWrapper {
    // EphemeralSecret doesn't implement Debug
    secret: EphemeralSecret,
    // But PublicKey does
    public: PublicKey,
}

// Manual Debug implementation that only shows the public key
impl fmt::Debug for SecretWrapper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SecretWrapper")
            .field("public", &self.public)
            .finish()
    }
}

impl Clone for SecretWrapper {
    fn clone(&self) -> Self {
        // We can't clone the EphemeralSecret directly, so create a new one
        let new_secret = EphemeralSecret::random_from_rng(OsRng);
        let new_public = PublicKey::from(&new_secret);
        Self { secret: new_secret, public: new_public }
    }
}

impl SecretWrapper {
    fn new() -> Self {
        let secret = EphemeralSecret::random_from_rng(OsRng);
        let public = PublicKey::from(&secret);
        Self { secret, public }
    }
    
    fn public_key(&self) -> PublicKey {
        self.public
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct SignalingPacket {
    sender_id: String,
    payload: Vec<u8>,
    nonce: Vec<u8>,
}

pub struct SDPManager {
    socket: Arc<UdpSocket>,
    routes: Arc<RwLock<HashMap<String, SocketAddr>>>,
    secret: SecretWrapper,
    peer_keys: Arc<RwLock<HashMap<String, PublicKey>>>,
}

impl SDPManager {
    pub fn new(bind_addr: SocketAddr) -> std::io::Result<Self> {
        let socket = UdpSocket::bind(bind_addr)?;
        socket.set_nonblocking(true)?;
        
        Ok(Self {
            socket: Arc::new(socket),
            routes: Arc::new(RwLock::new(HashMap::new())),
            secret: SecretWrapper::new(),
            peer_keys: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    pub async fn register(&self, id: String, addr: SocketAddr, public_key: PublicKey) {
        self.routes.write().await.insert(id.clone(), addr);
        self.peer_keys.write().await.insert(id, public_key);
    }

    pub async fn unregister(&self, id: &str) {
        self.routes.write().await.remove(id);
        self.peer_keys.write().await.remove(id);
    }

    async fn handle_packet(&self, packet: SignalingPacket, src: SocketAddr) -> Result<(), String> {
        let routes = self.routes.read().await;
        let socket = self.socket.clone();

        if let Some(route) = routes.get(&packet.sender_id) {
            if route != &src {
                // Only forward if source matches registered address
                return Ok(());
            }

            let serialized = serde_json::to_vec(&packet)
                .map_err(|e| format!("Serialization error: {}", e))?;

            socket.send_to(&serialized, *route)
                .map_err(|e| format!("Send error: {}", e))?;
        }

        Ok(())
    }

    pub async fn establish_connection(&self, peer_id: &str) -> Result<Vec<u8>, String> {
        let public = self.secret.public_key();
        let nonce: [u8; 12] = rand::thread_rng().gen();
        
        let routes = self.routes.read().await;
        if !routes.contains_key(peer_id) {
            return Err("Peer not found".to_string());
        }

        let packet = SignalingPacket {
            sender_id: "server".to_string(),
            payload: public.as_bytes().to_vec(),
            nonce: nonce.to_vec(),
        };

        let serialized = serde_json::to_vec(&packet)
            .map_err(|e| format!("Serialization error: {}", e))?;

        if let Some(route) = routes.get(peer_id) {
            self.socket.send_to(&serialized, *route)
                .map_err(|e| format!("Send error: {}", e))?;
        }

        Ok(nonce.to_vec())
    }

    pub async fn send_message(&self, peer_id: &str, data: Vec<u8>, _priority: u8) -> Result<(), String> {
        let routes = self.routes.read().await;
        
        if let Some(route) = routes.get(peer_id) {
            let packet = SignalingPacket {
                sender_id: "server".to_string(),
                payload: data,
                nonce: rand::thread_rng().gen::<[u8; 12]>().to_vec(),
            };

            let serialized = serde_json::to_vec(&packet)
                .map_err(|e| format!("Serialization error: {}", e))?;

            self.socket.send_to(&serialized, *route)
                .map_err(|e| format!("Send error: {}", e))?;
        } else {
            return Err(format!("No route found for peer {}", peer_id));
        }

        Ok(())
    }

    pub async fn start<F>(&self, handler: F) -> Result<(), String> 
    where
        F: Fn(Result<(Vec<u8>, SocketAddr, String), String>) + Send + Sync + 'static
    {
        let socket = self.socket.clone();
        let mut buf = vec![0u8; 65536];
        let handler = Arc::new(handler);

        loop {
            match socket.recv_from(&mut buf) {
                Ok((len, src)) => {
                    let data = &buf[..len];
                    let handler = handler.clone();
                    
                    match serde_json::from_slice::<SignalingPacket>(data) {
                        Ok(packet) => {
                            if let Err(e) = self.handle_packet(packet.clone(), src).await {
                                handler(Err(format!("Packet handling error: {}", e)));
                                continue;
                            }
                            handler(Ok((packet.payload, src, packet.sender_id)));
                        }
                        Err(e) => {
                            handler(Err(format!("Parse error: {}", e)));
                        }
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    tokio::time::sleep(std::time::Duration::from_millis(10)).await;
                }
                Err(e) => {
                    return Err(format!("Recv error: {}", e));
                }
            }
        }
    }

    pub fn get_public_key(&self) -> PublicKey {
        self.secret.public_key()
    }
}
```

===================
File: ./crates/icn-p2p/src/websocket.rs
Size: 35 bytes
===================
```rs
// Empty module file for websocket
```

===================
File: ./crates/icn-storage/src/cache.rs
Size: 4010 bytes
===================
```rs
use std::collections::HashMap;
use std::sync::Mutex;
use std::time::{Duration, Instant};

/// Entry in the storage cache
struct CacheEntry {
    data: Vec<u8>,
    expires_at: Instant,
}

/// Cache for the storage system
pub struct StorageCache {
    entries: Mutex<HashMap<String, CacheEntry>>,
    max_size: usize,
    ttl: Duration,
}

impl StorageCache {
    /// Create a new cache with the specified size limit and TTL
    pub fn new(max_size: usize, ttl: Duration) -> Self {
        Self {
            entries: Mutex::new(HashMap::with_capacity(max_size)),
            max_size,
            ttl,
        }
    }

    /// Store a value in the cache
    pub fn set(&self, key: String, value: Vec<u8>) {
        let mut entries = self.entries.lock().unwrap();
        
        // Clean expired entries if we're at capacity
        if entries.len() >= self.max_size {
            self.remove_expired(&mut entries);
        }
        
        // If still at capacity, remove oldest entry
        if entries.len() >= self.max_size {
            if let Some(oldest_key) = entries.keys()
                .min_by_key(|k| entries.get(*k).map(|e| e.expires_at))
                .cloned() {
                entries.remove(&oldest_key);
            }
        }
        
        entries.insert(key, CacheEntry {
            data: value,
            expires_at: Instant::now() + self.ttl,
        });
    }

    /// Retrieve a value from the cache if it exists and hasn't expired
    pub fn get(&self, key: &str) -> Option<Vec<u8>> {
        let mut entries = self.entries.lock().unwrap();
        
        match entries.get(key) {
            Some(entry) if entry.expires_at > Instant::now() => {
                Some(entry.data.clone())
            }
            _ => {
                // Remove expired entry if it exists
                entries.remove(key);
                None
            }
        }
    }

    /// Remove expired entries from the cache
    fn remove_expired(&self, entries: &mut HashMap<String, CacheEntry>) {
        let now = Instant::now();
        entries.retain(|_, entry| entry.expires_at > now);
    }

    /// Clear all entries from the cache
    pub fn clear(&self) {
        let mut entries = self.entries.lock().unwrap();
        entries.clear();
    }

    /// Get the current number of entries in the cache
    pub fn len(&self) -> usize {
        self.entries.lock().unwrap().len()
    }

    /// Check if the cache is empty
    pub fn is_empty(&self) -> bool {
        self.entries.lock().unwrap().is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;

    #[test]
    fn test_cache_basic_operations() {
        let cache = StorageCache::new(10, Duration::from_secs(1));
        
        // Test set and get
        cache.set("key1".to_string(), vec![1, 2, 3]);
        assert_eq!(cache.get("key1"), Some(vec![1, 2, 3]));
        
        // Test expiration
        thread::sleep(Duration::from_secs(2));
        assert_eq!(cache.get("key1"), None);
    }

    #[test]
    fn test_cache_capacity() {
        let cache = StorageCache::new(2, Duration::from_secs(10));
        
        // Fill cache
        cache.set("key1".to_string(), vec![1]);
        cache.set("key2".to_string(), vec![2]);
        
        // Add one more item
        cache.set("key3".to_string(), vec![3]);
        
        // Verify oldest item was removed
        assert_eq!(cache.len(), 2);
        assert_eq!(cache.get("key1"), None);
        assert_eq!(cache.get("key2"), Some(vec![2]));
        assert_eq!(cache.get("key3"), Some(vec![3]));
    }

    #[test]
    fn test_cache_clear() {
        let cache = StorageCache::new(10, Duration::from_secs(10));
        
        cache.set("key1".to_string(), vec![1]);
        cache.set("key2".to_string(), vec![2]);
        
        assert_eq!(cache.len(), 2);
        
        cache.clear();
        assert!(cache.is_empty());
        assert_eq!(cache.get("key1"), None);
        assert_eq!(cache.get("key2"), None);
    }
}
```

===================
File: ./crates/icn-types/src/errors.rs
Size: 1819 bytes
===================
```rs
use thiserror::Error;
use log::{error, warn};

#[derive(Debug, Error)]
pub enum IcnError {
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Federation error: {0}")]
    FederationError(String),
    
    #[error("Governance error: {0}")]
    GovernanceError(String),
    
    #[error("Identity error: {0}")]
    IdentityError(String),
    
    #[error("Consensus error: {0}")]
    ConsensusError(String),
    
    #[error("Storage error: {0}")]
    StorageError(String),
    
    #[error("Runtime error: {0}")]
    RuntimeError(String),
    
    #[error("Rate limiting: {0}")]
    RateLimitError(String),
    
    #[error("Validation failed: {0}")]
    ValidationError(String),
    
    #[error("Authentication error: {0}")]
    AuthenticationError(String),
    
    #[error("Authorization error: {0}")]
    AuthorizationError(String),
    
    #[error("Resource not found: {0}")]
    NotFoundError(String),
    
    #[error("Request timeout: {0}")]
    TimeoutError(String),
    
    #[error("Invalid input: {0}")]
    InvalidInputError(String),
    
    #[error("System error: {0}")]
    SystemError(String),
    
    #[error("Block error: {0}")]
    BlockError(#[from] super::BlockError),
    
    #[error("Unknown error: {0}")]
    Unknown(String),
}

/// Result type alias for ICN operations
pub type IcnResult<T> = Result<T, IcnError>;

/// Add a helper function for unified error logging
pub fn log_error(error: &IcnError, module: &str) {
    match error {
        IcnError::ValidationError(_) | 
        IcnError::RateLimitError(_) |
        IcnError::AuthorizationError(_) => {
            warn!("[{}] {}", module, error);
        },
        _ => {
            error!("[{}] {}", module, error);
        }
    }
}
```

===================
File: ./frontend/src/App.tsx
Size: 486 bytes
===================
```tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { NodeDashboard } from './components/nodes/NodeDashboard';
import { Layout } from './components/layout/Layout';

function App() {
  return (
    <Router>
      <Layout>
        <Routes>
          <Route path="/" element={<NodeDashboard />} />
          {/* Add other routes as they are implemented */}
        </Routes>
      </Layout>
    </Router>
  );
}

export default App;```

===================
File: ./frontend/src/components/authentication/Authentication.tsx
Size: 1808 bytes
===================
```tsx
// Define missing types
interface AuthResponse {
  did: string;
  challenge: string;
}

interface ZKProof {
  proof: string;
  publicSignals: string[];
}

interface Session {
  did: string;
  token: string;
}

// Add methods to initiate DID authentication, verify credentials, and establish a session
const initiateDIDAuth = async (): Promise<AuthResponse> => {
  try {
    const response = await fetch('http://localhost:8081/api/auth/initiate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error('Failed to initiate DID authentication');
    }

    return await response.json();
  } catch (error) {
    console.error('Error initiating DID authentication:', error);
    throw error;
  }
};

const verifyCredentials = async (proof: ZKProof): Promise<boolean> => {
  try {
    const response = await fetch('http://localhost:8081/api/auth/verify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(proof)
    });

    if (!response.ok) {
      throw new Error('Failed to verify credentials');
    }

    return await response.json();
  } catch (error) {
    console.error('Error verifying credentials:', error);
    throw error;
  }
};

const establishSession = async (did: string): Promise<Session> => {
  try {
    const response = await fetch('http://localhost:8081/api/auth/session', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ did })
    });

    if (!response.ok) {
      throw new Error('Failed to establish session');
    }

    return await response.json();
  } catch (error) {
    console.error('Error establishing session:', error);
    throw error;
  }
};```

===================
File: ./frontend/src/components/community/CommunityDashboard.tsx
Size: 7632 bytes
===================
```tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { AlertCircle, Users, Activity, BarChart3 } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { FixedSizeList as List } from 'react-window';
import ReputationDashboard from '../reputation/ReputationDashboard';

const ResourceRow = ({ index, style, data }) => {
  const resource = data[index];
  return (
    <div style={style}>
      <div className="flex justify-between text-sm mb-2">
        <span>{resource.name}</span>
        <span>{resource.utilization}%</span>
      </div>
      <Progress value={resource.utilization} className="h-2" />
    </div>
  );
};

const CommunityDashboard = () => {
  const [metrics, setMetrics] = useState({
    totalMembers: 0,
    activePolicies: 0,
    resourceUtilization: 0,
    monthlyActivity: [],
    reputationCategories: {
      governance: 0,
      resourceSharing: 0,
      technicalContributions: 0
    }
  });
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockData = {
      totalMembers: 156,
      activePolicies: 3,
      resourceUtilization: 78,
      monthlyActivity: [
        { month: 'Jan', activity: 65 },
        { month: 'Feb', activity: 75 },
        { month: 'Mar', activity: 85 },
        { month: 'Apr', activity: 90 }
      ],
      reputationCategories: {
        governance: 120,
        resourceSharing: 80,
        technicalContributions: 95
      }
    };

    setMetrics(mockData);
    setLoading(false);
  }, []);

  const resourceAllocation = [
    { name: 'Computing Resources', utilization: 75 },
    { name: 'Storage Resources', utilization: 60 },
    { name: 'Network Resources', utilization: 85 }
  ];

  const getListHeight = useCallback(() => {
    return Math.min(window.innerHeight * 0.4, 400);
  }, []);

  return (
    <div className="container mx-auto p-4 space-y-6">
      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="reputation">Reputation</TabsTrigger>
        </TabsList>
        <TabsContent value="overview">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <Card>
              <CardContent className="pt-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium text-gray-500">Total Members</p>
                    <h3 className="text-2xl font-bold">{metrics.totalMembers}</h3>
                  </div>
                  <Users className="h-8 w-8 text-blue-500" />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardContent className="pt-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium text-gray-500">Active Policies</p>
                    <h3 className="text-2xl font-bold">{metrics.activePolicies}</h3>
                  </div>
                  <AlertCircle className="h-8 w-8 text-green-500" />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardContent className="pt-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium text-gray-500">Resource Utilization</p>
                    <h3 className="text-2xl font-bold">{metrics.resourceUtilization}%</h3>
                  </div>
                  <Activity className="h-8 w-8 text-purple-500" />
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardContent className="pt-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm font-medium text-gray-500">Monthly Growth</p>
                    <h3 className="text-2xl font-bold">+12%</h3>
                  </div>
                  <BarChart3 className="h-8 w-8 text-orange-500" />
                </div>
              </CardContent>
            </Card>
          </div>

          <Card>
            <CardHeader>
              <CardTitle>Community Activity</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="h-64">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={metrics.monthlyActivity}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="month" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Line 
                      type="monotone" 
                      dataKey="activity" 
                      stroke="#8884d8"
                      strokeWidth={2}
                    />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Resource Allocation</CardTitle>
            </CardHeader>
            <CardContent>
              <List
                height={getListHeight()}
                itemCount={resourceAllocation.length}
                itemSize={60}
                width="100%"
                itemData={resourceAllocation}
              >
                {ResourceRow}
              </List>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Reputation Categories</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div>
                  <div className="flex justify-between text-sm mb-2">
                    <span>Governance</span>
                    <span>{metrics.reputationCategories.governance}</span>
                  </div>
                  <Progress value={metrics.reputationCategories.governance} className="h-2" />
                </div>
                <div>
                  <div className="flex justify-between text-sm mb-2">
                    <span>Resource Sharing</span>
                    <span>{metrics.reputationCategories.resourceSharing}</span>
                  </div>
                  <Progress value={metrics.reputationCategories.resourceSharing} className="h-2" />
                </div>
                <div>
                  <div className="flex justify-between text-sm mb-2">
                    <span>Technical Contributions</span>
                    <span>{metrics.reputationCategories.technicalContributions}</span>
                  </div>
                  <Progress value={metrics.reputationCategories.technicalContributions} className="h-2" />
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="reputation">
          <ReputationDashboard />
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default CommunityDashboard;
```

===================
File: ./frontend/src/components/consensus/ConsensusMonitor.tsx
Size: 6532 bytes
===================
```tsx
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';

type ConsensusStatus = 'Proposing' | 'Voting' | 'Finalizing' | 'Completed' | 'Failed';

interface ConsensusUpdate {
  round_number: number;
  status: ConsensusStatus;
  coordinator: string;
  votes_count: number;
}

interface BlockFinalized {
  block_number: number;
  transactions_count: number;
  timestamp: number;
}

interface ReputationUpdate {
  did: string;
  change: number;
  new_total: number;
  category: string; // Added category field
}

interface ErrorMessage {
  code: string;
  message: string;
}

interface WebSocketMessage {
  type: 'ConsensusUpdate' | 'BlockFinalized' | 'ReputationUpdate' | 'Error';
  data: ConsensusUpdate | BlockFinalized | ReputationUpdate | ErrorMessage;
}

const ConsensusMonitor: React.FC = () => {
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);
  const [connected, setConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    // Get DID from local storage or context
    const did = localStorage.getItem('userDid') || 'default-did';

    const connectWebSocket = () => {
      if (!wsRef.current) {
        try {
          wsRef.current = new WebSocket('ws://localhost:8080/ws');
          
          wsRef.current.onopen = () => {
            setConnected(true);
            // Send DID in a message after connection
            wsRef.current?.send(JSON.stringify({ type: 'identify', did }));
          };

          wsRef.current.onmessage = (event) => {
            try {
              const message: WebSocketMessage = JSON.parse(event.data);
              setMessages((prev) => [...prev, message].slice(-5)); // Keep last 5 messages
            } catch (e) {
              console.error('Failed to parse WebSocket message:', e);
            }
          };

          wsRef.current.onclose = () => {
            setConnected(false);
            wsRef.current = null;
            // Try to reconnect after 5 seconds
            setTimeout(connectWebSocket, 5000);
          };

          wsRef.current.onerror = (error) => {
            console.error('WebSocket error:', error);
            if (wsRef.current) {
              wsRef.current.close();
              wsRef.current = null;
            }
          };
        } catch (error) {
          console.error('Failed to establish WebSocket connection:', error);
          setTimeout(connectWebSocket, 5000);
        }
      }
    };

    connectWebSocket();

    return () => {
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
    };
  }, []);

  const renderConsensusUpdate = (data: ConsensusUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Consensus Round {data.round_number}</p>
          <Badge variant={
            data.status === 'Completed' ? 'default' :
            data.status === 'Failed' ? 'destructive' :
            'secondary'
          }>
            {data.status}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">Coordinator: {data.coordinator}</p>
        <p className="text-sm text-gray-600">Votes: {data.votes_count}</p>
      </CardContent>
    </Card>
  );

  const renderBlockFinalized = (data: BlockFinalized) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">New Block #{data.block_number}</p>
          <Badge>Finalized</Badge>
        </div>
        <p className="text-sm text-gray-600">Transactions: {data.transactions_count}</p>
        <p className="text-sm text-gray-600">
          Time: {new Date(data.timestamp * 1000).toLocaleString()}
        </p>
      </CardContent>
    </Card>
  );

  const renderReputationUpdate = (data: ReputationUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Reputation Change</p>
          <Badge variant={data.change > 0 ? 'default' : 'destructive'}>
            {data.change > 0 ? '+' : ''}{data.change}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">DID: {data.did}</p>
        <p className="text-sm text-gray-600">New Total: {data.new_total}</p>
        <p className="text-sm text-gray-600">Category: {data.category}</p> {/* Display category */}
      </CardContent>
    </Card>
  );

  const renderMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'ConsensusUpdate':
        return renderConsensusUpdate(message.data as ConsensusUpdate);
      case 'BlockFinalized':
        return renderBlockFinalized(message.data as BlockFinalized);
      case 'ReputationUpdate':
        return renderReputationUpdate(message.data as ReputationUpdate);
      case 'Error':
        const errorData = message.data as ErrorMessage;
        return (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>
              Error {errorData.code}: {errorData.message}
            </AlertDescription>
          </Alert>
        );
      default:
        return null;
    }
  };

  return (
    <div className="space-y-4 p-4">
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Consensus Monitor</CardTitle>
            <Badge variant={connected ? "default" : "destructive"}>
              {connected ? 'Connected' : 'Disconnected'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {messages.map((msg, i) => (
              <div key={i}>{renderMessage(msg)}</div>
            ))}
            {messages.length === 0 && (
              <p className="text-gray-500 text-center py-4">
                No consensus updates yet
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ConsensusMonitor;
```

===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
Size: 5014 bytes
===================
```tsx
import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { AlertCircle, Users, Activity, BarChart3 } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

const CooperativeDashboard = () => {
  const [metrics, setMetrics] = useState({
    totalMembers: 0,
    activeProposals: 0,
    resourceUtilization: 0,
    monthlyActivity: []
  });
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockData = {
      totalMembers: 156,
      activeProposals: 3,
      resourceUtilization: 78,
      monthlyActivity: [
        { month: 'Jan', activity: 65 },
        { month: 'Feb', activity: 75 },
        { month: 'Mar', activity: 85 },
        { month: 'Apr', activity: 90 }
      ]
    };

    setMetrics(mockData);
    setLoading(false);
  }, []);

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Members</p>
                <h3 className="text-2xl font-bold">{metrics.totalMembers}</h3>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{metrics.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Resource Utilization</p>
                <h3 className="text-2xl font-bold">{metrics.resourceUtilization}%</h3>
              </div>
              <Activity className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Monthly Growth</p>
                <h3 className="text-2xl font-bold">+12%</h3>
              </div>
              <BarChart3 className="h-8 w-8 text-orange-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Cooperative Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={metrics.monthlyActivity}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="activity" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Resource Allocation</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Computing Resources</span>
                <span>75%</span>
              </div>
              <Progress value={75} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Storage Resources</span>
                <span>60%</span>
              </div>
              <Progress value={60} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Network Resources</span>
                <span>85%</span>
              </div>
              <Progress value={85} className="h-2" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default CooperativeDashboard;```

