Project Code Dump - Generated Wed Nov  6 08:41:32 PM UTC 2024
======================================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── examples
│   │   ├── blockchain_test.rs
│   │   ├── ws_client.rs
│   │   └── ws_client2.rs
│   ├── lib.rs
│   ├── src
│   │   ├── api
│   │   │   ├── cooperative.rs
│   │   │   └── mod.rs
│   │   ├── blockchain
│   │   │   ├── block.rs
│   │   │   ├── blockchain.rs.bak
│   │   │   ├── chain.rs
│   │   │   ├── mod.rs
│   │   │   └── transaction.rs
│   │   ├── config
│   │   ├── consensus
│   │   │   ├── mod.rs
│   │   │   ├── proof_of_cooperation.rs
│   │   │   ├── tests.rs
│   │   │   └── types.rs
│   │   ├── cooperative
│   │   │   └── mod.rs
│   │   ├── governance
│   │   │   ├── mod.rs
│   │   │   └── proposal.rs
│   │   ├── identity
│   │   │   ├── authentication.rs
│   │   │   ├── did.rs
│   │   │   ├── identity_manager.rs
│   │   │   ├── identity_system.rs
│   │   │   ├── key_pair.rs
│   │   │   └── mod.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── network
│   │   │   └── mod.rs
│   │   ├── reputation
│   │   │   ├── mod.rs
│   │   │   └── reputation_system.rs
│   │   ├── utils
│   │   │   ├── mod.rs
│   │   │   └── notifications.rs
│   │   ├── vm
│   │   │   ├── contract.rs
│   │   │   ├── cooperative_metadata.rs
│   │   │   ├── event.rs
│   │   │   ├── execution_context.rs
│   │   │   ├── mod.rs
│   │   │   ├── opcode.rs
│   │   │   ├── tests
│   │   │   └── vm.rs
│   │   └── websocket
│   │       ├── handler.rs
│   │       └── mod.rs
│   ├── target
│   │   ├── CACHEDIR.TAG
│   │   └── debug
│   │       ├── build
│   │       ├── deps
│   │       ├── examples
│   │       ├── icn-backend
│   │       ├── icn-backend.d
│   │       ├── incremental
│   │       ├── libicn_backend.d
│   │       └── libicn_backend.rlib
│   └── tests
│       └── integration_test.rs
├── contracts
│   ├── cooperative
│   │   └── src
│   │       └── lib.rs
│   └── governance
├── docker
│   ├── backend.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── docs
│   ├── INDEX.md
│   ├── README.md
│   ├── api
│   ├── architecture
│   │   ├── backend
│   │   ├── backend.md
│   │   ├── diagrams
│   │   │   ├── component
│   │   │   ├── component.md
│   │   │   ├── sequence
│   │   │   └── system
│   │   ├── frontend
│   │   ├── overview
│   │   └── overview.md
│   ├── development
│   │   ├── guides
│   │   │   └── documentation-standards.md
│   │   ├── plans
│   │   └── setup
│   ├── docs
│   │   └── index.md
│   ├── guides
│   │   └── index.md
│   ├── mkdocs.yml
│   ├── specifications
│   │   ├── api
│   │   │   └── governance-api.md
│   │   ├── core
│   │   │   ├── 2024-11-01-reputation-system.md
│   │   │   ├── blockchain-system.md
│   │   │   ├── governance-system.md
│   │   │   ├── identity-system.md
│   │   │   ├── proof-of-cooperation.md
│   │   │   ├── reputation-system.md
│   │   │   ├── transaction-system.md
│   │   │   └── vm-system.md
│   │   └── protocols
│   ├── templates
│   │   ├── api-template.md
│   │   ├── core-component-template.md
│   │   └── protocol-template.md
│   └── user
│       ├── guides
│       │   ├── index.md
│       │   ├── onboarding-guide.md
│       │   └── resource-management.md
│       └── tutorials
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   │   ├── consensus
│   │   │   ├── cooperative
│   │   │   ├── governance
│   │   │   ├── identity
│   │   │   └── ui
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── project_code_dump.txt
├── setup_docs.sh
├── setup_venv.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── docmanager.cpython-312.pyc
    │   │   └── specgen.cpython-312.pyc
    │   ├── docmanager.py
    │   ├── docsctl
    │   └── specgen.py
    ├── install_docsctl.sh
    └── requirements.txt

69 directories, 93 files


===================
File: ./backend/src/identity/authentication.rs
===================
// src/identity/authentication.rs

pub struct Authentication {
    // Fields and methods for authentication
}


===================
File: ./backend/src/identity/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::{Serialize, Deserialize};
use rand::{thread_rng, RngCore};
use std::str::FromStr;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    #[serde(serialize_with = "serialize_public_key")]
    #[serde(deserialize_with = "deserialize_public_key")]
    pub public_key: PublicKey,
}

impl DID {
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);
        DID { id, public_key }
    }

    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let mut rng = thread_rng();
        
        // Generate random bytes for the secret key
        let mut secret_key_bytes = [0u8; 32];
        rng.fill_bytes(&mut secret_key_bytes);
        
        // Create secret key from the random bytes
        let secret_key = SecretKey::from_slice(&secret_key_bytes)
            .expect("Random bytes should produce valid key");
            
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);
        let did = DID { id, public_key };
        (did, secret_key)
    }
}

fn serialize_public_key<S>(key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&key.to_string())
}

fn deserialize_public_key<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let key_str = String::deserialize(deserializer)?;
    PublicKey::from_str(&key_str).map_err(serde::de::Error::custom)
}

===================
File: ./backend/src/identity/identity_system.rs
===================
use std::collections::HashMap;
use crate::identity::DID;

#[derive(Clone)]
pub struct IdentitySystem {
    permissions: HashMap<String, Vec<String>>,
    registered_dids: HashMap<String, DID>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        IdentitySystem {
            permissions: HashMap::new(),
            registered_dids: HashMap::new(),
        }
    }

    pub fn get_permissions(&self, did: &str) -> Vec<String> {
        self.permissions.get(did)
            .cloned()
            .unwrap_or_default()
    }

    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.permissions.insert(did.id.clone(), permissions);
        self.registered_dids.insert(did.id.clone(), did);
    }

    pub fn is_registered(&self, did: &str) -> bool {
        self.registered_dids.contains_key(did)
    }

    pub fn add_permission(&mut self, did: &str, permission: String) {
        if let Some(perms) = self.permissions.get_mut(did) {
            if !perms.contains(&permission) {
                perms.push(permission);
            }
        }
    }

    pub fn remove_permission(&mut self, did: &str, permission: &str) {
        if let Some(perms) = self.permissions.get_mut(did) {
            perms.retain(|p| p != permission);
        }
    }

    pub fn get_did(&self, did: &str) -> Option<&DID> {
        self.registered_dids.get(did)
    }
}

===================
File: ./backend/src/identity/key_pair.rs
===================
// src/identity/key_pair.rs

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
}


===================
File: ./backend/src/identity/mod.rs
===================
// src/identity/mod.rs

pub mod did;
// pub mod key_pair;
// pub mod identity_manager;
// pub mod authentication;
pub mod identity_system;

pub use did::DID;
// pub use key_pair::KeyPair;
// pub use identity_manager::IdentityManager;
// pub use authentication::Authentication;
pub use identity_system::IdentitySystem;


===================
File: ./backend/src/identity/identity_manager.rs
===================
// src/identity/identity_manager.rs

pub struct IdentityManager {
    // Fields and methods for managing identities
}


===================
File: ./backend/src/websocket/mod.rs
===================
// backend/src/websocket/mod.rs

mod handler;
pub use handler::WebSocketHandler;

===================
File: ./backend/src/websocket/handler.rs
===================
// src/websocket/handler.rs

// Previous imports remain the same
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::broadcast;
use tokio::sync::mpsc;
use warp::ws::{Message, WebSocket};
use serde::{Serialize, Deserialize};
use futures_util::{StreamExt, SinkExt, stream::{SplitSink, SplitStream}};
use serde_json::json;

use crate::consensus::RoundStatus;
use crate::consensus::types::{ValidatorInfo, ConsensusRound};
use crate::blockchain::Block;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WebSocketMessage {
    ConsensusUpdate {
        round_number: u64,
        status: RoundStatus,
        coordinator: String,
        votes_count: usize,
    },
    BlockFinalized {
        block_number: u64,
        transactions_count: usize,
        timestamp: u64,
    },
    ReputationUpdate {
        did: String,
        change: i64,
        new_total: i64,
        reason: String,
    },
    ValidatorUpdate {
        did: String,
        round: u64,
        status: String,
        reputation: i64,
    },
    CommandResponse {
        command: String,
        status: String,
        message: String,
        data: Option<serde_json::Value>,
    },
    Error {
        code: String,
        message: String,
    }
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
pub enum ClientMessage {
    RegisterValidator {
        did: String,
        initial_reputation: i64,
    },
    SubmitTransaction {
        transaction: serde_json::Value,
    },
    QueryStatus,
    ProposeBlock {
        block: serde_json::Value,
    },
    SubmitVote {
        vote: serde_json::Value,
    },
    QueryReputation {
        did: String,
    },
}

pub struct WebSocketHandler {
    connections: Arc<Mutex<HashMap<String, broadcast::Sender<WebSocketMessage>>>>,
}

impl WebSocketHandler {
    pub fn new() -> Self {
        WebSocketHandler {
            connections: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn handle_connection(&self, ws: WebSocket, did: String) {
        println!("New WebSocket connection from: {}", did);
        
        let (ws_sink, ws_stream) = ws.split();
        let (tx, rx) = mpsc::channel(32);
        
        let (broadcast_tx, _) = broadcast::channel(100);
        
        // Register the connection
        {
            let mut connections = self.connections.lock().unwrap();
            connections.insert(did.clone(), broadcast_tx);
            println!("Registered connection for: {}", did);
        }

        // Spawn the sender task
        let sender_task = tokio::spawn(Self::handle_sending(ws_sink, rx));
        
        // Spawn the receiver task
        let receiver_task = tokio::spawn(Self::handle_receiving(ws_stream, did.clone(), tx.clone()));

        // Send welcome message
        let welcome_msg = WebSocketMessage::CommandResponse {
            command: "connect".to_string(),
            status: "success".to_string(),
            message: format!("Welcome {}! Connected successfully.", did),
            data: None,
        };
        
        let _ = tx.send(welcome_msg).await;

        // Wait for either task to finish
        tokio::select! {
            _ = sender_task => println!("Sender task completed for {}", did),
            _ = receiver_task => println!("Receiver task completed for {}", did),
        }

        // Cleanup
        let mut connections = self.connections.lock().unwrap();
        connections.remove(&did);
        println!("Connection cleaned up for: {}", did);
    }

    async fn handle_sending(
        mut ws_sink: SplitSink<WebSocket, Message>,
        mut rx: mpsc::Receiver<WebSocketMessage>,
    ) {
        while let Some(message) = rx.recv().await {
            if let Ok(json) = serde_json::to_string(&message) {
                if let Err(e) = ws_sink.send(Message::text(json)).await {
                    eprintln!("Error sending message: {}", e);
                    break;
                }
            }
        }
    }

    async fn handle_receiving(
        mut ws_stream: SplitStream<WebSocket>,
        did: String,
        tx: mpsc::Sender<WebSocketMessage>,
    ) {
        while let Some(result) = ws_stream.next().await {
            match result {
                Ok(message) => {
                    if let Ok(text) = message.to_str() {
                        println!("Received message from {}: {}", did, text);
                        
                        let response = match serde_json::from_str::<ClientMessage>(text) {
                            Ok(client_msg) => match client_msg {
                                ClientMessage::RegisterValidator { did, initial_reputation } => {
                                    WebSocketMessage::CommandResponse {
                                        command: "register_validator".to_string(),
                                        status: "success".to_string(),
                                        message: format!("Validator {} registered with {} reputation", did, initial_reputation),
                                        data: Some(json!({
                                            "did": did,
                                            "reputation": initial_reputation
                                        })),
                                    }
                                },
                                ClientMessage::SubmitTransaction { transaction } => {
                                    WebSocketMessage::CommandResponse {
                                        command: "submit_transaction".to_string(),
                                        status: "success".to_string(),
                                        message: "Transaction submitted successfully".to_string(),
                                        data: Some(transaction),
                                    }
                                },
                                ClientMessage::QueryStatus => {
                                    WebSocketMessage::CommandResponse {
                                        command: "query_status".to_string(),
                                        status: "success".to_string(),
                                        message: "Current blockchain status".to_string(),
                                        data: Some(json!({
                                            "height": 1,
                                            "validators": 1,
                                            "pending_transactions": 0
                                        })),
                                    }
                                },
                                ClientMessage::ProposeBlock { block } => {
                                    WebSocketMessage::CommandResponse {
                                        command: "propose_block".to_string(),
                                        status: "success".to_string(),
                                        message: "Block proposed successfully".to_string(),
                                        data: Some(block),
                                    }
                                },
                                ClientMessage::SubmitVote { vote } => {
                                    WebSocketMessage::CommandResponse {
                                        command: "submit_vote".to_string(),
                                        status: "success".to_string(),
                                        message: "Vote submitted successfully".to_string(),
                                        data: Some(vote),
                                    }
                                },
                                ClientMessage::QueryReputation { did } => {
                                    WebSocketMessage::CommandResponse {
                                        command: "query_reputation".to_string(),
                                        status: "success".to_string(),
                                        message: format!("Current reputation for {}", did),
                                        data: Some(json!({
                                            "did": did,
                                            "reputation": 100,
                                            "last_updated": chrono::Utc::now().timestamp()
                                        })),
                                    }
                                },
                            },
                            Err(e) => WebSocketMessage::Error {
                                code: "INVALID_MESSAGE".to_string(),
                                message: format!("Failed to parse message: {}", e),
                            },
                        };

                        if let Err(e) = tx.send(response).await {
                            eprintln!("Error sending response through channel: {}", e);
                            break;
                        }
                    }
                }
                Err(e) => {
                    eprintln!("WebSocket error from {}: {}", did, e);
                    break;
                }
            }
        }
    }

    pub fn broadcast_consensus_update(&self, round: &ConsensusRound) {
        let msg = WebSocketMessage::ConsensusUpdate {
            round_number: round.round_number,
            status: round.status.clone(),
            coordinator: round.coordinator.clone(),
            votes_count: round.votes.len(),
        };
        self.broadcast_message(msg);
    }

    // Removed unused coordinator parameter
    pub fn broadcast_block_finalized(&self, block: &Block) {
        let msg = WebSocketMessage::BlockFinalized {
            block_number: block.index,
            transactions_count: block.transactions.len(),
            timestamp: block.timestamp as u64,
        };
        self.broadcast_message(msg);
    }

    pub fn broadcast_reputation_update(&self, did: String, change: i64, new_total: i64, reason: String) {
        let msg = WebSocketMessage::ReputationUpdate {
            did,
            change,
            new_total,
            reason,
        };
        self.broadcast_message(msg);
    }

    pub fn broadcast_validator_update(&self, validator: ValidatorInfo, round: u64, status: String) {
        let msg = WebSocketMessage::ValidatorUpdate {
            did: validator.did,
            round,
            status,
            reputation: validator.reputation,
        };
        self.broadcast_message(msg);
    }

    fn broadcast_message(&self, msg: WebSocketMessage) {
        if let Ok(connections) = self.connections.lock() {
            println!("Broadcasting message to {} connections", connections.len());
            let msg_str = serde_json::to_string(&msg).unwrap_or_default();
            println!("Broadcast content: {}", msg_str);
            
            for (did, sender) in connections.iter() {
                if let Err(e) = sender.send(msg.clone()) {
                    eprintln!("Failed to broadcast to {}: {}", did, e);
                } else {
                    println!("Successfully broadcast to {}", did);
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_websocket_message_serialization() {
        let msg = WebSocketMessage::CommandResponse {
            command: "test".to_string(),
            status: "success".to_string(),
            message: "Test message".to_string(),
            data: Some(json!({"test": "data"})),
        };

        let serialized = serde_json::to_string(&msg).unwrap();
        assert!(!serialized.is_empty());
        println!("Serialized message: {}", serialized);
    }
}

===================
File: ./backend/src/cooperative/mod.rs
===================


===================
File: ./backend/src/utils/notifications.rs
===================
use chrono::{DateTime, Utc};
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}

===================
File: ./backend/src/utils/mod.rs
===================
pub mod notifications;



===================
File: ./backend/src/vm/contract.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use super::opcode::OpCode;
use super::cooperative_metadata::CooperativeMetadata;

#[derive(Clone, Serialize, Deserialize)]
pub struct Contract {
    pub id: String,
    pub code: Vec<OpCode>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/cooperative_metadata.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct ResourceImpact {
    pub cpu_intensity: u8,
    pub memory_usage: u8,
    pub network_usage: u8,
    pub storage_usage: u8,
    pub bandwidth_usage: u8,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct CooperativeMetadata {
    pub creator_did: String,
    pub cooperative_id: String,
    pub purpose: String,
    pub resource_impact: ResourceImpact,
    pub federation_id: Option<String>,
    pub creation_timestamp: u64,
    pub last_updated: u64,
    pub member_count: u64,
    pub resource_allocation: HashMap<String, u64>,
}


===================
File: ./backend/src/vm/vm.rs
===================
use std::collections::HashMap;
use super::opcode::OpCode;
use super::contract::Contract;
use super::execution_context::ExecutionContext;
use super::cooperative_metadata::CooperativeMetadata;
use super::event::Event;

pub struct VM {
    stack: Vec<i64>,
    memory: HashMap<String, i64>,
    execution_context: Option<ExecutionContext>,
    events: Vec<Event>,
    logs: Vec<String>,
    pub reputation_context: HashMap<String, i64>,
    instruction_limit: usize,
    instruction_pointer: usize,
}

impl VM {
    pub fn new(instruction_limit: usize, reputation_context: HashMap<String, i64>) -> Self {
        VM {
            stack: Vec::new(),
            memory: HashMap::new(),
            execution_context: None,
            events: Vec::new(),
            logs: Vec::new(),
            reputation_context,
            instruction_limit,
            instruction_pointer: 0,
        }
    }

    pub fn get_reputation_context(&self) -> &HashMap<String, i64> {
        &self.reputation_context
    }

    pub fn set_execution_context(&mut self, context: ExecutionContext) {
        self.execution_context = Some(context);
    }

    pub fn execute_contract(&mut self, contract: &Contract) -> Result<(), String> {
        // Check execution context
        let context = self.execution_context.as_ref().ok_or("No execution context".to_string())?;

        // Check caller reputation
        let caller_reputation = self
            .reputation_context
            .get(&context.caller_did)
            .copied()
            .unwrap_or(0);
        if caller_reputation < contract.required_reputation {
            return Err("Insufficient reputation to execute contract".to_string());
        }

        // Check permissions
        for permission in &contract.permissions {
            if !context.permissions.contains(permission) {
                return Err(format!("Missing permission: {}", permission));
            }
        }

        // Execute instructions
        let code_len = contract.code.len();
        self.instruction_pointer = 0;

        while self.instruction_pointer < code_len {
            if self.instruction_pointer >= self.instruction_limit {
                return Err("Instruction limit exceeded".to_string());
            }

            let op = &contract.code[self.instruction_pointer];
            self.execute_instruction(op, &contract.cooperative_metadata)?;

            self.instruction_pointer += 1;
        }

        Ok(())
    }

    pub fn execute_instruction(
        &mut self,
        op: &OpCode,
        metadata: &CooperativeMetadata,
    ) -> Result<(), String> {
        match op {
            OpCode::Push(val) => {
                self.stack.push(*val);
                Ok(())
            }
            OpCode::Pop => {
                self.stack.pop().ok_or("Stack underflow".to_string())?;
                Ok(())
            }
            OpCode::Dup => {
                let val = *self.stack.last().ok_or("Stack underflow")?;
                self.stack.push(val);
                Ok(())
            }
            OpCode::Swap => {
                let len = self.stack.len();
                if len < 2 {
                    return Err("Not enough values on the stack to swap".to_string());
                }
                self.stack.swap(len - 1, len - 2);
                Ok(())
            }
            OpCode::Add => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a + b);
                Ok(())
            }
            OpCode::Sub => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a - b);
                Ok(())
            }
            OpCode::Mul => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a * b);
                Ok(())
            }
            OpCode::Div => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Division by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a / b);
                Ok(())
            }
            OpCode::Mod => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Modulo by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a % b);
                Ok(())
            }
            OpCode::Store(key) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(key.clone(), value);
                Ok(())
            }
            OpCode::Load(key) => {
                let value = self
                    .memory
                    .get(key)
                    .copied()
                    .ok_or("Key not found in memory".to_string())?;
                self.stack.push(value);
                Ok(())
            }
            OpCode::Jump(target) => {
                if *target >= self.instruction_limit {
                    return Err("Jump target out of bounds".to_string());
                }
                self.instruction_pointer = *target;
                Ok(())
            }
            OpCode::JumpIf(target) => {
                let condition = self.stack.pop().ok_or("Stack underflow")?;
                if condition != 0 {
                    if *target >= self.instruction_limit {
                        return Err("Jump target out of bounds".to_string());
                    }
                    self.instruction_pointer = *target;
                }
                Ok(())
            }
            OpCode::CreateCooperative => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"cooperative.create".to_string()) {
                    return Err("Permission denied: cooperative.create".to_string());
                }
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                if reputation < 100 {
                    return Err("Insufficient reputation to create cooperative".to_string());
                }
                self.emit_event(
                    "CooperativeCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::AllocateResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceAllocated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), resource_amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::TransferResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceTransferred",
                    metadata.cooperative_id.clone(),
                    [
                        ("amount".to_string(), resource_amount.to_string()),
                        ("to_member".to_string(), to_member_id.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateCooperativeMetadata => {
                Ok(())
            }
            OpCode::AddCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberAdded",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::RemoveCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberRemoved",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::SetMemberRole => {
                let role = self.stack.pop().ok_or("Stack underflow")?;
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "MemberRoleSet",
                    metadata.cooperative_id.clone(),
                    [
                        ("member_id".to_string(), member_id.to_string()),
                        ("role".to_string(), role.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::CreateProposal => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"proposal.create".to_string()) {
                    return Err("Permission denied: proposal.create".to_string());
                }
                self.emit_event(
                    "ProposalCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CastVote => {
                let vote_value = self.stack.pop().ok_or("Stack underflow")?;
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VoteCast",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("vote_value".to_string(), vote_value.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::DelegateVotes => {
                let delegate_to_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotesDelegated",
                    metadata.cooperative_id.clone(),
                    [("delegate_to".to_string(), delegate_to_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExecuteProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalExecuted",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CancelProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalCancelled",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExtendVotingPeriod => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                let additional_time = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotingPeriodExtended",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("additional_time".to_string(), additional_time.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateQuorum => {
                let new_quorum = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "QuorumUpdated",
                    metadata.cooperative_id.clone(),
                    [("new_quorum".to_string(), new_quorum.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CalculateVotingWeight => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::UpdateReputation(amount) => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                *reputation += *amount;
                self.emit_event(
                    "ReputationUpdated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::GetReputation => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::TransferReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let from_context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;

                    let from_reputation = self
                    .reputation_context
                    .entry(from_context.caller_did.clone())
                    .or_insert(0);
                if *from_reputation < amount {
                    return Err("Insufficient reputation to transfer".to_string());
                }

                *from_reputation -= amount;
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;

                self.emit_event(
                    "ReputationTransferred",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::BurnReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                if *reputation < amount {
                    return Err("Insufficient reputation to burn".to_string());
                }
                *reputation -= amount;
                self.emit_event(
                    "ReputationBurned",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::MintReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;
                self.emit_event(
                    "ReputationMinted",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::VerifyDID => {
                self.stack.push(1); // 1 for true
                Ok(())
            }
            OpCode::UpdateDIDDocument => {
                self.emit_event(
                    "DIDDocumentUpdated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CreateCredential => {
                self.emit_event(
                    "CredentialCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::VerifyCredential => {
                self.stack.push(1); // Assume credential is valid
                Ok(())
            }
            OpCode::RevokeCredential => {
                self.emit_event(
                    "CredentialRevoked",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::InitiateFederation => {
                self.emit_event(
                    "FederationInitiated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinFederation => {
                self.emit_event(
                    "FederationJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveFederation => {
                self.emit_event(
                    "FederationLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::SyncFederationState => {
                self.emit_event(
                    "FederationStateSynced",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateFederationAction => {
                self.stack.push(1); // Assume action is valid
                Ok(())
            }
            OpCode::CreateTransaction => {
                self.emit_event(
                    "TransactionCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateTransaction => {
                self.stack.push(1); // Assume transaction is valid
                Ok(())
            }
            OpCode::SignTransaction => {
                self.emit_event(
                    "TransactionSigned",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::BroadcastTransaction => {
                self.emit_event(
                    "TransactionBroadcasted",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::Log(message) => {
                self.logs.push(format!("Log: {}", message));
                Ok(())
            }
            OpCode::Halt => {
                self.instruction_pointer = self.instruction_limit;
                Ok(())
            }
            OpCode::EmitEvent(event_type) => {
                self.emit_event(event_type, metadata.cooperative_id.clone(), HashMap::new());
                Ok(())
            }
            OpCode::GetBlockNumber => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.block_number as i64);
                Ok(())
            }
            OpCode::GetTimestamp => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.timestamp as i64);
                Ok(())
            }
                // Add the GetCaller implementation here:
            OpCode::GetCaller => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let caller_id_hash = self.hash_did(&context.caller_did);
                self.stack.push(caller_id_hash);
                Ok(())
            }
            
            OpCode::Equal => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a == b { 1 } else { 0 });
                Ok(())
            }
            OpCode::NotEqual => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a != b { 1 } else { 0 });
                Ok(())
            }
            OpCode::GreaterThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a > b { 1 } else { 0 });
                Ok(())
            }
            OpCode::LessThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a < b { 1 } else { 0 });
                Ok(())
            }
            OpCode::And => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a & b);
                Ok(())
            }
            OpCode::Or => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a | b);
                Ok(())
            }
            OpCode::Not => {
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(!a);
                Ok(())
            }
            OpCode::Nop => Ok(()),
        }
    }

    fn emit_event(&mut self, event_type: &str, cooperative_id: String, data: HashMap<String, String>) {
        if let Some(context) = &self.execution_context {
            let event = Event {
                event_type: event_type.to_string(),
                cooperative_id,
                data,
                timestamp: context.timestamp,
            };
            self.events.push(event);
        }
    }

    fn hash_did(&self, did: &str) -> i64 {
        // Simple hash function for example purposes
        did.bytes().fold(0, |acc, b| acc + b as i64)
    }

    fn reverse_hash_did(&self, hash: i64) -> String {
        format!("did:placeholder:{}", hash)
    }

    pub fn get_logs(&self) -> &Vec<String> {
        &self.logs
    }

    pub fn get_events(&self) -> &Vec<Event> {
        &self.events
    }

    pub fn get_stack(&self) -> &Vec<i64> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.memory
    }
}

===================
File: ./backend/src/vm/tests/vm_tests.rs
===================
#[cfg(test)]
mod tests {
    use super::super::*;
    use std::collections::HashMap;

    fn setup_vm() -> VM {
        let instruction_limit = 1000;
        let reputation_context = HashMap::new();
        VM::new(instruction_limit, reputation_context)
    }

    fn default_execution_context() -> ExecutionContext {
        ExecutionContext {
            caller_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            timestamp: 1620000000,
            block_number: 1,
            reputation_score: 100,
            permissions: vec!["cooperative.create".to_string(), "proposal.create".to_string()],
        }
    }

    fn default_cooperative_metadata() -> CooperativeMetadata {
        CooperativeMetadata {
            creator_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            purpose: "Test Cooperative".to_string(),
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: 1620000000,
            last_updated: 1620000000,
            member_count: 1,
            resource_allocation: HashMap::new(),
        }
    }

    #[test]
    fn test_push_pop() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "test_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(20),
                OpCode::Pop,
                OpCode::Push(30),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 10);
        assert_eq!(stack[1], 30);
    }

    #[test]
    fn test_arithmetic_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "arithmetic_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(5),
                OpCode::Add,
                OpCode::Push(2),
                OpCode::Mul,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 30); // (10 + 5) * 2 = 30
    }

    #[test]
    fn test_memory_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "memory_contract".to_string(),
            code: vec![
                OpCode::Push(42),
                OpCode::Store("answer".to_string()),
                OpCode::Load("answer".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 42);
    }

    #[test]
    fn test_control_flow_jump() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_contract".to_string(),
            code: vec![
                OpCode::Push(1),             // 0
                OpCode::Jump(4),             // 1
                OpCode::Push(999),           // 2 (should be skipped)
                OpCode::Halt,                // 3 (should be skipped)
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 1);
        assert_eq!(stack[1], 2);
    }

    #[test]
    fn test_control_flow_jumpif() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_jumpif_contract".to_string(),
            code: vec![
                OpCode::Push(0),             // 0
                OpCode::JumpIf(4),           // 1 (should not jump)
                OpCode::Push(1),             // 2
                OpCode::Halt,                // 3
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1);
    }

    #[test]
    fn test_comparison_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "comparison_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(10),
                OpCode::Equal,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1); // 1 for true
    }

    #[test]
    fn test_cooperative_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "cooperative_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CooperativeCreated");
    }

    #[test]
    fn test_reputation_operations() {
        let mut reputation_context = HashMap::new();
        reputation_context.insert("did:icn:12345".to_string(), 50);

        let mut vm = VM::new(1000, reputation_context);
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "reputation_contract".to_string(),
            code: vec![
                OpCode::UpdateReputation(25),
                OpCode::GetReputation,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 75);

        let updated_reputation = vm.reputation_context.get("did:icn:12345").copied().unwrap_or(0);
        assert_eq!(updated_reputation, 75);
    }

    #[test]
    fn test_error_handling_division_by_zero() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "error_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(0),
                OpCode::Div,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero".to_string());
    }

    #[test]
    fn test_event_emission() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "event_contract".to_string(),
            code: vec![
                OpCode::EmitEvent("CustomEvent".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CustomEvent");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "high_reputation_contract".to_string(),
            code: vec![
                OpCode::Push(1),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 200,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient reputation to execute contract".to_string());
    }

    #[test]
    fn test_missing_permission() {
        let mut vm = setup_vm();
        let mut context = default_execution_context();
        context.permissions = vec![]; // No permissions
        vm.set_execution_context(context);

        let contract = Contract {
            id: "permission_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Missing permission: cooperative.create".to_string());
    }
}


===================
File: ./backend/src/vm/mod.rs
===================
// backend/src/vm/mod.rs

pub mod opcode;
pub mod contract;
pub mod vm;
pub mod execution_context;
pub mod cooperative_metadata;
pub mod event;

pub use contract::Contract;
pub use vm::VM;
pub use execution_context::ExecutionContext;

===================
File: ./backend/src/vm/opcode.rs
===================
// src/vm/opcode.rs

use serde::{Serialize, Deserialize};

/// Enum representing the various operations (`OpCode`) that can be executed in the virtual machine.
/// Each variant is an operation that affects the VM stack, memory, or interacts with other subsystems like
/// cooperative, governance, reputation, identity, federation, and system operations.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Stack Operations
    /// Push a value onto the stack.
    Push(i64),        
    /// Pop the top value from the stack.
    Pop,              
    /// Duplicate the top value on the stack.
    Dup,              
    /// Swap the top two values on the stack.
    Swap,             

    // Arithmetic Operations
    /// Add the top two values on the stack.
    Add,              
    /// Subtract the top two values on the stack.
    Sub,              
    /// Multiply the top two values on the stack.
    Mul,              
    /// Divide the top two values on the stack.
    Div,              
    /// Compute the modulo of the top two values on the stack.
    Mod,              

    // Memory Operations
    /// Store a value in memory with a specific key.
    Store(String),    
    /// Load a value from memory using a specific key.
    Load(String),     

    // Control Flow Operations
    /// Unconditional jump to a specified instruction index.
    Jump(usize),      
    /// Conditional jump to an instruction index if the top of the stack is non-zero.
    JumpIf(usize),    

    // Cooperative Operations
    /// Create a new cooperative entity.
    CreateCooperative,
    /// Join an existing cooperative.
    JoinCooperative,
    /// Leave a cooperative.
    LeaveCooperative,
    /// Allocate resources within a cooperative.
    AllocateResource,
    /// Transfer resources within or between cooperatives.
    TransferResource,
    /// Update cooperative metadata (e.g., purpose, mission).
    UpdateCooperativeMetadata,
    /// Add a member to a cooperative.
    AddCooperativeMember,
    /// Remove a member from a cooperative.
    RemoveCooperativeMember,
    /// Set a specific role for a cooperative member.
    SetMemberRole,

    // Governance Operations
    /// Create a new proposal in governance.
    CreateProposal,
    /// Cast a vote on a proposal.
    CastVote,
    /// Delegate voting rights to another member.
    DelegateVotes,
    /// Execute an approved proposal.
    ExecuteProposal,
    /// Update the quorum requirements for voting.
    UpdateQuorum,
    /// Cancel an existing proposal.
    CancelProposal,
    /// Extend the voting period for a proposal.
    ExtendVotingPeriod,
    /// Calculate the weight of a vote based on certain metrics.
    CalculateVotingWeight,

    // Reputation Operations
    /// Update a member's reputation by a specified value.
    UpdateReputation(i64),
    /// Retrieve a member's reputation.
    GetReputation,
    /// Transfer reputation between members.
    TransferReputation,
    /// Burn (remove) a certain amount of reputation.
    BurnReputation,
    /// Mint (create) a certain amount of reputation.
    MintReputation,

    // Identity Operations
    /// Verify a Decentralized Identifier (DID).
    VerifyDID,
    /// Update a Decentralized Identifier (DID) document.
    UpdateDIDDocument,
    /// Create a new credential associated with a DID.
    CreateCredential,
    /// Verify a given credential.
    VerifyCredential,
    /// Revoke a previously issued credential.
    RevokeCredential,

    // Federation Operations
    /// Initiate the process of federation.
    InitiateFederation,
    /// Join an existing federation.
    JoinFederation,
    /// Leave a federation.
    LeaveFederation,
    /// Synchronize federation state with peers.
    SyncFederationState,
    /// Validate a specific action within the federation.
    ValidateFederationAction,

    // Transaction Operations
    /// Create a new transaction.
    CreateTransaction,
    /// Validate an existing transaction.
    ValidateTransaction,
    /// Sign a transaction for verification purposes.
    SignTransaction,
    /// Broadcast a transaction to the network.
    BroadcastTransaction,

    // System Operations
    /// Log a message to the system logs.
    Log(String),
    /// Halt the execution of the current process.
    Halt,
    /// Emit an event with a message.
    EmitEvent(String),
    /// Retrieve the current block number.
    GetBlockNumber,
    /// Get the current timestamp.
    GetTimestamp,
    /// Retrieve the caller's DID or identity.
    GetCaller,

    // Comparison Operations
    /// Check if the top two stack values are equal.
    Equal,
    /// Check if the top two stack values are not equal.
    NotEqual,
    /// Check if the top value is greater than the second top value.
    GreaterThan,
    /// Check if the top value is less than the second top value.
    LessThan,

    // Logical Operations
    /// Perform logical AND on the top two stack values.
    And,
    /// Perform logical OR on the top two stack values.
    Or,
    /// Perform logical NOT on the top stack value.
    Not,

    // No Operation
    /// No operation (used for padding or delays).
    Nop,
}



===================
File: ./backend/src/vm/event.rs
===================
use std::collections::HashMap;

pub struct Event {
    pub event_type: String,
    pub cooperative_id: String,
    pub data: HashMap<String, String>,
    pub timestamp: u64,
}


===================
File: ./backend/src/vm/execution_context.rs
===================
pub struct ExecutionContext {
    pub caller_did: String,
    pub cooperative_id: String,
    pub timestamp: u64,
    pub block_number: u64,
    pub reputation_score: i64,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/network/mod.rs
===================
// src/network/mod.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::mpsc;
use tokio::net::{TcpListener, TcpStream};
use serde::{Serialize, Deserialize};
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::Message;

use crate::blockchain::Block;
use crate::consensus::ConsensusRound;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum NetworkMessage {
    // Peer discovery and management
    PeerAnnouncement {
        node_id: String,
        address: String,
    },
    PeerList {
        peers: Vec<(String, String)>,
    },
    
    // Consensus messages
    ConsensusProposal {
        round: ConsensusRound,
        block: Block,
    },
    ConsensusVote {
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    },
    
    // Block and transaction propagation
    NewBlock(Block),
    TransactionAnnouncement {
        tx_hash: String,
        from: String,
    },
    
    // Federation protocol messages
    FederationJoinRequest {
        cooperative_id: String,
        federation_id: String,
    },
    FederationResponse {
        approved: bool,
        federation_id: String,
        metadata: HashMap<String, String>,
    },
    
    // Cooperative synchronization
    ResourceStateSync {
        cooperative_id: String,
        resource_updates: HashMap<String, i64>,
    },
    
    // Status and health checks
    Ping(u64),
    Pong(u64),
}

pub struct NetworkHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    message_tx: mpsc::Sender<NetworkMessage>,
    message_rx: mpsc::Receiver<NetworkMessage>,
    listener_address: String,
}

struct PeerConnection {
    address: String,
    tx: mpsc::Sender<Message>,
    last_seen: std::time::Instant,
    reputation: i64,
}

impl NetworkHandler {
    pub fn new(node_id: String, listener_address: String) -> Self {
        let (tx, rx) = mpsc::channel(100);
        
        NetworkHandler {
            node_id,
            peers: Arc::new(Mutex::new(HashMap::new())),
            message_tx: tx,
            message_rx: rx,
            listener_address,
        }
    }

    pub async fn start(&mut self) -> Result<(), String> {
        let listener = TcpListener::bind(&self.listener_address)
            .await
            .map_err(|e| format!("Failed to bind listener: {}", e))?;
            
        println!("Network handler listening on: {}", self.listener_address);

        let peers = self.peers.clone();
        let node_id = self.node_id.clone();
        
        tokio::spawn(async move {
            while let Ok((stream, addr)) = listener.accept().await {
                println!("New connection from: {}", addr);
                
                let peer_handler = PeerHandler::new(
                    node_id.clone(),
                    peers.clone(),
                );
                
                tokio::spawn(async move {
                    if let Err(e) = peer_handler.handle_connection(stream).await {
                        eprintln!("Error handling connection: {}", e);
                    }
                });
            }
        });

        self.process_messages().await?;

        Ok(())
    }

    async fn process_messages(&mut self) -> Result<(), String> {
        while let Some(message) = self.message_rx.recv().await {
            match message {
                NetworkMessage::PeerAnnouncement { node_id, address } => {
                    self.handle_peer_announcement(node_id, address).await?;
                }
                NetworkMessage::NewBlock(block) => {
                    self.broadcast_block(block).await?;
                }
                NetworkMessage::ConsensusProposal { round, block } => {
                    self.broadcast_consensus_proposal(round, block).await?;
                }
                NetworkMessage::ConsensusVote { round_number, voter, approved, signature } => {
                    self.broadcast_consensus_vote(round_number, voter, approved, signature).await?;
                }
                _ => {}
            }
        }
        Ok(())
    }

    async fn handle_peer_announcement(&mut self, peer_id: String, address: String) -> Result<(), String> {
        let mut peers = self.peers.lock().unwrap();
        
        if !peers.contains_key(&peer_id) {
            match self.connect_to_peer(&address).await {
                Ok(connection) => {
                    peers.insert(peer_id.clone(), connection);
                    println!("Connected to peer: {}", peer_id);
                }
                Err(e) => {
                    eprintln!("Failed to connect to peer {}: {}", peer_id, e);
                }
            }
        }
        
        Ok(())
    }

    async fn connect_to_peer(&self, address: &str) -> Result<PeerConnection, String> {
        let url = format!("ws://{}", address);
        let (ws_stream, _) = connect_async(&url)
            .await
            .map_err(|e| format!("Failed to connect to peer: {}", e))?;
            
        let (sink, stream) = ws_stream.split();
        let (tx, mut rx) = mpsc::channel(32);

        tokio::spawn(async move {
            let mut sink = sink;
            while let Some(message) = rx.recv().await {
                if let Err(e) = sink.send(message).await {
                    eprintln!("Failed to send message: {}", e);
                    break;
                }
            }
        });

        tokio::spawn(async move {
            let mut stream = stream;
            while let Some(result) = stream.next().await {
                match result {
                    Ok(msg) => {
                        if let Ok(text) = msg.to_text() {
                            println!("Received message from peer: {}", text);
                        }
                    }
                    Err(e) => {
                        eprintln!("Error reading message: {}", e);
                        break;
                    }
                }
            }
        });

        Ok(PeerConnection {
            address: address.to_string(),
            tx,
            last_seen: std::time::Instant::now(),
            reputation: 0,
        })
    }

    async fn broadcast_block(&self, block: Block) -> Result<(), String> {
        let message = NetworkMessage::NewBlock(block);
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_proposal(&self, round: ConsensusRound, block: Block) -> Result<(), String> {
        let message = NetworkMessage::ConsensusProposal { round, block };
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_vote(
        &self,
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    ) -> Result<(), String> {
        let message = NetworkMessage::ConsensusVote {
            round_number,
            voter,
            approved,
            signature,
        };
        self.broadcast_message(&message).await
    }

    async fn broadcast_message(&self, message: &NetworkMessage) -> Result<(), String> {
        let message_json = serde_json::to_string(message)
            .map_err(|e| format!("Failed to serialize message: {}", e))?;
            
        let peers = self.peers.lock().unwrap();
        
        for (peer_id, connection) in peers.iter() {
            if let Err(e) = connection.tx.send(Message::Text(message_json.clone())).await {
                eprintln!("Failed to send message to peer {}: {}", peer_id, e);
            }
        }
        
        Ok(())
    }
}

struct PeerHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
}

impl PeerHandler {
    fn new(
        node_id: String,
        peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    ) -> Self {
        PeerHandler {
            node_id,
            peers,
        }
    }

    async fn handle_connection(&self, stream: TcpStream) -> Result<(), String> {
        let ws_stream = tokio_tungstenite::accept_async(stream)
            .await
            .map_err(|e| format!("Failed to accept WebSocket connection: {}", e))?;
            
        let (_sink, mut stream) = ws_stream.split();
        
        while let Some(message) = stream.next().await {
            match message {
                Ok(msg) => {
                    if let Ok(text) = msg.to_text() {
                        if let Ok(network_msg) = serde_json::from_str::<NetworkMessage>(text) {
                            self.handle_network_message(network_msg).await?;
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Error reading from WebSocket: {}", e);
                    break;
                }
            }
        }
        
        Ok(())
    }

    async fn handle_network_message(&self, message: NetworkMessage) -> Result<(), String> {
        match message {
            NetworkMessage::PeerAnnouncement { node_id, address } => {
                println!("Received peer announcement from {} at {}", node_id, address);
            }
            NetworkMessage::NewBlock(block) => {
                println!("Received new block: {}", block.index);
            }
            NetworkMessage::ConsensusProposal { round, block: _ } => {
                println!("Received consensus proposal for round {}", round.round_number);
            }
            NetworkMessage::ConsensusVote { round_number, voter, approved: _, signature: _ } => {
                println!("Received consensus vote from {} for round {}", voter, round_number);
            }
            _ => {
                println!("Received other network message type");
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_network_handler() {
        let handler = NetworkHandler::new(
            "test_node".to_string(),
            "127.0.0.1:0".to_string(),
        );
        assert_eq!(handler.node_id, "test_node");
    }
}

===================
File: ./backend/src/api/cooperative.rs
===================


===================
File: ./backend/src/api/mod.rs
===================


===================
File: ./backend/src/blockchain/chain.rs
===================
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use crate::consensus::{ProofOfCooperation, types::ConsensusConfig};
use crate::consensus::types::ConsensusRound;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::vm::{VM, Contract, ExecutionContext};
use crate::vm::event::Event;
use crate::websocket::WebSocketHandler;
use crate::blockchain::{Block, Transaction, TransactionType};

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub contracts: HashMap<String, Contract>,
    pub consensus: Arc<Mutex<ProofOfCooperation>>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub current_block_number: u64,
}

impl Blockchain {
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>, 
        reputation_system: Arc<Mutex<ReputationSystem>>,
    ) -> Self {
        let ws_handler = Arc::new(WebSocketHandler::new());
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler,
        )));

        Blockchain {
            chain: vec![Block::new(0, String::from("0"), vec![])],
            pending_transactions: vec![],
            contracts: HashMap::new(),
            consensus,
            identity_system,
            reputation_system,
            current_block_number: 1,
        }
    }

    pub fn create_contract(&mut self, contract: Contract) {
        self.contracts.insert(contract.id.clone(), contract);
    }

    pub async fn process_transaction(&mut self, transaction: &Transaction) -> Result<(), String> {
        match &transaction.transaction_type {
            TransactionType::Transfer { amount, receiver } => {
                self.validate_transaction(transaction)?;
                println!(
                    "Processing transfer of {} from {} to {}",
                    amount, transaction.sender, receiver
                );
                self.pending_transactions.push(transaction.clone());
                Ok(())
            }
            TransactionType::ContractExecution { contract_id, input_data: _ } => {
                let contract = self.get_contract(contract_id)?;

                let reputation_context = {
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                    reputation_system.get_reputation_context()
                };

                let (permissions, reputation_score) = {
                    let identity_system = self.identity_system.lock()
                        .map_err(|_| "Failed to acquire identity lock".to_string())?;
                    let perms = identity_system.get_permissions(&transaction.sender);
                    
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                    let score = reputation_system.get_reputation(&transaction.sender);
                    
                    (perms, score)
                };

                let mut vm = VM::new(1000, reputation_context);
                let execution_context = ExecutionContext {
                    caller_did: transaction.sender.clone(),
                    cooperative_id: contract.cooperative_metadata.cooperative_id.clone(),
                    timestamp: transaction.timestamp as u64,
                    block_number: self.current_block_number,
                    reputation_score,
                    permissions,
                };

                vm.set_execution_context(execution_context);

                match vm.execute_contract(contract) {
                    Ok(_) => {
                        self.handle_vm_events(&vm.get_events());

                        let mut reputation_system = self.reputation_system.lock()
                            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                        reputation_system.update_reputations(&vm.get_reputation_context());
                        
                        self.pending_transactions.push(transaction.clone());
                        Ok(())
                    }
                    Err(e) => Err(format!("Contract execution failed: {}", e)),
                }
            }
        }
    }

    fn validate_transaction(&self, transaction: &Transaction) -> Result<(), String> {
        let identity_valid = {
            let identity_system = self.identity_system.lock()
                .map_err(|_| "Failed to acquire identity system lock".to_string())?;
            identity_system.is_registered(&transaction.sender)
        };

        if !identity_valid {
            return Err("Invalid sender DID".to_string());
        }

        let reputation_valid = {
            let reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation system lock".to_string())?;
            reputation_system.get_reputation(&transaction.sender) >= 10
        };

        if !reputation_valid {
            return Err("Insufficient reputation".to_string());
        }

        Ok(())
    }

    fn get_contract(&self, contract_id: &str) -> Result<&Contract, String> {
        self.contracts.get(contract_id)
            .ok_or_else(|| format!("Contract {} not found", contract_id))
    }

    fn handle_vm_events(&self, events: &[Event]) {
        for event in events {
            match event.event_type.as_str() {
                "CooperativeCreated" => {
                    println!("Cooperative created: {:?}", event.data);
                }
                "ProposalCreated" => {
                    println!("Proposal created: {:?}", event.data);
                }
                _ => {
                    println!("Unknown event type: {}", event.event_type);
                }
            }
        }
    }

    pub async fn add_transaction(&mut self, transaction: Transaction) -> Result<(), String> {
        self.validate_transaction(&transaction)?;
        self.pending_transactions.push(transaction.clone());
        
        if self.pending_transactions.len() >= 10 {
            self.finalize_block().await?;
        }
        
        Ok(())
    }

    pub async fn finalize_block(&mut self) -> Result<(), String> {
        let previous_hash = self.chain.last()
            .map(|block| block.hash.clone())
            .unwrap_or_default();

        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        let consensus_guard = self.consensus.lock()
            .map_err(|_| "Failed to acquire consensus lock".to_string())?;
        let mut consensus = consensus_guard;
        
        consensus.start_round().await?;
        
        let validators = self.get_active_validators();
        if validators.is_empty() {
            return Err("No active validators available".to_string());
        }

        consensus.propose_block(&validators[0], new_block.clone()).await?;

        for validator in &validators {
            let signature = String::from("dummy_signature");
            consensus.submit_vote(validator, true, signature).await?;
        }

        let block = consensus.finalize_round().await?;
        let updates = consensus.get_reputation_updates().to_vec();
        
        drop(consensus);

        self.chain.push(block);
        self.pending_transactions.clear();
        
        let mut reputation_system = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        for (did, change) in updates {
            reputation_system.increase_reputation(&did, change);
        }

        self.current_block_number += 1;
        Ok(())
    }

    fn get_active_validators(&self) -> Vec<String> {
        vec![
            "did:icn:1".to_string(),
            "did:icn:2".to_string(),
            "did:icn:3".to_string(),
        ]
    }

    pub fn get_block(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    pub fn get_transaction_count(&self) -> usize {
        self.chain.iter().map(|block| block.transactions.len()).sum()
    }

    pub fn get_block_count(&self) -> usize {
        self.chain.len()
    }

    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.consensus.try_lock()
            .ok()
            .and_then(|consensus| consensus.get_current_round().map(|round| round.clone()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_blockchain_new() {
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));

        let blockchain = Blockchain::new(
            identity_system.clone(),
            reputation_system.clone(),
        );

        assert_eq!(blockchain.current_block_number, 1);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.pending_transactions.len(), 0);
    }
}


===================
File: ./backend/src/blockchain/mod.rs
===================
// src/blockchain/mod.rs

mod block;
mod transaction;
mod chain;

// Re-export the core types
pub use block::Block;
pub use transaction::{Transaction, TransactionType};
pub use chain::Blockchain;

// Module-level constants
pub const MAX_BLOCK_SIZE: usize = 1000; // Maximum transactions per block
pub const MIN_REPUTATION_FOR_TXN: i64 = 10; // Minimum reputation to submit transactions

===================
File: ./backend/src/blockchain/block.rs
===================
// src/blockchain/block.rs
use sha2::Digest;
use serde::{Serialize, Deserialize};
use super::Transaction;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u128,
    pub transactions: Vec<Transaction>,
    pub hash: String,
}

impl Block {
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>) -> Self {
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis();
        
        let mut hasher = sha2::Sha256::new();
        let transaction_data = serde_json::to_string(&transactions).unwrap_or_default();
        hasher.update(format!("{}{}{}{}", index, previous_hash, timestamp, transaction_data));
        let hash = format!("{:x}", hasher.finalize());

        Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash,
        }
    }
}

===================
File: ./backend/src/blockchain/transaction.rs
===================
// src/blockchain/transaction.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    Transfer {
        receiver: String,
        amount: u64,
    },
    ContractExecution {
        contract_id: String,
        input_data: HashMap<String, i64>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,
    pub transaction_type: TransactionType,
    pub timestamp: u128,
    pub hash: String,
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);

        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
        }
    }

    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            }
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        let result = hasher.finalize();
        format!("{:x}", result)
    }
}

===================
File: ./backend/src/reputation/reputation_system.rs
===================
use std::collections::HashMap;

pub struct ReputationSystem {
    reputations: HashMap<String, i64>, // DID -> Reputation Score
}

impl ReputationSystem {
    pub fn new() -> Self {
        ReputationSystem {
            reputations: HashMap::new(),
        }
    }

    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.reputations.clone()
    }

    pub fn update_reputations(&mut self, updated_reputations: HashMap<String, i64>) {
        for (did, score) in updated_reputations {
            self.reputations.insert(did, score);
        }
    }

    pub fn get_reputation(&self, did: &str) -> i64 {
        self.reputations.get(did).copied().unwrap_or(0)
    }

    // Additional methods for reputation management...
}


===================
File: ./backend/src/reputation/mod.rs
===================
use std::collections::HashMap;
#[allow(dead_code)]
#[derive(Clone)]
pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) += amount;
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) -= amount;
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        self.increase_reputation(did, reward_points);
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }

    /// Returns a clone of the reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates the reputation context with changes from the VM execution
    pub fn update_reputations(&mut self, updated_reputations: &HashMap<String, i64>) {
        for (did, reputation) in updated_reputations {
            self.scores.insert(did.clone(), *reputation);
        }
    }
}


===================
File: ./backend/src/governance/proposal.rs
===================
// src/governance/proposal.rs

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64, // Minimum reputation required to submit a proposal
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(
        id: u64,
        proposal_type: ProposalType,
        description: String,
        required_reputation: i64,
        duration: u64,
    ) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>, // Track proposals by ID for easier access
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/governance/mod.rs
===================
use std::collections::HashMap;

// ProposalType defines different types of proposals
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

// ProposalStatus represents the current status of a proposal
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

// Proposal struct holds data about each individual proposal
#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String, required_reputation: i64) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

// ProposalHistory struct holds a history of proposals and notifications
#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>,
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/main.rs
===================
mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;
mod websocket;
mod consensus;

use std::sync::{Arc, Mutex};
use warp::Filter;
use crate::websocket::WebSocketHandler;
use crate::blockchain::Blockchain;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::consensus::{ProofOfCooperation, types::ConsensusConfig};

#[tokio::main]
async fn main() {
    // Initialize identity and reputation systems
    let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
    let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
    
    // Create WebSocket handler for real-time updates
    let ws_handler = Arc::new(WebSocketHandler::new());
    
    // Initialize consensus system
    let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
        ConsensusConfig::default(),
        ws_handler.clone(),
    )));

    // Initialize the blockchain with identity and reputation systems
    let blockchain = Arc::new(Mutex::new(Blockchain::new(
        identity_system.clone(),
        reputation_system.clone(),
    )));

    // Define WebSocket route with DID header for user identification
    let ws_handler = ws_handler.clone();
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .and(warp::header::<String>("X-DID"))
        .and(warp::any().map(move || ws_handler.clone()))
        .map(|ws: warp::ws::Ws, did: String, handler: Arc<WebSocketHandler>| {
            ws.on_upgrade(move |socket| async move {
                handler.handle_connection(socket, did).await;
            })
        });

    // Start the WebSocket server
    println!("Starting WebSocket server on localhost:8081");
    warp::serve(ws_route)
        .run(([127, 0, 0, 1], 8081))
        .await;
}


===================
File: ./backend/src/lib.rs
===================
mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;
mod websocket;
mod consensus;
mod network;

// Re-export types for external use
pub use blockchain::{Block, Blockchain, Transaction, TransactionType};
pub use identity::IdentitySystem;
pub use reputation::ReputationSystem;
pub use governance::Proposal;
pub use consensus::types::ConsensusRound;
pub use consensus::{ProofOfCooperation, types::ConsensusConfig};
pub use vm::{VM, Contract, ExecutionContext};
pub use vm::opcode::OpCode;
pub use vm::cooperative_metadata::{CooperativeMetadata, ResourceImpact};
pub use websocket::WebSocketHandler;

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::broadcast;
use uuid;
use chrono;

pub struct ICNCore {
    blockchain: Arc<Mutex<Blockchain>>,
    identity_system: Arc<Mutex<IdentitySystem>>,
    reputation_system: Arc<Mutex<ReputationSystem>>,
    ws_handler: Arc<WebSocketHandler>,
    vm: Arc<Mutex<VM>>,
    event_bus: broadcast::Sender<SystemEvent>,
}

#[derive(Clone, Debug)]
pub enum SystemEvent {
    BlockCreated(Block),
    ProposalSubmitted(Proposal),
    VoteCast { proposal_id: u64, voter: String, vote: bool },
    ReputationChanged { did: String, change: i64, reason: String },
    ConsensusStarted(ConsensusRound),
    ConsensusFinished(Block),
    CooperativeCreated { id: String, creator: String },
    CooperativeJoined { id: String, member: String },
}

impl ICNCore {
    pub fn new() -> Self {
        let (event_tx, _) = broadcast::channel(100);
        
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());

        let blockchain = Arc::new(Mutex::new(Blockchain::new(
            identity_system.clone(),
            reputation_system.clone()
        )));

        let vm = VM::new(1000, reputation_system.lock().unwrap().get_reputation_context());
        let vm = Arc::new(Mutex::new(vm));

        ICNCore {
            blockchain,
            identity_system,
            reputation_system,
            ws_handler,
            vm,
            event_bus: event_tx,
        }
    }

    pub async fn create_cooperative(&self, creator_did: String, metadata: CooperativeMetadata) -> Result<String, String> {
        let identity = self.identity_system.lock()
            .map_err(|_| "Failed to acquire identity lock".to_string())?;
        if !identity.is_registered(&creator_did) {
            return Err("Creator DID not registered".to_string());
        }
        drop(identity);

        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        if reputation.get_reputation(&creator_did) < 100 {
            return Err("Insufficient reputation to create cooperative".to_string());
        }
        let reputation_score = reputation.get_reputation(&creator_did);
        drop(reputation);

        let contract = Contract {
            id: uuid::Uuid::new_v4().to_string(),
            code: vec![OpCode::CreateCooperative],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: metadata.clone(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let context = ExecutionContext {
            caller_did: creator_did.clone(),
            cooperative_id: contract.id.clone(),
            timestamp: chrono::Utc::now().timestamp() as u64,
            block_number: {
                let blockchain = self.blockchain.lock()
                    .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
                blockchain.current_block_number
            },
            reputation_score,
            permissions: vec!["cooperative.create".to_string()],
        };

        {
            let mut vm = self.vm.lock()
                .map_err(|_| "Failed to acquire VM lock".to_string())?;
            vm.set_execution_context(context);
            vm.execute_contract(&contract)?;
        }

        let transaction = Transaction::new(
            creator_did.clone(),
            TransactionType::ContractExecution {
                contract_id: contract.id.clone(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        let event = SystemEvent::CooperativeCreated {
            id: contract.id.clone(),
            creator: creator_did,
        };
        let _ = self.event_bus.send(event);

        Ok(contract.id)
    }

    pub async fn submit_proposal(&self, creator_did: String, proposal: Proposal) -> Result<u64, String> {
        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        if reputation.get_reputation(&creator_did) < proposal.required_reputation {
            return Err("Insufficient reputation to create proposal".to_string());
        }
        drop(reputation);

        let transaction = Transaction::new(
            creator_did,
            TransactionType::ContractExecution {
                contract_id: "governance".to_string(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        let event = SystemEvent::ProposalSubmitted(proposal.clone());
        let _ = self.event_bus.send(event);

        Ok(proposal.id)
    }

    pub async fn start_consensus_round(&self) -> Result<(), String> {
        let blockchain = self.blockchain.lock()
            .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
        
        if let Some(round) = blockchain.get_current_round() {
            drop(blockchain);
            // Fix applied here for type conversion
            let event = SystemEvent::ConsensusStarted(round.into());
            let _ = self.event_bus.send(event);
        }

        Ok(())
    }

    pub fn subscribe_to_events(&self) -> broadcast::Receiver<SystemEvent> {
        self.event_bus.subscribe()
    }
}

pub struct CooperativeManager {
    core: Arc<ICNCore>,
}

impl CooperativeManager {
    pub fn new(core: Arc<ICNCore>) -> Self {
        CooperativeManager { core }
    }

    pub async fn create_cooperative(
        &self, 
        creator_did: String, 
        _name: String,
        purpose: String
    ) -> Result<String, String> {
        let metadata = CooperativeMetadata {
            creator_did: creator_did.clone(),
            cooperative_id: uuid::Uuid::new_v4().to_string(),
            purpose,
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: chrono::Utc::now().timestamp() as u64,
            last_updated: chrono::Utc::now().timestamp() as u64,
            member_count: 1,
            resource_allocation: HashMap::new(),
        };

        self.core.create_cooperative(creator_did, metadata).await
    }

    pub async fn join_cooperative(&self, cooperative_id: String, member_did: String) -> Result<(), String> {
        let event = SystemEvent::CooperativeJoined {
            id: cooperative_id,
            member: member_did,
        };
        let _ = self.core.event_bus.send(event);
        Ok(())
    }
}

pub struct ICNNode {
    core: Arc<ICNCore>,
    node_id: String,
    peers: Arc<Mutex<HashMap<String, String>>>,
}

impl ICNNode {
    pub fn new(core: Arc<ICNCore>, node_id: String) -> Self {
        ICNNode {
            core,
            node_id,
            peers: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn start(&self) -> Result<(), String> {
        let mut event_rx = self.core.subscribe_to_events();
        self.core.start_consensus_round().await?;

        tokio::spawn(async move {
            while let Ok(event) = event_rx.recv().await {
                match event {
                    SystemEvent::BlockCreated(block) => {
                        println!("New block created: {}", block.index);
                    }
                    SystemEvent::ConsensusStarted(round) => {
                        println!("New consensus round started: {}", round.round_number);
                    }
                    _ => {}
                }
            }
        });

        Ok(())
    }

    pub async fn connect_to_peer(&self, peer_id: String, address: String) -> Result<(), String> {
        self.peers.lock()
            .map_err(|_| "Failed to acquire peers lock".to_string())?
            .insert(peer_id, address);
        Ok(())
    }
}


===================
File: ./backend/src/consensus/tests.rs
===================
# File: ./backend/src/consensus/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::blockchain::Blockchain;
    use crate::identity::IdentitySystem;
    use crate::reputation::ReputationSystem;

    fn setup_test_blockchain() -> Blockchain {
        let identity_system = IdentitySystem::new();
        let reputation_system = ReputationSystem::new();
        let mut blockchain = Blockchain::new(identity_system, reputation_system);
        
        // Register test validators
        blockchain.consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:3".to_string(), 100).unwrap();
        
        blockchain
    }

    #[test]
    fn test_consensus_integration() {
        let mut blockchain = setup_test_blockchain();
        
        // Add some test transactions
        let transaction = Transaction::new(
            "did:icn:1".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:2".to_string(),
                amount: 100,
            },
        );
        blockchain.add_transaction(transaction);

        // Try to finalize block through consensus
        assert!(blockchain.finalize_block().is_ok());
        
        // Verify block was added
        assert_eq!(blockchain.chain.len(), 2);
        
        // Verify reputation updates were applied
        let reputation_updates = blockchain.consensus.get_reputation_updates();
        assert!(!reputation_updates.is_empty());
    }

    #[test]
    fn test_consensus_failure_recovery() {
        let mut blockchain = setup_test_blockchain();
        
        // Simulate a failed consensus round
        blockchain.consensus.start_round().unwrap();
        blockchain.consensus.check_timeout();
        
        // Verify we can start a new round after failure
        assert!(blockchain.finalize_block().is_ok());
    }
}

===================
File: ./backend/src/consensus/types.rs
===================
// backend/src/consensus/types.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::blockchain::Block;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatorInfo {
    pub did: String,
    pub reputation: i64,
    pub voting_power: f64,
    pub last_active_round: u64,
    pub consecutive_missed_rounds: u32,
    pub total_blocks_validated: u64,
    pub performance_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRoundStats {
    pub total_voting_power: f64,
    pub participation_rate: f64,
    pub approval_rate: f64,
    pub round_duration_ms: u64,
    pub validator_count: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeightedVote {
    pub validator: String,
    pub approve: bool,
    pub voting_power: f64,
    pub timestamp: DateTime<Utc>,
    pub signature: String,
}

// Making ConsensusRound public so it can be accessed from other modules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    pub round_number: u64,
    pub coordinator: String,
    pub start_time: DateTime<Utc>,
    pub timeout: DateTime<Utc>,
    pub status: RoundStatus,
    pub proposed_block: Option<Block>,
    pub votes: HashMap<String, WeightedVote>,
    pub stats: ConsensusRoundStats,
}

impl ConsensusRound {
    pub fn duration_ms(&self) -> i64 {
        (Utc::now() - self.start_time).num_milliseconds()
    }

    pub fn is_timed_out(&self) -> bool {
        Utc::now() > self.timeout
    }

    pub fn get_participation_rate(&self, total_voting_power: f64) -> f64 {
        let votes_power: f64 = self.votes.values()
            .map(|v| v.voting_power)
            .sum();
        votes_power / total_voting_power
    }

    pub fn get_approval_rate(&self) -> f64 {
        let total_votes_power: f64 = self.votes.values()
            .map(|v| v.voting_power)
            .sum();
        
        if total_votes_power <= 0.0 {
            return 0.0;
        }

        let approval_power: f64 = self.votes.values()
            .filter(|v| v.approve)
            .map(|v| v.voting_power)
            .sum();

        approval_power / total_votes_power
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    Proposing,
    Voting,
    Finalizing,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusConfig {
    pub min_validator_reputation: i64,
    pub max_voting_power: f64,
    pub min_participation_rate: f64,
    pub min_approval_rate: f64,
    pub round_timeout_ms: u64,
    pub base_reward: i64,
    pub penalty_factor: f64,
}

impl Default for ConsensusConfig {
    fn default() -> Self {
        ConsensusConfig {
            min_validator_reputation: 100,
            max_voting_power: 0.1,
            min_participation_rate: 0.67,
            min_approval_rate: 0.67,
            round_timeout_ms: 30_000,
            base_reward: 10,
            penalty_factor: 1.5,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusError {
    InsufficientValidators,
    InvalidCoordinator,
    RoundInProgress,
    NoActiveRound,
    InvalidRoundState,
    TimedOut,
    ValidationFailed,
    NotValidator,
    InsufficientReputation,
    Custom(String),
}

impl std::fmt::Display for ConsensusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConsensusError::InsufficientValidators => 
                write!(f, "Insufficient number of active validators"),
            ConsensusError::InvalidCoordinator => 
                write!(f, "Invalid coordinator for this round"),
            ConsensusError::RoundInProgress => 
                write!(f, "Consensus round already in progress"),
            ConsensusError::NoActiveRound => 
                write!(f, "No active consensus round"),
            ConsensusError::InvalidRoundState => 
                write!(f, "Invalid round state for requested operation"),
            ConsensusError::TimedOut => 
                write!(f, "Consensus round timed out"),
            ConsensusError::ValidationFailed => 
                write!(f, "Block validation failed"),
            ConsensusError::NotValidator => 
                write!(f, "Not a registered validator"),
            ConsensusError::InsufficientReputation => 
                write!(f, "Insufficient reputation for operation"),
            ConsensusError::Custom(msg) => 
                write!(f, "{}", msg),
        }
    }
}

impl std::error::Error for ConsensusError {}

impl From<ConsensusError> for String {
    fn from(error: ConsensusError) -> String {
        error.to_string()
    }
}

pub mod utils {
    pub fn calculate_voting_power(reputation: i64, total_reputation: i64, max_power: f64) -> f64 {
        let raw_power = reputation as f64 / total_reputation as f64;
        raw_power.min(max_power)
    }

    pub fn calculate_penalty(base_penalty: i64, consecutive_misses: u32, factor: f64) -> i64 {
        -(base_penalty as f64 * factor * consecutive_misses as f64) as i64
    }
}


===================
File: ./backend/src/consensus/mod.rs
===================
pub mod proof_of_cooperation;
pub mod types;

pub use proof_of_cooperation::ProofOfCooperation;
pub use types::{ConsensusRound, RoundStatus, ConsensusConfig};  // Directly re-export from `types`

use std::sync::{Arc, Mutex};
use crate::blockchain::{Block, Transaction};
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub consensus: Arc<Mutex<ProofOfCooperation>>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub current_block_number: u64,
}

impl Blockchain {
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>, 
        reputation_system: Arc<Mutex<ReputationSystem>>,
        consensus: Arc<Mutex<ProofOfCooperation>>,
    ) -> Self {
        Blockchain {
            chain: vec![Block::new(0, String::from("0"), vec![])],
            pending_transactions: vec![],
            consensus,
            identity_system,
            reputation_system,
            current_block_number: 1,
        }
    }

    pub async fn finalize_block(&mut self) -> Result<(), String> {
        // Get consensus lock first
        let mut consensus = self.consensus.lock()
            .map_err(|_| "Failed to acquire consensus lock".to_string())?;

        // Start consensus round
        consensus.start_round().await?;

        let previous_hash = self.chain.last()
            .map(|block| block.hash.clone())
            .unwrap_or_default();

        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        let validators = self.get_active_validators();
        if validators.is_empty() {
            return Err("No active validators available".to_string());
        }

        // Drop current consensus lock before proposing block
        drop(consensus);

        // Propose block with new lock
        {
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            consensus.propose_block(&validators[0], new_block.clone()).await?;
        }

        // Submit votes
        for validator in validators {
            let signature = String::from("dummy_signature");
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            consensus.submit_vote(&validator, true, signature).await?;
        }

        // Finalize round
        let (finalized_block, reputation_updates) = {
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            let block = consensus.finalize_round().await?;
            let updates = consensus.get_reputation_updates().to_vec();
            (block, updates)
        };

        // Update state
        self.chain.push(finalized_block);
        self.pending_transactions.clear();
        
        // Apply reputation updates
        {
            let mut reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation lock".to_string())?;
            for (did, change) in reputation_updates {
                reputation_system.increase_reputation(&did, change);
            }
        }

        self.current_block_number += 1;
        Ok(())
    }

    fn get_active_validators(&self) -> Vec<String> {
        vec![
            "did:icn:1".to_string(),
            "did:icn:2".to_string(),
            "did:icn:3".to_string(),
        ]
    }

    pub async fn add_transaction(&mut self, transaction: Transaction) -> Result<(), String> {
        self.pending_transactions.push(transaction);
        if self.pending_transactions.len() >= 10 {
            self.finalize_block().await?;
        }
        Ok(())
    }

    pub fn get_block(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    pub fn get_transaction_count(&self) -> usize {
        self.chain.iter().map(|block| block.transactions.len()).sum()
    }

    pub fn get_block_count(&self) -> usize {
        self.chain.len()
    }

    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.consensus.try_lock()
            .ok()
            .and_then(|consensus| consensus.get_current_round())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::websocket::WebSocketHandler;

    #[tokio::test]
    async fn test_blockchain_new() {
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());
        
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler,
        )));

        let blockchain = Blockchain::new(
            identity_system,
            reputation_system,
            consensus,
        );

        assert_eq!(blockchain.current_block_number, 1);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.pending_transactions.len(), 0);
    }
}


===================
File: ./backend/src/consensus/proof_of_cooperation.rs
===================
// backend/src/consensus/proof_of_cooperation.rs

use std::sync::Arc;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use rand::{thread_rng, Rng};

use crate::websocket::WebSocketHandler;
use crate::blockchain::Block;
use crate::consensus::types::{
    ConsensusConfig,
    RoundStatus,
    WeightedVote,
    ValidatorInfo,
    ConsensusRoundStats,
    ConsensusRound,  // Now directly using ConsensusRound from types
};

pub struct ProofOfCooperation {
    config: ConsensusConfig,
    validators: HashMap<String, ValidatorInfo>,
    current_round: Option<ConsensusRound>,
    round_history: Vec<ConsensusRoundStats>,
    reputation_updates: Vec<(String, i64)>,
    ws_handler: Arc<WebSocketHandler>,
}

impl ProofOfCooperation {
    pub fn new(config: ConsensusConfig, ws_handler: Arc<WebSocketHandler>) -> Self {
        ProofOfCooperation {
            config,
            validators: HashMap::new(),
            current_round: None,
            round_history: Vec::new(),
            reputation_updates: Vec::new(),
            ws_handler,
        }
    }

    pub async fn start_round(&mut self) -> Result<(), String> {
        if self.current_round.is_some() {
            return Err("Round already in progress".to_string());
        }

        let active_validators: Vec<_> = self.validators.values()
            .filter(|v| v.reputation >= self.config.min_validator_reputation)
            .collect();

        if active_validators.len() < 3 {
            return Err("Insufficient validators".to_string());
        }

        let coordinator = self.select_coordinator(&active_validators)?;
        
        let round = ConsensusRound {
            round_number: self.round_history.len() as u64 + 1,
            coordinator: coordinator.did.clone(),
            start_time: Utc::now(),
            timeout: Utc::now() + chrono::Duration::milliseconds(self.config.round_timeout_ms as i64),
            status: RoundStatus::Proposing,
            proposed_block: None,
            votes: HashMap::new(),
            stats: ConsensusRoundStats {
                total_voting_power: 0.0,
                participation_rate: 0.0,
                approval_rate: 0.0,
                round_duration_ms: 0,
                validator_count: active_validators.len(),
            },
        };

        self.ws_handler.broadcast_consensus_update(&round);
        self.current_round = Some(round);
        Ok(())
    }

    pub async fn propose_block(&mut self, proposer_did: &str, block: Block) -> Result<(), String> {
        let validator = self.validators.get(proposer_did)
            .ok_or("Proposer not found")?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err("Insufficient reputation to propose".to_string());
        }

        let mut round = self.current_round.take()
            .ok_or("No active round")?;

        if round.coordinator != proposer_did {
            self.current_round = Some(round);
            return Err("Not the round coordinator".to_string());
        }

        round.proposed_block = Some(block.clone());
        round.status = RoundStatus::Voting;

        self.ws_handler.broadcast_consensus_update(&round);
        self.ws_handler.broadcast_block_finalized(&block);
        self.current_round = Some(round);
        Ok(())
    }

    pub async fn submit_vote(&mut self, validator_did: &str, approved: bool, signature: String) -> Result<(), String> {
        let validator = self.validators.get(validator_did)
            .ok_or("Not a registered validator")?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err("Insufficient reputation to vote".to_string());
        }

        let vote = WeightedVote {
            validator: validator_did.to_string(),
            approve: approved,
            voting_power: validator.voting_power,
            timestamp: Utc::now(),
            signature,
        };

        let mut round = self.current_round.take()
            .ok_or("No active round")?;

        round.votes.insert(validator_did.to_string(), vote);

        let total_power: f64 = self.validators.values()
            .filter(|v| v.reputation >= self.config.min_validator_reputation)
            .map(|v| v.voting_power)
            .sum();

        let votes_power: f64 = round.votes.values()
            .map(|v| v.voting_power)
            .sum();

        round.stats.total_voting_power = total_power;
        round.stats.participation_rate = votes_power / total_power;

        let approval_power: f64 = round.votes.values()
            .filter(|v| v.approve)
            .map(|v| v.voting_power)
            .sum();

        round.stats.approval_rate = if votes_power > 0.0 {
            approval_power / votes_power
        } else {
            0.0
        };

        if round.stats.participation_rate >= self.config.min_participation_rate
            && round.stats.approval_rate >= self.config.min_approval_rate {
            round.status = RoundStatus::Finalizing;
        }

        self.ws_handler.broadcast_consensus_update(&round);
        self.ws_handler.broadcast_validator_update(
            validator.clone(),
            round.round_number,
            if approved { "approved".to_string() } else { "rejected".to_string() }
        );

        self.current_round = Some(round);
        Ok(())
    }

    pub async fn finalize_round(&mut self) -> Result<Block, String> {
        let round = self.current_round.take()
            .ok_or("No active round")?;

        if round.status != RoundStatus::Finalizing {
            self.current_round = Some(round);
            return Err("Round not ready for finalization".to_string());
        }

        let block = round.proposed_block.clone()
            .ok_or("No proposed block")?;

        // Update validator stats
        for (validator_id, validator) in self.validators.iter_mut() {
            if round.votes.contains_key(validator_id) {
                validator.consecutive_missed_rounds = 0;
                validator.last_active_round = round.round_number;
                validator.reputation += self.config.base_reward;

                if validator_id == &round.coordinator {
                    validator.reputation += self.config.base_reward;
                }

                self.reputation_updates.push((
                    validator_id.clone(),
                    self.config.base_reward
                ));

                validator.performance_score = validator.performance_score * 0.95 + 0.05;
            } else {
                validator.consecutive_missed_rounds += 1;
                let penalty = -(self.config.base_reward as f64 *
                    self.config.penalty_factor *
                    validator.consecutive_missed_rounds as f64) as i64;
                validator.reputation += penalty;

                self.reputation_updates.push((
                    validator_id.clone(),
                    penalty
                ));

                validator.performance_score = validator.performance_score * 0.95;
            }
        }

        // Update history
        let mut stats = round.stats;
        stats.round_duration_ms = round.timeout
            .signed_duration_since(round.start_time)
            .num_milliseconds() as u64;
        self.round_history.push(stats);

        self.ws_handler.broadcast_block_finalized(&block);

        Ok(block)
    }

    pub fn get_reputation_updates(&self) -> &[(String, i64)] {
        &self.reputation_updates
    }

    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.current_round.clone()
    }

    fn select_coordinator<'a>(&self, active_validators: &'a [&ValidatorInfo]) 
        -> Result<&'a ValidatorInfo, String> 
    {
        let mut rng = thread_rng();

        let weights: Vec<f64> = active_validators.iter()
            .map(|v| (v.reputation as f64) * v.performance_score)
            .collect();

        let total_weight: f64 = weights.iter().sum();
        if total_weight <= 0.0 {
            return Err("No valid validators".to_string());
        }

        let selection_point = rng.gen_range(0.0..total_weight);
        let mut cumulative_weight = 0.0;

        for (i, weight) in weights.iter().enumerate() {
            cumulative_weight += weight;
            if cumulative_weight >= selection_point {
                return Ok(active_validators[i]);
            }
        }

        Err("Failed to select coordinator".to_string())
    }

    pub fn register_validator(&mut self, did: String, initial_reputation: i64) -> Result<(), String> {
        let validator = ValidatorInfo {
            did: did.clone(),
            reputation: initial_reputation,
            voting_power: 1.0,
            last_active_round: 0,
            consecutive_missed_rounds: 0,
            total_blocks_validated: 0,
            performance_score: 1.0,
        };

        self.validators.insert(did, validator);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_consensus() -> ProofOfCooperation {
        let config = ConsensusConfig::default();
        let ws_handler = Arc::new(WebSocketHandler::new());
        ProofOfCooperation::new(config, ws_handler)
    }

    fn add_test_validators(consensus: &mut ProofOfCooperation) {
        for i in 1..=3 {
            let validator = ValidatorInfo {
                did: format!("did:icn:test{}", i),
                reputation: 1000,
                voting_power: 1.0,
                last_active_round: 0,
                consecutive_missed_rounds: 0,
                total_blocks_validated: 0,
                performance_score: 1.0,
            };
            consensus.validators.insert(validator.did.clone(), validator);
        }
    }

    #[tokio::test]
    async fn test_start_round() {
        let mut consensus = setup_test_consensus();
        add_test_validators(&mut consensus);
        
        assert!(consensus.start_round().await.is_ok());
        assert!(consensus.current_round.is_some());
    }

    #[tokio::test]
    async fn test_insufficient_validators() {
        let mut consensus = setup_test_consensus();
        
        let result = consensus.start_round().await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient validators");
    }
}


===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
===================
import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { AlertCircle, Users, Activity, BarChart3 } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

const CooperativeDashboard = () => {
  const [metrics, setMetrics] = useState({
    totalMembers: 0,
    activeProposals: 0,
    resourceUtilization: 0,
    monthlyActivity: []
  });
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockData = {
      totalMembers: 156,
      activeProposals: 3,
      resourceUtilization: 78,
      monthlyActivity: [
        { month: 'Jan', activity: 65 },
        { month: 'Feb', activity: 75 },
        { month: 'Mar', activity: 85 },
        { month: 'Apr', activity: 90 }
      ]
    };

    setMetrics(mockData);
    setLoading(false);
  }, []);

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Members</p>
                <h3 className="text-2xl font-bold">{metrics.totalMembers}</h3>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{metrics.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Resource Utilization</p>
                <h3 className="text-2xl font-bold">{metrics.resourceUtilization}%</h3>
              </div>
              <Activity className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Monthly Growth</p>
                <h3 className="text-2xl font-bold">+12%</h3>
              </div>
              <BarChart3 className="h-8 w-8 text-orange-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Cooperative Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={metrics.monthlyActivity}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="activity" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Resource Allocation</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Computing Resources</span>
                <span>75%</span>
              </div>
              <Progress value={75} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Storage Resources</span>
                <span>60%</span>
              </div>
              <Progress value={60} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Network Resources</span>
                <span>85%</span>
              </div>
              <Progress value={85} className="h-2" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default CooperativeDashboard;

===================
File: ./frontend/src/components/governance/GovernanceDashboard.tsx
===================
import React, { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { AlertCircle, ChevronRight, Users, TrendingUp } from 'lucide-react'

type Proposal = {
  id: string
  title: string
  description: string
  status: 'active' | 'passed' | 'rejected'
  votesFor: number
  votesAgainst: number
  quorum: number
  createdBy: string
  endsAt: string
  totalVoters: number
  delegatedVotes: number
}

type VotingStats = {
  totalProposals: number
  activeProposals: number
  participationRate: number
  monthlyVotes: Array<{ month: string; votes: number }>
}

const GovernanceDashboard = () => {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [votingStats, setVotingStats] = useState<VotingStats>({
    totalProposals: 0,
    activeProposals: 0,
    participationRate: 0,
    monthlyVotes: []
  })
  const [selectedTab, setSelectedTab] = useState('active')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockProposals: Proposal[] = [
      {
        id: '1',
        title: 'Community Resource Allocation Q3',
        description: 'Proposal to allocate community resources for Q3 projects',
        status: 'active',
        votesFor: 750,
        votesAgainst: 250,
        quorum: 1000,
        createdBy: 'did:icn:alice',
        endsAt: '2024-11-01',
        totalVoters: 1500,
        delegatedVotes: 200
      },
      {
        id: '2',
        title: 'New Cooperation Guidelines',
        description: 'Updated guidelines for inter-cooperative collaboration',
        status: 'passed',
        votesFor: 800,
        votesAgainst: 100,
        quorum: 1000,
        createdBy: 'did:icn:bob',
        endsAt: '2024-10-15',
        totalVoters: 1200,
        delegatedVotes: 150
      }
    ]

    const mockStats = {
      totalProposals: 45,
      activeProposals: 3,
      participationRate: 78.5,
      monthlyVotes: [
        { month: 'Jan', votes: 120 },
        { month: 'Feb', votes: 150 },
        { month: 'Mar', votes: 180 },
        { month: 'Apr', votes: 220 }
      ]
    }

    setProposals(mockProposals)
    setVotingStats(mockStats)
    setLoading(false)
  }, [])

  const calculateProgress = (votesFor: number, votesAgainst: number) => {
    const total = votesFor + votesAgainst
    return total > 0 ? (votesFor / total) * 100 : 0
  }

  const ProposalCard = ({ proposal }: { proposal: Proposal }) => (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-semibold">{proposal.title}</h3>
          <p className="text-sm text-gray-600">{proposal.description}</p>
        </div>
        <span className={`px-2 py-1 rounded text-sm ${
          proposal.status === 'active' ? 'bg-blue-100 text-blue-800' :
          proposal.status === 'passed' ? 'bg-green-100 text-green-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        </span>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculateProgress(proposal.votesFor, proposal.votesAgainst).toFixed(1)}%</span>
        </div>
        <Progress 
          value={calculateProgress(proposal.votesFor, proposal.votesAgainst)} 
          className="h-2"
        />
        
        <div className="flex justify-between text-sm text-gray-600">
          <span>For: {proposal.votesFor}</span>
          <span>Against: {proposal.votesAgainst}</span>
        </div>

        <div className="flex justify-between items-center mt-4">
          <div className="text-sm text-gray-600">
            <p>Created by: {proposal.createdBy}</p>
            <p>Ends: {new Date(proposal.endsAt).toLocaleDateString()}</p>
          </div>
          {proposal.status === 'active' && (
            <Button className="space-x-2">
              <span>Vote Now</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </Card>
  )

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Participation Rate</p>
                <h3 className="text-2xl font-bold">{votingStats.participationRate}%</h3>
              </div>
              <Users className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.totalProposals}</h3>
              </div>
              <TrendingUp className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Voting Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={votingStats.monthlyVotes}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="votes" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Proposals</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList>
              <TabsTrigger value="active">Active</TabsTrigger>
              <TabsTrigger value="passed">Passed</TabsTrigger>
              <TabsTrigger value="rejected">Rejected</TabsTrigger>
            </TabsList>

            <TabsContent value="active" className="space-y-4">
              {proposals
                .filter(p => p.status === 'active')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="passed" className="space-y-4">
              {proposals
                .filter(p => p.status === 'passed')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="rejected" className="space-y-4">
              {proposals
                .filter(p => p.status === 'rejected')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      <Alert>
        <AlertDescription>
          You currently have {proposals[0]?.delegatedVotes || 0} votes delegated to you. 
          Visit the delegation page to manage your voting power.
        </AlertDescription>
      </Alert>
    </div>
  )
}

export default GovernanceDashboard

===================
File: ./frontend/src/components/consensus/ConsensusMonitor.tsx
===================
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';

type ConsensusStatus = 'Proposing' | 'Voting' | 'Finalizing' | 'Completed' | 'Failed';

interface ConsensusUpdate {
  round_number: number;
  status: ConsensusStatus;
  coordinator: string;
  votes_count: number;
}

interface BlockFinalized {
  block_number: number;
  transactions_count: number;
  timestamp: number;
}

interface ReputationUpdate {
  did: string;
  change: number;
  new_total: number;
}

interface ErrorMessage {
  code: string;
  message: string;
}

interface WebSocketMessage {
  type: 'ConsensusUpdate' | 'BlockFinalized' | 'ReputationUpdate' | 'Error';
  data: ConsensusUpdate | BlockFinalized | ReputationUpdate | ErrorMessage;
}

const ConsensusMonitor: React.FC = () => {
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);
  const [connected, setConnected] = useState(false);
  const ws = useRef<WebSocket | null>(null);

  useEffect(() => {
    // Get DID from local storage or context
    const did = localStorage.getItem('userDid') || 'default-did';

    const connectWebSocket = () => {
      try {
        ws.current = new WebSocket('ws://localhost:8080/ws');
        
        ws.current.onopen = () => {
          setConnected(true);
          // Send DID in a message after connection
          ws.current?.send(JSON.stringify({ type: 'identify', did }));
        };

        ws.current.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            setMessages((prev) => [...prev, message].slice(-5)); // Keep last 5 messages
          } catch (e) {
            console.error('Failed to parse WebSocket message:', e);
          }
        };

        ws.current.onclose = () => {
          setConnected(false);
          // Try to reconnect after 5 seconds
          setTimeout(connectWebSocket, 5000);
        };

        ws.current.onerror = (error) => {
          console.error('WebSocket error:', error);
          ws.current?.close();
        };
      } catch (error) {
        console.error('Failed to establish WebSocket connection:', error);
        setTimeout(connectWebSocket, 5000);
      }
    };

    connectWebSocket();

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const renderConsensusUpdate = (data: ConsensusUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Consensus Round {data.round_number}</p>
          <Badge variant={
            data.status === 'Completed' ? 'default' :
            data.status === 'Failed' ? 'destructive' :
            'secondary'
          }>
            {data.status}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">Coordinator: {data.coordinator}</p>
        <p className="text-sm text-gray-600">Votes: {data.votes_count}</p>
      </CardContent>
    </Card>
  );

  const renderBlockFinalized = (data: BlockFinalized) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">New Block #{data.block_number}</p>
          <Badge>Finalized</Badge>
        </div>
        <p className="text-sm text-gray-600">Transactions: {data.transactions_count}</p>
        <p className="text-sm text-gray-600">
          Time: {new Date(data.timestamp * 1000).toLocaleString()}
        </p>
      </CardContent>
    </Card>
  );

  const renderReputationUpdate = (data: ReputationUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Reputation Change</p>
          <Badge variant={data.change > 0 ? 'default' : 'destructive'}>
            {data.change > 0 ? '+' : ''}{data.change}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">DID: {data.did}</p>
        <p className="text-sm text-gray-600">New Total: {data.new_total}</p>
      </CardContent>
    </Card>
  );

  const renderMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'ConsensusUpdate':
        return renderConsensusUpdate(message.data as ConsensusUpdate);
      case 'BlockFinalized':
        return renderBlockFinalized(message.data as BlockFinalized);
      case 'ReputationUpdate':
        return renderReputationUpdate(message.data as ReputationUpdate);
      case 'Error':
        const errorData = message.data as ErrorMessage;
        return (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>
              Error {errorData.code}: {errorData.message}
            </AlertDescription>
          </Alert>
        );
      default:
        return null;
    }
  };

  return (
    <div className="space-y-4 p-4">
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Consensus Monitor</CardTitle>
            <Badge variant={connected ? "default" : "destructive"}>
              {connected ? 'Connected' : 'Disconnected'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {messages.map((msg, i) => (
              <div key={i}>{renderMessage(msg)}</div>
            ))}
            {messages.length === 0 && (
              <p className="text-gray-500 text-center py-4">
                No consensus updates yet
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ConsensusMonitor;

===================
File: ./backend/Cargo.toml
===================
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[[example]]
name = "blockchain_test"
path = "examples/blockchain_test.rs"

[[example]]
name = "ws_client"
path = "examples/ws_client.rs"

[[example]]
name = "ws_client2"
path = "examples/ws_client2.rs"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
futures = "0.3"
futures-util = "0.3"
rand = "0.8"
secp256k1 = { version = "0.24.3", features = ["rand"] }
sha2 = "0.10"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
tokio-tungstenite = "0.20"
url = "2.4"

[dev-dependencies]
tokio-tungstenite = "0.20"
url = "2.4"

===================
File: ./frontend/package.json
===================


===================
File: ./frontend/tsconfig.json
===================


===================
File: ./docker/docker-compose.yml
===================
version: '3.8'

services:
  backend:
    build:
      context: ../backend                        # Path to the backend source with Cargo.toml
      dockerfile: ../docker/backend.Dockerfile   # Path to backend Dockerfile in `docker`
    ports:
      - "8080:8080"  # HTTP
      - "8081:8081"  # WebSocket
    environment:
      - DATABASE_URL=postgres://icnuser:icnpass@db:5432/icndb

  frontend:
    build:
      context: ../frontend                       # Path to frontend source code
      dockerfile: ../docker/frontend.Dockerfile  # Path to frontend Dockerfile in `docker`
    ports:
      - "3000:3000"

  db:
    image: postgres:latest
    environment:
      POSTGRES_USER: icnuser
      POSTGRES_PASSWORD: icnpass
      POSTGRES_DB: icndb
    ports:
      - "5432:5432"

  docs:
    image: squidfunk/mkdocs-material:latest
    volumes:
      - ../docs:/docs
    ports:
      - "8000:8000"
    working_dir: /docs
    command: serve -a 0.0.0.0:8000


===================
File: ./docker/backend.Dockerfile
===================
# backend.Dockerfile
# Stage 1: Build the Rust app
FROM rust:latest AS builder

WORKDIR /app

COPY . .
RUN cargo build --release
RUN cargo test --release

# Stage 2: Create a smaller image to run the binary
FROM debian:buster-slim AS runner
WORKDIR /app
COPY --from=builder /app/target/release/icn-backend /usr/local/bin/icn-backend

# Expose both HTTP (8080) and WebSocket (8081) ports
EXPOSE 8080
EXPOSE 8081

CMD ["icn-backend"]


===================
File: ./docker/frontend.Dockerfile
===================
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
CMD ["npm", "start"]


===================
File: ./docs/docs/index.md
===================
# Welcome to MkDocs

For full documentation visit [mkdocs.org](https://www.mkdocs.org).

## Commands

* `mkdocs new [dir-name]` - Create a new project.
* `mkdocs serve` - Start the live-reloading docs server.
* `mkdocs build` - Build the documentation site.
* `mkdocs -h` - Print help message and exit.

## Project layout

    mkdocs.yml    # The configuration file.
    docs/
        index.md  # The documentation homepage.
        ...       # Other markdown pages, images and other files.


===================
File: ./docs/guides/index.md
===================
# User Guides

The following guides provide step-by-step instructions for using the ICN platform effectively.

## Contents
- [Getting Started](getting-started.md): Introduction to accessing and navigating the ICN platform.
- [Governance Guide](governance-guide.md): Detailed steps on participating in cooperative governance.
- [Reputation Management](reputation-management.md): Overview of how reputation influences roles and decision-making.

Additional guides will cover specific ICN features and best practices.


===================
File: ./docs/INDEX.md
===================
# Documentation Index


## Specification

- [Reputation System](specifications/core/2024-11-01-reputation-system.md) (v1.0.0, draft)


===================
File: ./docs/user/guides/resource-management.md
===================
# Resource Management Guide

## Introduction
Resource management within ICN allows cooperatives to allocate, share, and track resources efficiently. This guide covers the steps for creating resources, allocating them within a cooperative, and monitoring usage.

## Step 1: Create a Resource
1. Go to the Cooperative Resource tab.
2. Select “Create Resource” and provide details:
   - **Resource Type**: Define the type (e.g., funds, materials).
   - **Allocation**: Set initial availability and allocation limits.

## Step 2: Allocate Resource to Cooperative Members
1. Navigate to the Resource Allocation tab.
2. Select the resource and member(s) to allocate.
3. Set allocation limits based on cooperative needs.

## Step 3: Monitor Resource Usage
Regularly check the resource usage dashboard:
- **Allocated Resources**: Overview of allocated resources and remaining capacity.
- **Usage Trends**: Track member usage patterns to optimize future allocations.

## Tips for Effective Resource Management
- **Set Clear Limits**: Prevent overuse by establishing maximum allocations.
- **Review Allocation Periodically**: Adjust allocations based on changing cooperative needs.
- **Encourage Resource Sharing**: Promote shared resource access among members to maximize utility.


===================
File: ./docs/user/guides/index.md
===================


===================
File: ./docs/user/guides/onboarding-guide.md
===================

---

### `onboarding-guide.md` (Under `user/guides/`)

```markdown
# ICN Onboarding Guide

## Introduction
Welcome to the ICN platform! This guide walks you through creating a DID, joining a cooperative, and participating in governance.

## Step 1: Create Your DID
DIDs are the basis of ICN’s secure interactions. To create a DID:
1. Access the ICN Identity page.
2. Click “Generate DID.”
3. Copy your DID identifier and public key for future reference.

## Step 2: Join a Cooperative
1. Go to the Cooperative Directory.
2. Select a cooperative and click “Join.”
3. Complete the required fields, then submit your request.
   - **Note**: Some cooperatives require a minimum reputation score for entry.

## Step 3: Participate in Governance
As a cooperative member, you can vote on proposals:
1. Go to the Governance Dashboard.
2. View active proposals and click “Vote” on issues that matter to you.
3. Your reputation will influence the weight of your vote.

## Tips for New Members
- **Increase Reputation**: Engage in cooperative activities to boost your influence.
- **Track Notifications**: Stay updated on proposal deadlines to maximize participation.


===================
File: ./docs/development/guides/documentation-standards.md
===================
# Documentation Standards

## File Organization

- Use appropriate directory for document type
- Follow naming conventions
- Include required metadata

## Writing Style

- Be clear and concise
- Include code examples where appropriate
- Keep documentation up to date
- Use proper Markdown formatting

## Review Process

1. Create new document using tools
2. Submit for review
3. Address feedback
4. Update documentation index

## Templates

Use provided templates in `docs/templates/` for new documents.


===================
File: ./docs/README.md
===================
# ICN Documentation

## Structure

- `architecture/` - System architecture documentation
- `specifications/` - Technical specifications
- `development/` - Development guides and plans
- `user/` - User documentation and tutorials

## Getting Started

1. Install documentation tools:
   ```bash
   cd tools
   pip install -r requirements.txt
   ```

2. Generate documentation index:
   ```bash
   python tools/doctools/docmanager.py index
   ```

## Documentation Standards

Please refer to `development/guides/documentation-standards.md` for our documentation guidelines.


===================
File: ./docs/templates/protocol-template.md
===================
# {title} Protocol Specification

## 1. Protocol Overview

### 1.1 Purpose

### 1.2 Flow

## 2. Message Formats

## 3. State Machine

## 4. Security Model

## 5. Implementation Guidelines

## 6. Compatibility Requirements

## 7. Future Extensions


===================
File: ./docs/templates/api-template.md
===================
# {title} API Specification

## 1. API Overview

### 1.1 Purpose

### 1.2 Endpoints

## 2. Authentication

## 3. Endpoints Detail

## 4. Error Handling

## 5. Rate Limiting

## 6. Security Considerations

## 7. Example Usage


===================
File: ./docs/templates/core-component-template.md
===================
# {title}

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations


===================
File: ./docs/specifications/api/governance-api.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance API
type: api
version: 1.0.0
---

# Governance API

## Overview

### Purpose
The Governance API enables ICN members to submit, view, and vote on proposals. Each action requires DID-based access control and reputation permissions.

## Endpoints

### Create Proposal
- **Endpoint**: `POST /api/governance/proposals`
- **Request Body**:
  ```json
  {
    "proposal_type": "Funding",
    "description": "Allocate resources for new development",
    "duration": 60
  }


===================
File: ./docs/specifications/core/transaction-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-04'
status: draft
title: Transaction Lifecycle System
type: specification
version: 1.0.0
---

# Transaction Lifecycle System

## Overview
The Transaction Lifecycle System provides a secure, traceable, and immutable process for handling all cooperative transactions within the ICN. This document details the lifecycle of a transaction, from initiation and validation to finalization and storage in the blockchain. The system is designed to ensure consistency, security, and transparency in all cooperative actions.

### Purpose
- **Immutability**: Maintain a secure and unalterable record of all transactions.
- **Traceability**: Allow cooperatives to track resource allocation, proposal voting, and other actions.
- **Accountability**: Ensure all actions align with ICN's governance standards through DID and reputation validation.

### Components Involved
- **Blockchain Module**: Manages the chain of blocks where transactions are stored.
- **DID System**: Verifies the identities of transaction participants.
- **Reputation System**: Validates that users have the necessary reputation to execute actions.

---

## 1. Transaction Lifecycle

### 1.1 Transaction Initiation

1. **Process**:
   - A transaction is created with the following attributes: `sender`, `receiver`, `amount`, `timestamp`, and `purpose`.
   - A unique transaction hash is generated using `SHA-256` to prevent duplicates.

2. **Validation**:
   - The transaction undergoes an initial validation to confirm that the `sender` has a valid DID and that the specified `amount` respects the cooperative’s resource allocation limits.

3. **Attributes**:
   - **Sender**: The DID of the transaction initiator.
   - **Receiver**: The DID of the transaction recipient.
   - **Amount**: The value/resource quantity being transferred.
   - **Timestamp**: Millisecond timestamp of transaction initiation.
   - **Purpose**: A brief description of the transaction’s intent.

### 1.2 Transaction Validation

1. **DID Verification**:
   - Ensure that both the `sender` and `receiver` have valid DIDs. Invalid or nonexistent DIDs will cause the transaction to fail validation.
   
2. **Reputation Check**:
   - Confirm that the `sender` meets any minimum reputation thresholds required by the transaction type.
   - If the reputation requirement is not met, the transaction is rejected with an error.

3. **Signature Verification**:
   - The transaction must be signed by the `sender`’s key, verified using ECC (secp256k1) or, when specified, quantum-resistant keys (CRYSTALS-Dilithium).
   
4. **Timestamp Verification**:
   - Check that the `timestamp` is valid and aligns with recent blockchain activity to prevent replay attacks.

### 1.3 Transaction Processing

1. **Hashing**:
   - Calculate a unique hash for the transaction, incorporating attributes like `sender`, `receiver`, `amount`, and `timestamp`.
   
2. **Pending Pool**:
   - Place the validated transaction in the pending transactions pool until a new block is finalized.

### 1.4 Block Finalization

1. **Block Creation**:
   - At defined intervals or upon reaching a set number of transactions, pending transactions are bundled into a new block.
   
2. **Block Hashing**:
   - A hash of the new block is computed, linking it to the previous block for chain integrity.
   
3. **Chain Update**:
   - The finalized block is added to the blockchain, and the pending transactions pool is cleared.

---

## 2. Data Structures

### 2.1 Transaction Object

```rust
Transaction {
    sender: String,
    receiver: String,
    amount: u64,
    timestamp: u128,
    hash: String,
}


===================
File: ./docs/specifications/core/vm-system.md
===================
Certainly! Here's the expanded documentation for the Virtual Machine (VM), written in Markdown format and enclosed within a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/vm-system.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Virtual Machine (VM)
type: specification
version: 1.1.0
---

# Virtual Machine (VM) Specification

## 1. Overview

### 1.1 Purpose

The Virtual Machine (VM) is a core component of the Inter-Cooperative Network (ICN), responsible for executing cooperative-specific smart contracts. It interprets a set of predefined OpCodes, allowing for a range of operations that support governance, resource allocation, reputation management, and cooperative administration.

### 1.2 Core Components

- **Instruction Set**: A collection of OpCodes defining operations the VM can execute.
- **Execution Engine**: Processes instructions, manages the stack, memory, and control flow.
- **Security Mechanisms**: Enforces permissions, reputation requirements, and resource limits.
- **Event System**: Generates events during execution for logging and auditing.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 OpCode Enumeration

Defines the set of operations supported by the VM, categorized by functionality:

- **Arithmetic Operations**
  - `Add`, `Sub`, `Mul`, `Div`, `Mod`
- **Stack Operations**
  - `Push`, `Pop`, `Dup`, `Swap`
- **Memory Operations**
  - `Store`, `Load`
- **Control Flow Operations**
  - `Jump`, `JumpIf`, `Call`, `Return`
- **Cooperative Operations**
  - `CreateCooperative`, `JoinCooperative`, `LeaveCooperative`, `AllocateResource`, `TransferResource`
- **Governance Operations**
  - `CreateProposal`, `CastVote`, `DelegateVotes`, `ExecuteProposal`, `UpdateQuorum`
- **Reputation Operations**
  - `UpdateReputation`, `GetReputation`
- **Identity Operations**
  - `VerifyDID`, `UpdateDIDDocument`
- **System Operations**
  - `Log`, `Halt`, `EmitEvent`, `GetTimestamp`, `GetCaller`

#### 2.1.2 Contract Structure

```rust
struct Contract {
    id: String,
    code: Vec<(OpCode, Option<i64>)>,
    state: HashMap<String, i64>,
    required_reputation: i64,
    cooperative_metadata: CooperativeMetadata,
    version: String,
    dependencies: Vec<String>,
    permissions: Vec<String>,
}
```

- **id**: Unique identifier for the contract.
- **code**: Sequence of OpCodes and optional arguments.
- **state**: Persistent state specific to the contract.
- **required_reputation**: Minimum reputation required to execute the contract.
- **cooperative_metadata**: Metadata providing context for the cooperative.
- **version**: Contract versioning for updates and compatibility.
- **dependencies**: List of other contracts or libraries required.
- **permissions**: Access control permissions required.

#### 2.1.3 Execution Context

```rust
struct ExecutionContext {
    caller_did: String,
    cooperative_id: String,
    timestamp: u64,
    block_number: u64,
    reputation_score: i64,
    permissions: Vec<String>,
}
```

- **caller_did**: DID of the entity invoking the contract.
- **cooperative_id**: Identifier of the cooperative context.
- **timestamp**: Current timestamp of execution.
- **block_number**: Blockchain block number.
- **reputation_score**: Reputation score of the caller.
- **permissions**: Permissions of the caller.

### 2.2 Interfaces

#### 2.2.1 VM Methods

##### Execute Contract

- **Purpose**: Executes a contract from start to finish, enforcing all constraints.
- **Input**: `Contract`, `ExecutionContext`
- **Process**:
  1. **Permission Check**: Verify caller has necessary permissions.
  2. **Reputation Validation**: Ensure caller's reputation meets the requirement.
  3. **Initialize Stack and Memory**: Set up execution environment.
  4. **Instruction Execution**: Process OpCodes sequentially.
  5. **Event Emission**: Generate events as specified.
  6. **State Update**: Persist any changes to the contract state.
- **Output**: Execution result, updated state, events generated.

##### Execute Instruction

- **Purpose**: Processes a single OpCode and modifies the VM state accordingly.
- **Input**: `OpCode`, `Option<i64>`
- **Process**:
  - Handle operation based on the type of OpCode.
  - Update stack, memory, or control flow as needed.
- **Output**: Updated VM state.

### 2.3 Behaviors

#### 2.3.1 Stack Management

- **Structure**: LIFO (Last-In-First-Out) stack of 64-bit integers.
- **Operations**:
  - **Push**: Add value to the top of the stack.
  - **Pop**: Remove and return the top value.
  - **Dup**: Duplicate the top value.
  - **Swap**: Swap the top two values.

#### 2.3.2 Memory Management

- **Structure**: Key-value store (`HashMap<String, i64>`) for temporary storage.
- **Operations**:
  - **Store**: Save a value with a specified key.
  - **Load**: Retrieve a value by key.

#### 2.3.3 Control Flow

- **Jump**: Redirect execution to a specific instruction index.
- **JumpIf**: Conditional jump based on the top of the stack.
- **Call**: Invoke a function or subroutine.
- **Return**: Exit from a function or contract execution.

#### 2.3.4 Error Handling

- **Exception Types**:
  - **Stack Underflow/Overflow**
  - **Invalid Opcode**
  - **Permission Denied**
  - **Reputation Insufficient**
  - **Runtime Errors**: Division by zero, invalid memory access.

- **Handling Strategy**:
  - Execution halts on errors.
  - Generate error events with detailed messages.
  - Rollback any state changes made during execution.

### 2.4 Security Model

- **Reputation Enforcement**: Contracts specify minimum reputation; the VM enforces this before execution.
- **Permission Checks**: Caller permissions are validated against contract requirements.
- **Resource Limits**:
  - **Instruction Limit**: Maximum number of instructions per execution to prevent infinite loops.
  - **Stack Depth Limit**: Prevent stack overflows.
  - **Memory Usage Limit**: Cap on memory allocation.

- **Isolation**: Each contract execution is sandboxed, preventing interference with other contracts or global state.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Efficiency**: Optimize instruction execution for speed.
- **Scalability**: Handle multiple concurrent executions.
- **Lightweight**: Minimize resource consumption.

### 3.2 Security Requirements

- **Determinism**: Ensure contract execution is deterministic across all nodes.
- **Validation**: Strictly validate all inputs and OpCodes.
- **Auditability**: Maintain detailed logs and event histories.

### 3.3 Error Handling

- **Graceful Termination**: Contracts should fail safely without crashing the VM.
- **Clear Messaging**: Provide informative error messages for debugging.

## 4. Testing Requirements

- **Unit Tests**: Cover individual OpCodes and VM operations.
- **Integration Tests**: Test full contract executions in various scenarios.
- **Security Tests**: Include tests for permission enforcement and reputation checks.
- **Performance Tests**: Benchmark execution times and resource usage.

## 5. Monitoring and Metrics

- **Execution Logs**: Record each instruction executed.
- **Event Logs**: Capture all events emitted during execution.
- **Error Logs**: Record detailed information about any errors encountered.
- **Metrics**:
  - Execution time per contract.
  - Resource usage statistics.
  - Frequency of specific OpCodes.

## 6. Future Considerations

- **Extensibility**: Allow for new OpCodes and features to be added.
- **Language Support**: Develop higher-level languages that compile down to VM bytecode.
- **Interoperability**: Enable interaction with contracts on other blockchains or VMs.
- **Optimizations**: Implement Just-In-Time (JIT) compilation or other optimizations.

## Appendix

### A. OpCode Definitions

Provide detailed descriptions of each OpCode, including its function, expected stack state, and any arguments.

#### A.1 Arithmetic Operations

- **Add**
  - **Function**: Pops two values from the stack, pushes their sum.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a + b ]`
- **Sub**
  - **Function**: Pops two values, pushes the result of `a - b`.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a - b ]`
- *(Continue for other arithmetic OpCodes)*

#### A.2 Stack Operations

- *(Define `Push`, `Pop`, `Dup`, `Swap`)*

#### A.3 Memory Operations

- **Store**
  - **Function**: Stores a value in memory with a specified key.
  - **Arguments**: Key (from stack or instruction argument).
  - **Operation**:
    1. Pop value from stack.
    2. Use key to store the value in memory.

- **Load**
  - **Function**: Loads a value from memory onto the stack.
  - **Arguments**: Key.
  - **Operation**:
    1. Retrieve value associated with key.
    2. Push value onto the stack.

#### A.4 Control Flow Operations

- *(Define `Jump`, `JumpIf`, `Call`, `Return`)*

#### A.5 Cooperative Operations

- **CreateCooperative**
  - **Function**: Initiates a new cooperative.
  - **Requirements**: Caller must have sufficient reputation and permissions.
  - **Effect**: Emits `CooperativeCreated` event.

- *(Continue for other cooperative OpCodes)*

#### A.6 Governance Operations

- *(Define `CreateProposal`, `CastVote`, etc.)*

#### A.7 System Operations

- **Log**
  - **Function**: Logs a message or value for debugging.
  - **Operation**:
    1. Pop value from stack.
    2. Record value in execution logs.

- **Halt**
  - **Function**: Stops execution of the contract.
  - **Effect**: Returns control to the caller.

## References

- **ICN Architecture Overview**
- **Reputation System Specification**
- **Governance System Specification**

```

---

You can save this file as `vm-system.md` in your `./docs/specifications/core/` directory.

**Next Steps:**

- **Review the OpCode Definitions:** Ensure that all required operations are defined and that their behaviors align with the needs of your cooperatives.
- **Expand the Appendix:** Add detailed definitions for each OpCode, especially for custom cooperative and governance operations.
- **Integrate with Other Systems:** Cross-reference with the Identity System and Reputation System specifications to ensure consistent interactions.
- **Implement Security Measures:** Consider any additional security requirements specific to your use case.

**Let me know if you'd like to further refine any section or if you have additional components you'd like to develop!**

===================
File: ./docs/specifications/core/2024-11-01-reputation-system.md
===================
---
authors:
- Developer Name
date: '2024-11-01'
last_updated: '2024-11-01 00:48:30'
related_docs: []
reviewers:
- Tech Lead
status: draft
title: Reputation System
type: specification
version: 1.0.0

---

# Reputation System

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations



===================
File: ./docs/specifications/core/identity-system.md
===================
Apologies for the oversight. Here is the complete documentation for the Identity System, entirely within a code block so you can easily copy and paste it into your documentation folder.

---

**File: `./docs/specifications/core/identity-system.md`**

```markdown
---
authors:
  - Your Name
date: '2024-11-03'
status: draft
title: Identity System
type: specification
version: 1.0.0
---

# Identity System Specification

## 1. Overview

### 1.1 Purpose

The Identity System is responsible for managing Decentralized Identifiers (DIDs) within the Inter-Cooperative Network (ICN). It ensures secure authentication and authorization for users, cooperatives, and nodes by leveraging cryptographic key pairs. The system supports both Elliptic Curve Cryptography (ECC) and quantum-resistant algorithms to future-proof security.

### 1.2 Core Components

- **DID Management**: Creation, retrieval, and update of DIDs.
- **Authentication Service**: Verifies identities through cryptographic signatures.
- **Authorization Mechanism**: Controls access to resources based on roles and permissions.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 DID Document

```json
{
  "id": "did:icn:unique_identifier",
  "publicKey": "base64_encoded_public_key",
  "authentication": "authentication_method",
  "created": "timestamp",
  "updated": "timestamp"
}
```

- **id**: Unique identifier following the `did:icn:` namespace.
- **publicKey**: The public key associated with the DID, encoded in base64.
- **authentication**: Method used for verifying the DID owner.
- **created**: Timestamp of when the DID was created.
- **updated**: Timestamp of the last update to the DID document.

### 2.2 Interfaces

#### 2.2.1 API Endpoints

##### Create DID

- **Endpoint**: `POST /api/identity/did`
- **Description**: Registers a new DID in the network.
- **Request Body**:

  ```json
  {
    "publicKey": "base64_encoded_public_key"
  }
  ```

- **Response**:

  ```json
  {
    "did": "did:icn:unique_identifier"
  }
  ```

##### Resolve DID

- **Endpoint**: `GET /api/identity/did/{did}`
- **Description**: Retrieves the DID document for the specified DID.
- **Response**:

  ```json
  {
    "didDocument": {
      "id": "did:icn:unique_identifier",
      "publicKey": "base64_encoded_public_key",
      "authentication": "authentication_method",
      "created": "timestamp",
      "updated": "timestamp"
    }
  }
  ```

##### Authenticate

- **Endpoint**: `POST /api/identity/authenticate`
- **Description**: Verifies the identity and issues an authentication token.
- **Request Body**:

  ```json
  {
    "did": "did:icn:unique_identifier",
    "signature": "base64_encoded_signature",
    "nonce": "server_provided_nonce"
  }
  ```

- **Response**:

  ```json
  {
    "token": "jwt_token"
  }
  ```

### 2.3 Behaviors

#### 2.3.1 DID Creation Workflow

1. **Key Generation**: The user generates a key pair locally, choosing between ECC or quantum-resistant algorithms.
2. **Public Key Submission**: The user sends the public key to the Identity System via the `Create DID` endpoint.
3. **DID Registration**: The system creates a unique DID, stores the DID document, and returns the DID to the user.

#### 2.3.2 Authentication Workflow

1. **Nonce Request**: The user requests a nonce from the server to prevent replay attacks.
2. **Signature Generation**: The user signs the nonce with their private key.
3. **Authentication Request**: The user sends the DID, signature, and nonce to the server.
4. **Verification**: The server verifies the signature using the public key from the DID document.
5. **Token Issuance**: Upon successful verification, the server issues a JWT token for authenticated sessions.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Scalability**: The system should handle a large number of DID registrations and authentication requests concurrently.
- **Low Latency**: Authentication and DID resolution should occur with minimal delay to ensure a smooth user experience.

### 3.2 Security Requirements

- **Key Security**: Users must securely store their private keys; the system should never have access to private keys.
- **Replay Attack Prevention**: Use nonces or timestamps during authentication to prevent replay attacks.
- **Quantum Resistance**: Support for quantum-resistant algorithms like CRYSTALS-Dilithium and CRYSTALS-Kyber should be implemented to future-proof the system.

### 3.3 Error Handling

- **Detailed Error Messages**: Provide clear and actionable error messages without revealing sensitive information.
- **Failure Modes**: Gracefully handle failures in DID creation, resolution, and authentication.

## 4. Testing Requirements

- **Unit Tests**: Cover all functions related to DID management and authentication.
- **Integration Tests**: Test the interaction between the Identity System and other modules like the Reputation System and Governance Module.
- **Security Tests**: Perform vulnerability assessments and penetration testing to ensure robust security measures are in place.

## 5. Monitoring and Metrics

- **Audit Logs**: Maintain logs for DID creation, updates, and authentication attempts for auditing purposes.
- **Performance Metrics**: Monitor response times for API endpoints and system load.
- **Security Alerts**: Implement alerts for suspicious activities, such as repeated failed authentication attempts.

## 6. Future Considerations

- **DID Deactivation**: Provide a mechanism for users to deactivate or revoke their DIDs in case of key compromise.
- **Metadata Integration**: Include optional metadata in DID documents, such as reputation scores and cooperative affiliations.
- **Cross-Network Compatibility**: Ensure the Identity System is compatible with other decentralized networks for broader interoperability.
```

---

You can save this file as `identity-system.md` in your `./docs/specifications/core/` directory.

Would you like me to provide documentation for other components as well? If so, please let me know which one you'd like to work on next, and I'll prepare it accordingly.

===================
File: ./docs/specifications/core/proof-of-cooperation.md
===================
Certainly! Here is the documentation for the **Proof of Cooperation Consensus Mechanism**, focusing on security mechanisms, blockchain components, and efficiency considerations. The documentation is written in Markdown format and enclosed in a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/proof-of-cooperation.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Proof of Cooperation Consensus Mechanism
type: specification
version: 1.0.0
---

# Proof of Cooperation (PoC) Consensus Mechanism

## 1. Overview

### 1.1 Purpose

The Proof of Cooperation (PoC) is a consensus mechanism designed specifically for the Inter-Cooperative Network (ICN) to facilitate secure, efficient, and cooperative blockchain operations. Unlike traditional consensus mechanisms such as Proof of Work (PoW) or Proof of Stake (PoS), PoC emphasizes collaboration, democratic participation, and reputation-based accountability to align with cooperative principles.

### 1.2 Core Principles

- **Democratic Participation**: Ensures inclusive decision-making by allowing each node, representing a cooperative or individual within ICN, to contribute to consensus.
- **Incentivized Cooperation**: Rewards are based on positive contributions to the cooperative ecosystem rather than computational power or wealth.
- **Reputation-Driven Accountability**: Reputation scores influence participation and voting power, holding nodes accountable to ethical standards.
- **Environmental Sustainability**: Eliminates energy-intensive computations, maintaining an energy-efficient model.

## 2. Detailed Specifications

### 2.1 System Components

#### 2.1.1 Node Types and Roles

- **Validator Nodes**: Nodes that meet certain cooperative engagement criteria (e.g., reputation threshold) and participate in validating transactions and blocks.
- **Observer Nodes**: Nodes that maintain a copy of the blockchain for transparency and auditing but do not participate in validation.
- **Coordinator Node**: A validator node selected per consensus round to organize and propose blocks. Selection is based on a weighted lottery tied to reputation scores.

#### 2.1.2 Reputation System Integration

- **Reputation-Weighted Voting**: Nodes with higher reputation have slightly increased influence in the consensus process, capped to prevent centralization.
- **Dynamic Recalibration**: Reputation scores adjust based on ongoing contributions and decay over time to encourage continuous engagement.

### 2.2 Consensus Process

#### 2.2.1 Transaction Verification

1. **Submission**: Nodes submit transactions to the network.
2. **Preliminary Checks**: The Coordinator Node performs initial validation of transactions.
3. **Broadcast**: Validated transactions are broadcasted to Validator Nodes for multi-signature approval.

#### 2.2.2 Voting Round Execution

1. **Block Proposal**: The Coordinator Node assembles a candidate block with selected transactions.
2. **Reputation-Weighted Voting**:
   - Each Validator Node votes on the proposed block.
   - Votes are weighted based on reputation scores.
   - Voting power is capped to prevent undue influence.
3. **Consensus Threshold**: A supermajority (e.g., 66%) of weighted votes is required for block approval.

#### 2.2.3 Block Finalization

1. **Multi-Signature Collection**: Validator Nodes sign the approved block.
2. **Block Addition**: The signed block is added to the blockchain and propagated to the network.
3. **Reputation Adjustment**: Validators gain reputation for participation or lose reputation for misconduct.

### 2.3 Security Mechanisms

#### 2.3.1 Cryptographic Security

- **Asymmetric Encryption**: Utilizes public/private key pairs for secure communication and transaction signing.
- **Digital Signatures**: Ensures authenticity and non-repudiation of transactions and blocks.
- **Hash Functions**: Employs secure hash algorithms for data integrity.

#### 2.3.2 Sybil Attack Prevention

- **Reputation Requirements**: High reputation thresholds for Validator Nodes make it difficult for malicious actors to gain influence.
- **Identity Verification**: DIDs are tied to real-world cooperative entities, adding authenticity.

#### 2.3.3 Byzantine Fault Tolerance

- **Consensus Thresholds**: Requires a supermajority for block approval, tolerating up to one-third faulty or malicious nodes.
- **Multi-Signature Validation**: Collective block signing prevents unilateral block creation.

#### 2.3.4 Double-Spending Prevention

- **Transaction Finality**: Once confirmed, transactions are immutable.
- **Sequential Ordering**: Transactions are time-stamped and ordered to prevent conflicts.

#### 2.3.5 Integrity Audits and Penalties

- **Automated Audits**: Regular checks ensure protocol compliance.
- **Reputation Penalties**: Misconduct results in reputation loss.
- **Node Exclusion**: Severe violations can lead to temporary or permanent removal.

#### 2.3.6 Quantum-Resistant Cryptography

- **Post-Quantum Algorithms**: Implements CRYSTALS-Kyber and CRYSTALS-Dilithium for future-proof security.

### 2.4 Blockchain Components

#### 2.4.1 Block Structure

- **Block Header**:
  - **Previous Block Hash**: Links the block to the chain.
  - **Merkle Root**: Summarizes all transactions.
  - **Timestamp**: Time of block creation.
  - **Coordinator Signature**: Validates the Coordinator Node's role.
- **Block Body**:
  - **Transactions**: List of validated transactions.
  - **Validator Signatures**: Multi-signatures from Validator Nodes.

#### 2.4.2 Transactions

- **Standard Transactions**: Asset transfers between participants.
- **Governance Transactions**: Proposals and votes for network changes.
- **Metadata**: Additional information for transparency.

#### 2.4.3 State Management

- **State Database**: Maintains current account states.
- **State Transitions**: Defined by executed transactions.

### 2.5 Efficiency Considerations

#### 2.5.1 Consensus Efficiency

- **Lightweight Process**: Eliminates energy-intensive computations.
- **Fast Finality**: Quick transaction confirmation due to cooperative agreement.

#### 2.5.2 Scalability Solutions

- **Sharding**: Divides the network into smaller groups process 
#### 2.5.3 Resource Optimization

- **Minimal Hardware Requirements**: Encourages broader participation.
- **Bandwidth Management**: Efficient protocols reduce network load.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Transaction Throughput**: Optimize for high throughput suitable for network demands.
- **Latency Minimization**: Ensure minimal delay in consensus rounds.

### 3.2 Security Requirements

- **Immutable Ledger**: Blocks are immutable once added.
- **Access Control**: Only authorized nodes can validate and propose blocks.
- **Data Integrity**: Secure cryptographic practices ensure data integrity.

### 3.3 Error Handling

- **Invalid Transactions**: Provide clear error messages upon rejection.
- **Fork Handling**: Establish protocols for resolving chain forks.

## 4. Testing Requirements

- **Unit Tests**: Cover consensus mechanisms, transaction validation, and security features.
- **Integration Tests**: Test interactions with other systems like the Identity and Reputation Systems.
- **Stress Tests**: Simulate high network load to test scalability.

## 5. Monitoring and Metrics

- **Consensus Monitoring**: Track consensus round performance and validator participation.
- **Security Audits**: Regular audits to detect and mitigate threats.
- **Performance Metrics**: Monitor transaction rates and block times.

## 6. Future Considerations

- **Consensus Mechanism Evolution**: Continuously evaluate and improve the PoC mechanism.
- **Interoperability**: Explore compatibility with other networks.
- **Smart Contract Integration**: Enhance cooperative functions through smart contracts.

```

---

You can save this file as `proof-of-cooperation.md` in your `./docs/specifications/core/` directory.

**Note:** This document provides a detailed specification of the Proof of Cooperation consensus mechanism, focusing on security mechanisms, blockchain components, and efficiency considerations, as per your request.

**Next Steps:**

- **Review and Edit**: Please review the document and make any necessary adjustments or additions specific to your project's needs.
- **Integration**: Incorporate this documentation into your project to guide development and ensure alignment with the designed consensus mechanism.

Let me know if you'd like assistance with any other components or further details.

===================
File: ./docs/specifications/core/reputation-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Reputation System
type: specification
version: 1.0.0
---

# Reputation System

## Overview
The Reputation System provides a non-transferable measure of trust and engagement within ICN. Reputation scores influence voting power, cooperative roles, and the ability to initiate proposals.

### Purpose
- **Incentivize Positive Behavior**: Encourage cooperative engagement and responsible voting.
- **Access Control**: Regulate participation based on reputation thresholds.
- **Transparent Governance**: Use reputation as a metric for cooperative influence.

## Data Structures

### Reputation System
- **scores**: `HashMap<String, i64>` - Maps DIDs to reputation scores.

### Reputation Score
- **Minimum**: Define lower thresholds to prevent negative reputation abuse.
- **Decay (planned)**: Implement periodic decay to maintain active engagement.

## Methods

### Increase Reputation
Increases reputation for actions like voting, creating proposals, or contributing resources.

### Decrease Reputation
Penalizes reputation for actions deemed harmful or against cooperative rules.

### Reward Voting Participation
Rewards active participation in voting, providing an incentive to engage in governance.

## Implementation Guidelines
- **Reputation Decay**: Decay inactive accounts periodically to prevent influence stagnation.
- **Thresholds**: Set thresholds for actions, e.g., minimum score for creating proposals.

## Monitoring and Metrics
- **Reputation Trends**: Track changes to analyze member engagement.
- **Vote Influence Analysis**: Record how reputation impacts voting outcomes.


===================
File: ./docs/specifications/core/blockchain-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Blockchain System
type: specification
version: 1.0.0
---

# Blockchain System

## Overview
The Blockchain System is the immutable ledger of the ICN, tracking all transactions, proposals, and reputation changes. Each cooperative or member transaction is recorded in the blockchain for transparency and traceability.

### Purpose
- **Transaction Integrity**: Ensures secure, tamper-resistant records of cooperative actions.
- **Reputation and Proposal Tracking**: Logs all reputation changes and governance activities.
- **Decentralized Ledger**: Provides a distributed record for cooperative actions and economic exchanges.

## Data Structures

### Block
- **index**: `u64` - Sequential block index.
- **previous_hash**: `String` - Hash of the previous block, linking it to the chain.
- **timestamp**: `u128` - Millisecond timestamp of creation.
- **transactions**: `Vec<Transaction>` - List of transactions included in the block.

### Transaction
- **sender**: `String` - DID of sender.
- **receiver**: `String` - DID of receiver.
- **amount**: `u64` - Value or resource exchanged.
- **hash**: `String` - Unique hash of the transaction, based on contents.

## Methods

### Add Transaction
Adds a new transaction to the pending list, verifying its contents before committing.

### Finalize Block
Bundles pending transactions into a block, calculating hash and adding to the blockchain.

### Calculate Hash
Computes the hash for each block, securing the data and linking blocks sequentially.

## Implementation Guidelines
- **Block Size Limit**: Define a maximum number of transactions per block to manage processing time.
- **Difficulty and Verification**: For scalability, adjust verification complexity based on load.

## Monitoring and Metrics
- **Transaction Throughput**: Measure number of transactions per block.
- **Hash Verification**: Track hash generation time to monitor performance.


===================
File: ./docs/specifications/core/governance-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance System
type: specification
version: 1.0.0
---

# Governance System

## Overview
The Governance System enables cooperative members to create, vote on, and track proposals within ICN. Proposals coordinate resource allocations, policy changes, and initiatives through reputation-weighted voting.

### Purpose
- **Decentralized Decision-Making**: Empowers cooperatives with direct influence over decisions.
- **Transparent Proposal Tracking**: Manages proposals throughout their lifecycle.
- **Reputation-Based Voting**: Aligns voting power with user contributions and engagement.

## Data Structures

### Proposal
- **id**: `u64` - Unique proposal identifier.
- **type**: `ProposalType` - Enum indicating proposal type (e.g., Funding).
- **status**: `ProposalStatus` - Enum indicating status (e.g., Open, Closed).
- **votes**: `Vec<(String, i64)>` - List of votes, with voter DID and weighted reputation.

### ProposalHistory
- **proposals**: `VecDeque<Proposal>` - Queue of proposals.
- **notifications**: `VecDeque<String>` - Queue of notifications for proposal events.

## Methods

### Create Proposal
Creates a proposal, setting parameters (type, description, duration) and initializing with Open status.

### Vote on Proposal
Registers a vote, using weighted reputation for transparency.

### Close Proposal
Locks in the proposal’s results, preventing further votes.

### Send Voting Reminder
Sends notifications to prompt voting for proposals near closure.

## Implementation Guidelines
- **Reputation Requirements**: Define minimum reputation for creating and voting to ensure credibility.
- **Standard Proposal Types**: Classify proposal types (Funding, PolicyChange) for consistency.

## Monitoring and Metrics
- **Proposal Activity**: Track proposal creation and voting rates.
- **Outcome Recording**: Log vote distribution and final outcome for cooperative accountability.


===================
File: ./docs/architecture/backend.md
===================
# Backend Architecture

The ICN backend handles core blockchain operations, transaction processing, and governance functionalities.

## Modules
1. **Blockchain Module**: Manages the decentralized ledger for recording transactions.
2. **Identity and DID Module**: Handles DID (Decentralized Identifiers) for secure, pseudonymous interactions.
3. **Reputation System**: Tracks and manages reputation scores, influencing governance roles and decision-making.

## Data Flow
- **Transaction Lifecycle**: Transactions are submitted, validated, and recorded in the blockchain, with reputation updates.
- **Reputation Tracking**: User actions affect their reputation score, impacting cooperative influence.


===================
File: ./docs/architecture/overview.md
===================
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.


===================
File: ./docs/architecture/diagrams/component/component.md
===================
# Component Diagram

This section provides a visual overview of the ICN's architectural components.

## Diagram
![Component Diagram](../images/component-diagram.png)

## Description
The ICN architecture is modular, allowing each component to function independently but interconnect to support cooperative and governance functionalities.
1. **Frontend Modules**: User interfaces for governance and cooperative management.
2. **API Gateway**: Manages communication between frontend and backend.
3. **Blockchain & VM**: Ensures secure transaction processing and execution of smart contracts.


===================
File: ./docs/architecture/diagrams/component.md
===================


