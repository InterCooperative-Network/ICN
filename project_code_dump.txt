Project Code Dump - Generated Mon Nov  4 12:04:26 PM UTC 2024
======================================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── lib.rs
│   ├── src
│   │   ├── api
│   │   │   ├── cooperative.rs
│   │   │   └── mod.rs
│   │   ├── blockchain
│   │   │   ├── blockchain.rs
│   │   │   ├── mod.rs
│   │   │   └── transaction.rs
│   │   ├── config
│   │   ├── consensus
│   │   │   ├── mod.rs
│   │   │   ├── proof_of_cooperation.rs
│   │   │   ├── tests.rs
│   │   │   └── types.rs
│   │   ├── cooperative
│   │   │   └── mod.rs
│   │   ├── governance
│   │   │   └── mod.rs
│   │   ├── identity
│   │   │   ├── authentication.rs
│   │   │   ├── did.rs
│   │   │   ├── identity_manager.rs
│   │   │   ├── identity_system.rs
│   │   │   ├── key_pair.rs
│   │   │   └── mod.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── reputation
│   │   │   ├── mod.rs
│   │   │   └── reputation_system.rs
│   │   ├── utils
│   │   │   ├── mod.rs
│   │   │   └── notifications.rs
│   │   └── vm
│   │       ├── contract.rs
│   │       ├── cooperative_metadata.rs
│   │       ├── event.rs
│   │       ├── execution_context.rs
│   │       ├── mod.rs
│   │       ├── opcode.rs
│   │       ├── tests
│   │       └── vm.rs
│   ├── target
│   │   ├── CACHEDIR.TAG
│   │   └── debug
│   │       ├── build
│   │       ├── deps
│   │       ├── examples
│   │       ├── icn-backend
│   │       ├── icn-backend.d
│   │       ├── incremental
│   │       ├── libicn_backend.d
│   │       └── libicn_backend.rlib
│   └── tests
│       └── integration_test.rs
├── contracts
│   ├── cooperative
│   │   └── src
│   │       └── lib.rs
│   └── governance
├── docker
│   ├── backend.Dockerfile
│   ├── docker-compose.yml
│   ├── docs
│   └── frontend.Dockerfile
├── docs
│   ├── INDEX.md
│   ├── README.md
│   ├── api
│   ├── architecture
│   │   ├── backend
│   │   ├── backend.md
│   │   ├── diagrams
│   │   │   ├── component
│   │   │   ├── component.md
│   │   │   ├── sequence
│   │   │   └── system
│   │   ├── frontend
│   │   ├── overview
│   │   └── overview.md
│   ├── development
│   │   ├── guides
│   │   │   └── documentation-standards.md
│   │   ├── plans
│   │   └── setup
│   ├── docs
│   │   └── index.md
│   ├── guides
│   │   └── index.md
│   ├── mkdocs.yml
│   ├── specifications
│   │   ├── api
│   │   │   └── governance-api.md
│   │   ├── core
│   │   │   ├── 2024-11-01-reputation-system.md
│   │   │   ├── blockchain-system.md
│   │   │   ├── governance-system.md
│   │   │   ├── identity-system.md
│   │   │   ├── proof-of-cooperation.md
│   │   │   ├── reputation-system.md
│   │   │   ├── transaction-system.md
│   │   │   └── vm-system.md
│   │   └── protocols
│   ├── templates
│   │   ├── api-template.md
│   │   ├── core-component-template.md
│   │   └── protocol-template.md
│   └── user
│       ├── guides
│       │   ├── index.md
│       │   ├── onboarding-guide.md
│       │   └── resource-management.md
│       └── tutorials
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   │   ├── cooperative
│   │   │   ├── governance
│   │   │   ├── identity
│   │   │   └── ui
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── project_code_dump.txt
├── setup_docs.sh
├── setup_venv.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── docmanager.cpython-312.pyc
    │   │   └── specgen.cpython-312.pyc
    │   ├── docmanager.py
    │   ├── docsctl
    │   └── specgen.py
    ├── install_docsctl.sh
    └── requirements.txt

66 directories, 84 files


===================
File: ./backend/src/identity/authentication.rs
===================
// src/identity/authentication.rs

pub struct Authentication {
    // Fields and methods for authentication
}


===================
File: ./backend/src/identity/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::{Serialize, Deserialize};
use rand::{thread_rng, RngCore};
use std::str::FromStr;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    #[serde(serialize_with = "serialize_public_key")]
    #[serde(deserialize_with = "deserialize_public_key")]
    pub public_key: PublicKey,
}

impl DID {
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);
        DID { id, public_key }
    }

    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let mut rng = thread_rng();
        
        // Generate random bytes for the secret key
        let mut secret_key_bytes = [0u8; 32];
        rng.fill_bytes(&mut secret_key_bytes);
        
        // Create secret key from the random bytes
        let secret_key = SecretKey::from_slice(&secret_key_bytes)
            .expect("Random bytes should produce valid key");
            
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);
        let did = DID { id, public_key };
        (did, secret_key)
    }
}

fn serialize_public_key<S>(key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&key.to_string())
}

fn deserialize_public_key<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let key_str = String::deserialize(deserializer)?;
    PublicKey::from_str(&key_str).map_err(serde::de::Error::custom)
}

===================
File: ./backend/src/identity/identity_system.rs
===================
use std::collections::HashMap;
use crate::identity::DID;

#[derive(Clone)]
pub struct IdentitySystem {
    permissions: HashMap<String, Vec<String>>,
    registered_dids: HashMap<String, DID>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        IdentitySystem {
            permissions: HashMap::new(),
            registered_dids: HashMap::new(),
        }
    }

    pub fn get_permissions(&self, did: &str) -> Vec<String> {
        self.permissions.get(did)
            .cloned()
            .unwrap_or_default()
    }

    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.permissions.insert(did.id.clone(), permissions);
        self.registered_dids.insert(did.id.clone(), did);
    }

    pub fn is_registered(&self, did: &str) -> bool {
        self.registered_dids.contains_key(did)
    }

    pub fn add_permission(&mut self, did: &str, permission: String) {
        if let Some(perms) = self.permissions.get_mut(did) {
            if !perms.contains(&permission) {
                perms.push(permission);
            }
        }
    }

    pub fn remove_permission(&mut self, did: &str, permission: &str) {
        if let Some(perms) = self.permissions.get_mut(did) {
            perms.retain(|p| p != permission);
        }
    }

    pub fn get_did(&self, did: &str) -> Option<&DID> {
        self.registered_dids.get(did)
    }
}

===================
File: ./backend/src/identity/key_pair.rs
===================
// src/identity/key_pair.rs

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
}


===================
File: ./backend/src/identity/mod.rs
===================
// src/identity/mod.rs

pub mod did;
// pub mod key_pair;
// pub mod identity_manager;
// pub mod authentication;
pub mod identity_system;

pub use did::DID;
// pub use key_pair::KeyPair;
// pub use identity_manager::IdentityManager;
// pub use authentication::Authentication;
pub use identity_system::IdentitySystem;


===================
File: ./backend/src/identity/identity_manager.rs
===================
// src/identity/identity_manager.rs

pub struct IdentityManager {
    // Fields and methods for managing identities
}


===================
File: ./backend/src/cooperative/mod.rs
===================


===================
File: ./backend/src/utils/notifications.rs
===================
use chrono::{DateTime, Utc};
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}

===================
File: ./backend/src/utils/mod.rs
===================
pub mod notifications;



===================
File: ./backend/src/vm/contract.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use super::opcode::OpCode;
use super::cooperative_metadata::CooperativeMetadata;

#[derive(Clone, Serialize, Deserialize)]
pub struct Contract {
    pub id: String,
    pub code: Vec<OpCode>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/cooperative_metadata.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct ResourceImpact {
    pub cpu_intensity: u8,
    pub memory_usage: u8,
    pub network_usage: u8,
    pub storage_usage: u8,
    pub bandwidth_usage: u8,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct CooperativeMetadata {
    pub creator_did: String,
    pub cooperative_id: String,
    pub purpose: String,
    pub resource_impact: ResourceImpact,
    pub federation_id: Option<String>,
    pub creation_timestamp: u64,
    pub last_updated: u64,
    pub member_count: u64,
    pub resource_allocation: HashMap<String, u64>,
}


===================
File: ./backend/src/vm/vm.rs
===================
use std::collections::HashMap;
use super::opcode::OpCode;
use super::contract::Contract;
use super::execution_context::ExecutionContext;
use super::cooperative_metadata::CooperativeMetadata;
use super::event::Event;

pub struct VM {
    stack: Vec<i64>,
    memory: HashMap<String, i64>,
    execution_context: Option<ExecutionContext>,
    events: Vec<Event>,
    logs: Vec<String>,
    pub reputation_context: HashMap<String, i64>,
    instruction_limit: usize,
    instruction_pointer: usize,
}

impl VM {
    pub fn new(instruction_limit: usize, reputation_context: HashMap<String, i64>) -> Self {
        VM {
            stack: Vec::new(),
            memory: HashMap::new(),
            execution_context: None,
            events: Vec::new(),
            logs: Vec::new(),
            reputation_context,
            instruction_limit,
            instruction_pointer: 0,
        }
    }

    pub fn get_reputation_context(&self) -> &HashMap<String, i64> {
        &self.reputation_context
    }

    pub fn set_execution_context(&mut self, context: ExecutionContext) {
        self.execution_context = Some(context);
    }

    pub fn execute_contract(&mut self, contract: &Contract) -> Result<(), String> {
        // Check execution context
        let context = self.execution_context.as_ref().ok_or("No execution context".to_string())?;

        // Check caller reputation
        let caller_reputation = self
            .reputation_context
            .get(&context.caller_did)
            .copied()
            .unwrap_or(0);
        if caller_reputation < contract.required_reputation {
            return Err("Insufficient reputation to execute contract".to_string());
        }

        // Check permissions
        for permission in &contract.permissions {
            if !context.permissions.contains(permission) {
                return Err(format!("Missing permission: {}", permission));
            }
        }

        // Execute instructions
        let code_len = contract.code.len();
        self.instruction_pointer = 0;

        while self.instruction_pointer < code_len {
            if self.instruction_pointer >= self.instruction_limit {
                return Err("Instruction limit exceeded".to_string());
            }

            let op = &contract.code[self.instruction_pointer];
            self.execute_instruction(op, &contract.cooperative_metadata)?;

            self.instruction_pointer += 1;
        }

        Ok(())
    }

    pub fn execute_instruction(
        &mut self,
        op: &OpCode,
        metadata: &CooperativeMetadata,
    ) -> Result<(), String> {
        match op {
            OpCode::Push(val) => {
                self.stack.push(*val);
                Ok(())
            }
            OpCode::Pop => {
                self.stack.pop().ok_or("Stack underflow".to_string())?;
                Ok(())
            }
            OpCode::Dup => {
                let val = *self.stack.last().ok_or("Stack underflow")?;
                self.stack.push(val);
                Ok(())
            }
            OpCode::Swap => {
                let len = self.stack.len();
                if len < 2 {
                    return Err("Not enough values on the stack to swap".to_string());
                }
                self.stack.swap(len - 1, len - 2);
                Ok(())
            }
            OpCode::Add => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a + b);
                Ok(())
            }
            OpCode::Sub => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a - b);
                Ok(())
            }
            OpCode::Mul => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a * b);
                Ok(())
            }
            OpCode::Div => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Division by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a / b);
                Ok(())
            }
            OpCode::Mod => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Modulo by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a % b);
                Ok(())
            }
            OpCode::Store(key) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(key.clone(), value);
                Ok(())
            }
            OpCode::Load(key) => {
                let value = self
                    .memory
                    .get(key)
                    .copied()
                    .ok_or("Key not found in memory".to_string())?;
                self.stack.push(value);
                Ok(())
            }
            OpCode::Jump(target) => {
                if *target >= self.instruction_limit {
                    return Err("Jump target out of bounds".to_string());
                }
                self.instruction_pointer = *target;
                Ok(())
            }
            OpCode::JumpIf(target) => {
                let condition = self.stack.pop().ok_or("Stack underflow")?;
                if condition != 0 {
                    if *target >= self.instruction_limit {
                        return Err("Jump target out of bounds".to_string());
                    }
                    self.instruction_pointer = *target;
                }
                Ok(())
            }
            OpCode::CreateCooperative => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"cooperative.create".to_string()) {
                    return Err("Permission denied: cooperative.create".to_string());
                }
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                if reputation < 100 {
                    return Err("Insufficient reputation to create cooperative".to_string());
                }
                self.emit_event(
                    "CooperativeCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::AllocateResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceAllocated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), resource_amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::TransferResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceTransferred",
                    metadata.cooperative_id.clone(),
                    [
                        ("amount".to_string(), resource_amount.to_string()),
                        ("to_member".to_string(), to_member_id.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateCooperativeMetadata => {
                Ok(())
            }
            OpCode::AddCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberAdded",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::RemoveCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberRemoved",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::SetMemberRole => {
                let role = self.stack.pop().ok_or("Stack underflow")?;
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "MemberRoleSet",
                    metadata.cooperative_id.clone(),
                    [
                        ("member_id".to_string(), member_id.to_string()),
                        ("role".to_string(), role.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::CreateProposal => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"proposal.create".to_string()) {
                    return Err("Permission denied: proposal.create".to_string());
                }
                self.emit_event(
                    "ProposalCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CastVote => {
                let vote_value = self.stack.pop().ok_or("Stack underflow")?;
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VoteCast",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("vote_value".to_string(), vote_value.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::DelegateVotes => {
                let delegate_to_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotesDelegated",
                    metadata.cooperative_id.clone(),
                    [("delegate_to".to_string(), delegate_to_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExecuteProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalExecuted",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CancelProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalCancelled",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExtendVotingPeriod => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                let additional_time = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotingPeriodExtended",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("additional_time".to_string(), additional_time.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateQuorum => {
                let new_quorum = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "QuorumUpdated",
                    metadata.cooperative_id.clone(),
                    [("new_quorum".to_string(), new_quorum.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CalculateVotingWeight => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::UpdateReputation(amount) => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                *reputation += *amount;
                self.emit_event(
                    "ReputationUpdated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::GetReputation => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::TransferReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let from_context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;

                    let from_reputation = self
                    .reputation_context
                    .entry(from_context.caller_did.clone())
                    .or_insert(0);
                if *from_reputation < amount {
                    return Err("Insufficient reputation to transfer".to_string());
                }

                *from_reputation -= amount;
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;

                self.emit_event(
                    "ReputationTransferred",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::BurnReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                if *reputation < amount {
                    return Err("Insufficient reputation to burn".to_string());
                }
                *reputation -= amount;
                self.emit_event(
                    "ReputationBurned",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::MintReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;
                self.emit_event(
                    "ReputationMinted",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::VerifyDID => {
                self.stack.push(1); // 1 for true
                Ok(())
            }
            OpCode::UpdateDIDDocument => {
                self.emit_event(
                    "DIDDocumentUpdated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CreateCredential => {
                self.emit_event(
                    "CredentialCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::VerifyCredential => {
                self.stack.push(1); // Assume credential is valid
                Ok(())
            }
            OpCode::RevokeCredential => {
                self.emit_event(
                    "CredentialRevoked",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::InitiateFederation => {
                self.emit_event(
                    "FederationInitiated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinFederation => {
                self.emit_event(
                    "FederationJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveFederation => {
                self.emit_event(
                    "FederationLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::SyncFederationState => {
                self.emit_event(
                    "FederationStateSynced",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateFederationAction => {
                self.stack.push(1); // Assume action is valid
                Ok(())
            }
            OpCode::CreateTransaction => {
                self.emit_event(
                    "TransactionCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateTransaction => {
                self.stack.push(1); // Assume transaction is valid
                Ok(())
            }
            OpCode::SignTransaction => {
                self.emit_event(
                    "TransactionSigned",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::BroadcastTransaction => {
                self.emit_event(
                    "TransactionBroadcasted",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::Log(message) => {
                self.logs.push(format!("Log: {}", message));
                Ok(())
            }
            OpCode::Halt => {
                self.instruction_pointer = self.instruction_limit;
                Ok(())
            }
            OpCode::EmitEvent(event_type) => {
                self.emit_event(event_type, metadata.cooperative_id.clone(), HashMap::new());
                Ok(())
            }
            OpCode::GetBlockNumber => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.block_number as i64);
                Ok(())
            }
            OpCode::GetTimestamp => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.timestamp as i64);
                Ok(())
            }
                // Add the GetCaller implementation here:
            OpCode::GetCaller => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let caller_id_hash = self.hash_did(&context.caller_did);
                self.stack.push(caller_id_hash);
                Ok(())
            }
            
            OpCode::Equal => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a == b { 1 } else { 0 });
                Ok(())
            }
            OpCode::NotEqual => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a != b { 1 } else { 0 });
                Ok(())
            }
            OpCode::GreaterThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a > b { 1 } else { 0 });
                Ok(())
            }
            OpCode::LessThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a < b { 1 } else { 0 });
                Ok(())
            }
            OpCode::And => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a & b);
                Ok(())
            }
            OpCode::Or => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a | b);
                Ok(())
            }
            OpCode::Not => {
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(!a);
                Ok(())
            }
            OpCode::Nop => Ok(()),
        }
    }

    fn emit_event(&mut self, event_type: &str, cooperative_id: String, data: HashMap<String, String>) {
        if let Some(context) = &self.execution_context {
            let event = Event {
                event_type: event_type.to_string(),
                cooperative_id,
                data,
                timestamp: context.timestamp,
            };
            self.events.push(event);
        }
    }

    fn hash_did(&self, did: &str) -> i64 {
        // Simple hash function for example purposes
        did.bytes().fold(0, |acc, b| acc + b as i64)
    }

    fn reverse_hash_did(&self, hash: i64) -> String {
        format!("did:placeholder:{}", hash)
    }

    pub fn get_logs(&self) -> &Vec<String> {
        &self.logs
    }

    pub fn get_events(&self) -> &Vec<Event> {
        &self.events
    }

    pub fn get_stack(&self) -> &Vec<i64> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.memory
    }
}

===================
File: ./backend/src/vm/tests/vm_tests.rs
===================
#[cfg(test)]
mod tests {
    use super::super::*;
    use std::collections::HashMap;

    fn setup_vm() -> VM {
        let instruction_limit = 1000;
        let reputation_context = HashMap::new();
        VM::new(instruction_limit, reputation_context)
    }

    fn default_execution_context() -> ExecutionContext {
        ExecutionContext {
            caller_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            timestamp: 1620000000,
            block_number: 1,
            reputation_score: 100,
            permissions: vec!["cooperative.create".to_string(), "proposal.create".to_string()],
        }
    }

    fn default_cooperative_metadata() -> CooperativeMetadata {
        CooperativeMetadata {
            creator_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            purpose: "Test Cooperative".to_string(),
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: 1620000000,
            last_updated: 1620000000,
            member_count: 1,
            resource_allocation: HashMap::new(),
        }
    }

    #[test]
    fn test_push_pop() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "test_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(20),
                OpCode::Pop,
                OpCode::Push(30),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 10);
        assert_eq!(stack[1], 30);
    }

    #[test]
    fn test_arithmetic_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "arithmetic_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(5),
                OpCode::Add,
                OpCode::Push(2),
                OpCode::Mul,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 30); // (10 + 5) * 2 = 30
    }

    #[test]
    fn test_memory_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "memory_contract".to_string(),
            code: vec![
                OpCode::Push(42),
                OpCode::Store("answer".to_string()),
                OpCode::Load("answer".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 42);
    }

    #[test]
    fn test_control_flow_jump() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_contract".to_string(),
            code: vec![
                OpCode::Push(1),             // 0
                OpCode::Jump(4),             // 1
                OpCode::Push(999),           // 2 (should be skipped)
                OpCode::Halt,                // 3 (should be skipped)
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 1);
        assert_eq!(stack[1], 2);
    }

    #[test]
    fn test_control_flow_jumpif() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_jumpif_contract".to_string(),
            code: vec![
                OpCode::Push(0),             // 0
                OpCode::JumpIf(4),           // 1 (should not jump)
                OpCode::Push(1),             // 2
                OpCode::Halt,                // 3
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1);
    }

    #[test]
    fn test_comparison_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "comparison_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(10),
                OpCode::Equal,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1); // 1 for true
    }

    #[test]
    fn test_cooperative_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "cooperative_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CooperativeCreated");
    }

    #[test]
    fn test_reputation_operations() {
        let mut reputation_context = HashMap::new();
        reputation_context.insert("did:icn:12345".to_string(), 50);

        let mut vm = VM::new(1000, reputation_context);
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "reputation_contract".to_string(),
            code: vec![
                OpCode::UpdateReputation(25),
                OpCode::GetReputation,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 75);

        let updated_reputation = vm.reputation_context.get("did:icn:12345").copied().unwrap_or(0);
        assert_eq!(updated_reputation, 75);
    }

    #[test]
    fn test_error_handling_division_by_zero() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "error_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(0),
                OpCode::Div,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero".to_string());
    }

    #[test]
    fn test_event_emission() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "event_contract".to_string(),
            code: vec![
                OpCode::EmitEvent("CustomEvent".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CustomEvent");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "high_reputation_contract".to_string(),
            code: vec![
                OpCode::Push(1),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 200,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient reputation to execute contract".to_string());
    }

    #[test]
    fn test_missing_permission() {
        let mut vm = setup_vm();
        let mut context = default_execution_context();
        context.permissions = vec![]; // No permissions
        vm.set_execution_context(context);

        let contract = Contract {
            id: "permission_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Missing permission: cooperative.create".to_string());
    }
}


===================
File: ./backend/src/vm/mod.rs
===================
pub mod opcode;
pub mod contract;
pub mod vm;
pub mod execution_context;
pub mod cooperative_metadata;
pub mod event;

pub use opcode::OpCode;
pub use contract::Contract;
pub use vm::VM;
pub use execution_context::ExecutionContext;
pub use cooperative_metadata::{CooperativeMetadata, ResourceImpact};
pub use event::Event;


===================
File: ./backend/src/vm/opcode.rs
===================
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Stack Operations
    Push(i64),        // Push a value onto the stack
    Pop,              // Pop the top value from the stack
    Dup,              // Duplicate the top value on the stack
    Swap,             // Swap the top two values on the stack

    // Arithmetic Operations
    Add,              // Add top two values
    Sub,              // Subtract top two values
    Mul,              // Multiply top two values
    Div,              // Divide top two values
    Mod,              // Modulo of top two values

    // Memory Operations
    Store(String),    // Store a value in memory with a key
    Load(String),     // Load a value from memory with a key

    // Control Flow Operations
    Jump(usize),      // Unconditional jump to instruction index
    JumpIf(usize),    // Conditional jump if top of stack is non-zero

    // Cooperative Operations
    CreateCooperative,
    JoinCooperative,
    LeaveCooperative,
    AllocateResource,
    TransferResource,
    UpdateCooperativeMetadata,
    AddCooperativeMember,
    RemoveCooperativeMember,
    SetMemberRole,

    // Governance Operations
    CreateProposal,
    CastVote,
    DelegateVotes,
    ExecuteProposal,
    UpdateQuorum,
    CancelProposal,
    ExtendVotingPeriod,
    CalculateVotingWeight,

    // Reputation Operations
    UpdateReputation(i64),
    GetReputation,
    TransferReputation,
    BurnReputation,
    MintReputation,

    // Identity Operations
    VerifyDID,
    UpdateDIDDocument,
    CreateCredential,
    VerifyCredential,
    RevokeCredential,

    // Federation Operations
    InitiateFederation,
    JoinFederation,
    LeaveFederation,
    SyncFederationState,
    ValidateFederationAction,

    // Transaction Operations
    CreateTransaction,
    ValidateTransaction,
    SignTransaction,
    BroadcastTransaction,

    // System Operations
    Log(String),
    Halt,
    EmitEvent(String),
    GetBlockNumber,
    GetTimestamp,
    GetCaller,

    // Comparison Operations
    Equal,
    NotEqual,
    GreaterThan,
    LessThan,

    // Logical Operations
    And,
    Or,
    Not,

    // No Operation
    Nop,
}

===================
File: ./backend/src/vm/event.rs
===================
use std::collections::HashMap;

pub struct Event {
    pub event_type: String,
    pub cooperative_id: String,
    pub data: HashMap<String, String>,
    pub timestamp: u64,
}


===================
File: ./backend/src/vm/execution_context.rs
===================
pub struct ExecutionContext {
    pub caller_did: String,
    pub cooperative_id: String,
    pub timestamp: u64,
    pub block_number: u64,
    pub reputation_score: i64,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/api/cooperative.rs
===================


===================
File: ./backend/src/api/mod.rs
===================


===================
File: ./backend/src/blockchain/mod.rs
===================
pub mod transaction;

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use self::transaction::{Transaction, TransactionType};
use std::collections::HashMap;

use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::vm::{VM, Contract, ExecutionContext};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Block {
    pub index: u64,
    pub previous_hash: String,
    pub timestamp: u128,
    pub transactions: Vec<Transaction>, // Vector to hold transactions
    pub hash: String,
}

impl Block {
    /// Creates a new block with a list of transactions and calculates its hash.
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_hash(index, &previous_hash, timestamp, &transactions);

        Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash,
        }
    }

    /// Calculates a hash for the block based on its contents.
    fn calculate_hash(index: u64, previous_hash: &str, timestamp: u128, transactions: &Vec<Transaction>) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = serde_json::to_string(transactions).expect("Failed to serialize transactions");
        hasher.update(format!("{}{}{}{}", index, previous_hash, timestamp, transaction_data));
        let result = hasher.finalize();
        format!("{:x}", result)
    }
}

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub difficulty: usize,
    pub identity_system: IdentitySystem,
    pub reputation_system: ReputationSystem,
    pub contracts: HashMap<String, Contract>,
    pub current_block_number: u64,
}

impl Blockchain {
    /// Initializes a new blockchain with a genesis block.
    pub fn new(identity_system: IdentitySystem, reputation_system: ReputationSystem) -> Self {
        let genesis_block = Block::new(0, String::from("0"), vec![]);
        Blockchain {
            chain: vec![genesis_block],
            pending_transactions: vec![],
            difficulty: 2,
            identity_system,
            reputation_system,
            contracts: HashMap::new(),
            current_block_number: 1,
        }
    }

    /// Adds a new transaction to the list of pending transactions.
    pub fn add_transaction(&mut self, transaction: Transaction) {
        self.pending_transactions.push(transaction);
    }

    /// Finalizes a new block with pending transactions.
    pub fn finalize_block(&mut self) {
        let previous_hash = self.chain.last().unwrap().hash.clone();
        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        self.chain.push(new_block);
        self.pending_transactions.clear();
        self.current_block_number += 1;
    }

    /// Processes a transaction
    pub fn process_transaction(&mut self, transaction: &Transaction) -> Result<(), String> {
        match &transaction.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                // Handle transfer logic (simplified for this example)
                println!(
                    "Processed transfer of {} from {} to {}",
                    amount, transaction.sender, receiver
                );
                Ok(())
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                // Fetch the contract
                let contract = self.get_contract(contract_id)?;
                
                // Set up the VM
                let mut vm = VM::new(
                    1000, // Instruction limit
                    self.reputation_system.get_reputation_context(),
                );

                // Create ExecutionContext
                let execution_context = ExecutionContext {
                    caller_did: transaction.sender.clone(),
                    cooperative_id: contract.cooperative_metadata.cooperative_id.clone(),
                    timestamp: transaction.timestamp as u64,
                    block_number: self.current_block_number,
                    reputation_score: self.reputation_system.get_reputation(&transaction.sender),
                    permissions: self.identity_system.get_permissions(&transaction.sender),
                };

                vm.set_execution_context(execution_context);

                // Execute the contract
                let result = vm.execute_contract(&contract);

                // Handle result
                match result {
                    Ok(_) => {
                        // Update state based on vm.memory or vm.events
                        self.handle_vm_events(vm.get_events());
                        self.reputation_system.update_reputations(vm.get_reputation_context());
                        Ok(())
                    }
                    Err(e) => Err(format!("Contract execution failed: {}", e)),
                }
            }
            // ... handle other transaction types
        }
    }

    /// Handle VM events emitted during contract execution
    fn handle_vm_events(&mut self, events: &Vec<crate::vm::Event>) {
        for event in events {
            match event.event_type.as_str() {
                "CooperativeCreated" => {
                    // Update blockchain state to include the new cooperative
                    println!("Event: CooperativeCreated - {}", event.data.get("creator").unwrap());
                }
                "ProposalCreated" => {
                    // Add the proposal to the governance module
                    println!("Event: ProposalCreated");
                }
                // Handle other event types...
                _ => {
                    // Log or ignore unknown events
                    println!("Unknown event type: {}", event.event_type);
                }
            }
        }
    }

    /// Get a contract by ID
    fn get_contract(&self, contract_id: &str) -> Result<&Contract, String> {
        self.contracts.get(contract_id).ok_or_else(|| "Contract not found".to_string())
    }
}


===================
File: ./backend/src/blockchain/transaction.rs
===================
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    Transfer {
        receiver: String,
        amount: u64,
    },
    ContractExecution {
        contract_id: String,
        input_data: HashMap<String, i64>, // Optional input data for the contract
    },
    // ... other transaction types
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,       // DID of sender
    pub transaction_type: TransactionType,
    pub timestamp: u128,      // Transaction timestamp
    pub hash: String,         // Hash to secure transaction
}

impl Transaction {
    /// Creates a new transaction and calculates its hash
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);

        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
        }
    }

    /// Calculate the transaction hash based on transaction details
    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            }
            // Handle other transaction types
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        let result = hasher.finalize();
        format!("{:x}", result)
    }
}


===================
File: ./backend/src/blockchain/blockchain.rs
===================
use super::transaction::{Transaction, TransactionType};
use super::block::Block;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::vm::{VM, ExecutionContext};
use crate::vm::contract::Contract;
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub contracts: HashMap<String, Contract>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub current_block_number: u64,
}

impl Blockchain {
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>,
        reputation_system: Arc<Mutex<ReputationSystem>>,
    ) -> Self {
        Blockchain {
            chain: vec![],
            pending_transactions: vec![],
            contracts: HashMap::new(),
            identity_system,
            reputation_system,
            current_block_number: 0,
        }
    }

    pub fn process_transaction(&mut self, transaction: &Transaction) -> Result<(), String> {
        match &transaction.transaction_type {
            TransactionType::Transfer { amount, receiver } => {
                // Handle standard transfer transaction
                self.validate_transaction(transaction)?;
                // Update balances, etc.
                self.pending_transactions.push(transaction.clone());
                Ok(())
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                // Fetch the contract
                let contract = self.get_contract(contract_id)?;
                // Set up the VM
                let reputation_context = self.reputation_system.lock().unwrap().get_reputation_context();
                let mut vm = VM::new(1000, reputation_context);

                // Create ExecutionContext
                let identity_system = self.identity_system.lock().unwrap();
                let permissions = identity_system.get_permissions(&transaction.sender);
                let reputation_score = self.reputation_system.lock().unwrap().get_reputation(&transaction.sender);

                let execution_context = ExecutionContext {
                    caller_did: transaction.sender.clone(),
                    cooperative_id: contract.cooperative_metadata.cooperative_id.clone(),
                    timestamp: transaction.timestamp,
                    block_number: self.current_block_number,
                    reputation_score,
                    permissions,
                };

                vm.set_execution_context(execution_context);

                // Execute the contract
                let result = vm.execute_contract(&contract);

                // Handle result
                match result {
                    Ok(_) => {
                        // Update state based on vm.memory or vm.events
                        self.handle_vm_events(vm.get_events());
                        self.reputation_system.lock().unwrap().update_reputations(vm.reputation_context);
                        self.pending_transactions.push(transaction.clone());
                        Ok(())
                    }
                    Err(e) => Err(format!("Contract execution failed: {}", e)),
                }
            }
            // Handle other transaction types...
        }
    }

    fn validate_transaction(&self, transaction: &Transaction) -> Result<(), String> {
        // Validate transaction signature, balances, etc.
        Ok(())
    }

    fn get_contract(&self, contract_id: &str) -> Result<Contract, String> {
        self.contracts.get(contract_id).cloned().ok_or(format!("Contract {} not found", contract_id))
    }

    fn handle_vm_events(&mut self, events: &Vec<crate::vm::event::Event>) {
        for event in events {
            match event.event_type.as_str() {
                "CooperativeCreated" => {
                    // Update blockchain state to include the new cooperative
                    println!("Cooperative created: {:?}", event.data);
                }
                "ProposalCreated" => {
                    // Add the proposal to the governance module
                    println!("Proposal created: {:?}", event.data);
                }
                // Handle other event types...
                _ => {
                    // Log or ignore unknown events
                    println!("Unknown event: {:?}", event);
                }
            }
        }
    }

    pub fn create_contract(&mut self, contract: Contract) {
        self.contracts.insert(contract.id.clone(), contract);
    }
}


===================
File: ./backend/src/reputation/reputation_system.rs
===================
use std::collections::HashMap;

pub struct ReputationSystem {
    reputations: HashMap<String, i64>, // DID -> Reputation Score
}

impl ReputationSystem {
    pub fn new() -> Self {
        ReputationSystem {
            reputations: HashMap::new(),
        }
    }

    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.reputations.clone()
    }

    pub fn update_reputations(&mut self, updated_reputations: HashMap<String, i64>) {
        for (did, score) in updated_reputations {
            self.reputations.insert(did, score);
        }
    }

    pub fn get_reputation(&self, did: &str) -> i64 {
        self.reputations.get(did).copied().unwrap_or(0)
    }

    // Additional methods for reputation management...
}


===================
File: ./backend/src/reputation/mod.rs
===================
use std::collections::HashMap;
#[allow(dead_code)]
#[derive(Clone)]
pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) += amount;
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        *self.scores.entry(did.to_string()).or_insert(0) -= amount;
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        self.increase_reputation(did, reward_points);
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }

    /// Returns a clone of the reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates the reputation context with changes from the VM execution
    pub fn update_reputations(&mut self, updated_reputations: &HashMap<String, i64>) {
        for (did, reputation) in updated_reputations {
            self.scores.insert(did.clone(), *reputation);
        }
    }
}


===================
File: ./backend/src/governance/mod.rs
===================
use std::collections::VecDeque;
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: VecDeque<Proposal>,
    pub notifications: VecDeque<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: VecDeque::new(),
            notifications: VecDeque::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.push_back(proposal);
        self.notifications.push_back("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.iter_mut().find(|p| p.id == proposal_id) {
            proposal.close();
            self.notifications.push_back(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.iter() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push_back(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in &self.proposals {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}

===================
File: ./backend/src/main.rs
===================
mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;

use std::collections::HashMap;
use blockchain::{Blockchain, transaction::{Transaction, TransactionType}};
use identity::{DID, IdentitySystem};
use reputation::ReputationSystem;
use governance::{Proposal, ProposalType, ProposalHistory};
use vm::{Contract, CooperativeMetadata, OpCode, ResourceImpact};

fn main() {
    // Initialize systems
    let mut identity_system = IdentitySystem::new();
    let mut reputation_system = ReputationSystem::new();

    // Initialize Blockchain with IdentitySystem and ReputationSystem
    let mut blockchain = Blockchain::new(identity_system.clone(), reputation_system.clone());
    let mut proposal_history = ProposalHistory::new();

    // Generate DIDs
    let (sender_did, _) = DID::generate_random(String::from("did:icn:001"));
    let (receiver_did, _) = DID::generate_random(String::from("did:icn:002"));

    // Register DIDs in IdentitySystem with permissions
    identity_system.register_did(
        sender_did.clone(),
        vec![
            "cooperative.create".to_string(),
            "proposal.create".to_string(),
            "resource.allocate".to_string()
        ]
    );
    identity_system.register_did(receiver_did.clone(), vec![]);

    // Set initial reputation for sender (important for contract execution)
    reputation_system.increase_reputation(&sender_did.id, 100);  // Ensure enough reputation for contract execution

    // Create transactions
    let transaction1 = Transaction::new(
        sender_did.id.clone(),
        TransactionType::Transfer {
            receiver: receiver_did.id.clone(),
            amount: 100,
        },
    );
    blockchain.add_transaction(transaction1);

    let transaction2 = Transaction::new(
        receiver_did.id.clone(),
        TransactionType::Transfer {
            receiver: sender_did.id.clone(),
            amount: 50,
        },
    );
    blockchain.add_transaction(transaction2);

    // Finalize the block
    blockchain.finalize_block();

    // Process transactions
    let transactions_to_process: Vec<Transaction> = blockchain.chain.last()
        .map(|block| block.transactions.clone())
        .unwrap_or_default();
    
    for transaction in transactions_to_process {
        blockchain.process_transaction(&transaction)
            .unwrap_or_else(|e| println!("{}", e));
    }

    // Create and manage proposals
    let proposal1 = Proposal::new(
        1,
        ProposalType::Funding,
        String::from("Proposal for funding development."),
    );
    proposal_history.add_proposal(proposal1);

    let proposal2 = Proposal::new(
        2,
        ProposalType::PolicyChange,
        String::from("Proposal for changing cooperative policy."),
    );
    proposal_history.add_proposal(proposal2);

    // Vote and manage proposals
    proposal_history.send_voting_reminder();
    if let Some(proposal) = proposal_history.proposals.get_mut(0) {
        proposal.vote(&sender_did.id, 10);
        proposal.close();
    }
    if let Some(proposal) = proposal_history.proposals.get_mut(1) {
        proposal.vote(&receiver_did.id, 5);
    }

    // Display proposal history
    proposal_history.display_history();

    // Create and setup a test contract
    let metadata = CooperativeMetadata {
        creator_did: sender_did.id.clone(),
        cooperative_id: "coop1".to_string(),
        purpose: "Allocate resources for development".to_string(),
        resource_impact: ResourceImpact {
            cpu_intensity: 10,
            memory_usage: 10,
            network_usage: 10,
            storage_usage: 10,
            bandwidth_usage: 10,
        },
        federation_id: None,
        creation_timestamp: 1635724800,
        last_updated: 1635724800,
        member_count: 1,
        resource_allocation: HashMap::new(),
    };

    let contract = Contract {
        id: "contract1".to_string(),
        code: vec![
            OpCode::Push(1),
            OpCode::AllocateResource,
            OpCode::Halt,
        ],
        state: HashMap::new(),
        required_reputation: 50,  // This should now be less than sender's reputation
        cooperative_metadata: metadata.clone(),
        version: "1.0.0".to_string(),
        dependencies: Vec::new(),
        permissions: vec!["resource.allocate".to_string()],
    };

    // Register contract and create transaction
    blockchain.contracts.insert(contract.id.clone(), contract.clone());

    let contract_transaction = Transaction::new(
        sender_did.id.clone(),
        TransactionType::ContractExecution {
            contract_id: contract.id.clone(),
            input_data: HashMap::new(),
        },
    );

    blockchain.add_transaction(contract_transaction);
    blockchain.finalize_block();

    // Process the new block's transactions
    let transactions_to_process: Vec<Transaction> = blockchain.chain.last()
        .map(|block| block.transactions.clone())
        .unwrap_or_default();
    
    for transaction in transactions_to_process {
        blockchain.process_transaction(&transaction)
            .unwrap_or_else(|e| println!("{}", e));
    }

    println!("Blockchain and VM integration completed.");
}

===================
File: ./backend/src/lib.rs
===================
pub mod blockchain;
pub mod identity;
pub mod reputation;
pub mod governance;
pub mod utils;
pub mod vm;


===================
File: ./backend/src/consensus/tests.rs
===================
# File: ./backend/src/consensus/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::blockchain::Blockchain;
    use crate::identity::IdentitySystem;
    use crate::reputation::ReputationSystem;

    fn setup_test_blockchain() -> Blockchain {
        let identity_system = IdentitySystem::new();
        let reputation_system = ReputationSystem::new();
        let mut blockchain = Blockchain::new(identity_system, reputation_system);
        
        // Register test validators
        blockchain.consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:3".to_string(), 100).unwrap();
        
        blockchain
    }

    #[test]
    fn test_consensus_integration() {
        let mut blockchain = setup_test_blockchain();
        
        // Add some test transactions
        let transaction = Transaction::new(
            "did:icn:1".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:2".to_string(),
                amount: 100,
            },
        );
        blockchain.add_transaction(transaction);

        // Try to finalize block through consensus
        assert!(blockchain.finalize_block().is_ok());
        
        // Verify block was added
        assert_eq!(blockchain.chain.len(), 2);
        
        // Verify reputation updates were applied
        let reputation_updates = blockchain.consensus.get_reputation_updates();
        assert!(!reputation_updates.is_empty());
    }

    #[test]
    fn test_consensus_failure_recovery() {
        let mut blockchain = setup_test_blockchain();
        
        // Simulate a failed consensus round
        blockchain.consensus.start_round().unwrap();
        blockchain.consensus.check_timeout();
        
        // Verify we can start a new round after failure
        assert!(blockchain.finalize_block().is_ok());
    }
}

===================
File: ./backend/src/consensus/types.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use crate::blockchain::Block;

/// Represents a validator node in the network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Validator {
    /// The validator's DID
    pub did: String,
    
    /// Current reputation score
    pub reputation: i64,
    
    /// Block number of the last block this validator proposed
    pub last_block_proposed: u64,
    
    /// Number of consecutive validation rounds missed
    pub consecutive_missed_validations: u32,
    
    /// Whether the validator is currently active
    pub is_active: bool,
    
    /// The validator's voting power in the current round
    #[serde(skip_serializing_if = "Option::is_none")]
    pub voting_power: Option<f64>,
}

impl Validator {
    pub fn new(did: String, initial_reputation: i64) -> Self {
        Self {
            did,
            reputation: initial_reputation,
            last_block_proposed: 0,
            consecutive_missed_validations: 0,
            is_active: true,
            voting_power: None,
        }
    }

    pub fn calculate_voting_power(&mut self, total_reputation: i64) {
        self.voting_power = Some(self.reputation as f64 / total_reputation as f64);
    }

    pub fn is_eligible(&self, min_reputation: i64) -> bool {
        self.is_active && self.reputation >= min_reputation
    }
}

/// Represents the type of consensus message being sent
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusMessage {
    /// Proposal for a new block
    BlockProposal(Block),
    
    /// Vote for a proposed block
    Vote {
        /// The voting validator's DID
        validator: String,
        
        /// The hash of the block being voted on
        block_hash: String,
        
        /// Whether the validator approves the block
        approve: bool,
    },
    
    /// Request to start a new round
    StartRound {
        round_number: u64,
    },
    
    /// Notification that a round has been finalized
    RoundFinalized {
        round_number: u64,
        block_hash: String,
    },
}

/// Status of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    /// Block is being proposed by coordinator
    Proposing,
    
    /// Validators are voting on proposed block
    Voting,
    
    /// Round is being finalized
    Finalizing,
    
    /// Round completed successfully
    Completed,
    
    /// Round failed (timeout or other error)
    Failed,
}

/// Represents a single round of consensus
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    /// Unique round number
    pub round_number: u64,
    
    /// DID of the round's coordinator
    pub coordinator: String,
    
    /// The block being proposed (if any)
    pub proposed_block: Option<Block>,
    
    /// Map of validator DIDs to their votes
    pub votes: HashMap<String, bool>,
    
    /// Current status of the round
    pub status: RoundStatus,
    
    /// Timestamp when the round started
    pub start_time: u64,
    
    /// Maximum duration for the round in seconds
    pub timeout: u64,
}

impl ConsensusRound {
    pub fn new(round_number: u64, coordinator: String, timeout: u64, start_time: u64) -> Self {
        Self {
            round_number,
            coordinator,
            proposed_block: None,
            votes: HashMap::new(),
            status: RoundStatus::Proposing,
            start_time,
            timeout,
        }
    }

    pub fn has_voted(&self, validator_did: &str) -> bool {
        self.votes.contains_key(validator_did)
    }

    pub fn add_vote(&mut self, validator_did: String, approve: bool) {
        self.votes.insert(validator_did, approve);
    }

    pub fn get_approval_rate(&self) -> f64 {
        if self.votes.is_empty() {
            return 0.0;
        }
        
        let approve_count = self.votes.values().filter(|&&approve| approve).count();
        approve_count as f64 / self.votes.len() as f64
    }

    pub fn is_timed_out(&self, current_time: u64) -> bool {
        current_time - self.start_time > self.timeout
    }
}

/// Configuration for the consensus mechanism
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusConfig {
    /// Minimum number of validators required for consensus
    pub min_validators: usize,
    
    /// Threshold of votes required to approve a block (0.0 - 1.0)
    pub vote_threshold: f64,
    
    /// Round timeout in seconds
    pub round_timeout: u64,
    
    /// Minimum reputation required to be a validator
    pub min_reputation: i64,
    
    /// Base reward for participating in consensus
    pub participation_reward: i64,
    
    /// Extra reward for being the coordinator
    pub coordinator_reward: i64,
    
    /// Penalty for missing validation
    pub missed_validation_penalty: i64,
}

impl Default for ConsensusConfig {
    fn default() -> Self {
        Self {
            min_validators: 3,
            vote_threshold: 0.66,  // 66% approval required
            round_timeout: 60,     // 60 seconds
            min_reputation: 50,
            participation_reward: 1,
            coordinator_reward: 2,
            missed_validation_penalty: -1,
        }
    }
}

/// Result of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RoundResult {
    pub round_number: u64,
    pub successful: bool,
    pub finalized_block: Option<Block>,
    pub reputation_updates: Vec<(String, i64)>,
    pub participating_validators: Vec<String>,
}

/// Error types specific to consensus operations
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusError {
    InsufficientValidators,
    InvalidCoordinator,
    RoundInProgress,
    NoActiveRound,
    InvalidRoundState,
    TimedOut,
    ValidationFailed,
    NotValidator,
    InsufficientReputation,
    Custom(String),
}

impl std::fmt::Display for ConsensusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConsensusError::InsufficientValidators => 
                write!(f, "Insufficient number of active validators"),
            ConsensusError::InvalidCoordinator => 
                write!(f, "Invalid coordinator for this round"),
            ConsensusError::RoundInProgress => 
                write!(f, "Consensus round already in progress"),
            ConsensusError::NoActiveRound => 
                write!(f, "No active consensus round"),
            ConsensusError::InvalidRoundState => 
                write!(f, "Invalid round state for requested operation"),
            ConsensusError::TimedOut => 
                write!(f, "Consensus round timed out"),
            ConsensusError::ValidationFailed => 
                write!(f, "Block validation failed"),
            ConsensusError::NotValidator => 
                write!(f, "Not a registered validator"),
            ConsensusError::InsufficientReputation => 
                write!(f, "Insufficient reputation for operation"),
            ConsensusError::Custom(msg) => 
                write!(f, "{}", msg),
        }
    }
}

impl std::error::Error for ConsensusError {}

===================
File: ./backend/src/consensus/mod.rs
===================
# File: ./backend/src/consensus/mod.rs
mod proof_of_cooperation;
mod types;

pub use proof_of_cooperation::ProofOfCooperation;
pub use types::{ConsensusRound, RoundStatus, Validator};

# File: ./backend/src/consensus/types.rs
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Validator {
    pub did: String,
    pub reputation: i64,
    pub last_block_proposed: u64,
    pub consecutive_missed_validations: u32,
    pub is_active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    pub round_number: u64,
    pub coordinator: String,
    pub proposed_block: Option<crate::blockchain::Block>,
    pub votes: HashMap<String, bool>,
    pub status: RoundStatus,
    pub start_time: u64,
    pub timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    Proposing,
    Voting,
    Finalizing,
    Completed,
    Failed,
}

# File: ./backend/src/consensus/proof_of_cooperation.rs
// Copy the entire ProofOfCooperation implementation from the previous artifact here

# File: ./backend/src/blockchain/mod.rs
// Add this to the existing mod.rs
use crate::consensus::ProofOfCooperation;

pub struct Blockchain {
    // Add these fields to the existing Blockchain struct
    pub consensus: ProofOfCooperation,
    pub current_block_number: u64,
    // ... existing fields ...
}

impl Blockchain {
    pub fn new(identity_system: IdentitySystem, reputation_system: ReputationSystem) -> Self {
        Blockchain {
            chain: vec![Block::new(0, String::from("0"), vec![])],
            pending_transactions: vec![],
            difficulty: 2,
            identity_system,
            reputation_system,
            contracts: HashMap::new(),
            current_block_number: 1,
            // Initialize consensus with desired parameters
            consensus: ProofOfCooperation::new(
                3,      // min_validators
                0.66,   // vote_threshold (66%)
                60,     // round_timeout in seconds
                50,     // min_reputation
            ),
        }
    }

    // Add this method to handle block finalization through consensus
    pub fn finalize_block(&mut self) -> Result<(), String> {
        // Start a new consensus round
        self.consensus.start_round()?;

        // Create a new block with pending transactions
        let previous_hash = self.chain.last().unwrap().hash.clone();
        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
        );

        // Get the current round status and coordinator
        if let Some(round) = &self.consensus.current_round {
            // Propose the block (only coordinator can do this)
            self.consensus.propose_block(&round.coordinator, new_block)?;

            // In a real implementation, we would wait for votes here
            // For now, we'll assume the block is accepted

            // Finalize the round and get the accepted block
            let finalized_block = self.consensus.finalize_round()?;
            
            // Add the block to the chain
            self.chain.push(finalized_block);
            
            // Clear pending transactions
            self.pending_transactions.clear();
            
            // Update reputation based on consensus round
            let reputation_updates = self.consensus.get_reputation_updates();
            for (did, change) in reputation_updates {
                self.reputation_system.update_reputation(did, *change);
            }

            self.current_block_number += 1;
            Ok(())
        } else {
            Err("No active consensus round".to_string())
        }
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation.rs
===================
use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};

// Validator represents a node participating in consensus
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Validator {
    pub did: String,
    pub reputation: i64,
    pub last_block_proposed: u64,
    pub consecutive_missed_validations: u32,
    pub is_active: bool,
}

// ConsensusRound represents a single round of the PoC consensus
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    pub round_number: u64,
    pub coordinator: String,  // DID of the coordinator
    pub proposed_block: Option<Block>,
    pub votes: HashMap<String, bool>,  // DID -> vote
    pub status: RoundStatus,
    pub start_time: u64,
    pub timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    Proposing,
    Voting,
    Finalizing,
    Completed,
    Failed,
}

#[derive(Debug)]
pub struct ProofOfCooperation {
    // Core consensus state
    validators: HashMap<String, Validator>,
    current_round: Option<ConsensusRound>,
    finalized_blocks: Vec<Block>,
    
    // Configuration
    min_validators: usize,
    vote_threshold: f64,
    round_timeout: u64,
    min_reputation: i64,
    
    // Reputation tracking
    reputation_updates: Vec<(String, i64)>,  // (DID, reputation change)
}

impl ProofOfCooperation {
    pub fn new(min_validators: usize, vote_threshold: f64, round_timeout: u64, min_reputation: i64) -> Self {
        ProofOfCooperation {
            validators: HashMap::new(),
            current_round: None,
            finalized_blocks: Vec::new(),
            min_validators,
            vote_threshold,
            round_timeout,
            min_reputation,
            reputation_updates: Vec::new(),
        }
    }

    // Register a new validator
    pub fn register_validator(&mut self, did: String, initial_reputation: i64) -> Result<(), String> {
        if initial_reputation < self.min_reputation {
            return Err("Insufficient reputation to become validator".to_string());
        }

        let validator = Validator {
            did: did.clone(),
            reputation: initial_reputation,
            last_block_proposed: 0,
            consecutive_missed_validations: 0,
            is_active: true,
        };

        self.validators.insert(did, validator);
        Ok(())
    }

    // Select the coordinator for the next round using reputation-weighted selection
    fn select_coordinator(&self) -> Option<String> {
        let active_validators: Vec<_> = self.validators
            .values()
            .filter(|v| v.is_active && v.reputation >= self.min_reputation)
            .collect();

        if active_validators.len() < self.min_validators {
            return None;
        }

        // Calculate total reputation of active validators
        let total_reputation: i64 = active_validators.iter().map(|v| v.reputation).sum();
        
        // Generate random number between 0 and total_reputation
        let mut rng = rand::thread_rng();
        let selection_point = rng.gen_range(0..total_reputation);
        
        // Select coordinator based on reputation weight
        let mut cumulative_reputation = 0;
        for validator in active_validators {
            cumulative_reputation += validator.reputation;
            if cumulative_reputation > selection_point {
                return Some(validator.did.clone());
            }
        }
        
        None
    }

    // Start a new consensus round
    pub fn start_round(&mut self) -> Result<(), String> {
        if self.current_round.is_some() {
            return Err("Consensus round already in progress".to_string());
        }

        let coordinator = self.select_coordinator()
            .ok_or("Unable to select coordinator")?;

        let round = ConsensusRound {
            round_number: self.finalized_blocks.len() as u64 + 1,
            coordinator,
            proposed_block: None,
            votes: HashMap::new(),
            status: RoundStatus::Proposing,
            start_time: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            timeout: self.round_timeout,
        };

        self.current_round = Some(round);
        Ok(())
    }

    // Propose a block (called by coordinator)
    pub fn propose_block(&mut self, proposer_did: &str, block: Block) -> Result<(), String> {
        let round = self.current_round.as_mut()
            .ok_or("No active consensus round")?;

        if round.status != RoundStatus::Proposing {
            return Err("Round not in proposing state".to_string());
        }

        if round.coordinator != proposer_did {
            return Err("Only the coordinator can propose blocks".to_string());
        }

        round.proposed_block = Some(block);
        round.status = RoundStatus::Voting;
        Ok(())
    }

    // Submit a vote for the proposed block
    pub fn submit_vote(&mut self, validator_did: &str, vote: bool) -> Result<(), String> {
        let round = self.current_round.as_mut()
            .ok_or("No active consensus round")?;

        if round.status != RoundStatus::Voting {
            return Err("Round not in voting state".to_string());
        }

        if !self.validators.contains_key(validator_did) {
            return Err("Not a registered validator".to_string());
        }

        round.votes.insert(validator_did.to_string(), vote);

        // Check if we have enough votes to finalize
        if self.can_finalize_round() {
            round.status = RoundStatus::Finalizing;
        }

        Ok(())
    }

    // Check if we can finalize the current round
    fn can_finalize_round(&self) -> bool {
        if let Some(round) = &self.current_round {
            let total_reputation: i64 = self.validators
                .values()
                .filter(|v| v.is_active)
                .map(|v| v.reputation)
                .sum();

            let voting_reputation: i64 = round.votes.keys()
                .filter_map(|did| self.validators.get(did))
                .map(|v| v.reputation)
                .sum();

            let participation_ratio = voting_reputation as f64 / total_reputation as f64;
            let approval_reputation: i64 = round.votes.iter()
                .filter(|(_, &vote)| vote)
                .filter_map(|(did, _)| self.validators.get(did))
                .map(|v| v.reputation)
                .sum();

            let approval_ratio = approval_reputation as f64 / voting_reputation as f64;

            participation_ratio >= self.vote_threshold && approval_ratio >= self.vote_threshold
        } else {
            false
        }
    }

    // Finalize the current round
    pub fn finalize_round(&mut self) -> Result<Block, String> {
        let round = self.current_round.as_ref()
            .ok_or("No active consensus round")?;

        if round.status != RoundStatus::Finalizing {
            return Err("Round not ready for finalization".to_string());
        }

        let block = round.proposed_block.as_ref()
            .ok_or("No proposed block")?
            .clone();

        // Update validator reputations based on participation
        self.update_reputations(&round);

        // Add block to finalized blocks
        self.finalized_blocks.push(block.clone());

        // Reset current round
        self.current_round = None;

        Ok(block)
    }

    // Update validator reputations based on round participation
    fn update_reputations(&mut self, round: &ConsensusRound) {
        let active_validators: HashSet<_> = self.validators
            .values()
            .filter(|v| v.is_active)
            .map(|v| v.did.clone())
            .collect();

        // Reward validators who voted
        for voter_did in round.votes.keys() {
            if let Some(validator) = self.validators.get_mut(voter_did) {
                validator.reputation += 1;
                validator.consecutive_missed_validations = 0;
                self.reputation_updates.push((voter_did.clone(), 1));
            }
        }

        // Penalize validators who didn't vote
        for did in active_validators {
            if !round.votes.contains_key(&did) {
                if let Some(validator) = self.validators.get_mut(&did) {
                    validator.consecutive_missed_validations += 1;
                    
                    // Larger penalty for consecutive misses
                    let penalty = -(validator.consecutive_missed_validations as i64);
                    validator.reputation += penalty;
                    self.reputation_updates.push((did.clone(), penalty));

                    // Deactivate validator if reputation drops too low
                    if validator.reputation < self.min_reputation {
                        validator.is_active = false;
                    }
                }
            }
        }

        // Extra reward for the coordinator if round was successful
        if let Some(validator) = self.validators.get_mut(&round.coordinator) {
            validator.reputation += 2;
            self.reputation_updates.push((round.coordinator.clone(), 2));
        }
    }

    // Get the current round status
    pub fn get_round_status(&self) -> Option<RoundStatus> {
        self.current_round.as_ref().map(|r| r.status.clone())
    }

    // Get the list of reputation updates from the last round
    pub fn get_reputation_updates(&self) -> &Vec<(String, i64)> {
        &self.reputation_updates
    }

    // Check if a round has timed out
    pub fn check_timeout(&mut self) -> bool {
        if let Some(round) = &self.current_round {
            let current_time = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();
            
            if current_time - round.start_time > round.timeout {
                // Handle timeout by failing the round
                self.handle_timeout();
                return true;
            }
        }
        false
    }

    // Handle a round timeout
    fn handle_timeout(&mut self) {
        if let Some(round) = &mut self.current_round {
            round.status = RoundStatus::Failed;
            
            // Penalize the coordinator for timeout
            if let Some(validator) = self.validators.get_mut(&round.coordinator) {
                validator.reputation -= 3;
                self.reputation_updates.push((round.coordinator.clone(), -3));
            }
        }
        
        // Reset the round
        self.current_round = None;
    }
}

// Helper functions for tests
#[cfg(test)]
mod tests {
    use super::*;

    fn setup_consensus() -> ProofOfCooperation {
        ProofOfCooperation::new(3, 0.66, 60, 50)
    }

    #[test]
    fn test_validator_registration() {
        let mut consensus = setup_consensus();
        
        // Test successful registration
        assert!(consensus.register_validator("did:icn:1".to_string(), 100).is_ok());
        
        // Test registration with insufficient reputation
        assert!(consensus.register_validator("did:icn:2".to_string(), 40).is_err());
    }

    #[test]
    fn test_round_lifecycle() {
        let mut consensus = setup_consensus();
        
        // Register validators
        consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        consensus.register_validator("did:icn:3".to_string(), 100).unwrap();
        
        // Start round
        assert!(consensus.start_round().is_ok());
        
        // Verify round status
        assert_eq!(consensus.get_round_status(), Some(RoundStatus::Proposing));
    }

    #[test]
    fn test_reputation_updates() {
        let mut consensus = setup_consensus();
        
        // Register validators
        consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        
        // Start round and submit votes
        consensus.start_round().unwrap();
        if let Some(round) = &consensus.current_round {
            let coordinator = round.coordinator.clone();
            let block = Block::new(1, "prev_hash".to_string(), vec![]); // Create dummy block
            consensus.propose_block(&coordinator, block).unwrap();
            consensus.submit_vote("did:icn:1", true).unwrap();
            consensus.submit_vote("did:icn:2", true).unwrap();
        }
        
        // Check reputation updates
        let updates = consensus.get_reputation_updates();
        assert!(!updates.is_empty());
    }
}

===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
===================




===================
File: ./frontend/src/components/governance/GovernanceDashboard.tsx
===================
import React, { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { AlertCircle, ChevronRight, Users, TrendingUp } from 'lucide-react'

type Proposal = {
  id: string
  title: string
  description: string
  status: 'active' | 'passed' | 'rejected'
  votesFor: number
  votesAgainst: number
  quorum: number
  createdBy: string
  endsAt: string
  totalVoters: number
  delegatedVotes: number
}

type VotingStats = {
  totalProposals: number
  activeProposals: number
  participationRate: number
  monthlyVotes: Array<{ month: string; votes: number }>
}

const GovernanceDashboard = () => {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [votingStats, setVotingStats] = useState<VotingStats>({
    totalProposals: 0,
    activeProposals: 0,
    participationRate: 0,
    monthlyVotes: []
  })
  const [selectedTab, setSelectedTab] = useState('active')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockProposals: Proposal[] = [
      {
        id: '1',
        title: 'Community Resource Allocation Q3',
        description: 'Proposal to allocate community resources for Q3 projects',
        status: 'active',
        votesFor: 750,
        votesAgainst: 250,
        quorum: 1000,
        createdBy: 'did:icn:alice',
        endsAt: '2024-11-01',
        totalVoters: 1500,
        delegatedVotes: 200
      },
      {
        id: '2',
        title: 'New Cooperation Guidelines',
        description: 'Updated guidelines for inter-cooperative collaboration',
        status: 'passed',
        votesFor: 800,
        votesAgainst: 100,
        quorum: 1000,
        createdBy: 'did:icn:bob',
        endsAt: '2024-10-15',
        totalVoters: 1200,
        delegatedVotes: 150
      }
    ]

    const mockStats = {
      totalProposals: 45,
      activeProposals: 3,
      participationRate: 78.5,
      monthlyVotes: [
        { month: 'Jan', votes: 120 },
        { month: 'Feb', votes: 150 },
        { month: 'Mar', votes: 180 },
        { month: 'Apr', votes: 220 }
      ]
    }

    setProposals(mockProposals)
    setVotingStats(mockStats)
    setLoading(false)
  }, [])

  const calculateProgress = (votesFor: number, votesAgainst: number) => {
    const total = votesFor + votesAgainst
    return total > 0 ? (votesFor / total) * 100 : 0
  }

  const ProposalCard = ({ proposal }: { proposal: Proposal }) => (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-semibold">{proposal.title}</h3>
          <p className="text-sm text-gray-600">{proposal.description}</p>
        </div>
        <span className={`px-2 py-1 rounded text-sm ${
          proposal.status === 'active' ? 'bg-blue-100 text-blue-800' :
          proposal.status === 'passed' ? 'bg-green-100 text-green-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        </span>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculateProgress(proposal.votesFor, proposal.votesAgainst).toFixed(1)}%</span>
        </div>
        <Progress 
          value={calculateProgress(proposal.votesFor, proposal.votesAgainst)} 
          className="h-2"
        />
        
        <div className="flex justify-between text-sm text-gray-600">
          <span>For: {proposal.votesFor}</span>
          <span>Against: {proposal.votesAgainst}</span>
        </div>

        <div className="flex justify-between items-center mt-4">
          <div className="text-sm text-gray-600">
            <p>Created by: {proposal.createdBy}</p>
            <p>Ends: {new Date(proposal.endsAt).toLocaleDateString()}</p>
          </div>
          {proposal.status === 'active' && (
            <Button className="space-x-2">
              <span>Vote Now</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </Card>
  )

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Participation Rate</p>
                <h3 className="text-2xl font-bold">{votingStats.participationRate}%</h3>
              </div>
              <Users className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.totalProposals}</h3>
              </div>
              <TrendingUp className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Voting Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={votingStats.monthlyVotes}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="votes" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Proposals</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList>
              <TabsTrigger value="active">Active</TabsTrigger>
              <TabsTrigger value="passed">Passed</TabsTrigger>
              <TabsTrigger value="rejected">Rejected</TabsTrigger>
            </TabsList>

            <TabsContent value="active" className="space-y-4">
              {proposals
                .filter(p => p.status === 'active')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="passed" className="space-y-4">
              {proposals
                .filter(p => p.status === 'passed')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="rejected" className="space-y-4">
              {proposals
                .filter(p => p.status === 'rejected')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      <Alert>
        <AlertDescription>
          You currently have {proposals[0]?.delegatedVotes || 0} votes delegated to you. 
          Visit the delegation page to manage your voting power.
        </AlertDescription>
      </Alert>
    </div>
  )
}

export default GovernanceDashboard

===================
File: ./backend/Cargo.toml
===================
[package]
name = "icn-backend"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
warp = "0.3"
uuid = { version = "1.0", features = ["v4"] }
log = "0.4"
env_logger = "0.9"
sha2 = "0.10"
chrono = { version = "0.4", features = ["serde"] }
secp256k1 = "0.24"
rand = "0.8"

# Include any other dependencies you are using


===================
File: ./frontend/package.json
===================


===================
File: ./frontend/tsconfig.json
===================


===================
File: ./docker/docker-compose.yml
===================
version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: backend.Dockerfile
    volumes:
      - .:/app
    ports:
      - "8080:8080"
    command: ["cargo", "run", "--release"]

  test:
    build:
      context: .
      dockerfile: backend.Dockerfile
    command: ["cargo", "test", "--release"]

  docs:
    image: squidfunk/mkdocs-material:latest
    volumes:
      - ../docs:/docs                    # Maps the correct docs directory
    ports:
      - "8000:8000"
    working_dir: /docs                   # Set the working directory to /docs inside the container
    command: serve -a 0.0.0.0:8000       # Run MkDocs without prefixing `mkdocs`


===================
File: ./docker/backend.Dockerfile
===================
# Start from an official Rust image
FROM rust:latest

# Set the working directory
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . .

# Install any needed dependencies
RUN cargo build --release

# Add integration tests step to Dockerfile
RUN cargo test --release

# Run the binary when the container launches
CMD ["cargo", "run", "--release"]


===================
File: ./docker/frontend.Dockerfile
===================
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
CMD ["npm", "start"]


===================
File: ./docs/docs/index.md
===================
# Welcome to MkDocs

For full documentation visit [mkdocs.org](https://www.mkdocs.org).

## Commands

* `mkdocs new [dir-name]` - Create a new project.
* `mkdocs serve` - Start the live-reloading docs server.
* `mkdocs build` - Build the documentation site.
* `mkdocs -h` - Print help message and exit.

## Project layout

    mkdocs.yml    # The configuration file.
    docs/
        index.md  # The documentation homepage.
        ...       # Other markdown pages, images and other files.


===================
File: ./docs/guides/index.md
===================
# User Guides

The following guides provide step-by-step instructions for using the ICN platform effectively.

## Contents
- [Getting Started](getting-started.md): Introduction to accessing and navigating the ICN platform.
- [Governance Guide](governance-guide.md): Detailed steps on participating in cooperative governance.
- [Reputation Management](reputation-management.md): Overview of how reputation influences roles and decision-making.

Additional guides will cover specific ICN features and best practices.


===================
File: ./docs/INDEX.md
===================
# Documentation Index


## Specification

- [Reputation System](specifications/core/2024-11-01-reputation-system.md) (v1.0.0, draft)


===================
File: ./docs/user/guides/resource-management.md
===================
# Resource Management Guide

## Introduction
Resource management within ICN allows cooperatives to allocate, share, and track resources efficiently. This guide covers the steps for creating resources, allocating them within a cooperative, and monitoring usage.

## Step 1: Create a Resource
1. Go to the Cooperative Resource tab.
2. Select “Create Resource” and provide details:
   - **Resource Type**: Define the type (e.g., funds, materials).
   - **Allocation**: Set initial availability and allocation limits.

## Step 2: Allocate Resource to Cooperative Members
1. Navigate to the Resource Allocation tab.
2. Select the resource and member(s) to allocate.
3. Set allocation limits based on cooperative needs.

## Step 3: Monitor Resource Usage
Regularly check the resource usage dashboard:
- **Allocated Resources**: Overview of allocated resources and remaining capacity.
- **Usage Trends**: Track member usage patterns to optimize future allocations.

## Tips for Effective Resource Management
- **Set Clear Limits**: Prevent overuse by establishing maximum allocations.
- **Review Allocation Periodically**: Adjust allocations based on changing cooperative needs.
- **Encourage Resource Sharing**: Promote shared resource access among members to maximize utility.


===================
File: ./docs/user/guides/index.md
===================


===================
File: ./docs/user/guides/onboarding-guide.md
===================

---

### `onboarding-guide.md` (Under `user/guides/`)

```markdown
# ICN Onboarding Guide

## Introduction
Welcome to the ICN platform! This guide walks you through creating a DID, joining a cooperative, and participating in governance.

## Step 1: Create Your DID
DIDs are the basis of ICN’s secure interactions. To create a DID:
1. Access the ICN Identity page.
2. Click “Generate DID.”
3. Copy your DID identifier and public key for future reference.

## Step 2: Join a Cooperative
1. Go to the Cooperative Directory.
2. Select a cooperative and click “Join.”
3. Complete the required fields, then submit your request.
   - **Note**: Some cooperatives require a minimum reputation score for entry.

## Step 3: Participate in Governance
As a cooperative member, you can vote on proposals:
1. Go to the Governance Dashboard.
2. View active proposals and click “Vote” on issues that matter to you.
3. Your reputation will influence the weight of your vote.

## Tips for New Members
- **Increase Reputation**: Engage in cooperative activities to boost your influence.
- **Track Notifications**: Stay updated on proposal deadlines to maximize participation.


===================
File: ./docs/development/guides/documentation-standards.md
===================
# Documentation Standards

## File Organization

- Use appropriate directory for document type
- Follow naming conventions
- Include required metadata

## Writing Style

- Be clear and concise
- Include code examples where appropriate
- Keep documentation up to date
- Use proper Markdown formatting

## Review Process

1. Create new document using tools
2. Submit for review
3. Address feedback
4. Update documentation index

## Templates

Use provided templates in `docs/templates/` for new documents.


===================
File: ./docs/README.md
===================
# ICN Documentation

## Structure

- `architecture/` - System architecture documentation
- `specifications/` - Technical specifications
- `development/` - Development guides and plans
- `user/` - User documentation and tutorials

## Getting Started

1. Install documentation tools:
   ```bash
   cd tools
   pip install -r requirements.txt
   ```

2. Generate documentation index:
   ```bash
   python tools/doctools/docmanager.py index
   ```

## Documentation Standards

Please refer to `development/guides/documentation-standards.md` for our documentation guidelines.


===================
File: ./docs/templates/protocol-template.md
===================
# {title} Protocol Specification

## 1. Protocol Overview

### 1.1 Purpose

### 1.2 Flow

## 2. Message Formats

## 3. State Machine

## 4. Security Model

## 5. Implementation Guidelines

## 6. Compatibility Requirements

## 7. Future Extensions


===================
File: ./docs/templates/api-template.md
===================
# {title} API Specification

## 1. API Overview

### 1.1 Purpose

### 1.2 Endpoints

## 2. Authentication

## 3. Endpoints Detail

## 4. Error Handling

## 5. Rate Limiting

## 6. Security Considerations

## 7. Example Usage


===================
File: ./docs/templates/core-component-template.md
===================
# {title}

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations


===================
File: ./docs/specifications/api/governance-api.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance API
type: api
version: 1.0.0
---

# Governance API

## Overview

### Purpose
The Governance API enables ICN members to submit, view, and vote on proposals. Each action requires DID-based access control and reputation permissions.

## Endpoints

### Create Proposal
- **Endpoint**: `POST /api/governance/proposals`
- **Request Body**:
  ```json
  {
    "proposal_type": "Funding",
    "description": "Allocate resources for new development",
    "duration": 60
  }


===================
File: ./docs/specifications/core/transaction-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-04'
status: draft
title: Transaction Lifecycle System
type: specification
version: 1.0.0
---

# Transaction Lifecycle System

## Overview
The Transaction Lifecycle System provides a secure, traceable, and immutable process for handling all cooperative transactions within the ICN. This document details the lifecycle of a transaction, from initiation and validation to finalization and storage in the blockchain. The system is designed to ensure consistency, security, and transparency in all cooperative actions.

### Purpose
- **Immutability**: Maintain a secure and unalterable record of all transactions.
- **Traceability**: Allow cooperatives to track resource allocation, proposal voting, and other actions.
- **Accountability**: Ensure all actions align with ICN's governance standards through DID and reputation validation.

### Components Involved
- **Blockchain Module**: Manages the chain of blocks where transactions are stored.
- **DID System**: Verifies the identities of transaction participants.
- **Reputation System**: Validates that users have the necessary reputation to execute actions.

---

## 1. Transaction Lifecycle

### 1.1 Transaction Initiation

1. **Process**:
   - A transaction is created with the following attributes: `sender`, `receiver`, `amount`, `timestamp`, and `purpose`.
   - A unique transaction hash is generated using `SHA-256` to prevent duplicates.

2. **Validation**:
   - The transaction undergoes an initial validation to confirm that the `sender` has a valid DID and that the specified `amount` respects the cooperative’s resource allocation limits.

3. **Attributes**:
   - **Sender**: The DID of the transaction initiator.
   - **Receiver**: The DID of the transaction recipient.
   - **Amount**: The value/resource quantity being transferred.
   - **Timestamp**: Millisecond timestamp of transaction initiation.
   - **Purpose**: A brief description of the transaction’s intent.

### 1.2 Transaction Validation

1. **DID Verification**:
   - Ensure that both the `sender` and `receiver` have valid DIDs. Invalid or nonexistent DIDs will cause the transaction to fail validation.
   
2. **Reputation Check**:
   - Confirm that the `sender` meets any minimum reputation thresholds required by the transaction type.
   - If the reputation requirement is not met, the transaction is rejected with an error.

3. **Signature Verification**:
   - The transaction must be signed by the `sender`’s key, verified using ECC (secp256k1) or, when specified, quantum-resistant keys (CRYSTALS-Dilithium).
   
4. **Timestamp Verification**:
   - Check that the `timestamp` is valid and aligns with recent blockchain activity to prevent replay attacks.

### 1.3 Transaction Processing

1. **Hashing**:
   - Calculate a unique hash for the transaction, incorporating attributes like `sender`, `receiver`, `amount`, and `timestamp`.
   
2. **Pending Pool**:
   - Place the validated transaction in the pending transactions pool until a new block is finalized.

### 1.4 Block Finalization

1. **Block Creation**:
   - At defined intervals or upon reaching a set number of transactions, pending transactions are bundled into a new block.
   
2. **Block Hashing**:
   - A hash of the new block is computed, linking it to the previous block for chain integrity.
   
3. **Chain Update**:
   - The finalized block is added to the blockchain, and the pending transactions pool is cleared.

---

## 2. Data Structures

### 2.1 Transaction Object

```rust
Transaction {
    sender: String,
    receiver: String,
    amount: u64,
    timestamp: u128,
    hash: String,
}


===================
File: ./docs/specifications/core/vm-system.md
===================
Certainly! Here's the expanded documentation for the Virtual Machine (VM), written in Markdown format and enclosed within a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/vm-system.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Virtual Machine (VM)
type: specification
version: 1.1.0
---

# Virtual Machine (VM) Specification

## 1. Overview

### 1.1 Purpose

The Virtual Machine (VM) is a core component of the Inter-Cooperative Network (ICN), responsible for executing cooperative-specific smart contracts. It interprets a set of predefined OpCodes, allowing for a range of operations that support governance, resource allocation, reputation management, and cooperative administration.

### 1.2 Core Components

- **Instruction Set**: A collection of OpCodes defining operations the VM can execute.
- **Execution Engine**: Processes instructions, manages the stack, memory, and control flow.
- **Security Mechanisms**: Enforces permissions, reputation requirements, and resource limits.
- **Event System**: Generates events during execution for logging and auditing.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 OpCode Enumeration

Defines the set of operations supported by the VM, categorized by functionality:

- **Arithmetic Operations**
  - `Add`, `Sub`, `Mul`, `Div`, `Mod`
- **Stack Operations**
  - `Push`, `Pop`, `Dup`, `Swap`
- **Memory Operations**
  - `Store`, `Load`
- **Control Flow Operations**
  - `Jump`, `JumpIf`, `Call`, `Return`
- **Cooperative Operations**
  - `CreateCooperative`, `JoinCooperative`, `LeaveCooperative`, `AllocateResource`, `TransferResource`
- **Governance Operations**
  - `CreateProposal`, `CastVote`, `DelegateVotes`, `ExecuteProposal`, `UpdateQuorum`
- **Reputation Operations**
  - `UpdateReputation`, `GetReputation`
- **Identity Operations**
  - `VerifyDID`, `UpdateDIDDocument`
- **System Operations**
  - `Log`, `Halt`, `EmitEvent`, `GetTimestamp`, `GetCaller`

#### 2.1.2 Contract Structure

```rust
struct Contract {
    id: String,
    code: Vec<(OpCode, Option<i64>)>,
    state: HashMap<String, i64>,
    required_reputation: i64,
    cooperative_metadata: CooperativeMetadata,
    version: String,
    dependencies: Vec<String>,
    permissions: Vec<String>,
}
```

- **id**: Unique identifier for the contract.
- **code**: Sequence of OpCodes and optional arguments.
- **state**: Persistent state specific to the contract.
- **required_reputation**: Minimum reputation required to execute the contract.
- **cooperative_metadata**: Metadata providing context for the cooperative.
- **version**: Contract versioning for updates and compatibility.
- **dependencies**: List of other contracts or libraries required.
- **permissions**: Access control permissions required.

#### 2.1.3 Execution Context

```rust
struct ExecutionContext {
    caller_did: String,
    cooperative_id: String,
    timestamp: u64,
    block_number: u64,
    reputation_score: i64,
    permissions: Vec<String>,
}
```

- **caller_did**: DID of the entity invoking the contract.
- **cooperative_id**: Identifier of the cooperative context.
- **timestamp**: Current timestamp of execution.
- **block_number**: Blockchain block number.
- **reputation_score**: Reputation score of the caller.
- **permissions**: Permissions of the caller.

### 2.2 Interfaces

#### 2.2.1 VM Methods

##### Execute Contract

- **Purpose**: Executes a contract from start to finish, enforcing all constraints.
- **Input**: `Contract`, `ExecutionContext`
- **Process**:
  1. **Permission Check**: Verify caller has necessary permissions.
  2. **Reputation Validation**: Ensure caller's reputation meets the requirement.
  3. **Initialize Stack and Memory**: Set up execution environment.
  4. **Instruction Execution**: Process OpCodes sequentially.
  5. **Event Emission**: Generate events as specified.
  6. **State Update**: Persist any changes to the contract state.
- **Output**: Execution result, updated state, events generated.

##### Execute Instruction

- **Purpose**: Processes a single OpCode and modifies the VM state accordingly.
- **Input**: `OpCode`, `Option<i64>`
- **Process**:
  - Handle operation based on the type of OpCode.
  - Update stack, memory, or control flow as needed.
- **Output**: Updated VM state.

### 2.3 Behaviors

#### 2.3.1 Stack Management

- **Structure**: LIFO (Last-In-First-Out) stack of 64-bit integers.
- **Operations**:
  - **Push**: Add value to the top of the stack.
  - **Pop**: Remove and return the top value.
  - **Dup**: Duplicate the top value.
  - **Swap**: Swap the top two values.

#### 2.3.2 Memory Management

- **Structure**: Key-value store (`HashMap<String, i64>`) for temporary storage.
- **Operations**:
  - **Store**: Save a value with a specified key.
  - **Load**: Retrieve a value by key.

#### 2.3.3 Control Flow

- **Jump**: Redirect execution to a specific instruction index.
- **JumpIf**: Conditional jump based on the top of the stack.
- **Call**: Invoke a function or subroutine.
- **Return**: Exit from a function or contract execution.

#### 2.3.4 Error Handling

- **Exception Types**:
  - **Stack Underflow/Overflow**
  - **Invalid Opcode**
  - **Permission Denied**
  - **Reputation Insufficient**
  - **Runtime Errors**: Division by zero, invalid memory access.

- **Handling Strategy**:
  - Execution halts on errors.
  - Generate error events with detailed messages.
  - Rollback any state changes made during execution.

### 2.4 Security Model

- **Reputation Enforcement**: Contracts specify minimum reputation; the VM enforces this before execution.
- **Permission Checks**: Caller permissions are validated against contract requirements.
- **Resource Limits**:
  - **Instruction Limit**: Maximum number of instructions per execution to prevent infinite loops.
  - **Stack Depth Limit**: Prevent stack overflows.
  - **Memory Usage Limit**: Cap on memory allocation.

- **Isolation**: Each contract execution is sandboxed, preventing interference with other contracts or global state.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Efficiency**: Optimize instruction execution for speed.
- **Scalability**: Handle multiple concurrent executions.
- **Lightweight**: Minimize resource consumption.

### 3.2 Security Requirements

- **Determinism**: Ensure contract execution is deterministic across all nodes.
- **Validation**: Strictly validate all inputs and OpCodes.
- **Auditability**: Maintain detailed logs and event histories.

### 3.3 Error Handling

- **Graceful Termination**: Contracts should fail safely without crashing the VM.
- **Clear Messaging**: Provide informative error messages for debugging.

## 4. Testing Requirements

- **Unit Tests**: Cover individual OpCodes and VM operations.
- **Integration Tests**: Test full contract executions in various scenarios.
- **Security Tests**: Include tests for permission enforcement and reputation checks.
- **Performance Tests**: Benchmark execution times and resource usage.

## 5. Monitoring and Metrics

- **Execution Logs**: Record each instruction executed.
- **Event Logs**: Capture all events emitted during execution.
- **Error Logs**: Record detailed information about any errors encountered.
- **Metrics**:
  - Execution time per contract.
  - Resource usage statistics.
  - Frequency of specific OpCodes.

## 6. Future Considerations

- **Extensibility**: Allow for new OpCodes and features to be added.
- **Language Support**: Develop higher-level languages that compile down to VM bytecode.
- **Interoperability**: Enable interaction with contracts on other blockchains or VMs.
- **Optimizations**: Implement Just-In-Time (JIT) compilation or other optimizations.

## Appendix

### A. OpCode Definitions

Provide detailed descriptions of each OpCode, including its function, expected stack state, and any arguments.

#### A.1 Arithmetic Operations

- **Add**
  - **Function**: Pops two values from the stack, pushes their sum.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a + b ]`
- **Sub**
  - **Function**: Pops two values, pushes the result of `a - b`.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a - b ]`
- *(Continue for other arithmetic OpCodes)*

#### A.2 Stack Operations

- *(Define `Push`, `Pop`, `Dup`, `Swap`)*

#### A.3 Memory Operations

- **Store**
  - **Function**: Stores a value in memory with a specified key.
  - **Arguments**: Key (from stack or instruction argument).
  - **Operation**:
    1. Pop value from stack.
    2. Use key to store the value in memory.

- **Load**
  - **Function**: Loads a value from memory onto the stack.
  - **Arguments**: Key.
  - **Operation**:
    1. Retrieve value associated with key.
    2. Push value onto the stack.

#### A.4 Control Flow Operations

- *(Define `Jump`, `JumpIf`, `Call`, `Return`)*

#### A.5 Cooperative Operations

- **CreateCooperative**
  - **Function**: Initiates a new cooperative.
  - **Requirements**: Caller must have sufficient reputation and permissions.
  - **Effect**: Emits `CooperativeCreated` event.

- *(Continue for other cooperative OpCodes)*

#### A.6 Governance Operations

- *(Define `CreateProposal`, `CastVote`, etc.)*

#### A.7 System Operations

- **Log**
  - **Function**: Logs a message or value for debugging.
  - **Operation**:
    1. Pop value from stack.
    2. Record value in execution logs.

- **Halt**
  - **Function**: Stops execution of the contract.
  - **Effect**: Returns control to the caller.

## References

- **ICN Architecture Overview**
- **Reputation System Specification**
- **Governance System Specification**

```

---

You can save this file as `vm-system.md` in your `./docs/specifications/core/` directory.

**Next Steps:**

- **Review the OpCode Definitions:** Ensure that all required operations are defined and that their behaviors align with the needs of your cooperatives.
- **Expand the Appendix:** Add detailed definitions for each OpCode, especially for custom cooperative and governance operations.
- **Integrate with Other Systems:** Cross-reference with the Identity System and Reputation System specifications to ensure consistent interactions.
- **Implement Security Measures:** Consider any additional security requirements specific to your use case.

**Let me know if you'd like to further refine any section or if you have additional components you'd like to develop!**

===================
File: ./docs/specifications/core/2024-11-01-reputation-system.md
===================
---
authors:
- Developer Name
date: '2024-11-01'
last_updated: '2024-11-01 00:48:30'
related_docs: []
reviewers:
- Tech Lead
status: draft
title: Reputation System
type: specification
version: 1.0.0

---

# Reputation System

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations



===================
File: ./docs/specifications/core/identity-system.md
===================
Apologies for the oversight. Here is the complete documentation for the Identity System, entirely within a code block so you can easily copy and paste it into your documentation folder.

---

**File: `./docs/specifications/core/identity-system.md`**

```markdown
---
authors:
  - Your Name
date: '2024-11-03'
status: draft
title: Identity System
type: specification
version: 1.0.0
---

# Identity System Specification

## 1. Overview

### 1.1 Purpose

The Identity System is responsible for managing Decentralized Identifiers (DIDs) within the Inter-Cooperative Network (ICN). It ensures secure authentication and authorization for users, cooperatives, and nodes by leveraging cryptographic key pairs. The system supports both Elliptic Curve Cryptography (ECC) and quantum-resistant algorithms to future-proof security.

### 1.2 Core Components

- **DID Management**: Creation, retrieval, and update of DIDs.
- **Authentication Service**: Verifies identities through cryptographic signatures.
- **Authorization Mechanism**: Controls access to resources based on roles and permissions.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 DID Document

```json
{
  "id": "did:icn:unique_identifier",
  "publicKey": "base64_encoded_public_key",
  "authentication": "authentication_method",
  "created": "timestamp",
  "updated": "timestamp"
}
```

- **id**: Unique identifier following the `did:icn:` namespace.
- **publicKey**: The public key associated with the DID, encoded in base64.
- **authentication**: Method used for verifying the DID owner.
- **created**: Timestamp of when the DID was created.
- **updated**: Timestamp of the last update to the DID document.

### 2.2 Interfaces

#### 2.2.1 API Endpoints

##### Create DID

- **Endpoint**: `POST /api/identity/did`
- **Description**: Registers a new DID in the network.
- **Request Body**:

  ```json
  {
    "publicKey": "base64_encoded_public_key"
  }
  ```

- **Response**:

  ```json
  {
    "did": "did:icn:unique_identifier"
  }
  ```

##### Resolve DID

- **Endpoint**: `GET /api/identity/did/{did}`
- **Description**: Retrieves the DID document for the specified DID.
- **Response**:

  ```json
  {
    "didDocument": {
      "id": "did:icn:unique_identifier",
      "publicKey": "base64_encoded_public_key",
      "authentication": "authentication_method",
      "created": "timestamp",
      "updated": "timestamp"
    }
  }
  ```

##### Authenticate

- **Endpoint**: `POST /api/identity/authenticate`
- **Description**: Verifies the identity and issues an authentication token.
- **Request Body**:

  ```json
  {
    "did": "did:icn:unique_identifier",
    "signature": "base64_encoded_signature",
    "nonce": "server_provided_nonce"
  }
  ```

- **Response**:

  ```json
  {
    "token": "jwt_token"
  }
  ```

### 2.3 Behaviors

#### 2.3.1 DID Creation Workflow

1. **Key Generation**: The user generates a key pair locally, choosing between ECC or quantum-resistant algorithms.
2. **Public Key Submission**: The user sends the public key to the Identity System via the `Create DID` endpoint.
3. **DID Registration**: The system creates a unique DID, stores the DID document, and returns the DID to the user.

#### 2.3.2 Authentication Workflow

1. **Nonce Request**: The user requests a nonce from the server to prevent replay attacks.
2. **Signature Generation**: The user signs the nonce with their private key.
3. **Authentication Request**: The user sends the DID, signature, and nonce to the server.
4. **Verification**: The server verifies the signature using the public key from the DID document.
5. **Token Issuance**: Upon successful verification, the server issues a JWT token for authenticated sessions.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Scalability**: The system should handle a large number of DID registrations and authentication requests concurrently.
- **Low Latency**: Authentication and DID resolution should occur with minimal delay to ensure a smooth user experience.

### 3.2 Security Requirements

- **Key Security**: Users must securely store their private keys; the system should never have access to private keys.
- **Replay Attack Prevention**: Use nonces or timestamps during authentication to prevent replay attacks.
- **Quantum Resistance**: Support for quantum-resistant algorithms like CRYSTALS-Dilithium and CRYSTALS-Kyber should be implemented to future-proof the system.

### 3.3 Error Handling

- **Detailed Error Messages**: Provide clear and actionable error messages without revealing sensitive information.
- **Failure Modes**: Gracefully handle failures in DID creation, resolution, and authentication.

## 4. Testing Requirements

- **Unit Tests**: Cover all functions related to DID management and authentication.
- **Integration Tests**: Test the interaction between the Identity System and other modules like the Reputation System and Governance Module.
- **Security Tests**: Perform vulnerability assessments and penetration testing to ensure robust security measures are in place.

## 5. Monitoring and Metrics

- **Audit Logs**: Maintain logs for DID creation, updates, and authentication attempts for auditing purposes.
- **Performance Metrics**: Monitor response times for API endpoints and system load.
- **Security Alerts**: Implement alerts for suspicious activities, such as repeated failed authentication attempts.

## 6. Future Considerations

- **DID Deactivation**: Provide a mechanism for users to deactivate or revoke their DIDs in case of key compromise.
- **Metadata Integration**: Include optional metadata in DID documents, such as reputation scores and cooperative affiliations.
- **Cross-Network Compatibility**: Ensure the Identity System is compatible with other decentralized networks for broader interoperability.
```

---

You can save this file as `identity-system.md` in your `./docs/specifications/core/` directory.

Would you like me to provide documentation for other components as well? If so, please let me know which one you'd like to work on next, and I'll prepare it accordingly.

===================
File: ./docs/specifications/core/proof-of-cooperation.md
===================
Certainly! Here is the documentation for the **Proof of Cooperation Consensus Mechanism**, focusing on security mechanisms, blockchain components, and efficiency considerations. The documentation is written in Markdown format and enclosed in a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/proof-of-cooperation.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Proof of Cooperation Consensus Mechanism
type: specification
version: 1.0.0
---

# Proof of Cooperation (PoC) Consensus Mechanism

## 1. Overview

### 1.1 Purpose

The Proof of Cooperation (PoC) is a consensus mechanism designed specifically for the Inter-Cooperative Network (ICN) to facilitate secure, efficient, and cooperative blockchain operations. Unlike traditional consensus mechanisms such as Proof of Work (PoW) or Proof of Stake (PoS), PoC emphasizes collaboration, democratic participation, and reputation-based accountability to align with cooperative principles.

### 1.2 Core Principles

- **Democratic Participation**: Ensures inclusive decision-making by allowing each node, representing a cooperative or individual within ICN, to contribute to consensus.
- **Incentivized Cooperation**: Rewards are based on positive contributions to the cooperative ecosystem rather than computational power or wealth.
- **Reputation-Driven Accountability**: Reputation scores influence participation and voting power, holding nodes accountable to ethical standards.
- **Environmental Sustainability**: Eliminates energy-intensive computations, maintaining an energy-efficient model.

## 2. Detailed Specifications

### 2.1 System Components

#### 2.1.1 Node Types and Roles

- **Validator Nodes**: Nodes that meet certain cooperative engagement criteria (e.g., reputation threshold) and participate in validating transactions and blocks.
- **Observer Nodes**: Nodes that maintain a copy of the blockchain for transparency and auditing but do not participate in validation.
- **Coordinator Node**: A validator node selected per consensus round to organize and propose blocks. Selection is based on a weighted lottery tied to reputation scores.

#### 2.1.2 Reputation System Integration

- **Reputation-Weighted Voting**: Nodes with higher reputation have slightly increased influence in the consensus process, capped to prevent centralization.
- **Dynamic Recalibration**: Reputation scores adjust based on ongoing contributions and decay over time to encourage continuous engagement.

### 2.2 Consensus Process

#### 2.2.1 Transaction Verification

1. **Submission**: Nodes submit transactions to the network.
2. **Preliminary Checks**: The Coordinator Node performs initial validation of transactions.
3. **Broadcast**: Validated transactions are broadcasted to Validator Nodes for multi-signature approval.

#### 2.2.2 Voting Round Execution

1. **Block Proposal**: The Coordinator Node assembles a candidate block with selected transactions.
2. **Reputation-Weighted Voting**:
   - Each Validator Node votes on the proposed block.
   - Votes are weighted based on reputation scores.
   - Voting power is capped to prevent undue influence.
3. **Consensus Threshold**: A supermajority (e.g., 66%) of weighted votes is required for block approval.

#### 2.2.3 Block Finalization

1. **Multi-Signature Collection**: Validator Nodes sign the approved block.
2. **Block Addition**: The signed block is added to the blockchain and propagated to the network.
3. **Reputation Adjustment**: Validators gain reputation for participation or lose reputation for misconduct.

### 2.3 Security Mechanisms

#### 2.3.1 Cryptographic Security

- **Asymmetric Encryption**: Utilizes public/private key pairs for secure communication and transaction signing.
- **Digital Signatures**: Ensures authenticity and non-repudiation of transactions and blocks.
- **Hash Functions**: Employs secure hash algorithms for data integrity.

#### 2.3.2 Sybil Attack Prevention

- **Reputation Requirements**: High reputation thresholds for Validator Nodes make it difficult for malicious actors to gain influence.
- **Identity Verification**: DIDs are tied to real-world cooperative entities, adding authenticity.

#### 2.3.3 Byzantine Fault Tolerance

- **Consensus Thresholds**: Requires a supermajority for block approval, tolerating up to one-third faulty or malicious nodes.
- **Multi-Signature Validation**: Collective block signing prevents unilateral block creation.

#### 2.3.4 Double-Spending Prevention

- **Transaction Finality**: Once confirmed, transactions are immutable.
- **Sequential Ordering**: Transactions are time-stamped and ordered to prevent conflicts.

#### 2.3.5 Integrity Audits and Penalties

- **Automated Audits**: Regular checks ensure protocol compliance.
- **Reputation Penalties**: Misconduct results in reputation loss.
- **Node Exclusion**: Severe violations can lead to temporary or permanent removal.

#### 2.3.6 Quantum-Resistant Cryptography

- **Post-Quantum Algorithms**: Implements CRYSTALS-Kyber and CRYSTALS-Dilithium for future-proof security.

### 2.4 Blockchain Components

#### 2.4.1 Block Structure

- **Block Header**:
  - **Previous Block Hash**: Links the block to the chain.
  - **Merkle Root**: Summarizes all transactions.
  - **Timestamp**: Time of block creation.
  - **Coordinator Signature**: Validates the Coordinator Node's role.
- **Block Body**:
  - **Transactions**: List of validated transactions.
  - **Validator Signatures**: Multi-signatures from Validator Nodes.

#### 2.4.2 Transactions

- **Standard Transactions**: Asset transfers between participants.
- **Governance Transactions**: Proposals and votes for network changes.
- **Metadata**: Additional information for transparency.

#### 2.4.3 State Management

- **State Database**: Maintains current account states.
- **State Transitions**: Defined by executed transactions.

### 2.5 Efficiency Considerations

#### 2.5.1 Consensus Efficiency

- **Lightweight Process**: Eliminates energy-intensive computations.
- **Fast Finality**: Quick transaction confirmation due to cooperative agreement.

#### 2.5.2 Scalability Solutions

- **Sharding**: Divides the network into smaller groups processing transactions in parallel.
- **Layer-2 Solutions**: Off-chain protocols handle transactions to reduce main chain load.

#### 2.5.3 Resource Optimization

- **Minimal Hardware Requirements**: Encourages broader participation.
- **Bandwidth Management**: Efficient protocols reduce network load.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Transaction Throughput**: Optimize for high throughput suitable for network demands.
- **Latency Minimization**: Ensure minimal delay in consensus rounds.

### 3.2 Security Requirements

- **Immutable Ledger**: Blocks are immutable once added.
- **Access Control**: Only authorized nodes can validate and propose blocks.
- **Data Integrity**: Secure cryptographic practices ensure data integrity.

### 3.3 Error Handling

- **Invalid Transactions**: Provide clear error messages upon rejection.
- **Fork Handling**: Establish protocols for resolving chain forks.

## 4. Testing Requirements

- **Unit Tests**: Cover consensus mechanisms, transaction validation, and security features.
- **Integration Tests**: Test interactions with other systems like the Identity and Reputation Systems.
- **Stress Tests**: Simulate high network load to test scalability.

## 5. Monitoring and Metrics

- **Consensus Monitoring**: Track consensus round performance and validator participation.
- **Security Audits**: Regular audits to detect and mitigate threats.
- **Performance Metrics**: Monitor transaction rates and block times.

## 6. Future Considerations

- **Consensus Mechanism Evolution**: Continuously evaluate and improve the PoC mechanism.
- **Interoperability**: Explore compatibility with other networks.
- **Smart Contract Integration**: Enhance cooperative functions through smart contracts.

```

---

You can save this file as `proof-of-cooperation.md` in your `./docs/specifications/core/` directory.

**Note:** This document provides a detailed specification of the Proof of Cooperation consensus mechanism, focusing on security mechanisms, blockchain components, and efficiency considerations, as per your request.

**Next Steps:**

- **Review and Edit**: Please review the document and make any necessary adjustments or additions specific to your project's needs.
- **Integration**: Incorporate this documentation into your project to guide development and ensure alignment with the designed consensus mechanism.

Let me know if you'd like assistance with any other components or further details.

===================
File: ./docs/specifications/core/reputation-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Reputation System
type: specification
version: 1.0.0
---

# Reputation System

## Overview
The Reputation System provides a non-transferable measure of trust and engagement within ICN. Reputation scores influence voting power, cooperative roles, and the ability to initiate proposals.

### Purpose
- **Incentivize Positive Behavior**: Encourage cooperative engagement and responsible voting.
- **Access Control**: Regulate participation based on reputation thresholds.
- **Transparent Governance**: Use reputation as a metric for cooperative influence.

## Data Structures

### Reputation System
- **scores**: `HashMap<String, i64>` - Maps DIDs to reputation scores.

### Reputation Score
- **Minimum**: Define lower thresholds to prevent negative reputation abuse.
- **Decay (planned)**: Implement periodic decay to maintain active engagement.

## Methods

### Increase Reputation
Increases reputation for actions like voting, creating proposals, or contributing resources.

### Decrease Reputation
Penalizes reputation for actions deemed harmful or against cooperative rules.

### Reward Voting Participation
Rewards active participation in voting, providing an incentive to engage in governance.

## Implementation Guidelines
- **Reputation Decay**: Decay inactive accounts periodically to prevent influence stagnation.
- **Thresholds**: Set thresholds for actions, e.g., minimum score for creating proposals.

## Monitoring and Metrics
- **Reputation Trends**: Track changes to analyze member engagement.
- **Vote Influence Analysis**: Record how reputation impacts voting outcomes.


===================
File: ./docs/specifications/core/blockchain-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Blockchain System
type: specification
version: 1.0.0
---

# Blockchain System

## Overview
The Blockchain System is the immutable ledger of the ICN, tracking all transactions, proposals, and reputation changes. Each cooperative or member transaction is recorded in the blockchain for transparency and traceability.

### Purpose
- **Transaction Integrity**: Ensures secure, tamper-resistant records of cooperative actions.
- **Reputation and Proposal Tracking**: Logs all reputation changes and governance activities.
- **Decentralized Ledger**: Provides a distributed record for cooperative actions and economic exchanges.

## Data Structures

### Block
- **index**: `u64` - Sequential block index.
- **previous_hash**: `String` - Hash of the previous block, linking it to the chain.
- **timestamp**: `u128` - Millisecond timestamp of creation.
- **transactions**: `Vec<Transaction>` - List of transactions included in the block.

### Transaction
- **sender**: `String` - DID of sender.
- **receiver**: `String` - DID of receiver.
- **amount**: `u64` - Value or resource exchanged.
- **hash**: `String` - Unique hash of the transaction, based on contents.

## Methods

### Add Transaction
Adds a new transaction to the pending list, verifying its contents before committing.

### Finalize Block
Bundles pending transactions into a block, calculating hash and adding to the blockchain.

### Calculate Hash
Computes the hash for each block, securing the data and linking blocks sequentially.

## Implementation Guidelines
- **Block Size Limit**: Define a maximum number of transactions per block to manage processing time.
- **Difficulty and Verification**: For scalability, adjust verification complexity based on load.

## Monitoring and Metrics
- **Transaction Throughput**: Measure number of transactions per block.
- **Hash Verification**: Track hash generation time to monitor performance.


===================
File: ./docs/specifications/core/governance-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance System
type: specification
version: 1.0.0
---

# Governance System

## Overview
The Governance System enables cooperative members to create, vote on, and track proposals within ICN. Proposals coordinate resource allocations, policy changes, and initiatives through reputation-weighted voting.

### Purpose
- **Decentralized Decision-Making**: Empowers cooperatives with direct influence over decisions.
- **Transparent Proposal Tracking**: Manages proposals throughout their lifecycle.
- **Reputation-Based Voting**: Aligns voting power with user contributions and engagement.

## Data Structures

### Proposal
- **id**: `u64` - Unique proposal identifier.
- **type**: `ProposalType` - Enum indicating proposal type (e.g., Funding).
- **status**: `ProposalStatus` - Enum indicating status (e.g., Open, Closed).
- **votes**: `Vec<(String, i64)>` - List of votes, with voter DID and weighted reputation.

### ProposalHistory
- **proposals**: `VecDeque<Proposal>` - Queue of proposals.
- **notifications**: `VecDeque<String>` - Queue of notifications for proposal events.

## Methods

### Create Proposal
Creates a proposal, setting parameters (type, description, duration) and initializing with Open status.

### Vote on Proposal
Registers a vote, using weighted reputation for transparency.

### Close Proposal
Locks in the proposal’s results, preventing further votes.

### Send Voting Reminder
Sends notifications to prompt voting for proposals near closure.

## Implementation Guidelines
- **Reputation Requirements**: Define minimum reputation for creating and voting to ensure credibility.
- **Standard Proposal Types**: Classify proposal types (Funding, PolicyChange) for consistency.

## Monitoring and Metrics
- **Proposal Activity**: Track proposal creation and voting rates.
- **Outcome Recording**: Log vote distribution and final outcome for cooperative accountability.


===================
File: ./docs/architecture/backend.md
===================
# Backend Architecture

The ICN backend handles core blockchain operations, transaction processing, and governance functionalities.

## Modules
1. **Blockchain Module**: Manages the decentralized ledger for recording transactions.
2. **Identity and DID Module**: Handles DID (Decentralized Identifiers) for secure, pseudonymous interactions.
3. **Reputation System**: Tracks and manages reputation scores, influencing governance roles and decision-making.

## Data Flow
- **Transaction Lifecycle**: Transactions are submitted, validated, and recorded in the blockchain, with reputation updates.
- **Reputation Tracking**: User actions affect their reputation score, impacting cooperative influence.


===================
File: ./docs/architecture/overview.md
===================
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.


===================
File: ./docs/architecture/diagrams/component/component.md
===================
# Component Diagram

This section provides a visual overview of the ICN's architectural components.

## Diagram
![Component Diagram](../images/component-diagram.png)

## Description
The ICN architecture is modular, allowing each component to function independently but interconnect to support cooperative and governance functionalities.
1. **Frontend Modules**: User interfaces for governance and cooperative management.
2. **API Gateway**: Manages communication between frontend and backend.
3. **Blockchain & VM**: Ensures secure transaction processing and execution of smart contracts.


===================
File: ./docs/architecture/diagrams/component.md
===================


