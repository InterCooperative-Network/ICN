Project Code Dump - Generated Mon Nov 11 05:02:13 AM UTC 2024
======================================

Project Tree:
=============
.
├── backend
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── examples
│   │   ├── blockchain_test.rs
│   │   ├── integration_test.rs
│   │   ├── ws_client.rs
│   │   └── ws_client2.rs
│   ├── lib.rs
│   ├── src
│   │   ├── api
│   │   │   ├── cooperative.rs
│   │   │   └── mod.rs
│   │   ├── blockchain
│   │   │   ├── block.rs
│   │   │   ├── blockchain.rs.bak
│   │   │   ├── chain.rs
│   │   │   ├── mod.rs
│   │   │   └── transaction.rs
│   │   ├── community
│   │   │   └── mod.rs
│   │   ├── consensus
│   │   │   ├── mod.rs
│   │   │   ├── proof_of_cooperation.rs
│   │   │   ├── tests.rs
│   │   │   └── types.rs
│   │   ├── cooperative
│   │   │   └── mod.rs
│   │   ├── governance
│   │   │   ├── mod.rs
│   │   │   └── proposal.rs
│   │   ├── identity
│   │   │   ├── authentication.rs
│   │   │   ├── did.rs
│   │   │   ├── identity_manager.rs
│   │   │   ├── identity_system.rs
│   │   │   ├── key_pair.rs
│   │   │   └── mod.rs
│   │   ├── lib.rs
│   │   ├── main.rs
│   │   ├── monitoring
│   │   │   └── energy.rs
│   │   ├── network
│   │   │   └── mod.rs
│   │   ├── reputation
│   │   │   ├── mod.rs
│   │   │   └── reputation_system.rs
│   │   ├── utils
│   │   │   ├── mod.rs
│   │   │   └── notifications.rs
│   │   ├── vm
│   │   │   ├── contract.rs
│   │   │   ├── cooperative_metadata.rs
│   │   │   ├── event.rs
│   │   │   ├── execution_context.rs
│   │   │   ├── mod.rs
│   │   │   ├── opcode.rs
│   │   │   └── vm.rs
│   │   └── websocket
│   │       ├── handler.rs
│   │       └── mod.rs
│   └── tests
│       └── integration_test.rs
├── contracts
│   └── cooperative
│       └── src
│           └── lib.rs
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── docs
│   ├── INDEX.md
│   ├── README.md
│   ├── architecture
│   │   ├── backend.md
│   │   ├── diagrams
│   │   │   └── component.md
│   │   └── overview.md
│   ├── development
│   │   └── guides
│   │       └── documentation-standards.md
│   ├── docs
│   │   └── index.md
│   ├── guides
│   │   └── index.md
│   ├── mkdocs.yml
│   ├── specifications
│   │   ├── api
│   │   │   └── governance-api.md
│   │   └── core
│   │       ├── 2024-11-01-reputation-system.md
│   │       ├── blockchain-system.md
│   │       ├── governance-system.md
│   │       ├── identity-system.md
│   │       ├── proof-of-cooperation.md
│   │       ├── reputation-system.md
│   │       ├── transaction-system.md
│   │       └── vm-system.md
│   ├── templates
│   │   ├── api-template.md
│   │   ├── core-component-template.md
│   │   └── protocol-template.md
│   └── user
│       └── guides
│           ├── index.md
│           ├── onboarding-guide.md
│           └── resource-management.md
├── frontend
│   ├── package.json
│   └── tsconfig.json
├── generate_code_dump.sh
├── project_code_dump.txt
├── setup_docs.sh
├── setup_venv.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── docmanager.cpython-312.pyc
    │   │   └── specgen.cpython-312.pyc
    │   ├── docmanager.py
    │   ├── docsctl
    │   └── specgen.py
    ├── install_docsctl.sh
    └── requirements.txt

39 directories, 92 files


===================
File: ./backend/src/identity/authentication.rs
===================
// src/identity/authentication.rs

pub struct Authentication {
    // Fields and methods for authentication
}


===================
File: ./backend/src/identity/did.rs
===================
use secp256k1::{Secp256k1, SecretKey, PublicKey};
use serde::{Serialize, Deserialize};
use rand::{thread_rng, RngCore};
use std::str::FromStr;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DID {
    pub id: String,
    #[serde(serialize_with = "serialize_public_key")]
    #[serde(deserialize_with = "deserialize_public_key")]
    pub public_key: PublicKey,
}

impl DID {
    pub fn new(id: String, secret_key: &SecretKey) -> Self {
        let secp = Secp256k1::new();
        let public_key = PublicKey::from_secret_key(&secp, secret_key);
        DID { id, public_key }
    }

    pub fn generate_random(id: String) -> (Self, SecretKey) {
        let secp = Secp256k1::new();
        let mut rng = thread_rng();
        
        // Generate random bytes for the secret key
        let mut secret_key_bytes = [0u8; 32];
        rng.fill_bytes(&mut secret_key_bytes);
        
        // Create secret key from the random bytes
        let secret_key = SecretKey::from_slice(&secret_key_bytes)
            .expect("Random bytes should produce valid key");
            
        let public_key = PublicKey::from_secret_key(&secp, &secret_key);
        let did = DID { id, public_key };
        (did, secret_key)
    }
}

fn serialize_public_key<S>(key: &PublicKey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&key.to_string())
}

fn deserialize_public_key<'de, D>(deserializer: D) -> Result<PublicKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let key_str = String::deserialize(deserializer)?;
    PublicKey::from_str(&key_str).map_err(serde::de::Error::custom)
}

===================
File: ./backend/src/identity/identity_system.rs
===================
use std::collections::HashMap;
use crate::identity::DID;

#[derive(Clone)]
pub struct IdentitySystem {
    permissions: HashMap<String, Vec<String>>,
    registered_dids: HashMap<String, DID>,
}

impl IdentitySystem {
    pub fn new() -> Self {
        IdentitySystem {
            permissions: HashMap::new(),
            registered_dids: HashMap::new(),
        }
    }

    pub fn get_permissions(&self, did: &str) -> Vec<String> {
        self.permissions.get(did)
            .cloned()
            .unwrap_or_default()
    }

    pub fn register_did(&mut self, did: DID, permissions: Vec<String>) {
        self.permissions.insert(did.id.clone(), permissions);
        self.registered_dids.insert(did.id.clone(), did);
    }

    pub fn is_registered(&self, did: &str) -> bool {
        self.registered_dids.contains_key(did)
    }

    pub fn add_permission(&mut self, did: &str, permission: String) {
        if let Some(perms) = self.permissions.get_mut(did) {
            if !perms.contains(&permission) {
                perms.push(permission);
            }
        }
    }

    pub fn remove_permission(&mut self, did: &str, permission: &str) {
        if let Some(perms) = self.permissions.get_mut(did) {
            perms.retain(|p| p != permission);
        }
    }

    pub fn get_did(&self, did: &str) -> Option<&DID> {
        self.registered_dids.get(did)
    }
}

===================
File: ./backend/src/identity/key_pair.rs
===================
// src/identity/key_pair.rs

pub struct KeyPair {
    pub public_key: Vec<u8>,
    pub private_key: Vec<u8>,
}


===================
File: ./backend/src/identity/mod.rs
===================
// src/identity/mod.rs

pub mod did;
// pub mod key_pair;
// pub mod identity_manager;
// pub mod authentication;
pub mod identity_system;

pub use did::DID;
// pub use key_pair::KeyPair;
// pub use identity_manager::IdentityManager;
// pub use authentication::Authentication;
pub use identity_system::IdentitySystem;


===================
File: ./backend/src/identity/identity_manager.rs
===================
// src/identity/identity_manager.rs

pub struct IdentityManager {
    // Fields and methods for managing identities
}


===================
File: ./backend/src/websocket/mod.rs
===================
// backend/src/websocket/mod.rs

mod handler;
pub use handler::WebSocketHandler;

===================
File: ./backend/src/websocket/handler.rs
===================
// src/websocket/handler.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::{broadcast, mpsc};
use warp::ws::{Message, WebSocket};
use futures_util::{StreamExt, SinkExt};
use serde::{Serialize, Deserialize};
use chrono::Utc;
use tokio::sync::mpsc::Sender;
use std::sync::atomic::{AtomicU64, Ordering};

use crate::consensus::types::{ValidatorInfo, ConsensusRound, RoundStatus};
use crate::blockchain::Block;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WebSocketMessage {
    ConsensusUpdate {
        round_number: u64,
        status: RoundStatus,
        coordinator: String,
        votes_count: usize,
        participation_rate: f64,
        remaining_time_ms: i64,
    },
    BlockFinalized {
        block_number: u64,
        transactions_count: usize,
        timestamp: u64,
        proposer: String,
    },
    ReputationUpdate {
        did: String,
        change: i64,
        new_total: i64,
        reason: String,
        context: String,
    },
    ValidatorUpdate {
        did: String,
        round: u64,
        status: String,
        reputation: i64,
        performance_score: f64,
    },
    CommandResponse {
        command: String,
        status: String,
        message: String,
        data: Option<serde_json::Value>,
    },
    Error {
        code: String,
        message: String,
        details: Option<serde_json::Value>,
    },
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
pub enum ClientMessage {
    RegisterValidator {
        did: String,
        initial_reputation: i64,
    },
    SubmitTransaction {
        transaction: serde_json::Value,
    },
    QueryStatus,
    Subscribe {
        events: Vec<String>,
    },
}

#[derive(Clone)]
struct ConnectionInfo {
    tx: Sender<WebSocketMessage>,
    subscriptions: Vec<String>,
    connected_at: chrono::DateTime<Utc>,
    last_active: chrono::DateTime<Utc>,
}

pub struct WebSocketHandler {
    connections: Arc<Mutex<HashMap<String, ConnectionInfo>>>,
    broadcast_tx: broadcast::Sender<WebSocketMessage>,
    connection_counter: Arc<AtomicU64>,
}

impl WebSocketHandler {
    pub fn new() -> Self {
        let (broadcast_tx, _) = broadcast::channel(100);
        WebSocketHandler {
            connections: Arc::new(Mutex::new(HashMap::new())),
            broadcast_tx,
            connection_counter: Arc::new(AtomicU64::new(0)),
        }
    }

    pub async fn handle_connection(&self, ws: WebSocket, did: String) {
        println!("New WebSocket connection from: {}", did);
        let (mut ws_sink, mut ws_stream) = ws.split();
        let (tx, mut rx) = mpsc::channel(32);

        let connection_id = self.connection_counter.fetch_add(1, Ordering::SeqCst);

        // Register connection
        {
            let mut connections = self.connections.lock().unwrap();
            connections.insert(did.clone(), ConnectionInfo {
                tx: tx.clone(),
                subscriptions: vec!["all".to_string()],
                connected_at: Utc::now(),
                last_active: Utc::now(),
            });
        }

        // Handle outgoing messages
        let connections = Arc::clone(&self.connections);
        let did_for_cleanup = did.clone();
        
        let send_task = tokio::spawn(async move {
            while let Some(msg) = rx.recv().await {
                if let Ok(json) = serde_json::to_string(&msg) {
                    if ws_sink.send(Message::text(json)).await.is_err() {
                        break;
                    }
                }
            }
            let mut connections = connections.lock().unwrap();
            connections.remove(&did_for_cleanup);
            println!("Send task completed for connection {}", connection_id);
        });

        // Handle incoming messages
        let handler = Arc::new(self.clone());
        let did_for_receive = did.clone();

        let receive_task = tokio::spawn(async move {
            while let Some(result) = ws_stream.next().await {
                match result {
                    Ok(message) => {
                        if let Ok(text) = message.to_str() {
                            if let Ok(client_msg) = serde_json::from_str::<ClientMessage>(text) {
                                if let Err(e) = handle_client_message(handler.clone(), &did_for_receive, client_msg).await {
                                    println!("Error handling message: {}", e);
                                }
                            }
                        }
                    }
                    Err(e) => {
                        println!("WebSocket error from {}: {}", did_for_receive, e);
                        break;
                    }
                }
            }
        });

        tokio::select! {
            _ = send_task => println!("Send task completed for {}", did),
            _ = receive_task => println!("Receive task completed for {}", did),
        }
    }

    fn broadcast_message(&self, message: WebSocketMessage) {
        // Create a vector of all transmitters while holding the lock
        let txs: Vec<_> = {
            let connections = self.connections.lock().unwrap();
            connections.values()
                .map(|info| info.tx.clone())
                .collect()
        }; // Lock is dropped here

        // Send messages without holding the lock
        for tx in txs {
            let message = message.clone();
            tokio::spawn(async move {
                if let Err(e) = tx.send(message).await {
                    println!("Failed to broadcast message: {}", e);
                }
            });
        }
    }

    async fn send_to_client(&self, did: &str, message: WebSocketMessage) -> Result<(), String> {
        let tx = {
            let connections = self.connections.lock().unwrap();
            connections.get(did)
                .map(|info| info.tx.clone())
        };

        if let Some(tx) = tx {
            tx.send(message)
                .await
                .map_err(|e| format!("Failed to send message: {}", e))?;
        }
        Ok(())
    }

    pub fn broadcast_consensus_update(&self, round: &ConsensusRound) {
        let message = WebSocketMessage::ConsensusUpdate {
            round_number: round.round_number,
            status: round.status.clone(),
            coordinator: round.coordinator.clone(),
            votes_count: round.votes.len(),
            participation_rate: round.stats.participation_rate,
            remaining_time_ms: (round.timeout - Utc::now()).num_milliseconds().max(0),
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_block_finalized(&self, block: &Block) {
        let message = WebSocketMessage::BlockFinalized {
            block_number: block.index,
            transactions_count: block.transactions.len(),
            timestamp: block.timestamp,
            proposer: block.proposer.clone(),
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_reputation_update(
        &self,
        did: String,
        change: i64,
        new_total: i64,
        reason: String,
        context: String
    ) {
        let message = WebSocketMessage::ReputationUpdate {
            did,
            change,
            new_total,
            reason,
            context,
        };
        self.broadcast_message(message);
    }

    pub fn broadcast_validator_update(
        &self,
        validator: ValidatorInfo,
        round: u64,
        status: String
    ) {
        let message = WebSocketMessage::ValidatorUpdate {
            did: validator.did.clone(),
            round,
            status,
            reputation: validator.reputation,
            performance_score: validator.performance_score,
        };
        self.broadcast_message(message);
    }

    pub fn connection_count(&self) -> usize {
        self.connections.lock().unwrap().len()
    }

    pub fn cleanup_inactive_connections(&self, timeout_seconds: i64) {
        let mut connections = self.connections.lock().unwrap();
        let now = Utc::now();
        connections.retain(|_, info| {
            (now - info.last_active).num_seconds() < timeout_seconds
        });
    }
}

async fn handle_client_message(
    handler: Arc<WebSocketHandler>,
    did: &str,
    message: ClientMessage
) -> Result<(), String> {
    match message {
        ClientMessage::Subscribe { events } => {
            let response = WebSocketMessage::CommandResponse {
                command: "subscribe".to_string(),
                status: "success".to_string(),
                message: format!("Subscribed to {} events", events.len()),
                data: Some(serde_json::json!({ "events": events })),
            };
            handler.send_to_client(did, response).await
        },
        _ => {
            let response = WebSocketMessage::Error {
                code: "UNSUPPORTED".to_string(),
                message: "Message type not supported".to_string(),
                details: None,
            };
            handler.send_to_client(did, response).await
        }
    }
}

impl Clone for WebSocketHandler {
    fn clone(&self) -> Self {
        WebSocketHandler {
            connections: Arc::clone(&self.connections),
            broadcast_tx: self.broadcast_tx.clone(),
            connection_counter: Arc::clone(&self.connection_counter),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_connection_management() {
        let handler = WebSocketHandler::new();
        assert_eq!(handler.connection_count(), 0);
    }

    #[test]
    fn test_message_serialization() {
        let message = WebSocketMessage::ConsensusUpdate {
            round_number: 1,
            status: RoundStatus::Voting,
            coordinator: "did:icn:test".to_string(),
            votes_count: 3,
            participation_rate: 0.75,
            remaining_time_ms: 5000,
        };

        let serialized = serde_json::to_string(&message).unwrap();
        assert!(!serialized.is_empty());
    }
}

===================
File: ./backend/src/cooperative/mod.rs
===================
// src/cooperative/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;
use crate::claims::Claim;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, MemberRole>, // DID -> Role mapping
    pub resources: HashMap<String, Resource>,
    pub policies: Vec<Policy>,
    pub federation_ids: Vec<String>, // Other cooperatives this one federates with
    pub community_id: String,        // Associated civic community
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub name: String,
    pub resource_type: ResourceType,
    pub quantity: f64,
    pub unit: String,
    pub availability: ResourceAvailability,
    pub tags: Vec<String>,
    pub shared_with: Vec<String>, // Cooperative IDs
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ResourceType {
    Physical,
    Digital,
    Service,
    Skill,
    Space,
    Equipment,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAvailability {
    pub status: AvailabilityStatus,
    pub schedule: Option<Schedule>,
    pub conditions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AvailabilityStatus {
    Available,
    InUse,
    Reserved,
    Maintenance,
    Unavailable,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schedule {
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub recurring: bool,
    pub frequency: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub policy_type: PolicyType,
    pub description: String,
    pub rules: Vec<Rule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PolicyType {
    ResourceSharing,
    MembershipRequirement,
    FederationRule,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub condition: String,
    pub action: String,
    pub parameters: HashMap<String, String>,
}

impl Cooperative {
    pub fn new(
        id: String,
        name: String,
        description: String,
        community_id: String,
    ) -> Self {
        Cooperative {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            resources: HashMap::new(),
            policies: Vec::new(),
            federation_ids: Vec::new(),
            community_id,
        }
    }

    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }

    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.push(policy);
    }

    pub fn federate_with(&mut self, cooperative_id: String) {
        if !self.federation_ids.contains(&cooperative_id) {
            self.federation_ids.push(cooperative_id);
        }
    }
}

// Implement the trait for cooperative energy tracking
impl crate::monitoring::energy::EnergyAware for Cooperative {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record storage based on resource count
        let storage_size = (self.resources.len() * std::mem::size_of::<Resource>()) as u64;
        monitor.record_storage_operation(storage_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<MemberRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}// src/cooperative/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;
use crate::claims::Claim;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cooperative {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, MemberRole>, // DID -> Role mapping
    pub resources: HashMap<String, Resource>,
    pub policies: Vec<Policy>,
    pub federation_ids: Vec<String>, // Other cooperatives this one federates with
    pub community_id: String,        // Associated civic community
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resource {
    pub id: String,
    pub name: String,
    pub resource_type: ResourceType,
    pub quantity: f64,
    pub unit: String,
    pub availability: ResourceAvailability,
    pub tags: Vec<String>,
    pub shared_with: Vec<String>, // Cooperative IDs
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ResourceType {
    Physical,
    Digital,
    Service,
    Skill,
    Space,
    Equipment,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceAvailability {
    pub status: AvailabilityStatus,
    pub schedule: Option<Schedule>,
    pub conditions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AvailabilityStatus {
    Available,
    InUse,
    Reserved,
    Maintenance,
    Unavailable,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Schedule {
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub recurring: bool,
    pub frequency: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub policy_type: PolicyType,
    pub description: String,
    pub rules: Vec<Rule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PolicyType {
    ResourceSharing,
    MembershipRequirement,
    FederationRule,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub condition: String,
    pub action: String,
    pub parameters: HashMap<String, String>,
}

impl Cooperative {
    pub fn new(
        id: String,
        name: String,
        description: String,
        community_id: String,
    ) -> Self {
        Cooperative {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            resources: HashMap::new(),
            policies: Vec::new(),
            federation_ids: Vec::new(),
            community_id,
        }
    }

    pub fn add_member(&mut self, did: String, role: MemberRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_resource(&mut self, resource: Resource) -> Result<(), String> {
        if self.resources.contains_key(&resource.id) {
            return Err("Resource already exists".to_string());
        }
        self.resources.insert(resource.id.clone(), resource);
        Ok(())
    }

    pub fn add_policy(&mut self, policy: Policy) {
        self.policies.push(policy);
    }

    pub fn federate_with(&mut self, cooperative_id: String) {
        if !self.federation_ids.contains(&cooperative_id) {
            self.federation_ids.push(cooperative_id);
        }
    }
}

// Implement the trait for cooperative energy tracking
impl crate::monitoring::energy::EnergyAware for Cooperative {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record storage based on resource count
        let storage_size = (self.resources.len() * std::mem::size_of::<Resource>()) as u64;
        monitor.record_storage_operation(storage_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<MemberRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}

===================
File: ./backend/src/utils/notifications.rs
===================
use chrono::{DateTime, Utc};
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Notification {
    pub proposal_id: u64,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Notification {
    /// Creates a new notification with the current timestamp.
    pub fn new(proposal_id: u64, message: String) -> Self {
        Notification {
            proposal_id,
            message,
            timestamp: Utc::now(),
        }
    }

    /// Displays a formatted message for the notification.
    pub fn display(&self) {
        println!(
            "[{}] Proposal ID {}: {}",
            self.timestamp, self.proposal_id, self.message
        );
    }
}

===================
File: ./backend/src/utils/mod.rs
===================
pub mod notifications;



===================
File: ./backend/src/vm/contract.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use super::opcode::OpCode;
use super::cooperative_metadata::CooperativeMetadata;

#[derive(Clone, Serialize, Deserialize)]
pub struct Contract {
    pub id: String,
    pub code: Vec<OpCode>,
    pub state: HashMap<String, i64>,
    pub required_reputation: i64,
    pub cooperative_metadata: CooperativeMetadata,
    pub version: String,
    pub dependencies: Vec<String>,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/cooperative_metadata.rs
===================
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct ResourceImpact {
    pub cpu_intensity: u8,
    pub memory_usage: u8,
    pub network_usage: u8,
    pub storage_usage: u8,
    pub bandwidth_usage: u8,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct CooperativeMetadata {
    pub creator_did: String,
    pub cooperative_id: String,
    pub purpose: String,
    pub resource_impact: ResourceImpact,
    pub federation_id: Option<String>,
    pub creation_timestamp: u64,
    pub last_updated: u64,
    pub member_count: u64,
    pub resource_allocation: HashMap<String, u64>,
}


===================
File: ./backend/src/vm/vm.rs
===================
use std::collections::HashMap;
use super::opcode::OpCode;
use super::contract::Contract;
use super::execution_context::ExecutionContext;
use super::cooperative_metadata::CooperativeMetadata;
use super::event::Event;

pub struct VM {
    stack: Vec<i64>,
    memory: HashMap<String, i64>,
    execution_context: Option<ExecutionContext>,
    events: Vec<Event>,
    logs: Vec<String>,
    pub reputation_context: HashMap<String, i64>,
    instruction_limit: usize,
    instruction_pointer: usize,
}

impl VM {
    pub fn new(instruction_limit: usize, reputation_context: HashMap<String, i64>) -> Self {
        VM {
            stack: Vec::new(),
            memory: HashMap::new(),
            execution_context: None,
            events: Vec::new(),
            logs: Vec::new(),
            reputation_context,
            instruction_limit,
            instruction_pointer: 0,
        }
    }

    pub fn get_reputation_context(&self) -> &HashMap<String, i64> {
        &self.reputation_context
    }

    pub fn set_execution_context(&mut self, context: ExecutionContext) {
        self.execution_context = Some(context);
    }

    pub fn execute_contract(&mut self, contract: &Contract) -> Result<(), String> {
        // Check execution context
        let context = self.execution_context.as_ref().ok_or("No execution context".to_string())?;

        // Check caller reputation
        let caller_reputation = self
            .reputation_context
            .get(&context.caller_did)
            .copied()
            .unwrap_or(0);
        if caller_reputation < contract.required_reputation {
            return Err("Insufficient reputation to execute contract".to_string());
        }

        // Check permissions
        for permission in &contract.permissions {
            if !context.permissions.contains(permission) {
                return Err(format!("Missing permission: {}", permission));
            }
        }

        // Execute instructions
        let code_len = contract.code.len();
        self.instruction_pointer = 0;

        while self.instruction_pointer < code_len {
            if self.instruction_pointer >= self.instruction_limit {
                return Err("Instruction limit exceeded".to_string());
            }

            let op = &contract.code[self.instruction_pointer];
            self.execute_instruction(op, &contract.cooperative_metadata)?;

            self.instruction_pointer += 1;
        }

        Ok(())
    }

    pub fn execute_instruction(
        &mut self,
        op: &OpCode,
        metadata: &CooperativeMetadata,
    ) -> Result<(), String> {
        match op {
            OpCode::Push(val) => {
                self.stack.push(*val);
                Ok(())
            }
            OpCode::Pop => {
                self.stack.pop().ok_or("Stack underflow".to_string())?;
                Ok(())
            }
            OpCode::Dup => {
                let val = *self.stack.last().ok_or("Stack underflow")?;
                self.stack.push(val);
                Ok(())
            }
            OpCode::Swap => {
                let len = self.stack.len();
                if len < 2 {
                    return Err("Not enough values on the stack to swap".to_string());
                }
                self.stack.swap(len - 1, len - 2);
                Ok(())
            }
            OpCode::Add => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a + b);
                Ok(())
            }
            OpCode::Sub => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a - b);
                Ok(())
            }
            OpCode::Mul => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a * b);
                Ok(())
            }
            OpCode::Div => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Division by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a / b);
                Ok(())
            }
            OpCode::Mod => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                if b == 0 {
                    return Err("Modulo by zero".to_string());
                }
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a % b);
                Ok(())
            }
            OpCode::Store(key) => {
                let value = self.stack.pop().ok_or("Stack underflow")?;
                self.memory.insert(key.clone(), value);
                Ok(())
            }
            OpCode::Load(key) => {
                let value = self
                    .memory
                    .get(key)
                    .copied()
                    .ok_or("Key not found in memory".to_string())?;
                self.stack.push(value);
                Ok(())
            }
            OpCode::Jump(target) => {
                if *target >= self.instruction_limit {
                    return Err("Jump target out of bounds".to_string());
                }
                self.instruction_pointer = *target;
                Ok(())
            }
            OpCode::JumpIf(target) => {
                let condition = self.stack.pop().ok_or("Stack underflow")?;
                if condition != 0 {
                    if *target >= self.instruction_limit {
                        return Err("Jump target out of bounds".to_string());
                    }
                    self.instruction_pointer = *target;
                }
                Ok(())
            }
            OpCode::CreateCooperative => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"cooperative.create".to_string()) {
                    return Err("Permission denied: cooperative.create".to_string());
                }
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                if reputation < 100 {
                    return Err("Insufficient reputation to create cooperative".to_string());
                }
                self.emit_event(
                    "CooperativeCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveCooperative => {
                let _context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.emit_event(
                    "CooperativeLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::AllocateResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceAllocated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), resource_amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::TransferResource => {
                let resource_amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ResourceTransferred",
                    metadata.cooperative_id.clone(),
                    [
                        ("amount".to_string(), resource_amount.to_string()),
                        ("to_member".to_string(), to_member_id.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateCooperativeMetadata => {
                Ok(())
            }
            OpCode::AddCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberAdded",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::RemoveCooperativeMember => {
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "CooperativeMemberRemoved",
                    metadata.cooperative_id.clone(),
                    [("member_id".to_string(), member_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::SetMemberRole => {
                let role = self.stack.pop().ok_or("Stack underflow")?;
                let member_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "MemberRoleSet",
                    metadata.cooperative_id.clone(),
                    [
                        ("member_id".to_string(), member_id.to_string()),
                        ("role".to_string(), role.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::CreateProposal => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                if !context.permissions.contains(&"proposal.create".to_string()) {
                    return Err("Permission denied: proposal.create".to_string());
                }
                self.emit_event(
                    "ProposalCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CastVote => {
                let vote_value = self.stack.pop().ok_or("Stack underflow")?;
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VoteCast",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("vote_value".to_string(), vote_value.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::DelegateVotes => {
                let delegate_to_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotesDelegated",
                    metadata.cooperative_id.clone(),
                    [("delegate_to".to_string(), delegate_to_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExecuteProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalExecuted",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CancelProposal => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "ProposalCancelled",
                    metadata.cooperative_id.clone(),
                    [("proposal_id".to_string(), proposal_id.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::ExtendVotingPeriod => {
                let proposal_id = self.stack.pop().ok_or("Stack underflow")?;
                let additional_time = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "VotingPeriodExtended",
                    metadata.cooperative_id.clone(),
                    [
                        ("proposal_id".to_string(), proposal_id.to_string()),
                        ("additional_time".to_string(), additional_time.to_string()),
                    ]
                    .iter()
                    .cloned()
                    .collect(),
                );
                Ok(())
            }
            OpCode::UpdateQuorum => {
                let new_quorum = self.stack.pop().ok_or("Stack underflow")?;
                self.emit_event(
                    "QuorumUpdated",
                    metadata.cooperative_id.clone(),
                    [("new_quorum".to_string(), new_quorum.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::CalculateVotingWeight => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::UpdateReputation(amount) => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                *reputation += *amount;
                self.emit_event(
                    "ReputationUpdated",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::GetReputation => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .get(&context.caller_did)
                    .copied()
                    .unwrap_or(0);
                self.stack.push(reputation);
                Ok(())
            }
            OpCode::TransferReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let from_context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;

                    let from_reputation = self
                    .reputation_context
                    .entry(from_context.caller_did.clone())
                    .or_insert(0);
                if *from_reputation < amount {
                    return Err("Insufficient reputation to transfer".to_string());
                }

                *from_reputation -= amount;
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;

                self.emit_event(
                    "ReputationTransferred",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::BurnReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let reputation = self.reputation_context
                    .entry(context.caller_did.clone())
                    .or_insert(0);
                if *reputation < amount {
                    return Err("Insufficient reputation to burn".to_string());
                }
                *reputation -= amount;
                self.emit_event(
                    "ReputationBurned",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::MintReputation => {
                let amount = self.stack.pop().ok_or("Stack underflow")?;
                let to_did_hash = self.stack.pop().ok_or("Stack underflow")?;
                let to_did = self.reverse_hash_did(to_did_hash);
                let to_reputation = self.reputation_context.entry(to_did).or_insert(0);
                *to_reputation += amount;
                self.emit_event(
                    "ReputationMinted",
                    metadata.cooperative_id.clone(),
                    [("amount".to_string(), amount.to_string())]
                        .iter()
                        .cloned()
                        .collect(),
                );
                Ok(())
            }
            OpCode::VerifyDID => {
                self.stack.push(1); // 1 for true
                Ok(())
            }
            OpCode::UpdateDIDDocument => {
                self.emit_event(
                    "DIDDocumentUpdated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::CreateCredential => {
                self.emit_event(
                    "CredentialCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::VerifyCredential => {
                self.stack.push(1); // Assume credential is valid
                Ok(())
            }
            OpCode::RevokeCredential => {
                self.emit_event(
                    "CredentialRevoked",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::InitiateFederation => {
                self.emit_event(
                    "FederationInitiated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::JoinFederation => {
                self.emit_event(
                    "FederationJoined",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::LeaveFederation => {
                self.emit_event(
                    "FederationLeft",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::SyncFederationState => {
                self.emit_event(
                    "FederationStateSynced",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateFederationAction => {
                self.stack.push(1); // Assume action is valid
                Ok(())
            }
            OpCode::CreateTransaction => {
                self.emit_event(
                    "TransactionCreated",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::ValidateTransaction => {
                self.stack.push(1); // Assume transaction is valid
                Ok(())
            }
            OpCode::SignTransaction => {
                self.emit_event(
                    "TransactionSigned",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::BroadcastTransaction => {
                self.emit_event(
                    "TransactionBroadcasted",
                    metadata.cooperative_id.clone(),
                    HashMap::new(),
                );
                Ok(())
            }
            OpCode::Log(message) => {
                self.logs.push(format!("Log: {}", message));
                Ok(())
            }
            OpCode::Halt => {
                self.instruction_pointer = self.instruction_limit;
                Ok(())
            }
            OpCode::EmitEvent(event_type) => {
                self.emit_event(event_type, metadata.cooperative_id.clone(), HashMap::new());
                Ok(())
            }
            OpCode::GetBlockNumber => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.block_number as i64);
                Ok(())
            }
            OpCode::GetTimestamp => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                self.stack.push(context.timestamp as i64);
                Ok(())
            }
                // Add the GetCaller implementation here:
            OpCode::GetCaller => {
                let context = self.execution_context.as_ref()
                    .ok_or("No execution context".to_string())?;
                let caller_id_hash = self.hash_did(&context.caller_did);
                self.stack.push(caller_id_hash);
                Ok(())
            }
            
            OpCode::Equal => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a == b { 1 } else { 0 });
                Ok(())
            }
            OpCode::NotEqual => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a != b { 1 } else { 0 });
                Ok(())
            }
            OpCode::GreaterThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a > b { 1 } else { 0 });
                Ok(())
            }
            OpCode::LessThan => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(if a < b { 1 } else { 0 });
                Ok(())
            }
            OpCode::And => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a & b);
                Ok(())
            }
            OpCode::Or => {
                let b = self.stack.pop().ok_or("Stack underflow")?;
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(a | b);
                Ok(())
            }
            OpCode::Not => {
                let a = self.stack.pop().ok_or("Stack underflow")?;
                self.stack.push(!a);
                Ok(())
            }
            OpCode::Nop => Ok(()),
        }
    }

    fn emit_event(&mut self, event_type: &str, cooperative_id: String, data: HashMap<String, String>) {
        if let Some(context) = &self.execution_context {
            let event = Event {
                event_type: event_type.to_string(),
                cooperative_id,
                data,
                timestamp: context.timestamp,
            };
            self.events.push(event);
        }
    }

    fn hash_did(&self, did: &str) -> i64 {
        // Simple hash function for example purposes
        did.bytes().fold(0, |acc, b| acc + b as i64)
    }

    fn reverse_hash_did(&self, hash: i64) -> String {
        format!("did:placeholder:{}", hash)
    }

    pub fn get_logs(&self) -> &Vec<String> {
        &self.logs
    }

    pub fn get_events(&self) -> &Vec<Event> {
        &self.events
    }

    pub fn get_stack(&self) -> &Vec<i64> {
        &self.stack
    }

    pub fn get_memory(&self) -> &HashMap<String, i64> {
        &self.memory
    }
}

===================
File: ./backend/src/vm/tests/vm_tests.rs
===================
#[cfg(test)]
mod tests {
    use super::super::*;
    use std::collections::HashMap;

    fn setup_vm() -> VM {
        let instruction_limit = 1000;
        let reputation_context = HashMap::new();
        VM::new(instruction_limit, reputation_context)
    }

    fn default_execution_context() -> ExecutionContext {
        ExecutionContext {
            caller_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            timestamp: 1620000000,
            block_number: 1,
            reputation_score: 100,
            permissions: vec!["cooperative.create".to_string(), "proposal.create".to_string()],
        }
    }

    fn default_cooperative_metadata() -> CooperativeMetadata {
        CooperativeMetadata {
            creator_did: "did:icn:12345".to_string(),
            cooperative_id: "coop-1".to_string(),
            purpose: "Test Cooperative".to_string(),
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: 1620000000,
            last_updated: 1620000000,
            member_count: 1,
            resource_allocation: HashMap::new(),
        }
    }

    #[test]
    fn test_push_pop() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "test_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(20),
                OpCode::Pop,
                OpCode::Push(30),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 10);
        assert_eq!(stack[1], 30);
    }

    #[test]
    fn test_arithmetic_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "arithmetic_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(5),
                OpCode::Add,
                OpCode::Push(2),
                OpCode::Mul,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 30); // (10 + 5) * 2 = 30
    }

    #[test]
    fn test_memory_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "memory_contract".to_string(),
            code: vec![
                OpCode::Push(42),
                OpCode::Store("answer".to_string()),
                OpCode::Load("answer".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 42);
    }

    #[test]
    fn test_control_flow_jump() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_contract".to_string(),
            code: vec![
                OpCode::Push(1),             // 0
                OpCode::Jump(4),             // 1
                OpCode::Push(999),           // 2 (should be skipped)
                OpCode::Halt,                // 3 (should be skipped)
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 2);
        assert_eq!(stack[0], 1);
        assert_eq!(stack[1], 2);
    }

    #[test]
    fn test_control_flow_jumpif() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "control_flow_jumpif_contract".to_string(),
            code: vec![
                OpCode::Push(0),             // 0
                OpCode::JumpIf(4),           // 1 (should not jump)
                OpCode::Push(1),             // 2
                OpCode::Halt,                // 3
                OpCode::Push(2),             // 4
                OpCode::Halt,                // 5
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1);
    }

    #[test]
    fn test_comparison_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "comparison_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(10),
                OpCode::Equal,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());
        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 1); // 1 for true
    }

    #[test]
    fn test_cooperative_operations() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "cooperative_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CooperativeCreated");
    }

    #[test]
    fn test_reputation_operations() {
        let mut reputation_context = HashMap::new();
        reputation_context.insert("did:icn:12345".to_string(), 50);

        let mut vm = VM::new(1000, reputation_context);
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "reputation_contract".to_string(),
            code: vec![
                OpCode::UpdateReputation(25),
                OpCode::GetReputation,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let stack = vm.get_stack();
        assert_eq!(stack.len(), 1);
        assert_eq!(stack[0], 75);

        let updated_reputation = vm.reputation_context.get("did:icn:12345").copied().unwrap_or(0);
        assert_eq!(updated_reputation, 75);
    }

    #[test]
    fn test_error_handling_division_by_zero() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "error_contract".to_string(),
            code: vec![
                OpCode::Push(10),
                OpCode::Push(0),
                OpCode::Div,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero".to_string());
    }

    #[test]
    fn test_event_emission() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "event_contract".to_string(),
            code: vec![
                OpCode::EmitEvent("CustomEvent".to_string()),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_ok());

        let events = vm.get_events();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "CustomEvent");
    }

    #[test]
    fn test_insufficient_reputation() {
        let mut vm = setup_vm();
        vm.set_execution_context(default_execution_context());

        let contract = Contract {
            id: "high_reputation_contract".to_string(),
            code: vec![
                OpCode::Push(1),
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 200,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec![],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient reputation to execute contract".to_string());
    }

    #[test]
    fn test_missing_permission() {
        let mut vm = setup_vm();
        let mut context = default_execution_context();
        context.permissions = vec![]; // No permissions
        vm.set_execution_context(context);

        let contract = Contract {
            id: "permission_contract".to_string(),
            code: vec![
                OpCode::CreateCooperative,
                OpCode::Halt,
            ],
            state: HashMap::new(),
            required_reputation: 0,
            cooperative_metadata: default_cooperative_metadata(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let result = vm.execute_contract(&contract);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Missing permission: cooperative.create".to_string());
    }
}


===================
File: ./backend/src/vm/mod.rs
===================
// backend/src/vm/mod.rs

pub mod opcode;
pub mod contract;
pub mod vm;
pub mod execution_context;
pub mod cooperative_metadata;
pub mod event;

pub use contract::Contract;
pub use vm::VM;
pub use execution_context::ExecutionContext;

===================
File: ./backend/src/vm/opcode.rs
===================
// src/vm/opcode.rs

use serde::{Serialize, Deserialize};

/// Enum representing the various operations (`OpCode`) that can be executed in the virtual machine.
/// Each variant is an operation that affects the VM stack, memory, or interacts with other subsystems like
/// cooperative, governance, reputation, identity, federation, and system operations.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Stack Operations
    /// Push a value onto the stack.
    Push(i64),        
    /// Pop the top value from the stack.
    Pop,              
    /// Duplicate the top value on the stack.
    Dup,              
    /// Swap the top two values on the stack.
    Swap,             

    // Arithmetic Operations
    /// Add the top two values on the stack.
    Add,              
    /// Subtract the top two values on the stack.
    Sub,              
    /// Multiply the top two values on the stack.
    Mul,              
    /// Divide the top two values on the stack.
    Div,              
    /// Compute the modulo of the top two values on the stack.
    Mod,              

    // Memory Operations
    /// Store a value in memory with a specific key.
    Store(String),    
    /// Load a value from memory using a specific key.
    Load(String),     

    // Control Flow Operations
    /// Unconditional jump to a specified instruction index.
    Jump(usize),      
    /// Conditional jump to an instruction index if the top of the stack is non-zero.
    JumpIf(usize),    

    // Cooperative Operations
    /// Create a new cooperative entity.
    CreateCooperative,
    /// Join an existing cooperative.
    JoinCooperative,
    /// Leave a cooperative.
    LeaveCooperative,
    /// Allocate resources within a cooperative.
    AllocateResource,
    /// Transfer resources within or between cooperatives.
    TransferResource,
    /// Update cooperative metadata (e.g., purpose, mission).
    UpdateCooperativeMetadata,
    /// Add a member to a cooperative.
    AddCooperativeMember,
    /// Remove a member from a cooperative.
    RemoveCooperativeMember,
    /// Set a specific role for a cooperative member.
    SetMemberRole,

    // Governance Operations
    /// Create a new proposal in governance.
    CreateProposal,
    /// Cast a vote on a proposal.
    CastVote,
    /// Delegate voting rights to another member.
    DelegateVotes,
    /// Execute an approved proposal.
    ExecuteProposal,
    /// Update the quorum requirements for voting.
    UpdateQuorum,
    /// Cancel an existing proposal.
    CancelProposal,
    /// Extend the voting period for a proposal.
    ExtendVotingPeriod,
    /// Calculate the weight of a vote based on certain metrics.
    CalculateVotingWeight,

    // Reputation Operations
    /// Update a member's reputation by a specified value.
    UpdateReputation(i64),
    /// Retrieve a member's reputation.
    GetReputation,
    /// Transfer reputation between members.
    TransferReputation,
    /// Burn (remove) a certain amount of reputation.
    BurnReputation,
    /// Mint (create) a certain amount of reputation.
    MintReputation,

    // Identity Operations
    /// Verify a Decentralized Identifier (DID).
    VerifyDID,
    /// Update a Decentralized Identifier (DID) document.
    UpdateDIDDocument,
    /// Create a new credential associated with a DID.
    CreateCredential,
    /// Verify a given credential.
    VerifyCredential,
    /// Revoke a previously issued credential.
    RevokeCredential,

    // Federation Operations
    /// Initiate the process of federation.
    InitiateFederation,
    /// Join an existing federation.
    JoinFederation,
    /// Leave a federation.
    LeaveFederation,
    /// Synchronize federation state with peers.
    SyncFederationState,
    /// Validate a specific action within the federation.
    ValidateFederationAction,

    // Transaction Operations
    /// Create a new transaction.
    CreateTransaction,
    /// Validate an existing transaction.
    ValidateTransaction,
    /// Sign a transaction for verification purposes.
    SignTransaction,
    /// Broadcast a transaction to the network.
    BroadcastTransaction,

    // System Operations
    /// Log a message to the system logs.
    Log(String),
    /// Halt the execution of the current process.
    Halt,
    /// Emit an event with a message.
    EmitEvent(String),
    /// Retrieve the current block number.
    GetBlockNumber,
    /// Get the current timestamp.
    GetTimestamp,
    /// Retrieve the caller's DID or identity.
    GetCaller,

    // Comparison Operations
    /// Check if the top two stack values are equal.
    Equal,
    /// Check if the top two stack values are not equal.
    NotEqual,
    /// Check if the top value is greater than the second top value.
    GreaterThan,
    /// Check if the top value is less than the second top value.
    LessThan,

    // Logical Operations
    /// Perform logical AND on the top two stack values.
    And,
    /// Perform logical OR on the top two stack values.
    Or,
    /// Perform logical NOT on the top stack value.
    Not,

    // No Operation
    /// No operation (used for padding or delays).
    Nop,
}



===================
File: ./backend/src/vm/event.rs
===================
use std::collections::HashMap;

pub struct Event {
    pub event_type: String,
    pub cooperative_id: String,
    pub data: HashMap<String, String>,
    pub timestamp: u64,
}


===================
File: ./backend/src/vm/execution_context.rs
===================
pub struct ExecutionContext {
    pub caller_did: String,
    pub cooperative_id: String,
    pub timestamp: u64,
    pub block_number: u64,
    pub reputation_score: i64,
    pub permissions: Vec<String>,
}


===================
File: ./backend/src/vm/contracts/voting_rules.rs
===================
// src/vm/contracts/voting_rules.rs

#[derive(Clone, Serialize, Deserialize)]
pub struct CustomVotingRules {
    pub cooperative_id: String,
    pub use_reputation_weighting: bool,
    pub min_reputation_to_vote: Option<i64>,
    pub max_vote_weight: Option<f64>,
    pub quorum_requirement: f64,
    pub special_majority_requirement: Option<f64>,
    pub proposal_categories: HashMap<String, ProposalRules>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct ProposalRules {
    pub category: String,
    pub quorum_requirement: f64,
    pub approval_threshold: f64,
    pub reputation_multiplier: Option<f64>,
}

impl VotingRules for CustomVotingRules {
    fn calculate_vote_weight(&self, voter: &str, context: &VotingContext) -> f64 {
        if !self.use_reputation_weighting {
            return 1.0;
        }

        let reputation = context.reputation_scores
            .as_ref()
            .and_then(|scores| scores.get(voter))
            .copied()
            .unwrap_or(0);

        // Check minimum reputation requirement
        if let Some(min_rep) = self.min_reputation_to_vote {
            if reputation < min_rep {
                return 0.0;
            }
        }

        let category_rules = self.proposal_categories
            .get(&context.proposal_type)
            .cloned()
            .unwrap_or_default();

        // Calculate weight based on reputation
        let base_weight = if reputation <= 0 { 
            0.0 
        } else {
            1.0 + (reputation as f64 * category_rules.reputation_multiplier.unwrap_or(0.0))
        };

        // Apply maximum weight cap if configured
        if let Some(max_weight) = self.max_vote_weight {
            base_weight.min(max_weight)
        } else {
            base_weight
        }
    }

    fn is_proposal_approved(&self, votes: &HashMap<String, Vote>, context: &VotingContext) -> bool {
        let total_weights: f64 = votes.keys()
            .map(|voter| self.calculate_vote_weight(voter, context))
            .sum();

        let approval_weights: f64 = votes.iter()
            .filter(|(_, vote)| vote.approve)
            .map(|(voter, _)| self.calculate_vote_weight(voter, context))
            .sum();

        // Get category-specific rules
        let category_rules = self.proposal_categories
            .get(&context.proposal_type)
            .cloned()
            .unwrap_or_default();

        // Check quorum
        let quorum = category_rules.quorum_requirement.max(self.quorum_requirement);
        let participation_rate = votes.len() as f64 / context.total_members as f64;
        
        if participation_rate < quorum {
            return false;
        }

        // Check approval threshold
        let approval_rate = if total_weights > 0.0 {
            approval_weights / total_weights
        } else {
            0.0
        };

        approval_rate >= category_rules.approval_threshold
    }

    fn get_quorum_requirement(&self, context: &VotingContext) -> f64 {
        self.proposal_categories
            .get(&context.proposal_type)
            .map(|rules| rules.quorum_requirement)
            .unwrap_or(self.quorum_requirement)
    }
}

// Helper to create common voting rule configurations
pub fn create_voting_rules(cooperative_id: String) -> CustomVotingRules {
    let mut proposal_categories = HashMap::new();
    
    // Standard proposals - simple majority
    proposal_categories.insert("standard".to_string(), ProposalRules {
        category: "standard".to_string(),
        quorum_requirement: 0.5,
        approval_threshold: 0.5,
        reputation_multiplier: None,
    });
    
    // Resource allocation - higher requirements
    proposal_categories.insert("resource".to_string(), ProposalRules {
        category: "resource".to_string(),
        quorum_requirement: 0.6,
        approval_threshold: 0.6,
        reputation_multiplier: None,
    });
    
    // Critical changes - supermajority required
    proposal_categories.insert("critical".to_string(), ProposalRules {
        category: "critical".to_string(),
        quorum_requirement: 0.75,
        approval_threshold: 0.75,
        reputation_multiplier: None,
    });

    CustomVotingRules {
        cooperative_id,
        use_reputation_weighting: false,
        min_reputation_to_vote: None,
        max_vote_weight: None,
        quorum_requirement: 0.5,
        special_majority_requirement: None,
        proposal_categories,
    }
}

===================
File: ./backend/src/monitoring/energy.rs
===================
// src/monitoring/energy.rs

use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Instant;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnergyMetrics {
    // CPU usage metrics
    pub cpu_cycles: u64,
    pub instructions_executed: u64,
    
    // Memory metrics
    pub memory_reads: u64,
    pub memory_writes: u64,
    pub peak_memory_usage: usize,
    
    // Network metrics
    pub network_packets_sent: u64,
    pub network_bytes_transferred: u64,
    
    // Storage metrics
    pub storage_reads: u64,
    pub storage_writes: u64,
    pub storage_bytes_written: u64,
    
    // Consensus-specific metrics
    pub consensus_rounds: u64,
    pub validator_operations: u64,
    
    // Timing metrics
    pub operation_duration_ms: u64,
    
    // Estimated energy consumption (in joules)
    pub estimated_energy_consumption: f64,
    
    // Carbon footprint estimation (in grams CO2)
    pub estimated_carbon_footprint: f64,
    
    // Node-specific metrics
    pub node_location: Option<String>,  // For regional power grid calculations
    pub power_source: Option<String>,   // e.g., "grid", "renewable", "mixed"
}

pub struct EnergyMonitor {
    start_time: Instant,
    cpu_cycles: AtomicU64,
    instructions: AtomicU64,
    memory_ops: AtomicU64,
    network_ops: AtomicU64,
    consensus_ops: AtomicU64,
    storage_ops: AtomicU64,
    node_config: NodeEnergyConfig,
}

#[derive(Clone)]
pub struct NodeEnergyConfig {
    pub location: Option<String>,
    pub power_source: Option<String>,
    pub carbon_factor: f64,  // grams CO2 per kWh for this node's power source
    // Hardware-specific energy coefficients
    pub cpu_energy_factor: f64,
    pub memory_energy_factor: f64,
    pub network_energy_factor: f64,
    pub storage_energy_factor: f64,
}

impl Default for NodeEnergyConfig {
    fn default() -> Self {
        NodeEnergyConfig {
            location: None,
            power_source: None,
            carbon_factor: 500.0, // Default assumption: 500g CO2/kWh (mixed grid)
            cpu_energy_factor: 0.0000001,    // joules per CPU cycle
            memory_energy_factor: 0.0000002,  // joules per memory operation
            network_energy_factor: 0.0000005, // joules per network operation
            storage_energy_factor: 0.0000003, // joules per storage operation
        }
    }
}

impl EnergyMonitor {
    pub fn new(config: NodeEnergyConfig) -> Self {
        EnergyMonitor {
            start_time: Instant::now(),
            cpu_cycles: AtomicU64::new(0),
            instructions: AtomicU64::new(0),
            memory_ops: AtomicU64::new(0),
            network_ops: AtomicU64::new(0),
            consensus_ops: AtomicU64::new(0),
            storage_ops: AtomicU64::new(0),
            node_config: config,
        }
    }
    
    pub fn record_cpu_cycles(&self, cycles: u64) {
        self.cpu_cycles.fetch_add(cycles, Ordering::Relaxed);
    }
    
    pub fn record_instruction(&self) {
        self.instructions.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_memory_operation(&self, bytes: u64) {
        self.memory_ops.fetch_add(bytes, Ordering::Relaxed);
    }
    
    pub fn record_network_operation(&self, bytes: u64) {
        self.network_ops.fetch_add(bytes, Ordering::Relaxed);
    }
    
    pub fn record_consensus_operation(&self) {
        self.consensus_ops.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_storage_operation(&self, bytes: u64) {
        self.storage_ops.fetch_add(bytes, Ordering::Relaxed);
    }
    
    /// Calculate estimated energy consumption based on recorded metrics
    pub fn estimate_energy_consumption(&self) -> f64 {
        let cpu_energy = self.cpu_cycles.load(Ordering::Relaxed) as f64 
            * self.node_config.cpu_energy_factor;
            
        let memory_energy = self.memory_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.memory_energy_factor;
            
        let network_energy = self.network_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.network_energy_factor;
            
        let storage_energy = self.storage_ops.load(Ordering::Relaxed) as f64 
            * self.node_config.storage_energy_factor;
            
        cpu_energy + memory_energy + network_energy + storage_energy
    }
    
    /// Calculate carbon footprint based on energy consumption
    pub fn estimate_carbon_footprint(&self) -> f64 {
        let energy_kwh = self.estimate_energy_consumption() / 3_600_000.0; // Convert joules to kWh
        energy_kwh * self.node_config.carbon_factor
    }
    
    pub fn get_metrics(&self) -> EnergyMetrics {
        let total_memory_ops = self.memory_ops.load(Ordering::Relaxed);
        let total_network_ops = self.network_ops.load(Ordering::Relaxed);
        let total_storage_ops = self.storage_ops.load(Ordering::Relaxed);
        
        EnergyMetrics {
            cpu_cycles: self.cpu_cycles.load(Ordering::Relaxed),
            instructions_executed: self.instructions.load(Ordering::Relaxed),
            memory_reads: total_memory_ops / 2,  // Assuming 50/50 split
            memory_writes: total_memory_ops / 2,
            peak_memory_usage: 0, // Would need to implement memory tracking
            network_packets_sent: total_network_ops,
            network_bytes_transferred: total_network_ops,
            storage_reads: total_storage_ops / 2,
            storage_writes: total_storage_ops / 2,
            storage_bytes_written: total_storage_ops,
            consensus_rounds: self.consensus_ops.load(Ordering::Relaxed),
            validator_operations: 0, // Would need to implement validator tracking
            operation_duration_ms: self.start_time.elapsed().as_millis() as u64,
            estimated_energy_consumption: self.estimate_energy_consumption(),
            estimated_carbon_footprint: self.estimate_carbon_footprint(),
            node_location: self.node_config.location.clone(),
            power_source: self.node_config.power_source.clone(),
        }
    }
}

/// Trait for components that want to track their energy usage
pub trait EnergyAware {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor);
}

/// Implementation for the VM to track its energy usage
impl EnergyAware for crate::vm::VM {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor) {
        // Record CPU operations
        monitor.record_cpu_cycles(self.get_cycle_count());
        
        // Record instructions
        monitor.record_instruction();
        
        // Record memory operations
        if let Some(memory_usage) = self.get_memory_usage() {
            monitor.record_memory_operation(memory_usage);
        }
        
        // Record storage operations
        if let Some(storage_usage) = self.get_storage_usage() {
            monitor.record_storage_operation(storage_usage);
        }
    }
}

/// Implementation for the consensus system
impl EnergyAware for crate::consensus::ProofOfCooperation {
    fn record_energy_metrics(&self, monitor: &EnergyMonitor) {
        // Record consensus operations
        monitor.record_consensus_operation();
        
        // Record network operations for consensus messages
        if let Some(network_bytes) = self.get_network_usage() {
            monitor.record_network_operation(network_bytes);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_energy_monitoring() {
        let config = NodeEnergyConfig::default();
        let monitor = EnergyMonitor::new(config);
        
        // Simulate some operations
        monitor.record_cpu_cycles(1000);
        monitor.record_instruction();
        monitor.record_memory_operation(1024); // 1KB memory operation
        monitor.record_network_operation(512); // 512B network operation
        monitor.record_storage_operation(2048); // 2KB storage operation
        monitor.record_consensus_operation();
        
        let metrics = monitor.get_metrics();
        
        assert_eq!(metrics.cpu_cycles, 1000);
        assert_eq!(metrics.instructions_executed, 1);
        assert!(metrics.estimated_energy_consumption > 0.0);
        assert!(metrics.estimated_carbon_footprint > 0.0);
    }
    
    #[test]
    fn test_carbon_footprint_calculation() {
        let mut config = NodeEnergyConfig::default();
        config.carbon_factor = 100.0; // 100g CO2/kWh (renewable heavy grid)
        let monitor = EnergyMonitor::new(config);
        
        monitor.record_cpu_cycles(1000000); // Significant CPU usage
        
        let metrics = monitor.get_metrics();
        assert!(metrics.estimated_carbon_footprint > 0.0);
        assert!(metrics.estimated_carbon_footprint < 
                metrics.estimated_carbon_footprint * 5.0); // Should be significantly less than default grid
    }
}

===================
File: ./backend/src/network/mod.rs
===================
// src/network/mod.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::mpsc;
use tokio::net::{TcpListener, TcpStream};
use serde::{Serialize, Deserialize};
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::Message;

use crate::blockchain::Block;
use crate::consensus::ConsensusRound;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum NetworkMessage {
    // Peer discovery and management
    PeerAnnouncement {
        node_id: String,
        address: String,
    },
    PeerList {
        peers: Vec<(String, String)>,
    },
    
    // Consensus messages
    ConsensusProposal {
        round: ConsensusRound,
        block: Block,
    },
    ConsensusVote {
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    },
    
    // Block and transaction propagation
    NewBlock(Block),
    TransactionAnnouncement {
        tx_hash: String,
        from: String,
    },
    
    // Federation protocol messages
    FederationJoinRequest {
        cooperative_id: String,
        federation_id: String,
    },
    FederationResponse {
        approved: bool,
        federation_id: String,
        metadata: HashMap<String, String>,
    },
    
    // Cooperative synchronization
    ResourceStateSync {
        cooperative_id: String,
        resource_updates: HashMap<String, i64>,
    },
    
    // Status and health checks
    Ping(u64),
    Pong(u64),
}

pub struct NetworkHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    message_tx: mpsc::Sender<NetworkMessage>,
    message_rx: mpsc::Receiver<NetworkMessage>,
    listener_address: String,
}

struct PeerConnection {
    address: String,
    tx: mpsc::Sender<Message>,
    last_seen: std::time::Instant,
    reputation: i64,
}

impl NetworkHandler {
    pub fn new(node_id: String, listener_address: String) -> Self {
        let (tx, rx) = mpsc::channel(100);
        
        NetworkHandler {
            node_id,
            peers: Arc::new(Mutex::new(HashMap::new())),
            message_tx: tx,
            message_rx: rx,
            listener_address,
        }
    }

    pub async fn start(&mut self) -> Result<(), String> {
        let listener = TcpListener::bind(&self.listener_address)
            .await
            .map_err(|e| format!("Failed to bind listener: {}", e))?;
            
        println!("Network handler listening on: {}", self.listener_address);

        let peers = self.peers.clone();
        let node_id = self.node_id.clone();
        
        tokio::spawn(async move {
            while let Ok((stream, addr)) = listener.accept().await {
                println!("New connection from: {}", addr);
                
                let peer_handler = PeerHandler::new(
                    node_id.clone(),
                    peers.clone(),
                );
                
                tokio::spawn(async move {
                    if let Err(e) = peer_handler.handle_connection(stream).await {
                        eprintln!("Error handling connection: {}", e);
                    }
                });
            }
        });

        self.process_messages().await?;

        Ok(())
    }

    async fn process_messages(&mut self) -> Result<(), String> {
        while let Some(message) = self.message_rx.recv().await {
            match message {
                NetworkMessage::PeerAnnouncement { node_id, address } => {
                    self.handle_peer_announcement(node_id, address).await?;
                }
                NetworkMessage::NewBlock(block) => {
                    self.broadcast_block(block).await?;
                }
                NetworkMessage::ConsensusProposal { round, block } => {
                    self.broadcast_consensus_proposal(round, block).await?;
                }
                NetworkMessage::ConsensusVote { round_number, voter, approved, signature } => {
                    self.broadcast_consensus_vote(round_number, voter, approved, signature).await?;
                }
                _ => {}
            }
        }
        Ok(())
    }

    async fn handle_peer_announcement(&mut self, peer_id: String, address: String) -> Result<(), String> {
        let mut peers = self.peers.lock().unwrap();
        
        if !peers.contains_key(&peer_id) {
            match self.connect_to_peer(&address).await {
                Ok(connection) => {
                    peers.insert(peer_id.clone(), connection);
                    println!("Connected to peer: {}", peer_id);
                }
                Err(e) => {
                    eprintln!("Failed to connect to peer {}: {}", peer_id, e);
                }
            }
        }
        
        Ok(())
    }

    async fn connect_to_peer(&self, address: &str) -> Result<PeerConnection, String> {
        let url = format!("ws://{}", address);
        let (ws_stream, _) = connect_async(&url)
            .await
            .map_err(|e| format!("Failed to connect to peer: {}", e))?;
            
        let (sink, stream) = ws_stream.split();
        let (tx, mut rx) = mpsc::channel(32);

        tokio::spawn(async move {
            let mut sink = sink;
            while let Some(message) = rx.recv().await {
                if let Err(e) = sink.send(message).await {
                    eprintln!("Failed to send message: {}", e);
                    break;
                }
            }
        });

        tokio::spawn(async move {
            let mut stream = stream;
            while let Some(result) = stream.next().await {
                match result {
                    Ok(msg) => {
                        if let Ok(text) = msg.to_text() {
                            println!("Received message from peer: {}", text);
                        }
                    }
                    Err(e) => {
                        eprintln!("Error reading message: {}", e);
                        break;
                    }
                }
            }
        });

        Ok(PeerConnection {
            address: address.to_string(),
            tx,
            last_seen: std::time::Instant::now(),
            reputation: 0,
        })
    }

    async fn broadcast_block(&self, block: Block) -> Result<(), String> {
        let message = NetworkMessage::NewBlock(block);
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_proposal(&self, round: ConsensusRound, block: Block) -> Result<(), String> {
        let message = NetworkMessage::ConsensusProposal { round, block };
        self.broadcast_message(&message).await
    }

    async fn broadcast_consensus_vote(
        &self,
        round_number: u64,
        voter: String,
        approved: bool,
        signature: String,
    ) -> Result<(), String> {
        let message = NetworkMessage::ConsensusVote {
            round_number,
            voter,
            approved,
            signature,
        };
        self.broadcast_message(&message).await
    }

    async fn broadcast_message(&self, message: &NetworkMessage) -> Result<(), String> {
        let message_json = serde_json::to_string(message)
            .map_err(|e| format!("Failed to serialize message: {}", e))?;
            
        let peers = self.peers.lock().unwrap();
        
        for (peer_id, connection) in peers.iter() {
            if let Err(e) = connection.tx.send(Message::Text(message_json.clone())).await {
                eprintln!("Failed to send message to peer {}: {}", peer_id, e);
            }
        }
        
        Ok(())
    }
}

struct PeerHandler {
    node_id: String,
    peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
}

impl PeerHandler {
    fn new(
        node_id: String,
        peers: Arc<Mutex<HashMap<String, PeerConnection>>>,
    ) -> Self {
        PeerHandler {
            node_id,
            peers,
        }
    }

    async fn handle_connection(&self, stream: TcpStream) -> Result<(), String> {
        let ws_stream = tokio_tungstenite::accept_async(stream)
            .await
            .map_err(|e| format!("Failed to accept WebSocket connection: {}", e))?;
            
        let (_sink, mut stream) = ws_stream.split();
        
        while let Some(message) = stream.next().await {
            match message {
                Ok(msg) => {
                    if let Ok(text) = msg.to_text() {
                        if let Ok(network_msg) = serde_json::from_str::<NetworkMessage>(text) {
                            self.handle_network_message(network_msg).await?;
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Error reading from WebSocket: {}", e);
                    break;
                }
            }
        }
        
        Ok(())
    }

    async fn handle_network_message(&self, message: NetworkMessage) -> Result<(), String> {
        match message {
            NetworkMessage::PeerAnnouncement { node_id, address } => {
                println!("Received peer announcement from {} at {}", node_id, address);
            }
            NetworkMessage::NewBlock(block) => {
                println!("Received new block: {}", block.index);
            }
            NetworkMessage::ConsensusProposal { round, block: _ } => {
                println!("Received consensus proposal for round {}", round.round_number);
            }
            NetworkMessage::ConsensusVote { round_number, voter, approved: _, signature: _ } => {
                println!("Received consensus vote from {} for round {}", voter, round_number);
            }
            _ => {
                println!("Received other network message type");
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_network_handler() {
        let handler = NetworkHandler::new(
            "test_node".to_string(),
            "127.0.0.1:0".to_string(),
        );
        assert_eq!(handler.node_id, "test_node");
    }
}

===================
File: ./backend/src/api/cooperative.rs
===================


===================
File: ./backend/src/api/mod.rs
===================


===================
File: ./backend/src/blockchain/chain.rs
===================
// src/blockchain/chain.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use crate::consensus::ProofOfCooperation;
use crate::consensus::types::ConsensusRound;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::vm::{VM, Contract, ExecutionContext};
use crate::vm::event::Event;
use crate::blockchain::{Block, Transaction, TransactionType};

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub contracts: HashMap<String, Contract>,
    pub consensus: Arc<Mutex<ProofOfCooperation>>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub current_block_number: u64,
    coordinator_did: String,
}

impl Blockchain {
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>, 
        reputation_system: Arc<Mutex<ReputationSystem>>,
        consensus: Arc<Mutex<ProofOfCooperation>>,
    ) -> Self {
        let coordinator_did = "did:icn:genesis".to_string();
        
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: vec![],
            contracts: HashMap::new(),
            consensus,
            identity_system,
            reputation_system,
            current_block_number: 1,
            coordinator_did,
        }
    }

    pub fn create_contract(&mut self, contract: Contract) {
        self.contracts.insert(contract.id.clone(), contract);
    }

    pub async fn process_transaction(&mut self, transaction: &Transaction) -> Result<(), String> {
        match &transaction.transaction_type {
            TransactionType::Transfer { amount, receiver } => {
                self.validate_transaction(transaction)?;
                println!(
                    "Processing transfer of {} from {} to {}",
                    amount, transaction.sender, receiver
                );
                self.pending_transactions.push(transaction.clone());
                Ok(())
            }
            TransactionType::ContractExecution { contract_id, input_data: _ } => {
                let contract = self.get_contract(contract_id)?;

                let reputation_context = {
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                    reputation_system.get_reputation_context()
                };

                let (permissions, reputation_score) = {
                    let identity_system = self.identity_system.lock()
                        .map_err(|_| "Failed to acquire identity lock".to_string())?;
                    let perms = identity_system.get_permissions(&transaction.sender);
                    
                    let reputation_system = self.reputation_system.lock()
                        .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                    let score = reputation_system.get_reputation(&transaction.sender);
                    
                    (perms, score)
                };

                let mut vm = VM::new(1000, reputation_context);
                let execution_context = ExecutionContext {
                    caller_did: transaction.sender.clone(),
                    cooperative_id: contract.cooperative_metadata.cooperative_id.clone(),
                    timestamp: transaction.timestamp as u64,
                    block_number: self.current_block_number,
                    reputation_score,
                    permissions,
                };

                vm.set_execution_context(execution_context);

                match vm.execute_contract(contract) {
                    Ok(_) => {
                        self.handle_vm_events(&vm.get_events());

                        let mut reputation_system = self.reputation_system.lock()
                            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
                        reputation_system.update_reputations(&vm.get_reputation_context());
                        
                        self.pending_transactions.push(transaction.clone());
                        Ok(())
                    }
                    Err(e) => Err(format!("Contract execution failed: {}", e)),
                }
            }
        }
    }

    fn validate_transaction(&self, transaction: &Transaction) -> Result<(), String> {
        let identity_valid = {
            let identity_system = self.identity_system.lock()
                .map_err(|_| "Failed to acquire identity system lock".to_string())?;
            identity_system.is_registered(&transaction.sender)
        };

        if !identity_valid {
            return Err("Invalid sender DID".to_string());
        }

        let reputation_valid = {
            let reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation system lock".to_string())?;
            reputation_system.get_reputation(&transaction.sender) >= 10
        };

        if !reputation_valid {
            return Err("Insufficient reputation".to_string());
        }

        Ok(())
    }

    fn get_contract(&self, contract_id: &str) -> Result<&Contract, String> {
        self.contracts.get(contract_id)
            .ok_or_else(|| format!("Contract {} not found", contract_id))
    }

    fn handle_vm_events(&self, events: &[Event]) {
        for event in events {
            match event.event_type.as_str() {
                "CooperativeCreated" => {
                    println!("Cooperative created: {:?}", event.data);
                }
                "ProposalCreated" => {
                    println!("Proposal created: {:?}", event.data);
                }
                _ => {
                    println!("Unknown event type: {}", event.event_type);
                }
            }
        }
    }

    pub async fn add_transaction(&mut self, transaction: Transaction) -> Result<(), String> {
        self.validate_transaction(&transaction)?;
        self.pending_transactions.push(transaction.clone());
        
        if self.pending_transactions.len() >= 10 {
            self.finalize_block().await?;
        }
        
        Ok(())
    }

    pub async fn finalize_block(&mut self) -> Result<(), String> {
        // Get the current block's hash
        let previous_hash = self.chain.last()
            .map(|block| block.hash.clone())
            .unwrap_or_default();

        // Create new block with current coordinator
        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
            self.coordinator_did.clone(),
        );

        let consensus_guard = self.consensus.lock()
            .map_err(|_| "Failed to acquire consensus lock".to_string())?;
        let mut consensus = consensus_guard;
        
        consensus.start_round().await?;
        
        let validators = self.get_active_validators();
        if validators.is_empty() {
            return Err("No active validators available".to_string());
        }

        // Select new coordinator from validators
        self.coordinator_did = validators[0].clone();

        consensus.propose_block(&self.coordinator_did, new_block.clone()).await?;

        for validator in &validators {
            let signature = String::from("dummy_signature"); // TODO: Implement real signatures
            consensus.submit_vote(validator, true, signature).await?;
        }

        let block = consensus.finalize_round().await?;
        let updates = consensus.get_reputation_updates().to_vec();
        
        drop(consensus);

        self.chain.push(block);
        self.pending_transactions.clear();
        
        let mut reputation_system = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        for (did, change) in updates {
            reputation_system.increase_reputation(&did, change);
        }

        self.current_block_number += 1;
        Ok(())
    }

    fn get_active_validators(&self) -> Vec<String> {
        vec![
            "did:icn:validator1".to_string(),
            "did:icn:validator2".to_string(),
            "did:icn:validator3".to_string(),
        ]
    }

    pub fn get_block(&self, index: u64) -> Option<&Block> {
        self.chain.get(index as usize)
    }

    pub fn get_latest_block(&self) -> &Block {
        self.chain.last().unwrap()
    }

    pub fn get_transaction_count(&self) -> usize {
        self.chain.iter().map(|block| block.transactions.len()).sum()
    }

    pub fn get_block_count(&self) -> usize {
        self.chain.len()
    }

    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.consensus.try_lock()
            .ok()
            .and_then(|consensus| consensus.get_current_round().map(|round| round.clone()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_blockchain_new() {
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());
        
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler,
        )));

        let blockchain = Blockchain::new(
            identity_system,
            reputation_system,
            consensus,
        );

        assert_eq!(blockchain.current_block_number, 1);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.pending_transactions.len(), 0);
        assert_eq!(blockchain.coordinator_did, "did:icn:genesis");
    }
}

===================
File: ./backend/src/blockchain/mod.rs
===================
// src/blockchain/mod.rs

mod block;
mod transaction;
mod chain;

// Re-export the core types
pub use block::Block;
pub use transaction::{Transaction, TransactionType};
pub use chain::Blockchain;

// Module-level constants
pub const MAX_BLOCK_SIZE: usize = 1000; // Maximum transactions per block
pub const MIN_REPUTATION_FOR_TXN: i64 = 10; // Minimum reputation to submit transactions

===================
File: ./backend/src/blockchain/block.rs
===================
// src/blockchain/block.rs

use std::time::SystemTime;
use sha2::{Sha256, Digest};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

use super::Transaction;

/// Represents a block in the blockchain
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    /// Sequential index of this block in the chain
    pub index: u64,
    
    /// Hash of the previous block
    pub previous_hash: String,
    
    /// Unix timestamp in milliseconds when block was created
    pub timestamp: u64,
    
    /// List of transactions included in this block
    pub transactions: Vec<Transaction>,
    
    /// Hash of this block's contents
    pub hash: String,
    
    /// The DID of the validator that proposed this block
    pub proposer: String,
    
    /// Collection of validator signatures approving this block
    pub signatures: Vec<BlockSignature>,
    
    /// Metadata about the block creation
    pub metadata: BlockMetadata,
}

/// Signature from a validator approving a block
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockSignature {
    /// DID of the signing validator
    pub validator_did: String,
    
    /// The signature itself
    pub signature: String,
    
    /// Timestamp when signature was created
    pub timestamp: DateTime<Utc>,
    
    /// Voting power of the validator at time of signing
    pub voting_power: f64,
}

/// Additional metadata about block creation and validation
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BlockMetadata {
    /// Time taken to reach consensus (milliseconds)
    pub consensus_duration_ms: u64,
    
    /// Number of validators that participated
    pub validator_count: u32,
    
    /// Total voting power that approved the block
    pub total_voting_power: f64,
    
    /// Gas used by transactions in the block
    pub gas_used: u64,
    
    /// Size of the block in bytes
    pub size: u64,
}

impl Block {
    /// Creates a new block with the given parameters
    pub fn new(index: u64, previous_hash: String, transactions: Vec<Transaction>, proposer: String) -> Self {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        let metadata = BlockMetadata {
            consensus_duration_ms: 0,
            validator_count: 0,
            total_voting_power: 0.0,
            gas_used: transactions.iter().map(|tx| tx.gas_used()).sum(),
            size: 0,
        };

        let mut block = Block {
            index,
            previous_hash,
            timestamp,
            transactions,
            hash: String::new(),
            proposer,
            signatures: Vec::new(),
            metadata,
        };

        block.hash = block.calculate_hash();
        block
    }

    /// Creates a genesis block
    pub fn genesis() -> Self {
        Block::new(
            0,
            String::from("0"),
            vec![],
            String::from("genesis")
        )
    }

    /// Calculates the hash of the block's contents
    pub fn calculate_hash(&self) -> String {
        let mut hasher = Sha256::new();
        
        // Add block header fields
        hasher.update(self.index.to_string());
        hasher.update(&self.previous_hash);
        hasher.update(self.timestamp.to_string());
        
        // Add transaction hashes
        for tx in &self.transactions {
            hasher.update(&tx.hash);
        }
        
        // Add proposer
        hasher.update(&self.proposer);
        
        // Convert hash to hex string
        format!("{:x}", hasher.finalize())
    }

    /// Adds a validator's signature to the block
    pub fn add_signature(&mut self, validator_did: String, signature: String, voting_power: f64) -> bool {
        // Check if validator has already signed
        if self.signatures.iter().any(|s| s.validator_did == validator_did) {
            return false;
        }

        self.signatures.push(BlockSignature {
            validator_did,
            signature,
            timestamp: Utc::now(),
            voting_power,
        });

        // Update metadata
        self.metadata.validator_count = self.signatures.len() as u32;
        self.metadata.total_voting_power = self.signatures.iter()
            .map(|s| s.voting_power)
            .sum();

        true
    }

    /// Verifies the block's integrity
    pub fn verify(&self, previous_block: Option<&Block>) -> Result<(), String> {
        // Verify hash
        if self.hash != self.calculate_hash() {
            return Err("Invalid block hash".to_string());
        }

        // Verify previous hash and index if we have a parent block
        if let Some(prev) = previous_block {
            if self.previous_hash != prev.hash {
                return Err("Previous hash mismatch".to_string());
            }

            if self.index != prev.index + 1 {
                return Err("Invalid block index".to_string());
            }

            if self.timestamp <= prev.timestamp {
                return Err("Invalid timestamp".to_string());
            }
        }

        // Verify timestamp is not in the future
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        if self.timestamp > current_time + 5000 { // Allow 5 second drift
            return Err("Block timestamp is in the future".to_string());
        }

        // Verify all transactions
        for tx in &self.transactions {
            if !tx.validate() {
                return Err(format!("Invalid transaction: {}", tx.get_hash()));
            }
        }

        Ok(())
    }

    /// Updates the block's metadata after consensus is reached
    pub fn update_metadata(&mut self, consensus_duration_ms: u64, size: u64) {
        self.metadata.consensus_duration_ms = consensus_duration_ms;
        self.metadata.size = size;
        self.metadata.gas_used = self.transactions.iter()
            .map(|tx| tx.gas_used())
            .sum();
    }

    /// Gets the total gas used by all transactions in the block
    pub fn total_gas_used(&self) -> u64 {
        self.metadata.gas_used
    }

    /// Gets the number of transactions in the block
    pub fn transaction_count(&self) -> usize {
        self.transactions.len()
    }

    /// Gets the block size in bytes
    pub fn size(&self) -> u64 {
        self.metadata.size
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_block() -> Block {
        Block::new(
            1,
            "previous_hash".to_string(),
            vec![],
            "did:icn:proposer".to_string()
        )
    }

    #[test]
    fn test_block_creation() {
        let block = create_test_block();
        assert_eq!(block.index, 1);
        assert_eq!(block.previous_hash, "previous_hash");
        assert!(!block.hash.is_empty());
        assert_eq!(block.proposer, "did:icn:proposer");
    }

    #[test]
    fn test_block_hash_calculation() {
        let block = create_test_block();
        let hash = block.hash.clone();
        assert_eq!(block.calculate_hash(), hash);
    }

    #[test]
    fn test_signature_addition() {
        let mut block = create_test_block();
        assert!(block.add_signature(
            "did:icn:validator1".to_string(),
            "signature1".to_string(),
            0.5
        ));

        // Try adding same validator again
        assert!(!block.add_signature(
            "did:icn:validator1".to_string(),
            "signature2".to_string(),
            0.5
        ));

        assert_eq!(block.signatures.len(), 1);
        assert_eq!(block.metadata.validator_count, 1);
        assert_eq!(block.metadata.total_voting_power, 0.5);
    }

    #[test]
    fn test_block_verification() {
        let prev_block = Block::genesis();
        let block = Block::new(
            1,
            prev_block.hash.clone(),
            vec![],
            "did:icn:proposer".to_string()
        );

        assert!(block.verify(Some(&prev_block)).is_ok());
    }

    #[test]
    fn test_invalid_previous_hash() {
        let prev_block = create_test_block();
        let block = Block::new(
            2,
            "wrong_hash".to_string(),
            vec![],
            "did:icn:proposer".to_string()
        );

        assert!(block.verify(Some(&prev_block)).is_err());
    }

    #[test] 
    fn test_genesis_block() {
        let genesis = Block::genesis();
        assert_eq!(genesis.index, 0);
        assert_eq!(genesis.previous_hash, "0");
        assert!(genesis.transactions.is_empty());
        assert_eq!(genesis.proposer, "genesis");
    }
}

===================
File: ./backend/src/blockchain/transaction.rs
===================
// src/blockchain/transaction.rs

use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use chrono::Utc;
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TransactionType {
    Transfer {
        receiver: String,
        amount: u64,
    },
    ContractExecution {
        contract_id: String,
        input_data: HashMap<String, i64>,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Transaction {
    pub sender: String,
    pub transaction_type: TransactionType,
    pub timestamp: u128,
    pub hash: String,
    pub gas_limit: u64,
    pub gas_price: u64,
}

impl Transaction {
    pub fn new(sender: String, transaction_type: TransactionType) -> Self {
        let timestamp = Utc::now().timestamp_millis() as u128;
        let hash = Self::calculate_transaction_hash(&sender, &transaction_type, timestamp);

        Transaction {
            sender,
            transaction_type,
            timestamp,
            hash,
            gas_limit: 21000, // Base gas limit for standard transactions
            gas_price: 1,     // Base gas price unit
        }
    }

    fn calculate_transaction_hash(sender: &str, transaction_type: &TransactionType, timestamp: u128) -> String {
        let mut hasher = Sha256::new();
        let transaction_data = match transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                format!("Transfer:{}:{}:{}", sender, receiver, amount)
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                format!("ContractExecution:{}:{:?}", contract_id, input_data)
            }
        };
        hasher.update(format!("{}{}{}", sender, transaction_data, timestamp));
        format!("{:x}", hasher.finalize())
    }

    pub fn gas_used(&self) -> u64 {
        match &self.transaction_type {
            TransactionType::Transfer { .. } => {
                // Base cost for transfer
                self.gas_limit.min(21000)
            }
            TransactionType::ContractExecution { input_data, .. } => {
                // Base cost plus data size cost
                let base_cost = 21000;
                let data_cost = input_data.len() as u64 * 68; // 68 gas per data item
                self.gas_limit.min(base_cost + data_cost)
            }
        }
    }

    pub fn validate(&self) -> bool {
        // Ensure sender is not empty
        if self.sender.is_empty() {
            return false;
        }

        // Validate based on transaction type
        match &self.transaction_type {
            TransactionType::Transfer { receiver, amount } => {
                !receiver.is_empty() && *amount > 0
            }
            TransactionType::ContractExecution { contract_id, input_data } => {
                !contract_id.is_empty() && !input_data.is_empty()
            }
        }
    }

    pub fn get_total_gas_cost(&self) -> u64 {
        self.gas_used() * self.gas_price
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend(self.sender.as_bytes());
        bytes.extend(self.hash.as_bytes());
        bytes.extend(&self.timestamp.to_be_bytes());
        bytes
    }

    pub fn get_timestamp_ms(&self) -> u128 {
        self.timestamp
    }

    pub fn get_sender(&self) -> &str {
        &self.sender
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transfer_transaction_creation() {
        let sender = "did:icn:sender".to_string();
        let transaction = Transaction::new(
            sender.clone(),
            TransactionType::Transfer {
                receiver: "did:icn:receiver".to_string(),
                amount: 100,
            },
        );

        assert_eq!(transaction.sender, sender);
        assert!(!transaction.hash.is_empty());
        assert!(transaction.validate());
    }

    #[test]
    fn test_contract_execution_transaction() {
        let mut input_data = HashMap::new();
        input_data.insert("param1".to_string(), 42);
        
        let transaction = Transaction::new(
            "did:icn:sender".to_string(),
            TransactionType::ContractExecution {
                contract_id: "contract123".to_string(),
                input_data,
            },
        );

        assert!(transaction.validate());
        assert!(transaction.gas_used() > 21000); // Should be more than base cost
    }

    #[test]
    fn test_invalid_transaction() {
        let transaction = Transaction::new(
            "".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:receiver".to_string(),
                amount: 0,
            },
        );

        assert!(!transaction.validate());
    }

    #[test]
    fn test_gas_calculation() {
        let mut input_data = HashMap::new();
        input_data.insert("param1".to_string(), 42);
        input_data.insert("param2".to_string(), 43);
        
        let transaction = Transaction::new(
            "did:icn:sender".to_string(),
            TransactionType::ContractExecution {
                contract_id: "contract123".to_string(),
                input_data,
            },
        );

        assert!(transaction.gas_used() > 0);
        assert_eq!(transaction.get_total_gas_cost(), transaction.gas_used() * transaction.gas_price);
    }
}

===================
File: ./backend/src/reputation/reputation_system.rs
===================
// src/reputation/reputation_system.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::identity::DID;

/// Represents a change in reputation with context
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReputationChange {
    /// Amount of reputation changed (positive or negative)
    pub amount: i64,
    
    /// Reason for the reputation change
    pub reason: String,
    
    /// When the change occurred
    pub timestamp: DateTime<Utc>,
    
    /// Context or category of the change
    pub context: ReputationContext,
    
    /// DID of the entity that triggered the change
    pub trigger_did: Option<String>,
}

/// Different contexts where reputation can be earned or lost
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum ReputationContext {
    /// Consensus participation and validation
    Consensus,
    
    /// Governance participation (proposals, voting)
    Governance,
    
    /// Resource sharing and allocation
    Resources,
    
    /// Cooperative membership and participation
    Membership,
    
    /// General cooperative contributions
    Contribution,
}

/// Configuration for the reputation system
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReputationConfig {
    /// Minimum possible reputation score
    pub min_reputation: i64,
    
    /// Maximum possible reputation score
    pub max_reputation: i64,
    
    /// Base amount earned for positive actions
    pub base_reward: i64,
    
    /// Base amount lost for negative actions
    pub base_penalty: i64,
    
    /// How quickly reputation decays (percentage per day)
    pub decay_rate: f64,
    
    /// Minimum time between reputation updates
    pub update_cooldown_ms: u64,
}

impl Default for ReputationConfig {
    fn default() -> Self {
        ReputationConfig {
            min_reputation: 0,
            max_reputation: 10000,
            base_reward: 10,
            base_penalty: 10,
            decay_rate: 0.01, // 1% per day
            update_cooldown_ms: 60000, // 1 minute
        }
    }
}

/// Main reputation system implementation
pub struct ReputationSystem {
    /// Current reputation scores for all DIDs
    scores: HashMap<String, i64>,
    
    /// History of reputation changes
    history: HashMap<String, Vec<ReputationChange>>,
    
    /// Last update timestamp for each DID
    last_updated: HashMap<String, DateTime<Utc>>,
    
    /// System configuration
    config: ReputationConfig,
    
    /// Context-specific multipliers
    context_multipliers: HashMap<ReputationContext, f64>,
}

impl ReputationSystem {
    /// Creates a new reputation system with default configuration
    pub fn new() -> Self {
        let mut context_multipliers = HashMap::new();
        context_multipliers.insert(ReputationContext::Consensus, 1.5);
        context_multipliers.insert(ReputationContext::Governance, 1.2);
        context_multipliers.insert(ReputationContext::Resources, 1.0);
        context_multipliers.insert(ReputationContext::Membership, 1.0);
        context_multipliers.insert(ReputationContext::Contribution, 1.1);

        ReputationSystem {
            scores: HashMap::new(),
            history: HashMap::new(),
            last_updated: HashMap::new(),
            config: ReputationConfig::default(),
            context_multipliers,
        }
    }

    /// Gets the current reputation score for a DID
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Gets the reputation history for a DID
    pub fn get_history(&self, did: &str) -> Vec<ReputationChange> {
        self.history.get(did)
            .cloned()
            .unwrap_or_default()
    }

    /// Updates reputation with context and reason
    pub fn update_reputation(
        &mut self,
        did: &str,
        change: i64,
        context: ReputationContext,
        reason: String,
        trigger_did: Option<String>
    ) -> Result<i64, String> {
        // Check update cooldown
        let now = Utc::now();
        if let Some(last_update) = self.last_updated.get(did) {
            let elapsed = now.signed_duration_since(*last_update).num_milliseconds();
            if elapsed < self.config.update_cooldown_ms as i64 {
                return Err("Reputation update too soon".to_string());
            }
        }

        // Apply context multiplier
        let multiplier = self.context_multipliers
            .get(&context)
            .unwrap_or(&1.0);
        let adjusted_change = (change as f64 * multiplier) as i64;

        // Update score
        let current_score = self.get_reputation(did);
        let new_score = (current_score + adjusted_change)
            .max(self.config.min_reputation)
            .min(self.config.max_reputation);

        self.scores.insert(did.to_string(), new_score);
        self.last_updated.insert(did.to_string(), now);

        // Record change in history
        let change_record = ReputationChange {
            amount: adjusted_change,
            reason,
            timestamp: now,
            context,
            trigger_did,
        };

        self.history
            .entry(did.to_string())
            .or_insert_with(Vec::new)
            .push(change_record);

        Ok(new_score)
    }

    /// Increases reputation with context
    pub fn increase_reputation(
        &mut self,
        did: &str,
        amount: i64,
        context: ReputationContext,
        reason: String
    ) -> Result<i64, String> {
        self.update_reputation(did, amount.abs(), context, reason, None)
    }

    /// Decreases reputation with context
    pub fn decrease_reputation(
        &mut self,
        did: &str,
        amount: i64,
        context: ReputationContext,
        reason: String
    ) -> Result<i64, String> {
        self.update_reputation(did, -amount.abs(), context, reason, None)
    }

    /// Gets a copy of the current reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates multiple reputation scores at once
    pub fn update_reputations(&mut self, updates: &HashMap<String, i64>) {
        for (did, score) in updates {
            self.scores.insert(did.clone(), *score);
            self.last_updated.insert(did.clone(), Utc::now());
        }
    }

    /// Applies reputation decay to all scores
    pub fn apply_decay(&mut self) {
        let now = Utc::now();
        
        for (did, score) in self.scores.iter_mut() {
            if let Some(last_update) = self.last_updated.get(did) {
                let days = now.signed_duration_since(*last_update).num_days() as f64;
                if days > 0.0 {
                    let decay_factor = (1.0 - self.config.decay_rate).powi(days as i32);
                    *score = (*score as f64 * decay_factor) as i64;
                    self.last_updated.insert(did.clone(), now);
                }
            }
        }
    }

    /// Checks if a DID meets a reputation threshold
    pub fn meets_threshold(&self, did: &str, threshold: i64) -> bool {
        self.get_reputation(did) >= threshold
    }

    /// Gets top contributors by reputation
    pub fn get_top_contributors(&self, limit: usize) -> Vec<(String, i64)> {
        let mut contributors: Vec<_> = self.scores.iter()
            .map(|(k, v)| (k.clone(), *v))
            .collect();
        
        contributors.sort_by(|a, b| b.1.cmp(&a.1));
        contributors.truncate(limit);
        
        contributors
    }

    /// Calculates the total reputation in the system
    pub fn total_reputation(&self) -> i64 {
        self.scores.values().sum()
    }

    /// Updates the configuration
    pub fn update_config(&mut self, config: ReputationConfig) {
        self.config = config;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_system() -> ReputationSystem {
        ReputationSystem::new()
    }

    #[test]
    fn test_initial_reputation() {
        let system = setup_test_system();
        assert_eq!(system.get_reputation("test_did"), 0);
    }

    #[test]
    fn test_reputation_increase() {
        let mut system = setup_test_system();
        let result = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test increase".to_string()
        );
        
        assert!(result.is_ok());
        assert_eq!(system.get_reputation("test_did"), 150); // With 1.5x multiplier
    }

    #[test]
    fn test_reputation_decrease() {
        let mut system = setup_test_system();
        
        // First increase reputation
        system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test increase".to_string()
        ).unwrap();
        
        // Then decrease it
        let result = system.decrease_reputation(
            "test_did",
            50,
            ReputationContext::Consensus,
            "test decrease".to_string()
        );
        
        assert!(result.is_ok());
        assert_eq!(system.get_reputation("test_did"), 75); // 150 - (50 * 1.5)
    }

    #[test]
    fn test_reputation_limits() {
        let mut system = setup_test_system();
        
        // Test maximum
        system.increase_reputation(
            "test_did",
            system.config.max_reputation * 2,
            ReputationContext::Consensus,
            "test max".to_string()
        ).unwrap();
        
        assert_eq!(system.get_reputation("test_did"), system.config.max_reputation);
        
        // Test minimum
        system.decrease_reputation(
            "test_did",
            system.config.max_reputation * 2,
            ReputationContext::Consensus,
            "test min".to_string()
        ).unwrap();
        
        assert_eq!(system.get_reputation("test_did"), system.config.min_reputation);
    }

    #[test]
    fn test_reputation_decay() {
        let mut system = setup_test_system();
        
        // Set initial reputation
        system.increase_reputation(
            "test_did",
            1000,
            ReputationContext::Consensus,
            "initial".to_string()
        ).unwrap();
        
        // Force last_updated to be one day ago
        let one_day_ago = Utc::now() - chrono::Duration::days(1);
        system.last_updated.insert("test_did".to_string(), one_day_ago);
        
        // Apply decay
        system.apply_decay();
        
        // Check that reputation has decayed by decay_rate
        let expected = (1500.0 * (1.0 - system.config.decay_rate)) as i64;
        assert_eq!(system.get_reputation("test_did"), expected);
    }

    #[test]
    fn test_top_contributors() {
        let mut system = setup_test_system();
        
        // Add some test data
        system.increase_reputation(
            "did1",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        ).unwrap();
        
        system.increase_reputation(
            "did2",
            200,
            ReputationContext::Consensus,
            "test".to_string()
        ).unwrap();
        
        let top = system.get_top_contributors(2);
        assert_eq!(top.len(), 2);
        assert_eq!(top[0].0, "did2");
        assert_eq!(top[1].0, "did1");
    }

    #[test]
    fn test_update_cooldown() {
        let mut system = setup_test_system();
        
        // First update should succeed
        let result1 = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        );
        assert!(result1.is_ok());
        
        // Immediate second update should fail
        let result2 = system.increase_reputation(
            "test_did",
            100,
            ReputationContext::Consensus,
            "test".to_string()
        );
        assert!(result2.is_err());
    }
}

===================
File: ./backend/src/reputation/mod.rs
===================
// src/reputation/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationChange {
    pub did: String,
    pub change: i64,
    pub timestamp: DateTime<Utc>,
    pub reason: String,
    pub context: String,
}

#[derive(Clone)]
pub struct ReputationSystem {
    pub scores: HashMap<String, i64>,
    history: HashMap<String, Vec<ReputationChange>>,
}

impl ReputationSystem {
    /// Initializes a new Reputation System.
    pub fn new() -> Self {
        ReputationSystem {
            scores: HashMap::new(),
            history: HashMap::new(),
        }
    }

    /// Increases the reputation for a specific DID by a given amount.
    pub fn increase_reputation(&mut self, did: &str, amount: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: amount,
            timestamp: Utc::now(),
            reason: "Positive contribution".to_string(),
            context: "general".to_string(),
        };
        
        self.apply_reputation_change(did, change);
    }

    /// Decreases the reputation for a specific DID by a given amount.
    pub fn decrease_reputation(&mut self, did: &str, amount: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: -amount,
            timestamp: Utc::now(),
            reason: "Negative action".to_string(),
            context: "general".to_string(),
        };
        
        self.apply_reputation_change(did, change);
    }

    /// Applies a reputation change with context and history tracking
    fn apply_reputation_change(&mut self, did: &str, change: ReputationChange) {
        let score = self.scores.entry(did.to_string()).or_insert(0);
        *score += change.change;
        
        // Ensure score doesn't go below zero
        if *score < 0 {
            *score = 0;
        }
        
        // Record the change in history
        self.history.entry(did.to_string())
            .or_insert_with(Vec::new)
            .push(change);
    }

    /// Retrieves the reputation score for a given DID. Defaults to 0 if no score exists.
    pub fn get_reputation(&self, did: &str) -> i64 {
        *self.scores.get(did).unwrap_or(&0)
    }

    /// Rewards a user for voting participation by increasing their reputation score.
    pub fn reward_voting(&mut self, did: &str, reward_points: i64) {
        let change = ReputationChange {
            did: did.to_string(),
            change: reward_points,
            timestamp: Utc::now(),
            reason: "Voting participation".to_string(),
            context: "governance".to_string(),
        };
        
        self.apply_reputation_change(did, change);
        
        println!(
            "Reputation for {} increased by {} points for voting participation.",
            did, reward_points
        );
    }

    /// Returns a clone of the reputation context
    pub fn get_reputation_context(&self) -> HashMap<String, i64> {
        self.scores.clone()
    }

    /// Updates the reputation context with changes from the VM execution
    pub fn update_reputations(&mut self, updated_reputations: &HashMap<String, i64>) {
        for (did, reputation) in updated_reputations {
            let change = ReputationChange {
                did: did.clone(),
                change: reputation - self.get_reputation(did),
                timestamp: Utc::now(),
                reason: "VM execution update".to_string(),
                context: "contract".to_string(),
            };
            
            self.apply_reputation_change(did, change);
        }
    }

    /// Gets the reputation history for a given DID
    pub fn get_history(&self, did: &str) -> Vec<ReputationChange> {
        self.history.get(did)
            .cloned()
            .unwrap_or_default()
    }

    /// Gets the total reputation in the system
    pub fn total_reputation(&self) -> i64 {
        self.scores.values().sum()
    }

    /// Gets the top contributors by reputation score
    pub fn get_top_contributors(&self, limit: usize) -> Vec<(String, i64)> {
        let mut contributors: Vec<_> = self.scores.iter()
            .map(|(k, v)| (k.clone(), *v))
            .collect();
        
        contributors.sort_by(|a, b| b.1.cmp(&a.1));
        contributors.truncate(limit);
        
        contributors
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_reputation_increase() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        assert_eq!(system.get_reputation("did:icn:test"), 100);
    }
    
    #[test]
    fn test_reputation_decrease() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        system.decrease_reputation("did:icn:test", 50);
        assert_eq!(system.get_reputation("did:icn:test"), 50);
    }
    
    #[test]
    fn test_reputation_floor() {
        let mut system = ReputationSystem::new();
        system.decrease_reputation("did:icn:test", 100);
        assert_eq!(system.get_reputation("did:icn:test"), 0);
    }
    
    #[test]
    fn test_reputation_history() {
        let mut system = ReputationSystem::new();
        system.increase_reputation("did:icn:test", 100);
        system.decrease_reputation("did:icn:test", 50);
        
        let history = system.get_history("did:icn:test");
        assert_eq!(history.len(), 2);
        assert_eq!(history[0].change, 100);
        assert_eq!(history[1].change, -50);
    }
    
    #[test]
    fn test_voting_reward() {
        let mut system = ReputationSystem::new();
        system.reward_voting("did:icn:test", 10);
        assert_eq!(system.get_reputation("did:icn:test"), 10);
    }
}

===================
File: ./backend/src/governance/proposal.rs
===================
// src/governance/proposal.rs

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProposalStatus {
    Open,
    Closed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64, // Minimum reputation required to submit a proposal
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(
        id: u64,
        proposal_type: ProposalType,
        description: String,
        required_reputation: i64,
        duration: u64,
    ) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>, // Track proposals by ID for easier access
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/governance/mod.rs
===================
use std::collections::HashMap;

// ProposalType defines different types of proposals
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalType {
    Funding,
    PolicyChange,
    ResourceAllocation,
}

// ProposalStatus represents the current status of a proposal
#[derive(Debug, Clone, PartialEq)]
pub enum ProposalStatus {
    Open,
    Closed,
}

// Proposal struct holds data about each individual proposal
#[derive(Debug, Clone)]
pub struct Proposal {
    pub id: u64,
    pub proposal_type: ProposalType,
    pub description: String,
    pub resource_amount: Option<u64>,
    pub duration: u64,
    pub status: ProposalStatus,
    pub required_reputation: i64,
    votes: Vec<(String, i64)>, // Tuple of voter ID and vote weight
}

impl Proposal {
    /// Initializes a new proposal with the given parameters.
    pub fn new(id: u64, proposal_type: ProposalType, description: String, required_reputation: i64) -> Self {
        Proposal {
            id,
            proposal_type,
            description,
            resource_amount: None,
            duration: 60,
            status: ProposalStatus::Open,
            required_reputation,
            votes: Vec::new(),
        }
    }

    /// Validates the proposal type and ensures it's still open for voting.
    pub fn validate(&self, expected_type: ProposalType) -> bool {
        self.status == ProposalStatus::Open && self.proposal_type == expected_type
    }

    /// Registers a vote with the given voter ID and weight.
    pub fn vote(&mut self, voter_id: &str, weight: i64) {
        self.votes.push((voter_id.to_string(), weight));
    }

    /// Calculates the total votes based on weight.
    pub fn total_votes(&self) -> i64 {
        self.votes.iter().map(|(_, weight)| weight).sum()
    }

    /// Closes the proposal, preventing further voting.
    pub fn close(&mut self) {
        self.status = ProposalStatus::Closed;
    }

    /// Checks if the proposal is nearing its closing time and sends a notification.
    pub fn check_and_notify(&self, time_remaining: u64) {
        if time_remaining <= 15 && self.status == ProposalStatus::Open {
            println!(
                "Notification: Proposal '{}' is nearing its end. Time remaining: {} minutes.",
                self.description, time_remaining
            );
        }
    }
}

// ProposalHistory struct holds a history of proposals and notifications
#[derive(Debug)]
pub struct ProposalHistory {
    pub proposals: HashMap<u64, Proposal>,
    pub notifications: Vec<String>,
}

impl ProposalHistory {
    /// Initializes a new proposal history tracker.
    pub fn new() -> Self {
        ProposalHistory {
            proposals: HashMap::new(),
            notifications: Vec::new(),
        }
    }

    /// Adds a proposal to the history, generating a notification.
    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.proposals.insert(proposal.id, proposal);
        self.notifications.push("New proposal created.".to_string());
    }

    /// Closes a specific proposal by ID and notifies of closure.
    pub fn close_proposal(&mut self, proposal_id: u64) {
        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {
            proposal.close();
            self.notifications.push(format!(
                "Proposal '{}' has closed for voting",
                proposal.description
            ));
        }
    }

    /// Sends reminders for open proposals.
    pub fn send_voting_reminder(&mut self) {
        for proposal in self.proposals.values() {
            if proposal.status == ProposalStatus::Open {
                self.notifications.push(format!(
                    "Reminder: Proposal '{}' is still open for voting!",
                    proposal.description
                ));
            }
        }
    }

    /// Displays the proposal history with current vote counts.
    pub fn display_history(&self) {
        for proposal in self.proposals.values() {
            println!(
                "Proposal ID: {}, Description: '{}', Status: {:?}, Total Votes: {}",
                proposal.id,
                proposal.description,
                proposal.status,
                proposal.total_votes()
            );
        }
    }
}


===================
File: ./backend/src/main.rs
===================
// src/main.rs

mod blockchain;
mod identity;
mod reputation;
mod governance;
mod utils;
mod vm;
mod websocket;
mod consensus;

use std::sync::{Arc, Mutex};
use warp::Filter;
use crate::websocket::WebSocketHandler;
use crate::blockchain::Blockchain;
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;
use crate::consensus::{ProofOfCooperation, types::ConsensusConfig};

#[tokio::main]
async fn main() {
    // Initialize core systems
    let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
    let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
    
    // Create WebSocket handler for real-time updates
    let ws_handler = Arc::new(WebSocketHandler::new());
    
    // Initialize consensus system
    let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
        ConsensusConfig::default(),
        ws_handler.clone(),
    )));

    // Initialize the blockchain with all required systems
    let blockchain = Arc::new(Mutex::new(Blockchain::new(
        identity_system.clone(),
        reputation_system.clone(),
        consensus.clone(),
    )));

    // Define WebSocket route with DID header for user identification
    let ws_handler = ws_handler.clone();
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .and(warp::header::<String>("X-DID"))
        .and(warp::any().map(move || ws_handler.clone()))
        .map(|ws: warp::ws::Ws, did: String, handler: Arc<WebSocketHandler>| {
            ws.on_upgrade(move |socket| async move {
                handler.handle_connection(socket, did).await;
            })
        });

    println!("Starting WebSocket server on localhost:8081");
    warp::serve(ws_route)
        .run(([127, 0, 0, 1], 8081))
        .await;
}

===================
File: ./backend/src/community/mod.rs
===================
// src/community/mod.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::governance::Proposal;
use crate::claims::Claim;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Community {
    pub id: String,
    pub name: String,
    pub description: String,
    pub created_at: DateTime<Utc>,
    pub members: HashMap<String, CivicRole>, // DID -> Role mapping
    pub governance_model: GovernanceModel,
    pub active_proposals: Vec<Proposal>,
    pub policies: Vec<CivicPolicy>,
    pub cooperative_ids: Vec<String>, // Associated cooperatives
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CivicRole {
    pub role: String,
    pub permissions: Vec<String>,
    pub joined_at: DateTime<Utc>,
    pub verified_claims: Vec<Claim>,
    pub voting_history: Vec<VoteRecord>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceModel {
    pub model_type: GovernanceType,
    pub voting_rules: VotingRules,
    pub quorum_requirement: f64,
    pub decision_threshold: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GovernanceType {
    DirectDemocracy,
    DelegativeDemocracy,
    ConsensusBase,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VotingRules {
    pub voting_period_days: u32,
    pub min_participation: f64,
    pub allow_delegation: bool,
    pub require_claims: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoteRecord {
    pub proposal_id: String,
    pub vote: Vote,
    pub timestamp: DateTime<Utc>,
    pub weight: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Vote {
    For,
    Against,
    Abstain,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CivicPolicy {
    pub id: String,
    pub policy_type: CivicPolicyType,
    pub description: String,
    pub rules: Vec<PolicyRule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CivicPolicyType {
    Membership,
    Voting,
    DisputeResolution,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyRule {
    pub condition: String,
    pub effect: String,
    pub parameters: HashMap<String, String>,
}

impl Community {
    pub fn new(
        id: String,
        name: String,
        description: String,
        governance_model: GovernanceModel,
    ) -> Self {
        Community {
            id,
            name,
            description,
            created_at: Utc::now(),
            members: HashMap::new(),
            governance_model,
            active_proposals: Vec::new(),
            policies: Vec::new(),
            cooperative_ids: Vec::new(),
        }
    }

    pub fn add_member(&mut self, did: String, role: CivicRole) -> Result<(), String> {
        if self.members.contains_key(&did) {
            return Err("Member already exists".to_string());
        }
        self.members.insert(did, role);
        Ok(())
    }

    pub fn add_proposal(&mut self, proposal: Proposal) {
        self.active_proposals.push(proposal);
    }

    pub fn add_policy(&mut self, policy: CivicPolicy) {
        self.policies.push(policy);
    }

    pub fn associate_cooperative(&mut self, cooperative_id: String) {
        if !self.cooperative_ids.contains(&cooperative_id) {
            self.cooperative_ids.push(cooperative_id);
        }
    }

    pub fn record_vote(&mut self, did: &str, proposal_id: &str, vote: Vote) -> Result<(), String> {
        if let Some(member) = self.members.get_mut(did) {
            let vote_record = VoteRecord {
                proposal_id: proposal_id.to_string(),
                vote,
                timestamp: Utc::now(),
                weight: 1.0, // Basic weight, could be modified based on reputation/claims
            };
            member.voting_history.push(vote_record);
            Ok(())
        } else {
            Err("Member not found".to_string())
        }
    }
}

// Implement the trait for community energy tracking
impl crate::monitoring::energy::EnergyAware for Community {
    fn record_energy_metrics(&self, monitor: &crate::monitoring::energy::EnergyMonitor) {
        // Record basic operations
        monitor.record_instruction();
        
        // Record proposal storage
        let proposals_size = (self.active_proposals.len() * std::mem::size_of::<Proposal>()) as u64;
        monitor.record_storage_operation(proposals_size);
        
        // Record member operations
        let members_size = (self.members.len() * std::mem::size_of::<CivicRole>()) as u64;
        monitor.record_memory_operation(members_size);
    }
}

===================
File: ./backend/src/lib.rs
===================
// src/lib.rs

pub mod blockchain;
pub mod identity;
pub mod reputation;
pub mod governance;
pub mod utils;
pub mod vm;
pub mod websocket;
pub mod consensus;
pub mod network;

pub use blockchain::{Block, Blockchain, Transaction, TransactionType};
pub use identity::IdentitySystem;
pub use reputation::ReputationSystem;
pub use governance::Proposal;
pub use consensus::types::ConsensusRound;
pub use consensus::{ProofOfCooperation, types::ConsensusConfig};
pub use vm::{VM, Contract, ExecutionContext};
pub use vm::opcode::OpCode;
pub use vm::cooperative_metadata::{CooperativeMetadata, ResourceImpact};
pub use websocket::WebSocketHandler;

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::sync::broadcast;
use uuid;
use chrono;

pub struct ICNCore {
    blockchain: Arc<Mutex<Blockchain>>,
    identity_system: Arc<Mutex<IdentitySystem>>,
    reputation_system: Arc<Mutex<ReputationSystem>>,
    ws_handler: Arc<WebSocketHandler>,
    vm: Arc<Mutex<VM>>,
    event_bus: broadcast::Sender<SystemEvent>,
}

#[derive(Clone, Debug)]
pub enum SystemEvent {
    BlockCreated(Block),
    ProposalSubmitted(Proposal),
    VoteCast { proposal_id: u64, voter: String, vote: bool },
    ReputationChanged { did: String, change: i64, reason: String },
    ConsensusStarted(ConsensusRound),
    ConsensusFinished(Block),
    CooperativeCreated { id: String, creator: String },
    CooperativeJoined { id: String, member: String },
}

impl ICNCore {
    pub fn new() -> Self {
        let (event_tx, _) = broadcast::channel(100);
        
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());

        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler.clone(),
        )));

        let blockchain = Arc::new(Mutex::new(Blockchain::new(
            identity_system.clone(),
            reputation_system.clone(),
            consensus.clone()  // Add consensus argument
        )));

        let reputation_context = reputation_system.lock()
            .unwrap()
            .get_reputation_context();
            
        let vm = VM::new(1000, reputation_context);
        let vm = Arc::new(Mutex::new(vm));

        ICNCore {
            blockchain,
            identity_system,
            reputation_system,
            ws_handler,
            vm,
            event_bus: event_tx,
        }
    }


    pub async fn create_cooperative(&self, creator_did: String, metadata: CooperativeMetadata) -> Result<String, String> {
        let identity = self.identity_system.lock()
            .map_err(|_| "Failed to acquire identity lock".to_string())?;
        if !identity.is_registered(&creator_did) {
            return Err("Creator DID not registered".to_string());
        }
        drop(identity);

        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        if reputation.get_reputation(&creator_did) < 100 {
            return Err("Insufficient reputation to create cooperative".to_string());
        }
        let reputation_score = reputation.get_reputation(&creator_did);
        drop(reputation);

        let contract = Contract {
            id: uuid::Uuid::new_v4().to_string(),
            code: vec![OpCode::CreateCooperative],
            state: HashMap::new(),
            required_reputation: 100,
            cooperative_metadata: metadata.clone(),
            version: "1.0.0".to_string(),
            dependencies: vec![],
            permissions: vec!["cooperative.create".to_string()],
        };

        let context = ExecutionContext {
            caller_did: creator_did.clone(),
            cooperative_id: contract.id.clone(),
            timestamp: chrono::Utc::now().timestamp() as u64,
            block_number: {
                let blockchain = self.blockchain.lock()
                    .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
                blockchain.current_block_number
            },
            reputation_score,
            permissions: vec!["cooperative.create".to_string()],
        };

        {
            let mut vm = self.vm.lock()
                .map_err(|_| "Failed to acquire VM lock".to_string())?;
            vm.set_execution_context(context);
            vm.execute_contract(&contract)?;
        }

        let transaction = Transaction::new(
            creator_did.clone(),
            TransactionType::ContractExecution {
                contract_id: contract.id.clone(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        let event = SystemEvent::CooperativeCreated {
            id: contract.id.clone(),
            creator: creator_did,
        };
        let _ = self.event_bus.send(event);

        Ok(contract.id)
    }

    pub async fn submit_proposal(&self, creator_did: String, proposal: Proposal) -> Result<u64, String> {
        let reputation = self.reputation_system.lock()
            .map_err(|_| "Failed to acquire reputation lock".to_string())?;
        if reputation.get_reputation(&creator_did) < proposal.required_reputation {
            return Err("Insufficient reputation to create proposal".to_string());
        }
        drop(reputation);

        let transaction = Transaction::new(
            creator_did,
            TransactionType::ContractExecution {
                contract_id: "governance".to_string(),
                input_data: HashMap::new(),
            },
        );

        {
            let mut blockchain = self.blockchain.lock()
                .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
            blockchain.add_transaction(transaction).await?;
        }

        let event = SystemEvent::ProposalSubmitted(proposal.clone());
        let _ = self.event_bus.send(event);

        Ok(proposal.id)
    }

    pub async fn start_consensus_round(&self) -> Result<(), String> {
        let blockchain = self.blockchain.lock()
            .map_err(|_| "Failed to acquire blockchain lock".to_string())?;
        
        if let Some(round) = blockchain.get_current_round() {
            drop(blockchain);
            let event = SystemEvent::ConsensusStarted(round);
            let _ = self.event_bus.send(event);
        }

        Ok(())
    }

    pub fn subscribe_to_events(&self) -> broadcast::Receiver<SystemEvent> {
        self.event_bus.subscribe()
    }
}

pub struct CooperativeManager {
    core: Arc<ICNCore>,
}

impl CooperativeManager {
    pub fn new(core: Arc<ICNCore>) -> Self {
        CooperativeManager { core }
    }

    pub async fn create_cooperative(
        &self, 
        creator_did: String, 
        _name: String,
        purpose: String
    ) -> Result<String, String> {
        let metadata = CooperativeMetadata {
            creator_did: creator_did.clone(),
            cooperative_id: uuid::Uuid::new_v4().to_string(),
            purpose,
            resource_impact: ResourceImpact {
                cpu_intensity: 1,
                memory_usage: 1,
                network_usage: 1,
                storage_usage: 1,
                bandwidth_usage: 1,
            },
            federation_id: None,
            creation_timestamp: chrono::Utc::now().timestamp() as u64,
            last_updated: chrono::Utc::now().timestamp() as u64,
            member_count: 1,
            resource_allocation: HashMap::new(),
        };

        self.core.create_cooperative(creator_did, metadata).await
    }

    pub async fn join_cooperative(&self, cooperative_id: String, member_did: String) -> Result<(), String> {
        let event = SystemEvent::CooperativeJoined {
            id: cooperative_id,
            member: member_did,
        };
        let _ = self.core.event_bus.send(event);
        Ok(())
    }
}

pub struct ICNNode {
    core: Arc<ICNCore>,
    node_id: String,
    peers: Arc<Mutex<HashMap<String, String>>>,
}

impl ICNNode {
    pub fn new(core: Arc<ICNCore>, node_id: String) -> Self {
        ICNNode {
            core,
            node_id,
            peers: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn start(&self) -> Result<(), String> {
        let mut event_rx = self.core.subscribe_to_events();
        self.core.start_consensus_round().await?;

        tokio::spawn(async move {
            while let Ok(event) = event_rx.recv().await {
                match event {
                    SystemEvent::BlockCreated(block) => {
                        println!("New block created: {}", block.index);
                    }
                    SystemEvent::ConsensusStarted(round) => {
                        println!("New consensus round started: {}", round.round_number);
                    }
                    _ => {}
                }
            }
        });

        Ok(())
    }

    pub async fn connect_to_peer(&self, peer_id: String, address: String) -> Result<(), String> {
        self.peers.lock()
            .map_err(|_| "Failed to acquire peers lock".to_string())?
            .insert(peer_id, address);
        Ok(())
    }
}


===================
File: ./backend/src/consensus/tests.rs
===================
# File: ./backend/src/consensus/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::blockchain::Blockchain;
    use crate::identity::IdentitySystem;
    use crate::reputation::ReputationSystem;

    fn setup_test_blockchain() -> Blockchain {
        let identity_system = IdentitySystem::new();
        let reputation_system = ReputationSystem::new();
        let mut blockchain = Blockchain::new(identity_system, reputation_system);
        
        // Register test validators
        blockchain.consensus.register_validator("did:icn:1".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:2".to_string(), 100).unwrap();
        blockchain.consensus.register_validator("did:icn:3".to_string(), 100).unwrap();
        
        blockchain
    }

    #[test]
    fn test_consensus_integration() {
        let mut blockchain = setup_test_blockchain();
        
        // Add some test transactions
        let transaction = Transaction::new(
            "did:icn:1".to_string(),
            TransactionType::Transfer {
                receiver: "did:icn:2".to_string(),
                amount: 100,
            },
        );
        blockchain.add_transaction(transaction);

        // Try to finalize block through consensus
        assert!(blockchain.finalize_block().is_ok());
        
        // Verify block was added
        assert_eq!(blockchain.chain.len(), 2);
        
        // Verify reputation updates were applied
        let reputation_updates = blockchain.consensus.get_reputation_updates();
        assert!(!reputation_updates.is_empty());
    }

    #[test]
    fn test_consensus_failure_recovery() {
        let mut blockchain = setup_test_blockchain();
        
        // Simulate a failed consensus round
        blockchain.consensus.start_round().unwrap();
        blockchain.consensus.check_timeout();
        
        // Verify we can start a new round after failure
        assert!(blockchain.finalize_block().is_ok());
    }
}

===================
File: ./backend/src/consensus/types.rs
===================
// src/consensus/types.rs

use std::collections::HashMap;
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use crate::blockchain::Block;

/// Information about a validator in the network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatorInfo {
    /// Decentralized Identifier of the validator
    pub did: String,
    
    /// Current reputation score
    pub reputation: i64,
    
    /// Calculated voting power (0.0 to 1.0)
    pub voting_power: f64,
    
    /// Last consensus round the validator participated in
    pub last_active_round: u64,
    
    /// Number of consecutive rounds missed
    pub consecutive_missed_rounds: u32,
    
    /// Total number of blocks validated
    pub total_blocks_validated: u64,
    
    /// Performance score based on historical participation (0.0 to 1.0)
    pub performance_score: f64,
}

/// Statistics for a consensus round
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRoundStats {
    /// Total available voting power in the round
    pub total_voting_power: f64,
    
    /// Percentage of validators who participated
    pub participation_rate: f64,
    
    /// Percentage of voting power that approved the block
    pub approval_rate: f64,
    
    /// Duration of the round in milliseconds
    pub round_duration_ms: u64,
    
    /// Number of validators eligible to participate
    pub validator_count: usize,
}

/// A vote cast by a validator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeightedVote {
    /// DID of the validator casting the vote
    pub validator: String,
    
    /// Whether the validator approves the block
    pub approve: bool,
    
    /// Voting power of the validator
    pub voting_power: f64,
    
    /// When the vote was cast
    pub timestamp: DateTime<Utc>,
    
    /// Cryptographic signature of the vote
    pub signature: String,
}

/// State of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusRound {
    /// Sequential number of this round
    pub round_number: u64,
    
    /// DID of the coordinator for this round
    pub coordinator: String,
    
    /// When the round started
    pub start_time: DateTime<Utc>,
    
    /// When the round will timeout
    pub timeout: DateTime<Utc>,
    
    /// Current status of the round
    pub status: RoundStatus,
    
    /// The block being proposed (if any)
    pub proposed_block: Option<Block>,
    
    /// Votes received, keyed by validator DID
    pub votes: HashMap<String, WeightedVote>,
    
    /// Statistics for the round
    pub stats: ConsensusRoundStats,
}

/// Status of a consensus round
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RoundStatus {
    /// Waiting for block proposal
    Proposing,
    
    /// Collecting votes from validators
    Voting,
    
    /// Preparing to commit the block
    Finalizing,
    
    /// Round successfully completed
    Completed,
    
    /// Round failed to reach consensus
    Failed,
}

/// Configuration parameters for the consensus mechanism
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusConfig {
    /// Minimum reputation required to be a validator
    pub min_validator_reputation: i64,
    
    /// Maximum voting power any validator can have
    pub max_voting_power: f64,
    
    /// Minimum participation required for valid consensus
    pub min_participation_rate: f64,
    
    /// Minimum approval required for valid consensus
    pub min_approval_rate: f64,
    
    /// How long before a round times out (milliseconds)
    pub round_timeout_ms: u64,
    
    /// Base reputation reward for participation
    pub base_reward: i64,
    
    /// Multiplier for consecutive missed rounds
    pub penalty_factor: f64,
}

impl Default for ConsensusConfig {
    fn default() -> Self {
        ConsensusConfig {
            min_validator_reputation: 100,
            max_voting_power: 0.1,
            min_participation_rate: 0.67,  // 2/3 participation required
            min_approval_rate: 0.67,       // 2/3 approval required
            round_timeout_ms: 30_000,      // 30 seconds
            base_reward: 10,
            penalty_factor: 1.5,
        }
    }
}

/// Possible consensus-related errors
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusError {
    /// Not enough validators available
    InsufficientValidators,
    
    /// Proposed block came from wrong coordinator
    InvalidCoordinator,
    
    /// Cannot start new round while one is in progress
    RoundInProgress,
    
    /// No consensus round is currently active
    NoActiveRound,
    
    /// Action invalid for current round state
    InvalidRoundState,
    
    /// Round exceeded time limit
    TimedOut,
    
    /// Block validation failed
    ValidationFailed,
    
    /// Entity is not a registered validator
    NotValidator,
    
    /// Validator lacks required reputation
    InsufficientReputation,
    
    /// Custom error with message
    Custom(String),
}

impl std::fmt::Display for ConsensusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConsensusError::InsufficientValidators => 
                write!(f, "Insufficient number of active validators"),
            ConsensusError::InvalidCoordinator => 
                write!(f, "Invalid coordinator for this round"),
            ConsensusError::RoundInProgress => 
                write!(f, "Consensus round already in progress"),
            ConsensusError::NoActiveRound => 
                write!(f, "No active consensus round"),
            ConsensusError::InvalidRoundState => 
                write!(f, "Invalid round state for requested operation"),
            ConsensusError::TimedOut => 
                write!(f, "Consensus round timed out"),
            ConsensusError::ValidationFailed => 
                write!(f, "Block validation failed"),
            ConsensusError::NotValidator => 
                write!(f, "Not a registered validator"),
            ConsensusError::InsufficientReputation => 
                write!(f, "Insufficient reputation for operation"),
            ConsensusError::Custom(msg) => 
                write!(f, "{}", msg),
        }
    }
}

impl std::error::Error for ConsensusError {}

impl From<ConsensusError> for String {
    fn from(error: ConsensusError) -> String {
        error.to_string()
    }
}

/// Utility functions for consensus calculations
pub mod utils {
    /// Calculate voting power based on reputation
    pub fn calculate_voting_power(reputation: i64, total_reputation: i64, max_power: f64) -> f64 {
        let raw_power = reputation as f64 / total_reputation as f64;
        raw_power.min(max_power)
    }

    /// Calculate penalty for missed rounds
    pub fn calculate_penalty(base_penalty: i64, consecutive_misses: u32, factor: f64) -> i64 {
        -(base_penalty as f64 * factor * consecutive_misses as f64) as i64
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_consensus_config_default() {
        let config = ConsensusConfig::default();
        assert_eq!(config.min_validator_reputation, 100);
        assert_eq!(config.max_voting_power, 0.1);
        assert_eq!(config.min_participation_rate, 0.67);
        assert_eq!(config.min_approval_rate, 0.67);
    }

    #[test]
    fn test_voting_power_calculation() {
        let power = utils::calculate_voting_power(500, 1000, 0.1);
        assert!(power <= 0.1);
        assert!(power > 0.0);
    }

    #[test]
    fn test_penalty_calculation() {
        let penalty = utils::calculate_penalty(10, 3, 1.5);
        assert_eq!(penalty, -45); // -10 * 1.5 * 3
    }

    #[test]
    fn test_consensus_error_display() {
        let error = ConsensusError::InsufficientValidators;
        assert_eq!(
            error.to_string(),
            "Insufficient number of active validators"
        );
    }

    #[test]
    fn test_weighted_vote_creation() {
        let vote = WeightedVote {
            validator: "did:icn:test".to_string(),
            approve: true,
            voting_power: 0.5,
            timestamp: Utc::now(),
            signature: "sig".to_string(),
        };
        assert_eq!(vote.validator, "did:icn:test");
        assert_eq!(vote.voting_power, 0.5);
    }
}

===================
File: ./backend/src/consensus/mod.rs
===================
// src/consensus/mod.rs

pub mod proof_of_cooperation;
pub mod types;

pub use proof_of_cooperation::ProofOfCooperation;
pub use types::{ConsensusRound, ConsensusConfig, RoundStatus}; 

use std::sync::{Arc, Mutex};
use crate::blockchain::{Block, Transaction};
use crate::identity::IdentitySystem;
use crate::reputation::ReputationSystem;

pub struct Blockchain {
    pub chain: Vec<Block>,
    pub pending_transactions: Vec<Transaction>,
    pub consensus: Arc<Mutex<ProofOfCooperation>>,
    pub identity_system: Arc<Mutex<IdentitySystem>>,
    pub reputation_system: Arc<Mutex<ReputationSystem>>,
    pub current_block_number: u64,
    coordinator_did: String,
}

impl Blockchain {
    pub fn new(
        identity_system: Arc<Mutex<IdentitySystem>>, 
        reputation_system: Arc<Mutex<ReputationSystem>>,
        consensus: Arc<Mutex<ProofOfCooperation>>,
    ) -> Self {
        let coordinator_did = "did:icn:genesis".to_string();
        
        Blockchain {
            chain: vec![Block::genesis()],
            pending_transactions: vec![],
            consensus,
            identity_system,
            reputation_system,
            current_block_number: 1,
            coordinator_did,
        }
    }

    pub async fn finalize_block(&mut self) -> Result<(), String> {
        let previous_hash = self.chain.last()
            .map(|block| block.hash.clone())
            .unwrap_or_default();

        let new_block = Block::new(
            self.chain.len() as u64,
            previous_hash,
            self.pending_transactions.clone(),
            self.coordinator_did.clone(),
        );

        let mut consensus = self.consensus.lock()
            .map_err(|_| "Failed to acquire consensus lock".to_string())?;
        
        consensus.start_round().await?;

        let validators = self.get_active_validators();
        if validators.is_empty() {
            return Err("No active validators available".to_string());
        }

        drop(consensus);

        {
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            consensus.propose_block(&validators[0], new_block.clone()).await?;
        }

        for validator in validators {
            let signature = String::from("dummy_signature");
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            consensus.submit_vote(&validator, true, signature).await?;
        }

        let (finalized_block, reputation_updates) = {
            let mut consensus = self.consensus.lock()
                .map_err(|_| "Failed to acquire consensus lock".to_string())?;
            let block = consensus.finalize_round().await?;
            let updates = consensus.get_reputation_updates().to_vec();
            (block, updates)
        };

        self.chain.push(finalized_block);
        self.pending_transactions.clear();
        
        {
            let mut reputation_system = self.reputation_system.lock()
                .map_err(|_| "Failed to acquire reputation lock".to_string())?;
            for (did, change) in reputation_updates {
                reputation_system.increase_reputation(&did, change);
            }
        }

        self.current_block_number += 1;
        Ok(())
    }

    fn get_active_validators(&self) -> Vec<String> {
        vec![
            "did:icn:validator1".to_string(),
            "did:icn:validator2".to_string(),
            "did:icn:validator3".to_string(),
        ]
    }

    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.consensus.try_lock()
            .ok()
            .and_then(|consensus| consensus.get_current_round())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::websocket::WebSocketHandler;

    #[tokio::test]
    async fn test_blockchain_new() {
        let identity_system = Arc::new(Mutex::new(IdentitySystem::new()));
        let reputation_system = Arc::new(Mutex::new(ReputationSystem::new()));
        let ws_handler = Arc::new(WebSocketHandler::new());
        
        let consensus = Arc::new(Mutex::new(ProofOfCooperation::new(
            ConsensusConfig::default(),
            ws_handler,
        )));

        let blockchain = Blockchain::new(
            identity_system.clone(),
            reputation_system.clone(),
            consensus,
        );

        assert_eq!(blockchain.current_block_number, 1);
        assert_eq!(blockchain.chain.len(), 1);
        assert_eq!(blockchain.pending_transactions.len(), 0);
        assert_eq!(blockchain.coordinator_did, "did:icn:genesis");
    }
}

===================
File: ./backend/src/consensus/proof_of_cooperation.rs
===================
// src/consensus/proof_of_cooperation.rs

use std::sync::Arc;
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use rand::{thread_rng, Rng};
use serde::{Serialize, Deserialize};

use crate::websocket::WebSocketHandler;
use crate::blockchain::Block;
use crate::consensus::types::{
    ConsensusConfig,
    RoundStatus,
    WeightedVote,
    ValidatorInfo,
    ConsensusRoundStats,
    ConsensusRound,
    ConsensusError,
};

/// Proof of Cooperation (PoC) consensus mechanism implementation.
/// 
/// The PoC system is designed around reputation-weighted consensus where validators
/// gain influence through positive contributions to the network rather than 
/// computational power or staked assets.
///
/// Key features:
/// - Reputation-based validator selection
/// - Multi-phase consensus process
/// - Real-time status updates via WebSocket
/// - Built-in penalties for malicious behavior
/// - Dynamic reputation adjustments
/// - Protection against Sybil attacks through reputation requirements
pub struct ProofOfCooperation {
    /// Configuration parameters for the consensus mechanism
    config: ConsensusConfig,
    
    /// Map of validator DIDs to their information/state
    validators: HashMap<String, ValidatorInfo>,
    
    /// Current consensus round state
    current_round: Option<ConsensusRound>,
    
    /// History of completed rounds' statistics
    round_history: Vec<ConsensusRoundStats>,
    
    /// Pending reputation updates to be applied
    reputation_updates: Vec<(String, i64)>,
    
    /// WebSocket handler for real-time updates
    ws_handler: Arc<WebSocketHandler>,
}

impl ProofOfCooperation {
    /// Creates a new instance of the PoC consensus mechanism
    pub fn new(config: ConsensusConfig, ws_handler: Arc<WebSocketHandler>) -> Self {
        ProofOfCooperation {
            config,
            validators: HashMap::new(),
            current_round: None,
            round_history: Vec::new(),
            reputation_updates: Vec::new(),
            ws_handler,
        }
    }

    /// Starts a new consensus round
    ///
    /// This initiates the consensus process by:
    /// 1. Checking if there's already an active round
    /// 2. Validating there are sufficient active validators
    /// 3. Selecting a coordinator based on reputation-weighted random selection
    /// 4. Creating and broadcasting the new round state
    ///
    /// # Returns
    /// - Ok(()) if the round starts successfully
    /// - Err(String) with a description if the round cannot be started
    pub async fn start_round(&mut self) -> Result<(), String> {
        if self.current_round.is_some() {
            return Err("Round already in progress".to_string());
        }

        let active_validators: Vec<_> = self.validators.values()
            .filter(|v| v.reputation >= self.config.min_validator_reputation)
            .collect();

        if active_validators.len() < 3 {
            return Err("Insufficient validators".to_string());
        }

        let coordinator = self.select_coordinator(&active_validators)?;
        
        let round = ConsensusRound {
            round_number: self.round_history.len() as u64 + 1,
            coordinator: coordinator.did.clone(),
            start_time: Utc::now(),
            timeout: Utc::now() + chrono::Duration::milliseconds(self.config.round_timeout_ms as i64),
            status: RoundStatus::Proposing,
            proposed_block: None,
            votes: HashMap::new(),
            stats: ConsensusRoundStats {
                total_voting_power: 0.0,
                participation_rate: 0.0,
                approval_rate: 0.0,
                round_duration_ms: 0,
                validator_count: active_validators.len(),
            },
        };

        self.ws_handler.broadcast_consensus_update(&round);
        self.current_round = Some(round);
        Ok(())
    }

    /// Proposes a new block for the current round
    ///
    /// # Arguments
    /// * `proposer_did` - The DID of the validator proposing the block
    /// * `block` - The proposed block
    ///
    /// # Returns
    /// - Ok(()) if the proposal is accepted
    /// - Err(String) describing why the proposal was rejected
    pub async fn propose_block(&mut self, proposer_did: &str, block: Block) -> Result<(), String> {
        let validator = self.validators.get(proposer_did)
            .ok_or("Proposer not found")?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err("Insufficient reputation to propose".to_string());
        }

        let mut round = self.current_round.take()
            .ok_or("No active round")?;

        if round.coordinator != proposer_did {
            self.current_round = Some(round);
            return Err("Not the round coordinator".to_string());
        }

        round.proposed_block = Some(block.clone());
        round.status = RoundStatus::Voting;

        self.ws_handler.broadcast_consensus_update(&round);
        self.ws_handler.broadcast_block_finalized(&block);
        self.current_round = Some(round);
        Ok(())
    }

    /// Submits a vote for the current round
    ///
    /// # Arguments
    /// * `validator_did` - The DID of the voting validator
    /// * `approved` - Whether the validator approves the proposed block
    /// * `signature` - Cryptographic signature of the vote
    ///
    /// # Returns
    /// - Ok(()) if the vote is accepted
    /// - Err(String) describing why the vote was rejected
    pub async fn submit_vote(&mut self, validator_did: &str, approved: bool, signature: String) -> Result<(), String> {
        let validator = self.validators.get(validator_did)
            .ok_or("Not a registered validator")?;

        if validator.reputation < self.config.min_validator_reputation {
            return Err("Insufficient reputation to vote".to_string());
        }

        let vote = WeightedVote {
            validator: validator_did.to_string(),
            approve: approved,
            voting_power: validator.voting_power,
            timestamp: Utc::now(),
            signature,
        };

        let mut round = self.current_round.take()
            .ok_or("No active round")?;

        round.votes.insert(validator_did.to_string(), vote);

        // Calculate total available voting power
        let total_power: f64 = self.validators.values()
            .filter(|v| v.reputation >= self.config.min_validator_reputation)
            .map(|v| v.voting_power)
            .sum();

        // Calculate actual voting power used
        let votes_power: f64 = round.votes.values()
            .map(|v| v.voting_power)
            .sum();

        round.stats.total_voting_power = total_power;
        round.stats.participation_rate = votes_power / total_power;

        // Calculate approval rate
        let approval_power: f64 = round.votes.values()
            .filter(|v| v.approve)
            .map(|v| v.voting_power)
            .sum();

        round.stats.approval_rate = if votes_power > 0.0 {
            approval_power / votes_power
        } else {
            0.0
        };

        // Check if we've reached consensus thresholds
        if round.stats.participation_rate >= self.config.min_participation_rate
            && round.stats.approval_rate >= self.config.min_approval_rate {
            round.status = RoundStatus::Finalizing;
        }

        // Broadcast updates
        self.ws_handler.broadcast_consensus_update(&round);
        self.ws_handler.broadcast_validator_update(
            validator.clone(),
            round.round_number,
            if approved { "approved".to_string() } else { "rejected".to_string() }
        );

        self.current_round = Some(round);
        Ok(())
    }

    /// Finalizes the current consensus round
    ///
    /// This method:
    /// 1. Validates the round is ready for finalization
    /// 2. Updates validator statistics and reputation
    /// 3. Applies reputation rewards/penalties
    /// 4. Records round history
    ///
    /// # Returns
    /// - Ok(Block) with the finalized block
    /// - Err(String) describing why finalization failed
    pub async fn finalize_round(&mut self) -> Result<Block, String> {
        let round = self.current_round.take()
            .ok_or("No active round")?;

        if round.status != RoundStatus::Finalizing {
            self.current_round = Some(round);
            return Err("Round not ready for finalization".to_string());
        }

        let block = round.proposed_block.clone()
            .ok_or("No proposed block")?;

        // Update validator statistics and reputation
        for (validator_id, validator) in self.validators.iter_mut() {
            if round.votes.contains_key(validator_id) {
                // Reward participation
                validator.consecutive_missed_rounds = 0;
                validator.last_active_round = round.round_number;
                validator.reputation += self.config.base_reward;

                // Additional reward for coordinator
                if validator_id == &round.coordinator {
                    validator.reputation += self.config.base_reward;
                }

                self.reputation_updates.push((
                    validator_id.clone(),
                    self.config.base_reward
                ));

                validator.performance_score = validator.performance_score * 0.95 + 0.05;
            } else {
                // Penalize non-participation
                validator.consecutive_missed_rounds += 1;
                let penalty = -(self.config.base_reward as f64 *
                    self.config.penalty_factor *
                    validator.consecutive_missed_rounds as f64) as i64;
                validator.reputation += penalty;

                self.reputation_updates.push((
                    validator_id.clone(),
                    penalty
                ));

                validator.performance_score = validator.performance_score * 0.95;
            }
        }

        // Update round history
        let mut stats = round.stats;
        stats.round_duration_ms = round.timeout
            .signed_duration_since(round.start_time)
            .num_milliseconds() as u64;
        self.round_history.push(stats);

        self.ws_handler.broadcast_block_finalized(&block);

        Ok(block)
    }

    /// Gets the current list of reputation updates
    pub fn get_reputation_updates(&self) -> &[(String, i64)] {
        &self.reputation_updates
    }

    /// Gets the current round state if one exists
    pub fn get_current_round(&self) -> Option<ConsensusRound> {
        self.current_round.clone()
    }

    /// Selects a coordinator for the next round using reputation-weighted random selection
    fn select_coordinator<'a>(&self, active_validators: &'a [&ValidatorInfo]) 
        -> Result<&'a ValidatorInfo, String> 
    {
        let mut rng = thread_rng();

        let weights: Vec<f64> = active_validators.iter()
            .map(|v| (v.reputation as f64) * v.performance_score)
            .collect();

        let total_weight: f64 = weights.iter().sum();
        if total_weight <= 0.0 {
            return Err("No valid validators".to_string());
        }

        let selection_point = rng.gen_range(0.0..total_weight);
        let mut cumulative_weight = 0.0;

        for (i, weight) in weights.iter().enumerate() {
            cumulative_weight += weight;
            if cumulative_weight >= selection_point {
                return Ok(active_validators[i]);
            }
        }

        Err("Failed to select coordinator".to_string())
    }

    /// Registers a new validator with the consensus mechanism
    pub fn register_validator(&mut self, did: String, initial_reputation: i64) -> Result<(), String> {
        let validator = ValidatorInfo {
            did: did.clone(),
            reputation: initial_reputation,
            voting_power: 1.0,
            last_active_round: 0,
            consecutive_missed_rounds: 0,
            total_blocks_validated: 0,
            performance_score: 1.0,
        };

        self.validators.insert(did, validator);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_consensus() -> ProofOfCooperation {
        let config = ConsensusConfig::default();
        let ws_handler = Arc::new(WebSocketHandler::new());
        ProofOfCooperation::new(config, ws_handler)
    }

    fn add_test_validators(consensus: &mut ProofOfCooperation) {
        for i in 1..=3 {
            let validator = ValidatorInfo {
                did: format!("did:icn:test{}", i),
                reputation: 1000,
                voting_power: 1.0,
                last_active_round: 0,
                consecutive_missed_rounds: 0,
                total_blocks_validated: 0,
                performance_score: 1.0,
            };
            consensus.validators.insert(validator.did.clone(), validator);
        }
    }

    #[tokio::test]
    async fn test_start_round() {
        let mut consensus = setup_test_consensus();
        add_test_validators(&mut consensus);
        
        assert!(consensus.start_round().await.is_ok());
        assert!(consensus.current_round.is_some());
    }

    #[tokio::test]
    async fn test_insufficient_validators() {
        let mut consensus = setup_test_consensus();
        
        let result = consensus.start_round().await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Insufficient validators");
    }

    #[tokio::test]
    async fn test_propose_block() {
        let mut consensus = setup_test_consensus();
        add_test_validators(&mut consensus);
        
        // Start a round first
        consensus.start_round().await.unwrap();
        
        // Get the coordinator's DID
        let coordinator_did = consensus.current_round.as_ref().unwrap().coordinator.clone();
        
        // Create a test block
        let block = Block::new(
            1,
            "previous_hash".to_string(),
            vec![]
        );
        
        // Test proposal
        let result = consensus.propose_block(&coordinator_did, block).await;
        assert!(result.is_ok());
        
        // Verify round status changed
        assert_eq!(
            consensus.current_round.as_ref().unwrap().status,
            RoundStatus::Voting
        );
    }

    #[tokio::test]
    async fn test_invalid_proposer() {
        let mut consensus = setup_test_consensus();
        add_test_validators(&mut consensus);
        
        consensus.start_round().await.unwrap();
        
        let block = Block::new(
            1,
            "previous_hash".to_string(),
            vec![]
        );
        
        let result = consensus.propose_block("invalid_did", block).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Proposer not found");
    }
}


===================
File: ./frontend/src/components/cooperative/CooperativeDashboard.tsx
===================
import React, { useState, useEffect } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { AlertCircle, Users, Activity, BarChart3 } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

const CooperativeDashboard = () => {
  const [metrics, setMetrics] = useState({
    totalMembers: 0,
    activeProposals: 0,
    resourceUtilization: 0,
    monthlyActivity: []
  });
  
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockData = {
      totalMembers: 156,
      activeProposals: 3,
      resourceUtilization: 78,
      monthlyActivity: [
        { month: 'Jan', activity: 65 },
        { month: 'Feb', activity: 75 },
        { month: 'Mar', activity: 85 },
        { month: 'Apr', activity: 90 }
      ]
    };

    setMetrics(mockData);
    setLoading(false);
  }, []);

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Members</p>
                <h3 className="text-2xl font-bold">{metrics.totalMembers}</h3>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{metrics.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Resource Utilization</p>
                <h3 className="text-2xl font-bold">{metrics.resourceUtilization}%</h3>
              </div>
              <Activity className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Monthly Growth</p>
                <h3 className="text-2xl font-bold">+12%</h3>
              </div>
              <BarChart3 className="h-8 w-8 text-orange-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Cooperative Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={metrics.monthlyActivity}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="activity" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Resource Allocation</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Computing Resources</span>
                <span>75%</span>
              </div>
              <Progress value={75} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Storage Resources</span>
                <span>60%</span>
              </div>
              <Progress value={60} className="h-2" />
            </div>
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Network Resources</span>
                <span>85%</span>
              </div>
              <Progress value={85} className="h-2" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default CooperativeDashboard;

===================
File: ./frontend/src/components/governance/GovernanceDashboard.tsx
===================
import React, { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { AlertCircle, ChevronRight, Users, TrendingUp } from 'lucide-react'

type Proposal = {
  id: string
  title: string
  description: string
  status: 'active' | 'passed' | 'rejected'
  votesFor: number
  votesAgainst: number
  quorum: number
  createdBy: string
  endsAt: string
  totalVoters: number
  delegatedVotes: number
}

type VotingStats = {
  totalProposals: number
  activeProposals: number
  participationRate: number
  monthlyVotes: Array<{ month: string; votes: number }>
}

const GovernanceDashboard = () => {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [votingStats, setVotingStats] = useState<VotingStats>({
    totalProposals: 0,
    activeProposals: 0,
    participationRate: 0,
    monthlyVotes: []
  })
  const [selectedTab, setSelectedTab] = useState('active')
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Mock data - replace with actual API calls
    const mockProposals: Proposal[] = [
      {
        id: '1',
        title: 'Community Resource Allocation Q3',
        description: 'Proposal to allocate community resources for Q3 projects',
        status: 'active',
        votesFor: 750,
        votesAgainst: 250,
        quorum: 1000,
        createdBy: 'did:icn:alice',
        endsAt: '2024-11-01',
        totalVoters: 1500,
        delegatedVotes: 200
      },
      {
        id: '2',
        title: 'New Cooperation Guidelines',
        description: 'Updated guidelines for inter-cooperative collaboration',
        status: 'passed',
        votesFor: 800,
        votesAgainst: 100,
        quorum: 1000,
        createdBy: 'did:icn:bob',
        endsAt: '2024-10-15',
        totalVoters: 1200,
        delegatedVotes: 150
      }
    ]

    const mockStats = {
      totalProposals: 45,
      activeProposals: 3,
      participationRate: 78.5,
      monthlyVotes: [
        { month: 'Jan', votes: 120 },
        { month: 'Feb', votes: 150 },
        { month: 'Mar', votes: 180 },
        { month: 'Apr', votes: 220 }
      ]
    }

    setProposals(mockProposals)
    setVotingStats(mockStats)
    setLoading(false)
  }, [])

  const calculateProgress = (votesFor: number, votesAgainst: number) => {
    const total = votesFor + votesAgainst
    return total > 0 ? (votesFor / total) * 100 : 0
  }

  const ProposalCard = ({ proposal }: { proposal: Proposal }) => (
    <Card className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <h3 className="text-lg font-semibold">{proposal.title}</h3>
          <p className="text-sm text-gray-600">{proposal.description}</p>
        </div>
        <span className={`px-2 py-1 rounded text-sm ${
          proposal.status === 'active' ? 'bg-blue-100 text-blue-800' :
          proposal.status === 'passed' ? 'bg-green-100 text-green-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status.charAt(0).toUpperCase() + proposal.status.slice(1)}
        </span>
      </div>

      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span>Progress</span>
          <span>{calculateProgress(proposal.votesFor, proposal.votesAgainst).toFixed(1)}%</span>
        </div>
        <Progress 
          value={calculateProgress(proposal.votesFor, proposal.votesAgainst)} 
          className="h-2"
        />
        
        <div className="flex justify-between text-sm text-gray-600">
          <span>For: {proposal.votesFor}</span>
          <span>Against: {proposal.votesAgainst}</span>
        </div>

        <div className="flex justify-between items-center mt-4">
          <div className="text-sm text-gray-600">
            <p>Created by: {proposal.createdBy}</p>
            <p>Ends: {new Date(proposal.endsAt).toLocaleDateString()}</p>
          </div>
          {proposal.status === 'active' && (
            <Button className="space-x-2">
              <span>Vote Now</span>
              <ChevronRight className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </Card>
  )

  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Active Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.activeProposals}</h3>
              </div>
              <AlertCircle className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Participation Rate</p>
                <h3 className="text-2xl font-bold">{votingStats.participationRate}%</h3>
              </div>
              <Users className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-gray-500">Total Proposals</p>
                <h3 className="text-2xl font-bold">{votingStats.totalProposals}</h3>
              </div>
              <TrendingUp className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Voting Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={votingStats.monthlyVotes}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="votes" 
                  stroke="#8884d8"
                  strokeWidth={2}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Proposals</CardTitle>
        </CardHeader>
        <CardContent>
          <Tabs value={selectedTab} onValueChange={setSelectedTab}>
            <TabsList>
              <TabsTrigger value="active">Active</TabsTrigger>
              <TabsTrigger value="passed">Passed</TabsTrigger>
              <TabsTrigger value="rejected">Rejected</TabsTrigger>
            </TabsList>

            <TabsContent value="active" className="space-y-4">
              {proposals
                .filter(p => p.status === 'active')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="passed" className="space-y-4">
              {proposals
                .filter(p => p.status === 'passed')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>

            <TabsContent value="rejected" className="space-y-4">
              {proposals
                .filter(p => p.status === 'rejected')
                .map(proposal => (
                  <ProposalCard key={proposal.id} proposal={proposal} />
                ))}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>

      <Alert>
        <AlertDescription>
          You currently have {proposals[0]?.delegatedVotes || 0} votes delegated to you. 
          Visit the delegation page to manage your voting power.
        </AlertDescription>
      </Alert>
    </div>
  )
}

export default GovernanceDashboard

===================
File: ./frontend/src/components/consensus/ConsensusMonitor.tsx
===================
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';

type ConsensusStatus = 'Proposing' | 'Voting' | 'Finalizing' | 'Completed' | 'Failed';

interface ConsensusUpdate {
  round_number: number;
  status: ConsensusStatus;
  coordinator: string;
  votes_count: number;
}

interface BlockFinalized {
  block_number: number;
  transactions_count: number;
  timestamp: number;
}

interface ReputationUpdate {
  did: string;
  change: number;
  new_total: number;
}

interface ErrorMessage {
  code: string;
  message: string;
}

interface WebSocketMessage {
  type: 'ConsensusUpdate' | 'BlockFinalized' | 'ReputationUpdate' | 'Error';
  data: ConsensusUpdate | BlockFinalized | ReputationUpdate | ErrorMessage;
}

const ConsensusMonitor: React.FC = () => {
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);
  const [connected, setConnected] = useState(false);
  const ws = useRef<WebSocket | null>(null);

  useEffect(() => {
    // Get DID from local storage or context
    const did = localStorage.getItem('userDid') || 'default-did';

    const connectWebSocket = () => {
      try {
        ws.current = new WebSocket('ws://localhost:8080/ws');
        
        ws.current.onopen = () => {
          setConnected(true);
          // Send DID in a message after connection
          ws.current?.send(JSON.stringify({ type: 'identify', did }));
        };

        ws.current.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            setMessages((prev) => [...prev, message].slice(-5)); // Keep last 5 messages
          } catch (e) {
            console.error('Failed to parse WebSocket message:', e);
          }
        };

        ws.current.onclose = () => {
          setConnected(false);
          // Try to reconnect after 5 seconds
          setTimeout(connectWebSocket, 5000);
        };

        ws.current.onerror = (error) => {
          console.error('WebSocket error:', error);
          ws.current?.close();
        };
      } catch (error) {
        console.error('Failed to establish WebSocket connection:', error);
        setTimeout(connectWebSocket, 5000);
      }
    };

    connectWebSocket();

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const renderConsensusUpdate = (data: ConsensusUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Consensus Round {data.round_number}</p>
          <Badge variant={
            data.status === 'Completed' ? 'default' :
            data.status === 'Failed' ? 'destructive' :
            'secondary'
          }>
            {data.status}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">Coordinator: {data.coordinator}</p>
        <p className="text-sm text-gray-600">Votes: {data.votes_count}</p>
      </CardContent>
    </Card>
  );

  const renderBlockFinalized = (data: BlockFinalized) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">New Block #{data.block_number}</p>
          <Badge>Finalized</Badge>
        </div>
        <p className="text-sm text-gray-600">Transactions: {data.transactions_count}</p>
        <p className="text-sm text-gray-600">
          Time: {new Date(data.timestamp * 1000).toLocaleString()}
        </p>
      </CardContent>
    </Card>
  );

  const renderReputationUpdate = (data: ReputationUpdate) => (
    <Card className="mb-4">
      <CardContent className="pt-6">
        <div className="flex justify-between items-start mb-2">
          <p className="font-medium">Reputation Change</p>
          <Badge variant={data.change > 0 ? 'default' : 'destructive'}>
            {data.change > 0 ? '+' : ''}{data.change}
          </Badge>
        </div>
        <p className="text-sm text-gray-600">DID: {data.did}</p>
        <p className="text-sm text-gray-600">New Total: {data.new_total}</p>
      </CardContent>
    </Card>
  );

  const renderMessage = (message: WebSocketMessage) => {
    switch (message.type) {
      case 'ConsensusUpdate':
        return renderConsensusUpdate(message.data as ConsensusUpdate);
      case 'BlockFinalized':
        return renderBlockFinalized(message.data as BlockFinalized);
      case 'ReputationUpdate':
        return renderReputationUpdate(message.data as ReputationUpdate);
      case 'Error':
        const errorData = message.data as ErrorMessage;
        return (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>
              Error {errorData.code}: {errorData.message}
            </AlertDescription>
          </Alert>
        );
      default:
        return null;
    }
  };

  return (
    <div className="space-y-4 p-4">
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle>Consensus Monitor</CardTitle>
            <Badge variant={connected ? "default" : "destructive"}>
              {connected ? 'Connected' : 'Disconnected'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {messages.map((msg, i) => (
              <div key={i}>{renderMessage(msg)}</div>
            ))}
            {messages.length === 0 && (
              <p className="text-gray-500 text-center py-4">
                No consensus updates yet
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ConsensusMonitor;

===================
File: ./backend/Cargo.toml
===================
[package]
name = "icn-backend"
version = "0.1.0"
edition = "2021"

[[example]]
name = "blockchain_test"
path = "examples/blockchain_test.rs"

[[example]]
name = "ws_client"
path = "examples/ws_client.rs"

[[example]]
name = "integration_test"
path = "examples/integration_test.rs"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
warp = "0.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
futures = "0.3"
futures-util = "0.3"
rand = "0.8"
secp256k1 = { version = "0.24.3", features = ["rand"] }
sha2 = "0.10"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
tokio-tungstenite = "0.20"
url = "2.4"
http = "0.2"

[dev-dependencies]
tokio-tungstenite = { version = "0.20", features = ["native-tls"] }
url = "2.4"
http = "0.2"

===================
File: ./frontend/package.json
===================


===================
File: ./frontend/tsconfig.json
===================


===================
File: ./docker/docker-compose.yml
===================
version: '3.8'

services:
  backend:
    build:
      context: ../backend                        # Path to the backend source with Cargo.toml
      dockerfile: ../docker/backend.Dockerfile   # Path to backend Dockerfile in `docker`
    ports:
      - "8081:8081"  # WebSocket
    environment:
      - DATABASE_URL=postgres://icnuser:icnpass@db:5432/icndb

  frontend:
    build:
      context: ../frontend                       # Path to frontend source code
      dockerfile: ../docker/frontend.Dockerfile  # Path to frontend Dockerfile in `docker`
    ports:
      - "3000:3000"

  db:
    image: postgres:latest
    environment:
      POSTGRES_USER: icnuser
      POSTGRES_PASSWORD: icnpass
      POSTGRES_DB: icndb
    ports:
      - "5432:5432"

  docs:
    image: squidfunk/mkdocs-material:latest
    volumes:
      - ../docs:/docs
    ports:
      - "8000:8000"
    working_dir: /docs
    command: serve -a 0.0.0.0:8000

===================
File: ./docker/backend.Dockerfile
===================
# backend.Dockerfile

# Stage 1: Build the Rust app
FROM rust:1.71.0 AS builder

WORKDIR /app

# Copy Cargo.toml and Cargo.lock
COPY Cargo.toml Cargo.lock ./

# Build dependencies
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release
RUN rm -rf src

# Copy the rest of the project
COPY . .

# Build the project
RUN cargo build --release
RUN cargo test --release

# Stage 2: Create a smaller image to run the binary
FROM debian:bullseye-slim AS runner
WORKDIR /app
COPY --from=builder /app/target/release/icn-backend /usr/local/bin/icn-backend

EXPOSE 8081

CMD ["icn-backend"]


===================
File: ./docker/frontend.Dockerfile
===================
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
CMD ["npm", "start"]


===================
File: ./docs/docs/index.md
===================
# Welcome to MkDocs

For full documentation visit [mkdocs.org](https://www.mkdocs.org).

## Commands

* `mkdocs new [dir-name]` - Create a new project.
* `mkdocs serve` - Start the live-reloading docs server.
* `mkdocs build` - Build the documentation site.
* `mkdocs -h` - Print help message and exit.

## Project layout

    mkdocs.yml    # The configuration file.
    docs/
        index.md  # The documentation homepage.
        ...       # Other markdown pages, images and other files.


===================
File: ./docs/guides/index.md
===================
# User Guides

The following guides provide step-by-step instructions for using the ICN platform effectively.

## Contents
- [Getting Started](getting-started.md): Introduction to accessing and navigating the ICN platform.
- [Governance Guide](governance-guide.md): Detailed steps on participating in cooperative governance.
- [Reputation Management](reputation-management.md): Overview of how reputation influences roles and decision-making.

Additional guides will cover specific ICN features and best practices.


===================
File: ./docs/INDEX.md
===================
# Documentation Index


## Specification

- [Reputation System](specifications/core/2024-11-01-reputation-system.md) (v1.0.0, draft)


===================
File: ./docs/user/guides/resource-management.md
===================
# Resource Management Guide

## Introduction
Resource management within ICN allows cooperatives to allocate, share, and track resources efficiently. This guide covers the steps for creating resources, allocating them within a cooperative, and monitoring usage.

## Step 1: Create a Resource
1. Go to the Cooperative Resource tab.
2. Select “Create Resource” and provide details:
   - **Resource Type**: Define the type (e.g., funds, materials).
   - **Allocation**: Set initial availability and allocation limits.

## Step 2: Allocate Resource to Cooperative Members
1. Navigate to the Resource Allocation tab.
2. Select the resource and member(s) to allocate.
3. Set allocation limits based on cooperative needs.

## Step 3: Monitor Resource Usage
Regularly check the resource usage dashboard:
- **Allocated Resources**: Overview of allocated resources and remaining capacity.
- **Usage Trends**: Track member usage patterns to optimize future allocations.

## Tips for Effective Resource Management
- **Set Clear Limits**: Prevent overuse by establishing maximum allocations.
- **Review Allocation Periodically**: Adjust allocations based on changing cooperative needs.
- **Encourage Resource Sharing**: Promote shared resource access among members to maximize utility.


===================
File: ./docs/user/guides/index.md
===================


===================
File: ./docs/user/guides/onboarding-guide.md
===================

---

### `onboarding-guide.md` (Under `user/guides/`)

```markdown
# ICN Onboarding Guide

## Introduction
Welcome to the ICN platform! This guide walks you through creating a DID, joining a cooperative, and participating in governance.

## Step 1: Create Your DID
DIDs are the basis of ICN’s secure interactions. To create a DID:
1. Access the ICN Identity page.
2. Click “Generate DID.”
3. Copy your DID identifier and public key for future reference.

## Step 2: Join a Cooperative
1. Go to the Cooperative Directory.
2. Select a cooperative and click “Join.”
3. Complete the required fields, then submit your request.
   - **Note**: Some cooperatives require a minimum reputation score for entry.

## Step 3: Participate in Governance
As a cooperative member, you can vote on proposals:
1. Go to the Governance Dashboard.
2. View active proposals and click “Vote” on issues that matter to you.
3. Your reputation will influence the weight of your vote.

## Tips for New Members
- **Increase Reputation**: Engage in cooperative activities to boost your influence.
- **Track Notifications**: Stay updated on proposal deadlines to maximize participation.


===================
File: ./docs/development/guides/documentation-standards.md
===================
# Documentation Standards

## File Organization

- Use appropriate directory for document type
- Follow naming conventions
- Include required metadata

## Writing Style

- Be clear and concise
- Include code examples where appropriate
- Keep documentation up to date
- Use proper Markdown formatting

## Review Process

1. Create new document using tools
2. Submit for review
3. Address feedback
4. Update documentation index

## Templates

Use provided templates in `docs/templates/` for new documents.


===================
File: ./docs/README.md
===================
# ICN Documentation

## Structure

- `architecture/` - System architecture documentation
- `specifications/` - Technical specifications
- `development/` - Development guides and plans
- `user/` - User documentation and tutorials

## Getting Started

1. Install documentation tools:
   ```bash
   cd tools
   pip install -r requirements.txt
   ```

2. Generate documentation index:
   ```bash
   python tools/doctools/docmanager.py index
   ```

## Documentation Standards

Please refer to `development/guides/documentation-standards.md` for our documentation guidelines.


===================
File: ./docs/templates/protocol-template.md
===================
# {title} Protocol Specification

## 1. Protocol Overview

### 1.1 Purpose

### 1.2 Flow

## 2. Message Formats

## 3. State Machine

## 4. Security Model

## 5. Implementation Guidelines

## 6. Compatibility Requirements

## 7. Future Extensions


===================
File: ./docs/templates/api-template.md
===================
# {title} API Specification

## 1. API Overview

### 1.1 Purpose

### 1.2 Endpoints

## 2. Authentication

## 3. Endpoints Detail

## 4. Error Handling

## 5. Rate Limiting

## 6. Security Considerations

## 7. Example Usage


===================
File: ./docs/templates/core-component-template.md
===================
# {title}

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations


===================
File: ./docs/specifications/api/governance-api.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance API
type: api
version: 1.0.0
---

# Governance API

## Overview

### Purpose
The Governance API enables ICN members to submit, view, and vote on proposals. Each action requires DID-based access control and reputation permissions.

## Endpoints

### Create Proposal
- **Endpoint**: `POST /api/governance/proposals`
- **Request Body**:
  ```json
  {
    "proposal_type": "Funding",
    "description": "Allocate resources for new development",
    "duration": 60
  }


===================
File: ./docs/specifications/core/transaction-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-04'
status: draft
title: Transaction Lifecycle System
type: specification
version: 1.0.0
---

# Transaction Lifecycle System

## Overview
The Transaction Lifecycle System provides a secure, traceable, and immutable process for handling all cooperative transactions within the ICN. This document details the lifecycle of a transaction, from initiation and validation to finalization and storage in the blockchain. The system is designed to ensure consistency, security, and transparency in all cooperative actions.

### Purpose
- **Immutability**: Maintain a secure and unalterable record of all transactions.
- **Traceability**: Allow cooperatives to track resource allocation, proposal voting, and other actions.
- **Accountability**: Ensure all actions align with ICN's governance standards through DID and reputation validation.

### Components Involved
- **Blockchain Module**: Manages the chain of blocks where transactions are stored.
- **DID System**: Verifies the identities of transaction participants.
- **Reputation System**: Validates that users have the necessary reputation to execute actions.

---

## 1. Transaction Lifecycle

### 1.1 Transaction Initiation

1. **Process**:
   - A transaction is created with the following attributes: `sender`, `receiver`, `amount`, `timestamp`, and `purpose`.
   - A unique transaction hash is generated using `SHA-256` to prevent duplicates.

2. **Validation**:
   - The transaction undergoes an initial validation to confirm that the `sender` has a valid DID and that the specified `amount` respects the cooperative’s resource allocation limits.

3. **Attributes**:
   - **Sender**: The DID of the transaction initiator.
   - **Receiver**: The DID of the transaction recipient.
   - **Amount**: The value/resource quantity being transferred.
   - **Timestamp**: Millisecond timestamp of transaction initiation.
   - **Purpose**: A brief description of the transaction’s intent.

### 1.2 Transaction Validation

1. **DID Verification**:
   - Ensure that both the `sender` and `receiver` have valid DIDs. Invalid or nonexistent DIDs will cause the transaction to fail validation.
   
2. **Reputation Check**:
   - Confirm that the `sender` meets any minimum reputation thresholds required by the transaction type.
   - If the reputation requirement is not met, the transaction is rejected with an error.

3. **Signature Verification**:
   - The transaction must be signed by the `sender`’s key, verified using ECC (secp256k1) or, when specified, quantum-resistant keys (CRYSTALS-Dilithium).
   
4. **Timestamp Verification**:
   - Check that the `timestamp` is valid and aligns with recent blockchain activity to prevent replay attacks.

### 1.3 Transaction Processing

1. **Hashing**:
   - Calculate a unique hash for the transaction, incorporating attributes like `sender`, `receiver`, `amount`, and `timestamp`.
   
2. **Pending Pool**:
   - Place the validated transaction in the pending transactions pool until a new block is finalized.

### 1.4 Block Finalization

1. **Block Creation**:
   - At defined intervals or upon reaching a set number of transactions, pending transactions are bundled into a new block.
   
2. **Block Hashing**:
   - A hash of the new block is computed, linking it to the previous block for chain integrity.
   
3. **Chain Update**:
   - The finalized block is added to the blockchain, and the pending transactions pool is cleared.

---

## 2. Data Structures

### 2.1 Transaction Object

```rust
Transaction {
    sender: String,
    receiver: String,
    amount: u64,
    timestamp: u128,
    hash: String,
}


===================
File: ./docs/specifications/core/vm-system.md
===================
Certainly! Here's the expanded documentation for the Virtual Machine (VM), written in Markdown format and enclosed within a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/vm-system.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Virtual Machine (VM)
type: specification
version: 1.1.0
---

# Virtual Machine (VM) Specification

## 1. Overview

### 1.1 Purpose

The Virtual Machine (VM) is a core component of the Inter-Cooperative Network (ICN), responsible for executing cooperative-specific smart contracts. It interprets a set of predefined OpCodes, allowing for a range of operations that support governance, resource allocation, reputation management, and cooperative administration.

### 1.2 Core Components

- **Instruction Set**: A collection of OpCodes defining operations the VM can execute.
- **Execution Engine**: Processes instructions, manages the stack, memory, and control flow.
- **Security Mechanisms**: Enforces permissions, reputation requirements, and resource limits.
- **Event System**: Generates events during execution for logging and auditing.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 OpCode Enumeration

Defines the set of operations supported by the VM, categorized by functionality:

- **Arithmetic Operations**
  - `Add`, `Sub`, `Mul`, `Div`, `Mod`
- **Stack Operations**
  - `Push`, `Pop`, `Dup`, `Swap`
- **Memory Operations**
  - `Store`, `Load`
- **Control Flow Operations**
  - `Jump`, `JumpIf`, `Call`, `Return`
- **Cooperative Operations**
  - `CreateCooperative`, `JoinCooperative`, `LeaveCooperative`, `AllocateResource`, `TransferResource`
- **Governance Operations**
  - `CreateProposal`, `CastVote`, `DelegateVotes`, `ExecuteProposal`, `UpdateQuorum`
- **Reputation Operations**
  - `UpdateReputation`, `GetReputation`
- **Identity Operations**
  - `VerifyDID`, `UpdateDIDDocument`
- **System Operations**
  - `Log`, `Halt`, `EmitEvent`, `GetTimestamp`, `GetCaller`

#### 2.1.2 Contract Structure

```rust
struct Contract {
    id: String,
    code: Vec<(OpCode, Option<i64>)>,
    state: HashMap<String, i64>,
    required_reputation: i64,
    cooperative_metadata: CooperativeMetadata,
    version: String,
    dependencies: Vec<String>,
    permissions: Vec<String>,
}
```

- **id**: Unique identifier for the contract.
- **code**: Sequence of OpCodes and optional arguments.
- **state**: Persistent state specific to the contract.
- **required_reputation**: Minimum reputation required to execute the contract.
- **cooperative_metadata**: Metadata providing context for the cooperative.
- **version**: Contract versioning for updates and compatibility.
- **dependencies**: List of other contracts or libraries required.
- **permissions**: Access control permissions required.

#### 2.1.3 Execution Context

```rust
struct ExecutionContext {
    caller_did: String,
    cooperative_id: String,
    timestamp: u64,
    block_number: u64,
    reputation_score: i64,
    permissions: Vec<String>,
}
```

- **caller_did**: DID of the entity invoking the contract.
- **cooperative_id**: Identifier of the cooperative context.
- **timestamp**: Current timestamp of execution.
- **block_number**: Blockchain block number.
- **reputation_score**: Reputation score of the caller.
- **permissions**: Permissions of the caller.

### 2.2 Interfaces

#### 2.2.1 VM Methods

##### Execute Contract

- **Purpose**: Executes a contract from start to finish, enforcing all constraints.
- **Input**: `Contract`, `ExecutionContext`
- **Process**:
  1. **Permission Check**: Verify caller has necessary permissions.
  2. **Reputation Validation**: Ensure caller's reputation meets the requirement.
  3. **Initialize Stack and Memory**: Set up execution environment.
  4. **Instruction Execution**: Process OpCodes sequentially.
  5. **Event Emission**: Generate events as specified.
  6. **State Update**: Persist any changes to the contract state.
- **Output**: Execution result, updated state, events generated.

##### Execute Instruction

- **Purpose**: Processes a single OpCode and modifies the VM state accordingly.
- **Input**: `OpCode`, `Option<i64>`
- **Process**:
  - Handle operation based on the type of OpCode.
  - Update stack, memory, or control flow as needed.
- **Output**: Updated VM state.

### 2.3 Behaviors

#### 2.3.1 Stack Management

- **Structure**: LIFO (Last-In-First-Out) stack of 64-bit integers.
- **Operations**:
  - **Push**: Add value to the top of the stack.
  - **Pop**: Remove and return the top value.
  - **Dup**: Duplicate the top value.
  - **Swap**: Swap the top two values.

#### 2.3.2 Memory Management

- **Structure**: Key-value store (`HashMap<String, i64>`) for temporary storage.
- **Operations**:
  - **Store**: Save a value with a specified key.
  - **Load**: Retrieve a value by key.

#### 2.3.3 Control Flow

- **Jump**: Redirect execution to a specific instruction index.
- **JumpIf**: Conditional jump based on the top of the stack.
- **Call**: Invoke a function or subroutine.
- **Return**: Exit from a function or contract execution.

#### 2.3.4 Error Handling

- **Exception Types**:
  - **Stack Underflow/Overflow**
  - **Invalid Opcode**
  - **Permission Denied**
  - **Reputation Insufficient**
  - **Runtime Errors**: Division by zero, invalid memory access.

- **Handling Strategy**:
  - Execution halts on errors.
  - Generate error events with detailed messages.
  - Rollback any state changes made during execution.

### 2.4 Security Model

- **Reputation Enforcement**: Contracts specify minimum reputation; the VM enforces this before execution.
- **Permission Checks**: Caller permissions are validated against contract requirements.
- **Resource Limits**:
  - **Instruction Limit**: Maximum number of instructions per execution to prevent infinite loops.
  - **Stack Depth Limit**: Prevent stack overflows.
  - **Memory Usage Limit**: Cap on memory allocation.

- **Isolation**: Each contract execution is sandboxed, preventing interference with other contracts or global state.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Efficiency**: Optimize instruction execution for speed.
- **Scalability**: Handle multiple concurrent executions.
- **Lightweight**: Minimize resource consumption.

### 3.2 Security Requirements

- **Determinism**: Ensure contract execution is deterministic across all nodes.
- **Validation**: Strictly validate all inputs and OpCodes.
- **Auditability**: Maintain detailed logs and event histories.

### 3.3 Error Handling

- **Graceful Termination**: Contracts should fail safely without crashing the VM.
- **Clear Messaging**: Provide informative error messages for debugging.

## 4. Testing Requirements

- **Unit Tests**: Cover individual OpCodes and VM operations.
- **Integration Tests**: Test full contract executions in various scenarios.
- **Security Tests**: Include tests for permission enforcement and reputation checks.
- **Performance Tests**: Benchmark execution times and resource usage.

## 5. Monitoring and Metrics

- **Execution Logs**: Record each instruction executed.
- **Event Logs**: Capture all events emitted during execution.
- **Error Logs**: Record detailed information about any errors encountered.
- **Metrics**:
  - Execution time per contract.
  - Resource usage statistics.
  - Frequency of specific OpCodes.

## 6. Future Considerations

- **Extensibility**: Allow for new OpCodes and features to be added.
- **Language Support**: Develop higher-level languages that compile down to VM bytecode.
- **Interoperability**: Enable interaction with contracts on other blockchains or VMs.
- **Optimizations**: Implement Just-In-Time (JIT) compilation or other optimizations.

## Appendix

### A. OpCode Definitions

Provide detailed descriptions of each OpCode, including its function, expected stack state, and any arguments.

#### A.1 Arithmetic Operations

- **Add**
  - **Function**: Pops two values from the stack, pushes their sum.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a + b ]`
- **Sub**
  - **Function**: Pops two values, pushes the result of `a - b`.
  - **Stack Before**: `[ ... , a, b ]`
  - **Stack After**: `[ ... , a - b ]`
- *(Continue for other arithmetic OpCodes)*

#### A.2 Stack Operations

- *(Define `Push`, `Pop`, `Dup`, `Swap`)*

#### A.3 Memory Operations

- **Store**
  - **Function**: Stores a value in memory with a specified key.
  - **Arguments**: Key (from stack or instruction argument).
  - **Operation**:
    1. Pop value from stack.
    2. Use key to store the value in memory.

- **Load**
  - **Function**: Loads a value from memory onto the stack.
  - **Arguments**: Key.
  - **Operation**:
    1. Retrieve value associated with key.
    2. Push value onto the stack.

#### A.4 Control Flow Operations

- *(Define `Jump`, `JumpIf`, `Call`, `Return`)*

#### A.5 Cooperative Operations

- **CreateCooperative**
  - **Function**: Initiates a new cooperative.
  - **Requirements**: Caller must have sufficient reputation and permissions.
  - **Effect**: Emits `CooperativeCreated` event.

- *(Continue for other cooperative OpCodes)*

#### A.6 Governance Operations

- *(Define `CreateProposal`, `CastVote`, etc.)*

#### A.7 System Operations

- **Log**
  - **Function**: Logs a message or value for debugging.
  - **Operation**:
    1. Pop value from stack.
    2. Record value in execution logs.

- **Halt**
  - **Function**: Stops execution of the contract.
  - **Effect**: Returns control to the caller.

## References

- **ICN Architecture Overview**
- **Reputation System Specification**
- **Governance System Specification**

```

---

You can save this file as `vm-system.md` in your `./docs/specifications/core/` directory.

**Next Steps:**

- **Review the OpCode Definitions:** Ensure that all required operations are defined and that their behaviors align with the needs of your cooperatives.
- **Expand the Appendix:** Add detailed definitions for each OpCode, especially for custom cooperative and governance operations.
- **Integrate with Other Systems:** Cross-reference with the Identity System and Reputation System specifications to ensure consistent interactions.
- **Implement Security Measures:** Consider any additional security requirements specific to your use case.

**Let me know if you'd like to further refine any section or if you have additional components you'd like to develop!**

===================
File: ./docs/specifications/core/2024-11-01-reputation-system.md
===================
---
authors:
- Developer Name
date: '2024-11-01'
last_updated: '2024-11-01 00:48:30'
related_docs: []
reviewers:
- Tech Lead
status: draft
title: Reputation System
type: specification
version: 1.0.0

---

# Reputation System

## 1. Overview

### 1.1 Purpose

### 1.2 Core Components

## 2. Detailed Specifications

### 2.1 Data Structures

### 2.2 Interfaces

### 2.3 Behaviors

## 3. Implementation Guidelines

### 3.1 Performance Requirements

### 3.2 Security Requirements

### 3.3 Error Handling

## 4. Testing Requirements

## 5. Monitoring and Metrics

## 6. Future Considerations



===================
File: ./docs/specifications/core/identity-system.md
===================
Apologies for the oversight. Here is the complete documentation for the Identity System, entirely within a code block so you can easily copy and paste it into your documentation folder.

---

**File: `./docs/specifications/core/identity-system.md`**

```markdown
---
authors:
  - Your Name
date: '2024-11-03'
status: draft
title: Identity System
type: specification
version: 1.0.0
---

# Identity System Specification

## 1. Overview

### 1.1 Purpose

The Identity System is responsible for managing Decentralized Identifiers (DIDs) within the Inter-Cooperative Network (ICN). It ensures secure authentication and authorization for users, cooperatives, and nodes by leveraging cryptographic key pairs. The system supports both Elliptic Curve Cryptography (ECC) and quantum-resistant algorithms to future-proof security.

### 1.2 Core Components

- **DID Management**: Creation, retrieval, and update of DIDs.
- **Authentication Service**: Verifies identities through cryptographic signatures.
- **Authorization Mechanism**: Controls access to resources based on roles and permissions.

## 2. Detailed Specifications

### 2.1 Data Structures

#### 2.1.1 DID Document

```json
{
  "id": "did:icn:unique_identifier",
  "publicKey": "base64_encoded_public_key",
  "authentication": "authentication_method",
  "created": "timestamp",
  "updated": "timestamp"
}
```

- **id**: Unique identifier following the `did:icn:` namespace.
- **publicKey**: The public key associated with the DID, encoded in base64.
- **authentication**: Method used for verifying the DID owner.
- **created**: Timestamp of when the DID was created.
- **updated**: Timestamp of the last update to the DID document.

### 2.2 Interfaces

#### 2.2.1 API Endpoints

##### Create DID

- **Endpoint**: `POST /api/identity/did`
- **Description**: Registers a new DID in the network.
- **Request Body**:

  ```json
  {
    "publicKey": "base64_encoded_public_key"
  }
  ```

- **Response**:

  ```json
  {
    "did": "did:icn:unique_identifier"
  }
  ```

##### Resolve DID

- **Endpoint**: `GET /api/identity/did/{did}`
- **Description**: Retrieves the DID document for the specified DID.
- **Response**:

  ```json
  {
    "didDocument": {
      "id": "did:icn:unique_identifier",
      "publicKey": "base64_encoded_public_key",
      "authentication": "authentication_method",
      "created": "timestamp",
      "updated": "timestamp"
    }
  }
  ```

##### Authenticate

- **Endpoint**: `POST /api/identity/authenticate`
- **Description**: Verifies the identity and issues an authentication token.
- **Request Body**:

  ```json
  {
    "did": "did:icn:unique_identifier",
    "signature": "base64_encoded_signature",
    "nonce": "server_provided_nonce"
  }
  ```

- **Response**:

  ```json
  {
    "token": "jwt_token"
  }
  ```

### 2.3 Behaviors

#### 2.3.1 DID Creation Workflow

1. **Key Generation**: The user generates a key pair locally, choosing between ECC or quantum-resistant algorithms.
2. **Public Key Submission**: The user sends the public key to the Identity System via the `Create DID` endpoint.
3. **DID Registration**: The system creates a unique DID, stores the DID document, and returns the DID to the user.

#### 2.3.2 Authentication Workflow

1. **Nonce Request**: The user requests a nonce from the server to prevent replay attacks.
2. **Signature Generation**: The user signs the nonce with their private key.
3. **Authentication Request**: The user sends the DID, signature, and nonce to the server.
4. **Verification**: The server verifies the signature using the public key from the DID document.
5. **Token Issuance**: Upon successful verification, the server issues a JWT token for authenticated sessions.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Scalability**: The system should handle a large number of DID registrations and authentication requests concurrently.
- **Low Latency**: Authentication and DID resolution should occur with minimal delay to ensure a smooth user experience.

### 3.2 Security Requirements

- **Key Security**: Users must securely store their private keys; the system should never have access to private keys.
- **Replay Attack Prevention**: Use nonces or timestamps during authentication to prevent replay attacks.
- **Quantum Resistance**: Support for quantum-resistant algorithms like CRYSTALS-Dilithium and CRYSTALS-Kyber should be implemented to future-proof the system.

### 3.3 Error Handling

- **Detailed Error Messages**: Provide clear and actionable error messages without revealing sensitive information.
- **Failure Modes**: Gracefully handle failures in DID creation, resolution, and authentication.

## 4. Testing Requirements

- **Unit Tests**: Cover all functions related to DID management and authentication.
- **Integration Tests**: Test the interaction between the Identity System and other modules like the Reputation System and Governance Module.
- **Security Tests**: Perform vulnerability assessments and penetration testing to ensure robust security measures are in place.

## 5. Monitoring and Metrics

- **Audit Logs**: Maintain logs for DID creation, updates, and authentication attempts for auditing purposes.
- **Performance Metrics**: Monitor response times for API endpoints and system load.
- **Security Alerts**: Implement alerts for suspicious activities, such as repeated failed authentication attempts.

## 6. Future Considerations

- **DID Deactivation**: Provide a mechanism for users to deactivate or revoke their DIDs in case of key compromise.
- **Metadata Integration**: Include optional metadata in DID documents, such as reputation scores and cooperative affiliations.
- **Cross-Network Compatibility**: Ensure the Identity System is compatible with other decentralized networks for broader interoperability.
```

---

You can save this file as `identity-system.md` in your `./docs/specifications/core/` directory.

Would you like me to provide documentation for other components as well? If so, please let me know which one you'd like to work on next, and I'll prepare it accordingly.

===================
File: ./docs/specifications/core/proof-of-cooperation.md
===================
Certainly! Here is the documentation for the **Proof of Cooperation Consensus Mechanism**, focusing on security mechanisms, blockchain components, and efficiency considerations. The documentation is written in Markdown format and enclosed in a code block so you can easily paste it into your documentation folder.

---

**File: `./docs/specifications/core/proof-of-cooperation.md`**

```markdown
---
authors:
  - Matt Faherty
date: '2024-11-03'
status: draft
title: Proof of Cooperation Consensus Mechanism
type: specification
version: 1.0.0
---

# Proof of Cooperation (PoC) Consensus Mechanism

## 1. Overview

### 1.1 Purpose

The Proof of Cooperation (PoC) is a consensus mechanism designed specifically for the Inter-Cooperative Network (ICN) to facilitate secure, efficient, and cooperative blockchain operations. Unlike traditional consensus mechanisms such as Proof of Work (PoW) or Proof of Stake (PoS), PoC emphasizes collaboration, democratic participation, and reputation-based accountability to align with cooperative principles.

### 1.2 Core Principles

- **Democratic Participation**: Ensures inclusive decision-making by allowing each node, representing a cooperative or individual within ICN, to contribute to consensus.
- **Incentivized Cooperation**: Rewards are based on positive contributions to the cooperative ecosystem rather than computational power or wealth.
- **Reputation-Driven Accountability**: Reputation scores influence participation and voting power, holding nodes accountable to ethical standards.
- **Environmental Sustainability**: Eliminates energy-intensive computations, maintaining an energy-efficient model.

## 2. Detailed Specifications

### 2.1 System Components

#### 2.1.1 Node Types and Roles

- **Validator Nodes**: Nodes that meet certain cooperative engagement criteria (e.g., reputation threshold) and participate in validating transactions and blocks.
- **Observer Nodes**: Nodes that maintain a copy of the blockchain for transparency and auditing but do not participate in validation.
- **Coordinator Node**: A validator node selected per consensus round to organize and propose blocks. Selection is based on a weighted lottery tied to reputation scores.

#### 2.1.2 Reputation System Integration

- **Reputation-Weighted Voting**: Nodes with higher reputation have slightly increased influence in the consensus process, capped to prevent centralization.
- **Dynamic Recalibration**: Reputation scores adjust based on ongoing contributions and decay over time to encourage continuous engagement.

### 2.2 Consensus Process

#### 2.2.1 Transaction Verification

1. **Submission**: Nodes submit transactions to the network.
2. **Preliminary Checks**: The Coordinator Node performs initial validation of transactions.
3. **Broadcast**: Validated transactions are broadcasted to Validator Nodes for multi-signature approval.

#### 2.2.2 Voting Round Execution

1. **Block Proposal**: The Coordinator Node assembles a candidate block with selected transactions.
2. **Reputation-Weighted Voting**:
   - Each Validator Node votes on the proposed block.
   - Votes are weighted based on reputation scores.
   - Voting power is capped to prevent undue influence.
3. **Consensus Threshold**: A supermajority (e.g., 66%) of weighted votes is required for block approval.

#### 2.2.3 Block Finalization

1. **Multi-Signature Collection**: Validator Nodes sign the approved block.
2. **Block Addition**: The signed block is added to the blockchain and propagated to the network.
3. **Reputation Adjustment**: Validators gain reputation for participation or lose reputation for misconduct.

### 2.3 Security Mechanisms

#### 2.3.1 Cryptographic Security

- **Asymmetric Encryption**: Utilizes public/private key pairs for secure communication and transaction signing.
- **Digital Signatures**: Ensures authenticity and non-repudiation of transactions and blocks.
- **Hash Functions**: Employs secure hash algorithms for data integrity.

#### 2.3.2 Sybil Attack Prevention

- **Reputation Requirements**: High reputation thresholds for Validator Nodes make it difficult for malicious actors to gain influence.
- **Identity Verification**: DIDs are tied to real-world cooperative entities, adding authenticity.

#### 2.3.3 Byzantine Fault Tolerance

- **Consensus Thresholds**: Requires a supermajority for block approval, tolerating up to one-third faulty or malicious nodes.
- **Multi-Signature Validation**: Collective block signing prevents unilateral block creation.

#### 2.3.4 Double-Spending Prevention

- **Transaction Finality**: Once confirmed, transactions are immutable.
- **Sequential Ordering**: Transactions are time-stamped and ordered to prevent conflicts.

#### 2.3.5 Integrity Audits and Penalties

- **Automated Audits**: Regular checks ensure protocol compliance.
- **Reputation Penalties**: Misconduct results in reputation loss.
- **Node Exclusion**: Severe violations can lead to temporary or permanent removal.

#### 2.3.6 Quantum-Resistant Cryptography

- **Post-Quantum Algorithms**: Implements CRYSTALS-Kyber and CRYSTALS-Dilithium for future-proof security.

### 2.4 Blockchain Components

#### 2.4.1 Block Structure

- **Block Header**:
  - **Previous Block Hash**: Links the block to the chain.
  - **Merkle Root**: Summarizes all transactions.
  - **Timestamp**: Time of block creation.
  - **Coordinator Signature**: Validates the Coordinator Node's role.
- **Block Body**:
  - **Transactions**: List of validated transactions.
  - **Validator Signatures**: Multi-signatures from Validator Nodes.

#### 2.4.2 Transactions

- **Standard Transactions**: Asset transfers between participants.
- **Governance Transactions**: Proposals and votes for network changes.
- **Metadata**: Additional information for transparency.

#### 2.4.3 State Management

- **State Database**: Maintains current account states.
- **State Transitions**: Defined by executed transactions.

### 2.5 Efficiency Considerations

#### 2.5.1 Consensus Efficiency

- **Lightweight Process**: Eliminates energy-intensive computations.
- **Fast Finality**: Quick transaction confirmation due to cooperative agreement.

#### 2.5.2 Scalability Solutions

- **Sharding**: Divides the network into smaller groups process 
#### 2.5.3 Resource Optimization

- **Minimal Hardware Requirements**: Encourages broader participation.
- **Bandwidth Management**: Efficient protocols reduce network load.

## 3. Implementation Guidelines

### 3.1 Performance Requirements

- **Transaction Throughput**: Optimize for high throughput suitable for network demands.
- **Latency Minimization**: Ensure minimal delay in consensus rounds.

### 3.2 Security Requirements

- **Immutable Ledger**: Blocks are immutable once added.
- **Access Control**: Only authorized nodes can validate and propose blocks.
- **Data Integrity**: Secure cryptographic practices ensure data integrity.

### 3.3 Error Handling

- **Invalid Transactions**: Provide clear error messages upon rejection.
- **Fork Handling**: Establish protocols for resolving chain forks.

## 4. Testing Requirements

- **Unit Tests**: Cover consensus mechanisms, transaction validation, and security features.
- **Integration Tests**: Test interactions with other systems like the Identity and Reputation Systems.
- **Stress Tests**: Simulate high network load to test scalability.

## 5. Monitoring and Metrics

- **Consensus Monitoring**: Track consensus round performance and validator participation.
- **Security Audits**: Regular audits to detect and mitigate threats.
- **Performance Metrics**: Monitor transaction rates and block times.

## 6. Future Considerations

- **Consensus Mechanism Evolution**: Continuously evaluate and improve the PoC mechanism.
- **Interoperability**: Explore compatibility with other networks.
- **Smart Contract Integration**: Enhance cooperative functions through smart contracts.

```

---

You can save this file as `proof-of-cooperation.md` in your `./docs/specifications/core/` directory.

**Note:** This document provides a detailed specification of the Proof of Cooperation consensus mechanism, focusing on security mechanisms, blockchain components, and efficiency considerations, as per your request.

**Next Steps:**

- **Review and Edit**: Please review the document and make any necessary adjustments or additions specific to your project's needs.
- **Integration**: Incorporate this documentation into your project to guide development and ensure alignment with the designed consensus mechanism.

Let me know if you'd like assistance with any other components or further details.

===================
File: ./docs/specifications/core/reputation-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Reputation System
type: specification
version: 1.0.0
---

# Reputation System

## Overview
The Reputation System provides a non-transferable measure of trust and engagement within ICN. Reputation scores influence voting power, cooperative roles, and the ability to initiate proposals.

### Purpose
- **Incentivize Positive Behavior**: Encourage cooperative engagement and responsible voting.
- **Access Control**: Regulate participation based on reputation thresholds.
- **Transparent Governance**: Use reputation as a metric for cooperative influence.

## Data Structures

### Reputation System
- **scores**: `HashMap<String, i64>` - Maps DIDs to reputation scores.

### Reputation Score
- **Minimum**: Define lower thresholds to prevent negative reputation abuse.
- **Decay (planned)**: Implement periodic decay to maintain active engagement.

## Methods

### Increase Reputation
Increases reputation for actions like voting, creating proposals, or contributing resources.

### Decrease Reputation
Penalizes reputation for actions deemed harmful or against cooperative rules.

### Reward Voting Participation
Rewards active participation in voting, providing an incentive to engage in governance.

## Implementation Guidelines
- **Reputation Decay**: Decay inactive accounts periodically to prevent influence stagnation.
- **Thresholds**: Set thresholds for actions, e.g., minimum score for creating proposals.

## Monitoring and Metrics
- **Reputation Trends**: Track changes to analyze member engagement.
- **Vote Influence Analysis**: Record how reputation impacts voting outcomes.


===================
File: ./docs/specifications/core/blockchain-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Blockchain System
type: specification
version: 1.0.0
---

# Blockchain System

## Overview
The Blockchain System is the immutable ledger of the ICN, tracking all transactions, proposals, and reputation changes. Each cooperative or member transaction is recorded in the blockchain for transparency and traceability.

### Purpose
- **Transaction Integrity**: Ensures secure, tamper-resistant records of cooperative actions.
- **Reputation and Proposal Tracking**: Logs all reputation changes and governance activities.
- **Decentralized Ledger**: Provides a distributed record for cooperative actions and economic exchanges.

## Data Structures

### Block
- **index**: `u64` - Sequential block index.
- **previous_hash**: `String` - Hash of the previous block, linking it to the chain.
- **timestamp**: `u128` - Millisecond timestamp of creation.
- **transactions**: `Vec<Transaction>` - List of transactions included in the block.

### Transaction
- **sender**: `String` - DID of sender.
- **receiver**: `String` - DID of receiver.
- **amount**: `u64` - Value or resource exchanged.
- **hash**: `String` - Unique hash of the transaction, based on contents.

## Methods

### Add Transaction
Adds a new transaction to the pending list, verifying its contents before committing.

### Finalize Block
Bundles pending transactions into a block, calculating hash and adding to the blockchain.

### Calculate Hash
Computes the hash for each block, securing the data and linking blocks sequentially.

## Implementation Guidelines
- **Block Size Limit**: Define a maximum number of transactions per block to manage processing time.
- **Difficulty and Verification**: For scalability, adjust verification complexity based on load.

## Monitoring and Metrics
- **Transaction Throughput**: Measure number of transactions per block.
- **Hash Verification**: Track hash generation time to monitor performance.


===================
File: ./docs/specifications/core/governance-system.md
===================
---
authors:
- Matt Faherty
date: '2024-11-03'
status: draft
title: Governance System
type: specification
version: 1.0.0
---

# Governance System

## Overview
The Governance System enables cooperative members to create, vote on, and track proposals within ICN. Proposals coordinate resource allocations, policy changes, and initiatives through reputation-weighted voting.

### Purpose
- **Decentralized Decision-Making**: Empowers cooperatives with direct influence over decisions.
- **Transparent Proposal Tracking**: Manages proposals throughout their lifecycle.
- **Reputation-Based Voting**: Aligns voting power with user contributions and engagement.

## Data Structures

### Proposal
- **id**: `u64` - Unique proposal identifier.
- **type**: `ProposalType` - Enum indicating proposal type (e.g., Funding).
- **status**: `ProposalStatus` - Enum indicating status (e.g., Open, Closed).
- **votes**: `Vec<(String, i64)>` - List of votes, with voter DID and weighted reputation.

### ProposalHistory
- **proposals**: `VecDeque<Proposal>` - Queue of proposals.
- **notifications**: `VecDeque<String>` - Queue of notifications for proposal events.

## Methods

### Create Proposal
Creates a proposal, setting parameters (type, description, duration) and initializing with Open status.

### Vote on Proposal
Registers a vote, using weighted reputation for transparency.

### Close Proposal
Locks in the proposal’s results, preventing further votes.

### Send Voting Reminder
Sends notifications to prompt voting for proposals near closure.

## Implementation Guidelines
- **Reputation Requirements**: Define minimum reputation for creating and voting to ensure credibility.
- **Standard Proposal Types**: Classify proposal types (Funding, PolicyChange) for consistency.

## Monitoring and Metrics
- **Proposal Activity**: Track proposal creation and voting rates.
- **Outcome Recording**: Log vote distribution and final outcome for cooperative accountability.


===================
File: ./docs/architecture/backend.md
===================
# Backend Architecture

The ICN backend handles core blockchain operations, transaction processing, and governance functionalities.

## Modules
1. **Blockchain Module**: Manages the decentralized ledger for recording transactions.
2. **Identity and DID Module**: Handles DID (Decentralized Identifiers) for secure, pseudonymous interactions.
3. **Reputation System**: Tracks and manages reputation scores, influencing governance roles and decision-making.

## Data Flow
- **Transaction Lifecycle**: Transactions are submitted, validated, and recorded in the blockchain, with reputation updates.
- **Reputation Tracking**: User actions affect their reputation score, impacting cooperative influence.


===================
File: ./docs/architecture/overview.md
===================
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.
# Architecture Overview

The ICN (Inter-Cooperative Network) platform is designed to support decentralized and cooperative governance, resource allocation, and community-based decision-making. This document outlines the overarching architecture that powers the ICN platform.

## Key Components
- **Backend Services**: Provides core functionality, including blockchain operations, identity management, and governance processes.
- **Frontend Interface**: User-facing applications, including the Governance Dashboard and Cooperative Management.
- **Smart Contracts**: Custom cooperative-specific contracts handled by a virtual machine (VM).

## Interaction Flow
1. **User Actions**: Users initiate requests through the frontend.
2. **API Processing**: Requests are routed to backend services via secure API endpoints.
3. **Blockchain and VM**: Transactions are validated, and cooperative actions are processed on-chain.


===================
File: ./docs/architecture/diagrams/component/component.md
===================
# Component Diagram

This section provides a visual overview of the ICN's architectural components.

## Diagram
![Component Diagram](../images/component-diagram.png)

## Description
The ICN architecture is modular, allowing each component to function independently but interconnect to support cooperative and governance functionalities.
1. **Frontend Modules**: User interfaces for governance and cooperative management.
2. **API Gateway**: Manages communication between frontend and backend.
3. **Blockchain & VM**: Ensures secure transaction processing and execution of smart contracts.


===================
File: ./docs/architecture/diagrams/component.md
===================


