Project Code Dump - Generated Sun Dec  8 11:16:07 UTC 2024
======================================

LLM Context Information
======================
This is a distributed cooperative network system with the following key components:

Core Components:
- Backend: Rust-based node implementation
- Frontend: TypeScript/React web interface
- Contracts: Smart contracts for cooperative governance

Architecture Overview:
- Blockchain: Handles consensus and state management
- Identity: DID-based identity management
- Relationship: Tracks member interactions and relationships
- Reputation: Manages trust and reputation scores
- Governance: Handles proposals and voting
- WebSocket: Real-time communication layer

File Organization:
- /backend/src/: Core Rust implementation
- /frontend/src/: React frontend application
- /contracts/: Smart contract implementations
- /docker/: Deployment configurations

======================

Project Tree:
=============
.
├── Cargo.lock
├── Cargo.toml
├── ICN.code-workspace
├── contracts
│   ├── cooperative
│   │   └── src
│   └── governance
├── crates
│   ├── icn-consensus
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-core
│   │   ├── Cargo.lock
│   │   ├── Cargo.toml
│   │   ├── lib.rs,old
│   │   └── src
│   ├── icn-crypto
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-p2p
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-runtime
│   │   ├── Cargo.toml
│   │   └── src
│   ├── icn-storage
│   │   ├── Cargo.toml
│   │   ├── migrations
│   │   └── src
│   └── icn-types
│       ├── Cargo.toml
│       └── src
├── create_docs_dump.sh
├── docker
│   ├── backend.Dockerfile
│   ├── backend_new.Dockerfile
│   ├── docker-compose.yml
│   └── frontend.Dockerfile
├── frontend
│   ├── package.json
│   ├── src
│   │   ├── app
│   │   ├── components
│   │   ├── contexts
│   │   ├── hooks
│   │   ├── lib
│   │   └── styles
│   └── tsconfig.json
├── generate_code_dump.sh
├── icn_backup_20241207.tar.gz
├── improved-setup.sh
├── inventory_nodes.sh
├── old_src_backup
│   ├── api
│   │   ├── cooperative.rs
│   │   └── mod.rs
│   ├── blockchain
│   │   ├── block.rs
│   │   ├── chain.rs
│   │   ├── mod.rs
│   │   └── transaction.rs
│   ├── claims
│   │   └── mod.rs
│   ├── community
│   │   └── mod.rs
│   ├── config
│   ├── consensus
│   ├── cooperative
│   │   └── mod.rs
│   ├── governance
│   │   ├── mod.rs
│   │   └── proposal.rs
│   ├── identity
│   │   ├── authentication.rs
│   │   ├── did.rs
│   │   ├── identity_manager.rs
│   │   ├── identity_system.rs
│   │   ├── key_pair.rs
│   │   └── mod.rs
│   ├── lib.rs
│   ├── main.rs
│   ├── monitoring
│   │   ├── energy.rs
│   │   ├── metrics.rs
│   │   ├── mod.rs
│   │   ├── prometheus.rs
│   │   └── service.rs
│   ├── network
│   ├── relationship
│   │   ├── mod.rs
│   │   ├── models
│   │   ├── system.rs
│   │   └── types.rs
│   ├── reputation
│   │   ├── mod.rs
│   │   └── reputation_system.rs
│   ├── state
│   │   ├── merkle_tree.rs
│   │   ├── migrations.rs
│   │   ├── mod.rs
│   │   ├── persistence.rs
│   │   ├── state_migrations.rs
│   │   └── validation.rs
│   ├── storage
│   ├── utils
│   │   ├── mod.rs
│   │   └── notifications.rs
│   ├── vm
│   └── websocket
│       ├── backend.code-workspace
│       ├── handler.rs
│       └── mod.rs
├── project_code_dump.txt
├── project_docs_dump.txt
├── setup_and_run_script.sh
├── setup_docs.sh
├── setup_venv.sh
├── start_docs_server.sh
└── tools
    ├── README.md
    ├── activate-docs-env.sh
    ├── activate-docs-env.sh.bak
    ├── doctools
    │   ├── __init__.py
    │   ├── docmanager.py
    │   ├── docsctl
    │   ├── specgen.py
    │   └── venv
    ├── install_docsctl.sh
    └── requirements.txt

===================
File: ./docker/docker-compose.yml
Size: 829 bytes
Modified: 2024-11-20 22:07:42.247802666 +0000

===================

===================
File: ./crates/icn-storage/src/lib.rs
Size: 908 bytes
Modified: 2024-12-08 05:34:52.756969543 +0000
Dependencies:
mod error;
mod integration_tests {
mod tests;

===================
```rs
//! ICN Storage implementation
//! 
//! This crate provides persistent storage and state management for the ICN network.

mod error;
pub mod storage;
pub mod state;
#[cfg(test)]
mod tests;

pub use error::{StorageError, StorageResult};
pub use storage::{StorageManager, StorageConfig};
pub use state::{StateManager, NetworkState};

/// Initialize the storage system
pub async fn init(config: StorageConfig) -> StorageResult<StorageManager> {
    let storage = StorageManager::new(config).await?;
    
    // Run any pending migrations
    storage.run_migrations().await?;
    
    Ok(storage)
}

#[cfg(test)]
mod integration_tests {
    use super::*;
    use tokio;

    #[tokio::test]
    async fn test_storage_initialization() {
        let config = StorageConfig::default();
        let storage = init(config).await.unwrap();
        assert!(storage.get_latest_block_height().await.unwrap() >= 0);
    }
}```

===================
File: ./crates/icn-crypto/src/lib.rs
Size: 177 bytes
Modified: 2024-12-07 10:51:04.870587319 +0000
Dependencies:
mod tests {

===================
```rs
//! ICN crypto crate

pub fn init() {
    println!("Initializing icn-crypto");
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

===================
File: ./crates/icn-types/src/lib.rs
Size: 658 bytes
Modified: 2024-12-07 23:22:29.894333983 +0000
Dependencies:
mod block;
mod error;  // Add this line
mod identity;
mod relationship;
mod reputation;
mod transaction;

===================
```rs
// crates/icn-types/src/lib.rs

mod block;
mod transaction;
mod identity;
mod relationship;
mod reputation;
mod error;  // Add this line

pub use block::Block;
pub use transaction::{Transaction, TransactionType};
pub use identity::DID;
pub use relationship::{Relationship, RelationshipType};
pub use reputation::{ReputationSystem, ReputationContext, ReputationScore};
// Export error types
pub use error::{
    CoreError, StorageError, ConsensusError, NetworkError, IdentityError,
    CoreResult, StorageResult, ConsensusResult, NetworkResult, IdentityResult,
};

pub trait Validate {
    fn validate(&self) -> CoreResult<()>;  // Updated to use CoreResult
}```

===================
File: ./crates/icn-p2p/src/lib.rs
Size: 56 bytes
Modified: 2024-12-07 10:58:37.661642490 +0000
Dependencies:
use icn_types::*;

===================
```rs
pub mod protocol;
pub mod websocket;

use icn_types::*;
```

===================
File: ./crates/icn-runtime/src/lib.rs
Size: 49 bytes
Modified: 2024-12-07 10:58:37.663642511 +0000
Dependencies:
use icn_types::*;

===================
```rs
pub mod vm;
pub mod executor;

use icn_types::*;
```

===================
File: ./crates/icn-consensus/src/lib.rs
Size: 3406 bytes
Modified: 2024-12-08 11:12:11.335534728 +0000
Dependencies:
mod config;
mod error;
mod metrics;
mod proof_of_cooperation;
mod tests {
use std::time::Duration;

===================
```rs
// src/lib.rs

//! ICN Consensus Library
//! 
//! This library implements the Proof of Cooperation consensus mechanism for the
//! Inter-Cooperative Network (ICN). It provides a Byzantine fault-tolerant consensus
//! system that uses reputation-weighted voting and energy-aware metrics.

mod config;
mod error;
mod metrics;
mod proof_of_cooperation;

use std::time::Duration;

pub use config::ConsensusConfig;
pub use error::{ConsensusError, ConsensusResult};
pub use metrics::ConsensusMetrics;
pub use proof_of_cooperation::{ProofOfCooperation, ConsensusEvent};

/// Trait defining the core consensus engine interface
#[async_trait::async_trait]
pub trait ConsensusEngine: Send + Sync {
    /// Start a new consensus round
    /// 
    /// This selects a coordinator and initializes the round state.
    /// Returns an error if there aren't enough active validators.
    async fn start_round(&mut self) -> ConsensusResult<()>;

    /// Propose a new block for the current round
    /// 
    /// The block must be proposed by the current round's coordinator.
    /// Returns an error if the block is invalid or the proposer isn't authorized.
    async fn propose_block(&mut self, block: icn_types::Block) -> ConsensusResult<()>;

    /// Verify a proposed block
    /// 
    /// Checks the block's validity including:
    /// - Block structure and signatures
    /// - Height continuity
    /// - Timestamp validity
    /// - Transaction validity
    async fn verify_block(&self, block: &icn_types::Block) -> ConsensusResult<()>;

    /// Submit a vote for the current round
    /// 
    /// Validators can vote to approve or reject the proposed block.
    /// Returns an error if the validator isn't authorized or has already voted.
    async fn submit_vote(&mut self, validator_did: String, approve: bool) -> ConsensusResult<()>;

    /// Check if the round has reached consensus
    /// 
    /// Returns true if enough weighted votes have been collected to reach
    /// the consensus threshold.
    async fn has_consensus(&self) -> ConsensusResult<bool>;
}

/// Configuration for the consensus system
#[derive(Debug, Clone)]
pub struct ConsensusOpts {
    /// Minimum number of validators required for consensus
    pub min_validators: usize,
    
    /// Timeout duration for consensus rounds
    pub round_timeout: Duration,
    
    /// Required threshold of weighted votes to reach consensus (0.0-1.0)
    pub consensus_threshold: f64,
    
    /// Maximum time difference allowed for block timestamps
    pub max_timestamp_diff: Duration,
    
    /// Maximum size of the event broadcast channel
    pub event_channel_size: usize,
}

impl Default for ConsensusOpts {
    fn default() -> Self {
        Self {
            min_validators: 4,
            round_timeout: Duration::from_secs(30),
            consensus_threshold: 0.66,
            max_timestamp_diff: Duration::from_secs(60),
            event_channel_size: 1000,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio;

    #[tokio::test]
    async fn test_consensus_opts_defaults() {
        let opts = ConsensusOpts::default();
        assert!(opts.min_validators >= 4, "Should require enough validators for BFT");
        assert!(opts.consensus_threshold > 0.66, "Should require >2/3 consensus");
        assert!(opts.round_timeout >= Duration::from_secs(30), "Should allow enough time for consensus");
    }
}```

===================
File: ./crates/icn-core/src/main.rs
Size: 3811 bytes
Modified: 2024-12-08 11:07:03.369157426 +0000
Dependencies:
use anyhow::Result;
use config::{Config, File};
use icn_consensus::{ConsensusConfig, ProofOfCooperation};
use icn_p2p::websocket::WebSocketHandler;
use icn_storage::state::StateManager;
use icn_types::*;
use serde::Deserialize;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, error, Level};
use tracing_subscriber::{FmtSubscriber, EnvFilter};
use warp::Filter;

===================
```rs
// crates/icn-core/src/main.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use warp::Filter;
use tracing::{info, error, Level};
use tracing_subscriber::{FmtSubscriber, EnvFilter};
use config::{Config, File};
use anyhow::Result;
use serde::Deserialize;

use icn_types::*;
use icn_consensus::{ConsensusConfig, ProofOfCooperation};
use icn_p2p::websocket::WebSocketHandler;
use icn_storage::state::StateManager;

#[derive(Debug, Deserialize)]
struct AppConfig {
    server: ServerConfig,
    consensus: ConsensusConfig,
    storage: StorageConfig,
}

#[derive(Debug, Deserialize)]
struct ServerConfig {
    host: String,
    port: u16,
}

#[derive(Debug, Deserialize)]
struct StorageConfig {
    url: String,
    max_connections: u32,
}

async fn setup_config() -> Result<AppConfig> {
    let config = Config::builder()
        .add_source(File::with_name("config/default"))
        .add_source(File::with_name("config/local").required(false))
        .build()?;

    Ok(config.try_deserialize()?)
}

async fn setup_logging() -> Result<()> {
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env()
            .add_directive(Level::INFO.into())
            .add_directive("icn_core=debug".parse()?))
        .with_thread_ids(true)
        .with_target(false)
        .with_file(true)
        .with_line_number(true)
        .pretty()
        .try_init()?;

    Ok(())
}

async fn setup_metrics() -> Result<()> {
    // TODO: Implement metrics setup with prometheus
    Ok(())
}

async fn setup_storage(config: &StorageConfig) -> Result<Arc<StateManager>> {
    let storage = StateManager::with_config(config.url.clone(), config.max_connections).await?;
    Ok(Arc::new(storage))
}

async fn setup_consensus(
    config: ConsensusConfig,
    ws_handler: Arc<WebSocketHandler>,
) -> Result<Arc<RwLock<ProofOfCooperation>>> {
    let consensus = ProofOfCooperation::new(config, ws_handler);
    Ok(Arc::new(RwLock::new(consensus)))
}

fn setup_routes(
    ws_handler: Arc<WebSocketHandler>,
    storage: Arc<StateManager>,
    consensus: Arc<RwLock<ProofOfCooperation>>,
) -> impl Filter<Extract = impl warp::Reply, Error = warp::Rejection> + Clone {
    let ws_route = warp::path("ws")
        .and(warp::ws())
        .and(warp::header::<String>("X-DID"))
        .and(warp::any().map(move || ws_handler.clone()))
        .map(|ws: warp::ws::Ws, did: String, handler: Arc<WebSocketHandler>| {
            ws.on_upgrade(move |socket| async move {
                if let Err(e) = handler.handle_connection(socket, did).await {
                    error!("WebSocket connection error: {}", e);
                }
            })
        });

    let health_route = warp::path("health")
        .and(warp::get())
        .map(|| "OK");

    ws_route.or(health_route)
}

#[tokio::main]
async fn main() -> Result<()> {
    // Setup phase
    setup_logging().await?;
    info!("Starting ICN node...");

    let config = setup_config().await?;
    info!("Configuration loaded");

    setup_metrics().await?;
    info!("Metrics initialized");

    // Initialize core systems
    let storage = setup_storage(&config.storage).await?;
    info!("Storage system initialized");

    let ws_handler = Arc::new(WebSocketHandler::new());
    info!("WebSocket handler initialized");
    
    let consensus = setup_consensus(config.consensus, ws_handler.clone()).await?;
    info!("Consensus system initialized");

    // Setup routes
    let routes = setup_routes(ws_handler, storage, consensus);
    info!("Routes configured");

    // Start server
    let addr = format!("{}:{}", config.server.host, config.server.port)
        .parse()
        .expect("Invalid address");

    info!("Starting server on {}", addr);
    warp::serve(routes)
        .run(addr)
        .await;

    Ok(())
}```

===================
File: ./crates/icn-core/src/lib.rs
Size: 198 bytes
Modified: 2024-12-07 10:58:37.655642427 +0000
Dependencies:
use icn_consensus as consensus;
use icn_p2p as p2p;
use icn_runtime as runtime;
use icn_storage as storage;
use icn_types::*;

===================
```rs
pub mod api;
pub mod cooperative;
pub mod governance;
pub mod service;

use icn_types::*;
use icn_consensus as consensus;
use icn_storage as storage;
use icn_p2p as p2p;
use icn_runtime as runtime;
```

